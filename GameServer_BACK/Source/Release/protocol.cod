; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\muserver_dev\development\MU-S8EP2-Repack\GameServer\Source\protocol.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ltesttime@@3HA					; ltesttime
PUBLIC	?logincounttest@@3HA				; logincounttest
PUBLIC	?tempindex@@3HA					; tempindex
PUBLIC	?iCount@@3HA					; iCount
PUBLIC	?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB	; CryptoPP::FixedBlockSize<8>::BLOCKSIZE
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::IV_LENGTH
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::IV_LENGTH
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::IV_LENGTH
_BSS	SEGMENT
?ltesttime@@3HA DD 01H DUP (?)				; ltesttime
?logincounttest@@3HA DD 01H DUP (?)			; logincounttest
?tempindex@@3HA DD 01H DUP (?)				; tempindex
?iCount@@3HA DD	01H DUP (?)				; iCount
_BSS	ENDS
_DATA	SEGMENT
_g_sttKALIMAGATE_LEVEL DD 028H
	DD	082H
	DD	014H
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	015dH
	DD	0137H
	DD	015dH
	DD	015eH
	DD	0190H
	DD	015eH
	DD	0190H
_g_iKalimaGateGateIndex DD 058H
	DD	059H
	DD	05aH
	DD	05bH
	DD	05cH
	DD	05dH
	DD	074H
_IT_TicketRate DD 046H
	DD	046H
	DD	046H
	DD	046H
	DD	046H
	DD	046H
_IT_TicketZen DD 02dc6c0H
	DD	04c4b40H
	DD	06acfc0H
	DD	0895440H
	DD	0a7d8c0H
	DD	0c65d40H
_IT_REWARD_A DD	0493e0H
	DD	053020H
	DD	05cc60H
	DD	0668a0H
	DD	0704e0H
	DD	07a120H
_IT_REWARD_B DD	0c350H
	DD	0ea60H
	DD	011170H
	DD	013880H
	DD	015f90H
	DD	0186a0H
_IT_REWARD_C DD	0258H
	DD	04b0H
	DD	0708H
	DD	0960H
	DD	0bb8H
	DD	0e10H
_IT_REWARD_D DD	04b0H
	DD	0960H
	DD	0e10H
	DD	012c0H
	DD	01770H
	DD	01c20H
_IT_REWARD_E DD	0aH
	DD	014H
	DD	01eH
	DD	028H
	DD	032H
	DD	03cH
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	070H
	DD	00H
	DD	0190H
	DD	00H
	DD	0190H
	DD	010eH
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	00H
	DD	0190H
	DD	00H
	DD	0190H
_g_sttCHAOSCASTLE_LEVEL DD 0aH
	DD	031H
	DD	0aH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
	DD	00H
	DD	0190H
	DD	00H
	DD	0190H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_DATA	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<24,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<24,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<16,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<16,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<8,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<8,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB
CONST	SEGMENT
?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB DD 08H	; CryptoPP::FixedBlockSize<8>::BLOCKSIZE
CONST	ENDS
PUBLIC	?set@PBMSG_HEAD@@QAEXPAEEE@Z			; PBMSG_HEAD::set
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD@@QAEXPAEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 1
?set@PBMSG_HEAD@@QAEXPAEEE@Z PROC			; PBMSG_HEAD::set, COMDAT
; _this$ = ecx

; 85   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 87   : 		lpBuf[1] = size;

  00006	8a 4d 10	 mov	 cl, BYTE PTR _size$[ebp]

; 88   : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  0000f	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00012	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 89   : 	};	// line : 22

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?set@PBMSG_HEAD@@QAEXPAEEE@Z ENDP			; PBMSG_HEAD::set
_TEXT	ENDS
PUBLIC	?set@PWMSG_HEAD@@QAEXPAEEH@Z			; PWMSG_HEAD::set
; Function compile flags: /Ogtp
;	COMDAT ?set@PWMSG_HEAD@@QAEXPAEEH@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 4
?set@PWMSG_HEAD@@QAEXPAEEH@Z PROC			; PWMSG_HEAD::set, COMDAT
; _this$ = ecx

; 110  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 		lpBuf[0] = 0xC2;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 112  : 		lpBuf[1] = SET_NUMBERH(size);

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  00009	8b d1		 mov	 edx, ecx

; 113  : 		lpBuf[2] = SET_NUMBERL(size);

  0000b	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 114  : 		lpBuf[3] = head;

  0000e	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00011	c1 ea 08	 shr	 edx, 8
  00014	c6 00 c2	 mov	 BYTE PTR [eax], 194	; 000000c2H
  00017	88 50 01	 mov	 BYTE PTR [eax+1], dl
  0001a	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 115  : 	};

  0001d	5d		 pop	 ebp
  0001e	c2 0c 00	 ret	 12			; 0000000cH
?set@PWMSG_HEAD@@QAEXPAEEH@Z ENDP			; PWMSG_HEAD::set
_TEXT	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
; Function compile flags: /Ogtp
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 139  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 140  : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 141  : 		lpBuf[1] = size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 142  : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 143  : 		lpBuf[3] = sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 144  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	?GetChatPrice@CGensSystem@@QAEHXZ		; CGensSystem::GetChatPrice
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\guildclass.h
;	COMDAT ?GetChatPrice@CGensSystem@@QAEHXZ
_TEXT	SEGMENT
?GetChatPrice@CGensSystem@@QAEHXZ PROC			; CGensSystem::GetChatPrice, COMDAT
; _this$ = ecx

; 275  : 	int GetChatPrice(){ return this->m_ChatPrice; };

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	c3		 ret	 0
?GetChatPrice@CGensSystem@@QAEHXZ ENDP			; CGensSystem::GetChatPrice
_TEXT	ENDS
PUBLIC	?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::IsValidDurationTime
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\tdurmagickeychecker.h
;	COMDAT ?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::IsValidDurationTime, COMDAT
; _this$ = ecx

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 20   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00004	8a 5d 08	 mov	 bl, BYTE PTR _btMagicKey$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0000d	3c 3b		 cmp	 al, 59			; 0000003bH
  0000f	77 1e		 ja	 SHORT $LN1@IsValidDur

; 21   : 		{
; 22   : 			if ( (GetTickCount() - this->m_dwDurationTime[btMagicKey]) < 15000 )

  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00017	0f b6 cb	 movzx	 ecx, bl
  0001a	2b 04 8e	 sub	 eax, DWORD PTR [esi+ecx*4]
  0001d	3d 98 3a 00 00	 cmp	 eax, 15000		; 00003a98H
  00022	73 0b		 jae	 SHORT $LN1@IsValidDur

; 23   : 			{
; 24   : 				return TRUE;

  00024	5e		 pop	 esi
  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	5b		 pop	 ebx

; 29   : 
; 30   : 	};	// line : 25

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN1@IsValidDur:
  0002f	5e		 pop	 esi

; 25   : 			}
; 26   : 		}
; 27   : 
; 28   : 		return FALSE;

  00030	33 c0		 xor	 eax, eax
  00032	5b		 pop	 ebx

; 29   : 
; 30   : 	};	// line : 25

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::IsValidDurationTime
_TEXT	ENDS
PUBLIC	?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z	; TDurMagicKeyChecker::IsValidCount
; Function compile flags: /Ogtp
;	COMDAT ?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z PROC		; TDurMagicKeyChecker::IsValidCount, COMDAT
; _this$ = ecx

; 34   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 35   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00007	fe c8		 dec	 al
  00009	b1 3b		 mov	 cl, 59			; 0000003bH
  0000b	3a c8		 cmp	 cl, al
  0000d	1b c0		 sbb	 eax, eax
  0000f	40		 inc	 eax

; 36   : 		{
; 37   : 			if ( this->m_btValidCount[btMagicKey] >= 0 )
; 38   : 			{
; 39   : 				return TRUE;
; 40   : 			}
; 41   : 		}
; 42   : 		return FALSE;
; 43   : 	};	// line : 38

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z ENDP		; TDurMagicKeyChecker::IsValidCount
_TEXT	ENDS
PUBLIC	?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z	; TDurMagicKeyChecker::SetDurationTime
; Function compile flags: /Ogtp
;	COMDAT ?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
_dwCurrentTickCount$ = 12				; size = 4
?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z PROC	; TDurMagicKeyChecker::SetDurationTime, COMDAT
; _this$ = ecx

; 46   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	8a 45 08	 mov	 al, BYTE PTR _btMagicKey$[ebp]
  00006	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00009	80 fa 3b	 cmp	 dl, 59			; 0000003bH
  0000c	77 11		 ja	 SHORT $LN1@SetDuratio

; 48   : 		{
; 49   : 			this->m_dwDurationTime[btMagicKey] = dwCurrentTickCount;

  0000e	8b 55 0c	 mov	 edx, DWORD PTR _dwCurrentTickCount$[ebp]
  00011	0f b6 c0	 movzx	 eax, al
  00014	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 50   : 			this->m_btValidCount[btMagicKey] = 7;

  00017	c6 84 08 f0 00
	00 00 07	 mov	 BYTE PTR [eax+ecx+240], 7
$LN1@SetDuratio:

; 51   : 		}
; 52   : 	};	// line : 47

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z ENDP	; TDurMagicKeyChecker::SetDurationTime
_TEXT	ENDS
PUBLIC	?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidDurationTime
; Function compile flags: /Ogtp
;	COMDAT ?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::GetValidDurationTime, COMDAT
; _this$ = ecx

; 57   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	8a 45 08	 mov	 al, BYTE PTR _btMagicKey$[ebp]
  00006	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00009	80 fa 3b	 cmp	 dl, 59			; 0000003bH
  0000c	77 0a		 ja	 SHORT $LN1@GetValidDu

; 59   : 		{
; 60   : 			return this->m_dwDurationTime[btMagicKey];

  0000e	0f b6 c0	 movzx	 eax, al
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 64   : 	};	// line : 70

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN1@GetValidDu:

; 61   : 		}
; 62   : 
; 63   : 		return -77;

  00018	b8 b3 ff ff ff	 mov	 eax, -77		; ffffffb3H

; 64   : 	};	// line : 70

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::GetValidDurationTime
_TEXT	ENDS
PUBLIC	?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z	; TDurMagicKeyChecker::GetValidCount
; Function compile flags: /Ogtp
;	COMDAT ?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::GetValidCount, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	8a 45 08	 mov	 al, BYTE PTR _btMagicKey$[ebp]
  00006	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00009	80 fa 3b	 cmp	 dl, 59			; 0000003bH
  0000c	77 0f		 ja	 SHORT $LN1@GetValidCo

; 69   : 		{		
; 70   : 			return this->m_btValidCount[btMagicKey];

  0000e	0f b6 c0	 movzx	 eax, al
  00011	0f b6 84 08 f0
	00 00 00	 movzx	 eax, BYTE PTR [eax+ecx+240]

; 74   : 	};	// line : 80

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN1@GetValidCo:

; 71   : 		}
; 72   : 
; 73   : 		return -77;

  0001d	b8 b3 ff ff ff	 mov	 eax, -77		; ffffffb3H

; 74   : 	};	// line : 80

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::GetValidCount
_TEXT	ENDS
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1OBJECTSTRUCT@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1OBJECTSTRUCT@@QAE@XZ$0
__ehfuncinfo$??1OBJECTSTRUCT@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1OBJECTSTRUCT@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1OBJECTSTRUCT@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0003b	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00041	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00048	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1OBJECTSTRUCT@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
__ehhandler$??1OBJECTSTRUCT@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1OBJECTSTRUCT@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	?GetQeustCount@CQuestInfo@@QAEHXZ		; CQuestInfo::GetQeustCount
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\questinfo.h
;	COMDAT ?GetQeustCount@CQuestInfo@@QAEHXZ
_TEXT	SEGMENT
?GetQeustCount@CQuestInfo@@QAEHXZ PROC			; CQuestInfo::GetQeustCount, COMDAT
; _this$ = ecx

; 84   : 	int GetQeustCount(){return m_QuestCount;}

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetQeustCount@CQuestInfo@@QAEHXZ ENDP			; CQuestInfo::GetQeustCount
_TEXT	ENDS
PUBLIC	?GetCastleState@CCastleSiegeSync@@QAEHXZ	; CCastleSiegeSync::GetCastleState
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\castlesiegesync.h
;	COMDAT ?GetCastleState@CCastleSiegeSync@@QAEHXZ
_TEXT	SEGMENT
?GetCastleState@CCastleSiegeSync@@QAEHXZ PROC		; CCastleSiegeSync::GetCastleState, COMDAT
; _this$ = ecx

; 34   : 	int  GetCastleState(){return this->m_iCurCastleState;};	// line : 70

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetCastleState@CCastleSiegeSync@@QAEHXZ ENDP		; CCastleSiegeSync::GetCastleState
_TEXT	ENDS
PUBLIC	?GetCastleOwnerGuild@CCastleSiegeSync@@QAEPADXZ	; CCastleSiegeSync::GetCastleOwnerGuild
; Function compile flags: /Ogtp
;	COMDAT ?GetCastleOwnerGuild@CCastleSiegeSync@@QAEPADXZ
_TEXT	SEGMENT
?GetCastleOwnerGuild@CCastleSiegeSync@@QAEPADXZ PROC	; CCastleSiegeSync::GetCastleOwnerGuild, COMDAT
; _this$ = ecx

; 36   : 	LPSTR GetCastleOwnerGuild(){return this->m_szCastleOwnerGuild;};	// line : 85

  00000	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetCastleOwnerGuild@CCastleSiegeSync@@QAEPADXZ ENDP	; CCastleSiegeSync::GetCastleOwnerGuild
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@ ; `string'
PUBLIC	?TalkRefDel@CQeustNpcTeleport@@QAEXXZ		; CQeustNpcTeleport::TalkRefDel
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	__imp__EnterCriticalSection@4:PROC
;	COMDAT ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\gobjmonster.h
CONST	SEGMENT
??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@ DB 'QeustNpc R'
	DB	'efCount Dec= %d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ
_TEXT	SEGMENT
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ PROC		; CQeustNpcTeleport::TalkRefDel, COMDAT
; _this$ = ecx

; 75   : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 76   : 		EnterCriticalSection(&this->CsRef);

  00004	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00007	57		 push	 edi
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 77   : 		this->RefCount--;

  0000e	ff 0e		 dec	 DWORD PTR [esi]

; 78   : 
; 79   : 		if ( this->RefCount < 0 )

  00010	79 06		 jns	 SHORT $LN1@TalkRefDel

; 80   : 		{
; 81   : 			this->RefCount = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@TalkRefDel:

; 82   : 		}
; 83   : 		
; 84   : 		LogAdd("QeustNpc RefCount Dec= %d", this->RefCount);

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
  0001a	50		 push	 eax
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00026	83 c4 08	 add	 esp, 8

; 85   : 		LeaveCriticalSection(&this->CsRef);

  00029	57		 push	 edi
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi

; 86   : 	};	// line : 135

  00032	c3		 ret	 0
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ENDP		; CQeustNpcTeleport::TalkRefDel
_TEXT	ENDS
PUBLIC	?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ ; CDevilSquare::GetState
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\devilsquare.h
;	COMDAT ?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ
_TEXT	SEGMENT
?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ PROC ; CDevilSquare::GetState, COMDAT
; _this$ = ecx

; 46   : 	enum eDevilSquareState GetState(){return this->m_eState;};	// line : 93

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ ENDP ; CDevilSquare::GetState
_TEXT	ENDS
PUBLIC	?GetMapSvrGroup@CMapServerManager@@QAEHXZ	; CMapServerManager::GetMapSvrGroup
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\mapservermanager.h
;	COMDAT ?GetMapSvrGroup@CMapServerManager@@QAEHXZ
_TEXT	SEGMENT
?GetMapSvrGroup@CMapServerManager@@QAEHXZ PROC		; CMapServerManager::GetMapSvrGroup, COMDAT
; _this$ = ecx

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  00000	8b 81 00 6b 01
	00		 mov	 eax, DWORD PTR [ecx+92928]
  00006	85 c0		 test	 eax, eax
  00008	74 05		 je	 SHORT $LN1@GetMapSvrG

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  0000a	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]

; 60   : 	}

  0000e	c3		 ret	 0
$LN1@GetMapSvrG:

; 58   : 		}
; 59   : 		return -1;

  0000f	83 c8 ff	 or	 eax, -1

; 60   : 	}

  00012	c3		 ret	 0
?GetMapSvrGroup@CMapServerManager@@QAEHXZ ENDP		; CMapServerManager::GetMapSvrGroup
_TEXT	ENDS
PUBLIC	??_7_CS_NPC_DATA@@6B@				; _CS_NPC_DATA::`vftable'
PUBLIC	??1_CS_NPC_DATA@@UAE@XZ				; _CS_NPC_DATA::~_CS_NPC_DATA
PUBLIC	??_R4_CS_NPC_DATA@@6B@				; _CS_NPC_DATA::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU_CS_NPC_DATA@@@8			; _CS_NPC_DATA `RTTI Type Descriptor'
PUBLIC	??_R3_CS_NPC_DATA@@8				; _CS_NPC_DATA::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_CS_NPC_DATA@@8				; _CS_NPC_DATA::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_CS_NPC_DATA@@8			; _CS_NPC_DATA::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_E_CS_NPC_DATA@@UAEPAXI@Z:PROC		; _CS_NPC_DATA::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@_CS_NPC_DATA@@8
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\castlesiege.h
rdata$r	SEGMENT
??_R1A@?0A@EA@_CS_NPC_DATA@@8 DD FLAT:??_R0?AU_CS_NPC_DATA@@@8 ; _CS_NPC_DATA::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_CS_NPC_DATA@@8
rdata$r	ENDS
;	COMDAT ??_R2_CS_NPC_DATA@@8
rdata$r	SEGMENT
??_R2_CS_NPC_DATA@@8 DD FLAT:??_R1A@?0A@EA@_CS_NPC_DATA@@8 ; _CS_NPC_DATA::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_CS_NPC_DATA@@8
rdata$r	SEGMENT
??_R3_CS_NPC_DATA@@8 DD 00H				; _CS_NPC_DATA::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_CS_NPC_DATA@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_CS_NPC_DATA@@@8
_DATA	SEGMENT
??_R0?AU_CS_NPC_DATA@@@8 DD FLAT:??_7type_info@@6B@	; _CS_NPC_DATA `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_CS_NPC_DATA@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_CS_NPC_DATA@@6B@
rdata$r	SEGMENT
??_R4_CS_NPC_DATA@@6B@ DD 00H				; _CS_NPC_DATA::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU_CS_NPC_DATA@@@8
	DD	FLAT:??_R3_CS_NPC_DATA@@8
rdata$r	ENDS
;	COMDAT ??_7_CS_NPC_DATA@@6B@
CONST	SEGMENT
??_7_CS_NPC_DATA@@6B@ DD FLAT:??_R4_CS_NPC_DATA@@6B@	; _CS_NPC_DATA::`vftable'
	DD	FLAT:??_E_CS_NPC_DATA@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1_CS_NPC_DATA@@UAE@XZ
_TEXT	SEGMENT
??1_CS_NPC_DATA@@UAE@XZ PROC				; _CS_NPC_DATA::~_CS_NPC_DATA, COMDAT
; _this$ = ecx

; 75   : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_CS_NPC_DATA@@6B@

; 76   : 
; 77   : 	};

  00006	c3		 ret	 0
??1_CS_NPC_DATA@@UAE@XZ ENDP				; _CS_NPC_DATA::~_CS_NPC_DATA
_TEXT	ENDS
PUBLIC	?Clear@_CS_NPC_DATA@@QAEXXZ			; _CS_NPC_DATA::Clear
; Function compile flags: /Ogtp
;	COMDAT ?Clear@_CS_NPC_DATA@@QAEXXZ
_TEXT	SEGMENT
?Clear@_CS_NPC_DATA@@QAEXXZ PROC			; _CS_NPC_DATA::Clear, COMDAT
; _this$ = ecx

; 81   : 		m_bIN_USE = 0;
; 82   : 		m_iNPC_NUM = -1;

  00000	83 c8 ff	 or	 eax, -1
  00003	33 d2		 xor	 edx, edx
  00005	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00008	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 83   : 		m_iNPC_INDEX = -1;

  0000b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 84   : 		m_iNPC_LIVE = 0;

  0000e	89 51 68	 mov	 DWORD PTR [ecx+104], edx

; 85   : 		m_iNPC_AUTH = -1;

  00011	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 86   : 		m_bNPC_DBSAVE = 0;

  00014	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 87   : 		m_iNPC_SIDE = 0;

  00017	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 88   : 		m_iNPC_OBJINDEX = -1;

  0001a	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 89   : 		m_iNPC_DF_LEVEL = 0;

  0001d	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 90   : 		m_iNPC_RG_LEVEL = 0;

  00020	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 91   : 		m_iNPC_MAXHP = 0;

  00023	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 92   : 		m_iNPC_HP = 0;

  00026	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 93   : 		m_iNPC_SX = -1;

  00029	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 94   : 		m_iNPC_SY = -1;

  0002c	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 95   : 		m_iNPC_DX = -1;

  0002f	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 96   : 		m_iNPC_DY = -1;

  00032	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 97   : 		m_iNPC_DIR = -1;

  00035	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 98   : 		m_iNPC_BASE_DF_LEVEL = 0;

  00038	89 51 40	 mov	 DWORD PTR [ecx+64], edx

; 99   : 		m_iNPC_BASE_RG_LEVEL = 0;

  0003b	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 100  : 		m_iNPC_BASE_MAXHP = 0;

  0003e	89 51 48	 mov	 DWORD PTR [ecx+72], edx

; 101  : 		m_iNPC_BASE_HP = 0;

  00041	89 51 4c	 mov	 DWORD PTR [ecx+76], edx

; 102  : 		m_iNPC_BASE_SX = -1;

  00044	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 103  : 		m_iNPC_BASE_SY = -1;

  00047	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 104  : 		m_iNPC_BASE_DX = -1;

  0004a	89 41 58	 mov	 DWORD PTR [ecx+88], eax

; 105  : 		m_iNPC_BASE_DY = -1;

  0004d	89 41 5c	 mov	 DWORD PTR [ecx+92], eax

; 106  : 		m_iNPC_BASE_DIR = -1;

  00050	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 107  : 		m_iCsNpcExistVal = 0;

  00053	89 51 70	 mov	 DWORD PTR [ecx+112], edx

; 108  : 	}

  00056	c3		 ret	 0
?Clear@_CS_NPC_DATA@@QAEXXZ ENDP			; _CS_NPC_DATA::Clear
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_G_CS_NPC_DATA@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_CS_NPC_DATA@@UAEPAXI@Z PROC			; _CS_NPC_DATA::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_CS_NPC_DATA@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G_CS_NPC_DATA@@UAEPAXI@Z ENDP			; _CS_NPC_DATA::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?IsScroll@SnakeBegins@@QAE_NG@Z			; SnakeBegins::IsScroll
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\snakebegins.h
;	COMDAT ?IsScroll@SnakeBegins@@QAE_NG@Z
_TEXT	SEGMENT
_ItemType$ = 8						; size = 2
?IsScroll@SnakeBegins@@QAE_NG@Z PROC			; SnakeBegins::IsScroll, COMDAT
; _this$ = ecx

; 18   : 	bool	IsScroll(WORD ItemType) { return ItemType >= ITEMGET(14, 210) && ItemType <= ITEMGET(14, 213); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _ItemType$[ebp]
  00006	05 2e e3 ff ff	 add	 eax, -7378		; ffffe32eH
  0000b	66 b9 03 00	 mov	 cx, 3
  0000f	66 3b c8	 cmp	 cx, ax
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?IsScroll@SnakeBegins@@QAE_NG@Z ENDP			; SnakeBegins::IsScroll
_TEXT	ENDS
PUBLIC	?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z	; CNewPVP::IsDuel
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.h
;	COMDAT ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z PROC		; CNewPVP::IsDuel, COMDAT
; _this$ = ecx

; 296  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 297  : 		return CHECK_LIMIT(obj.m_iDuelUser, OBJMAX);

  00003	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00006	8b 80 50 12 00
	00		 mov	 eax, DWORD PTR [eax+4688]
  0000c	85 c0		 test	 eax, eax
  0000e	79 06		 jns	 SHORT $LN3@IsDuel
  00010	33 c0		 xor	 eax, eax

; 298  : 	}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN3@IsDuel:

; 297  : 		return CHECK_LIMIT(obj.m_iDuelUser, OBJMAX);

  00016	33 c9		 xor	 ecx, ecx
  00018	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0001d	0f 9e c1	 setle	 cl
  00020	8b c1		 mov	 eax, ecx

; 298  : 	}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ENDP		; CNewPVP::IsDuel
_TEXT	ENDS
PUBLIC	?IsVulcanusMap@CNewPVP@@QAEHH@Z			; CNewPVP::IsVulcanusMap
; Function compile flags: /Ogtp
;	COMDAT ?IsVulcanusMap@CNewPVP@@QAEHH@Z
_TEXT	SEGMENT
_nMapNumber$ = 8					; size = 4
?IsVulcanusMap@CNewPVP@@QAEHH@Z PROC			; CNewPVP::IsVulcanusMap, COMDAT
; _this$ = ecx

; 307  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  : 		return nMapNumber == MAP_INDEX_VULCANUS;

  00003	33 c0		 xor	 eax, eax
  00005	83 7d 08 3f	 cmp	 DWORD PTR _nMapNumber$[ebp], 63 ; 0000003fH
  00009	0f 94 c0	 sete	 al

; 309  : 	}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?IsVulcanusMap@CNewPVP@@QAEHH@Z ENDP			; CNewPVP::IsVulcanusMap
_TEXT	ENDS
PUBLIC	?IsPKFieldMap@CNewPVP@@QAEHH@Z			; CNewPVP::IsPKFieldMap
; Function compile flags: /Ogtp
;	COMDAT ?IsPKFieldMap@CNewPVP@@QAEHH@Z
_TEXT	SEGMENT
_nMapNumber$ = 8					; size = 4
?IsPKFieldMap@CNewPVP@@QAEHH@Z PROC			; CNewPVP::IsPKFieldMap, COMDAT
; _this$ = ecx

; 312  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		return nMapNumber == MAP_INDEX_PKFIELD;

  00003	33 c0		 xor	 eax, eax
  00005	83 7d 08 40	 cmp	 DWORD PTR _nMapNumber$[ebp], 64 ; 00000040H
  00009	0f 94 c0	 sete	 al

; 314  : 	}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?IsPKFieldMap@CNewPVP@@QAEHH@Z ENDP			; CNewPVP::IsPKFieldMap
_TEXT	ENDS
PUBLIC	?getInstance@MonsterSpawnerMng@@SAPAV1@XZ	; MonsterSpawnerMng::getInstance
EXTRN	??0MonsterSpawnerMng@@QAE@XZ:PROC		; MonsterSpawnerMng::MonsterSpawnerMng
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	?m_Instance@MonsterSpawnerMng@@0PAV1@A:DWORD	; MonsterSpawnerMng::m_Instance
;	COMDAT xdata$x
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\monsterspawner.h
xdata$x	SEGMENT
__unwindtable$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ$0
__ehfuncinfo$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
_TEXT	SEGMENT
$T233450 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?getInstance@MonsterSpawnerMng@@SAPAV1@XZ PROC		; MonsterSpawnerMng::getInstance, COMDAT

; 137  : 	static MonsterSpawnerMng* getInstance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 138  : 		if (m_Instance == NULL) {

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A ; MonsterSpawnerMng::m_Instance
  00028	85 c0		 test	 eax, eax
  0002a	75 3a		 jne	 SHORT $LN1@getInstanc

; 139  : 			m_Instance = new MonsterSpawnerMng();

  0002c	6a 24		 push	 36			; 00000024H
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 f0	 mov	 DWORD PTR $T233450[ebp], eax
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	85 c0		 test	 eax, eax
  00042	74 1b		 je	 SHORT $LN4@getInstanc
  00044	8b c8		 mov	 ecx, eax
  00046	e8 00 00 00 00	 call	 ??0MonsterSpawnerMng@@QAE@XZ ; MonsterSpawnerMng::MonsterSpawnerMng
  0004b	a3 00 00 00 00	 mov	 DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A, eax ; MonsterSpawnerMng::m_Instance

; 140  : 		}
; 141  : 		return m_Instance;
; 142  : 	}

  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN4@getInstanc:

; 139  : 			m_Instance = new MonsterSpawnerMng();

  0005f	33 c0		 xor	 eax, eax
  00061	a3 00 00 00 00	 mov	 DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A, eax ; MonsterSpawnerMng::m_Instance
$LN1@getInstanc:

; 140  : 		}
; 141  : 		return m_Instance;
; 142  : 	}

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T233450[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getInstance@MonsterSpawnerMng@@SAPAV1@XZ ENDP		; MonsterSpawnerMng::getInstance
PUBLIC	?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z	; PacketCheckTime
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
;	COMDAT ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z PROC		; PacketCheckTime, COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 118  : 	if ( ( GetTickCount() - lpObj->m_PacketCheckTime ) < 300 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	57		 push	 edi
  00008	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  0000e	ff d7		 call	 edi
  00010	2b 86 7c 05 00
	00		 sub	 eax, DWORD PTR [esi+1404]
  00016	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  0001b	73 06		 jae	 SHORT $LN1@PacketChec

; 119  : 	{
; 120  : 		return FALSE;

  0001d	5f		 pop	 edi
  0001e	33 c0		 xor	 eax, eax
  00020	5e		 pop	 esi

; 125  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN1@PacketChec:

; 121  : 	}
; 122  : 
; 123  : 	lpObj->m_PacketCheckTime = GetTickCount();

  00023	ff d7		 call	 edi
  00025	89 86 7c 05 00
	00		 mov	 DWORD PTR [esi+1404], eax
  0002b	5f		 pop	 edi

; 124  : 	return TRUE;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	5e		 pop	 esi

; 125  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; PacketCheckTime
_TEXT	ENDS
PUBLIC	??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?DataEncryptCheck@@YAHHEH@Z			; DataEncryptCheck
EXTRN	?CloseClient@@YAXH@Z:PROC			; CloseClient
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT ??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@ DB 'Err'
	DB	'or-L1 : Not Encrypt %s %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DataEncryptCheck@@YAHHEH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_protoNum$ = 12						; size = 1
_Encrypt$ = 16						; size = 4
?DataEncryptCheck@@YAHHEH@Z PROC			; DataEncryptCheck, COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 134  : 	if ( Encrypt == FALSE )

  00003	83 7d 10 00	 cmp	 DWORD PTR _Encrypt$[ebp], 0
  00007	75 35		 jne	 SHORT $LN1@DataEncryp

; 135  : 	{
; 136  : 		LogAdd("Error-L1 : Not Encrypt %s %d", gObj[aIndex].AccountID, protoNum);

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  0000d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00017	8b ce		 mov	 ecx, esi
  00019	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  0001f	50		 push	 eax
  00020	8d 44 11 52	 lea	 eax, DWORD PTR [ecx+edx+82]
  00024	50		 push	 eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 137  : 		CloseClient(aIndex);

  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00036	83 c4 10	 add	 esp, 16			; 00000010H

; 138  : 		return FALSE;

  00039	33 c0		 xor	 eax, eax
  0003b	5e		 pop	 esi

; 142  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN1@DataEncryp:

; 139  : 	}
; 140  : 
; 141  : 	return TRUE;

  0003e	b8 01 00 00 00	 mov	 eax, 1

; 142  : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?DataEncryptCheck@@YAHHEH@Z ENDP			; DataEncryptCheck
_TEXT	ENDS
PUBLIC	??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?TestSend@@YAXXZ				; TestSend
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
;	COMDAT ??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@
CONST	SEGMENT
??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@ DB 'TEST Data Send', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?TestSend@@YAXXZ
_TEXT	SEGMENT
_pMsg$ = -2008						; size = 2004
__$ArrayPad$ = -4					; size = 4
?TestSend@@YAXXZ PROC					; TestSend, COMDAT

; 1381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 07 00
	00		 sub	 esp, 2008		; 000007d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1382 : 	PMSG_TEST pMsg;
; 1383 : 	int size = sizeof(pMsg);
; 1384 : 	pMsg.h.c = 0xC2;
; 1385 : 	pMsg.h.headcode = 0xFF;	// Test Packet
; 1386 : 	pMsg.h.sizeH = SET_NUMBERH(size);
; 1387 : 	pMsg.h.sizeL = SET_NUMBERL(size);
; 1388 : 	DataSend( tempindex, (LPBYTE)&pMsg, size);

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?tempindex@@3HA ; tempindex
  00019	68 d4 07 00 00	 push	 2004			; 000007d4H
  0001e	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	c7 85 28 f8 ff
	ff c2 07 d4 ff	 mov	 DWORD PTR _pMsg$[ebp], -2881598 ; ffd407c2H
  00030	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1389 : 	DataSend( tempindex, (LPBYTE)&pMsg, size);

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR ?tempindex@@3HA ; tempindex
  0003a	68 d4 07 00 00	 push	 2004			; 000007d4H
  0003f	8d 95 28 f8 ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  00045	52		 push	 edx
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1390 : 	LogAdd("TEST Data Send");

  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1391 : }

  00057	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005a	33 cd		 xor	 ecx, ebp
  0005c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?TestSend@@YAXXZ ENDP					; TestSend
_TEXT	ENDS
PUBLIC	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z		; MsgSendV2
; Function compile flags: /Ogtp
;	COMDAT ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_Msg$ = 12						; size = 4
_size$ = 16						; size = 4
?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z PROC		; MsgSendV2, COMDAT

; 1401 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1402 : 	for ( int n=0;n<MAX_VIEWPORT;n++)

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000b	57		 push	 edi
  0000c	81 c6 48 0c 00
	00		 add	 esi, 3144		; 00000c48H
  00012	bf 4b 00 00 00	 mov	 edi, 75			; 0000004bH
$LL5@MsgSendV2:

; 1403 : 	{
; 1404 : 		if ( lpObj->VpPlayer2[n].type == OBJ_USER )

  00017	80 7e 04 01	 cmp	 BYTE PTR [esi+4], 1
  0001b	75 17		 jne	 SHORT $LN4@MsgSendV2

; 1405 : 		{
; 1406 : 			if ( lpObj->VpPlayer2[n].state != 0 )

  0001d	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00020	74 12		 je	 SHORT $LN4@MsgSendV2

; 1407 : 			{
; 1408 : 				DataSend(lpObj->VpPlayer2[n].number, Msg, size);

  00022	8b 45 0c	 mov	 eax, DWORD PTR _Msg$[ebp]
  00025	0f bf 4e 02	 movsx	 ecx, WORD PTR [esi+2]
  00029	53		 push	 ebx
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@MsgSendV2:

; 1402 : 	for ( int n=0;n<MAX_VIEWPORT;n++)

  00034	83 c6 0c	 add	 esi, 12			; 0000000cH
  00037	4f		 dec	 edi
  00038	75 dd		 jne	 SHORT $LL5@MsgSendV2
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx

; 1409 : 			}
; 1410 : 		}
; 1411 : 	}
; 1412 : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ENDP		; MsgSendV2
_TEXT	ENDS
PUBLIC	??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@ ; `string'
PUBLIC	?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z	; CGLiveClient
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
;	COMDAT ??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@
CONST	SEGMENT
??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@ DB '['
	DB	'%s][%s][%s] ClientHack Detected : Editing AttackSpeed [%d][%d'
	DB	'] [%d][%d]', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z
_TEXT	SEGMENT
_lpClientTime$ = 8					; size = 4
_aIndex$ = 12						; size = 2
?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z PROC		; CGLiveClient, COMDAT

; 1417 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1418 : VM_START
; 1419 : 
; 1420 : 	if ( gObj[aIndex].Connected > PLAYER_CONNECTED )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	56		 push	 esi
  00009	0f bf 75 0c	 movsx	 esi, WORD PTR _aIndex$[ebp]
  0000d	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00013	83 7c 06 04 01	 cmp	 DWORD PTR [esi+eax+4], 1
  00018	7e 15		 jle	 SHORT $LN6@CGLiveClie

; 1421 : 	{
; 1422 : 		gObj[aIndex].ConnectCheckTime = GetTickCount();

  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	89 44 0e 3c	 mov	 DWORD PTR [esi+ecx+60], eax
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN6@CGLiveClie:

; 1423 : 	}
; 1424 : 
; 1425 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  0002f	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  00034	0f 85 85 00 00
	00		 jne	 $LN2@CGLiveClie

; 1426 : 	{
; 1427 : 		if ( gObj[aIndex].m_AttackSpeed < lpClientTime->AttackSpeed || gObj[aIndex].m_MagicSpeed < lpClientTime->MagicSpeed )

  0003a	8b 94 06 6c 06
	00 00		 mov	 edx, DWORD PTR [esi+eax+1644]
  00041	57		 push	 edi
  00042	8b 7d 08	 mov	 edi, DWORD PTR _lpClientTime$[ebp]
  00045	0f b7 4f 08	 movzx	 ecx, WORD PTR [edi+8]
  00049	3b d1		 cmp	 edx, ecx
  0004b	7c 1b		 jl	 SHORT $LN9@CGLiveClie
  0004d	53		 push	 ebx
  0004e	0f b7 5f 0a	 movzx	 ebx, WORD PTR [edi+10]
  00052	39 9c 06 70 06
	00 00		 cmp	 DWORD PTR [esi+eax+1648], ebx
  00059	5b		 pop	 ebx
  0005a	7c 0c		 jl	 SHORT $LN9@CGLiveClie

; 1435 : 			}
; 1436 : 		}
; 1437 : 		else
; 1438 : 		{
; 1439 : 			gObj[aIndex].m_AttackSpeedHackDetectedCount = 0;

  0005c	5f		 pop	 edi
  0005d	c6 84 06 78 05
	00 00 00	 mov	 BYTE PTR [esi+eax+1400], 0
  00065	5e		 pop	 esi

; 1440 : 		}
; 1441 : 	}
; 1442 : VM_END
; 1443 : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
$LN9@CGLiveClie:

; 1428 : 		{
; 1429 : 			LogAddC(2, "[%s][%s][%s] ClientHack Detected : Editing AttackSpeed [%d][%d] [%d][%d]", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Ip_addr, gObj[aIndex].m_AttackSpeed, lpClientTime->AttackSpeed, gObj[aIndex].m_MagicSpeed, lpClientTime->MagicSpeed);

  00068	0f b7 7f 0a	 movzx	 edi, WORD PTR [edi+10]
  0006c	57		 push	 edi
  0006d	8b bc 06 70 06
	00 00		 mov	 edi, DWORD PTR [esi+eax+1648]
  00074	57		 push	 edi
  00075	51		 push	 ecx
  00076	52		 push	 edx
  00077	8d 54 06 1c	 lea	 edx, DWORD PTR [esi+eax+28]
  0007b	52		 push	 edx
  0007c	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00080	51		 push	 ecx
  00081	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00085	52		 push	 edx
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@
  0008b	6a 02		 push	 2
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1430 : 			gObj[aIndex].m_AttackSpeedHackDetectedCount++;

  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00098	fe 84 06 78 05
	00 00		 inc	 BYTE PTR [esi+eax+1400]

; 1431 : 
; 1432 : 			if ( gObj[aIndex].m_AttackSpeedHackDetectedCount > 3 )

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a4	83 c4 24	 add	 esp, 36			; 00000024H
  000a7	80 bc 06 78 05
	00 00 03	 cmp	 BYTE PTR [esi+eax+1400], 3
  000af	76 0d		 jbe	 SHORT $LN10@CGLiveClie

; 1433 : 			{
; 1434 : 				CloseClient(aIndex);

  000b1	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000bb	83 c4 04	 add	 esp, 4
$LN10@CGLiveClie:
  000be	5f		 pop	 edi
$LN2@CGLiveClie:
  000bf	5e		 pop	 esi

; 1440 : 		}
; 1441 : 	}
; 1442 : VM_END
; 1443 : }

  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ENDP		; CGLiveClient
_TEXT	ENDS
PUBLIC	?EncryptCheckSumKey@@YAGG@Z			; EncryptCheckSumKey
EXTRN	_rand:PROC
; Function compile flags: /Ogtp
;	COMDAT ?EncryptCheckSumKey@@YAGG@Z
_TEXT	SEGMENT
_wSource$ = 8						; size = 2
?EncryptCheckSumKey@@YAGG@Z PROC			; EncryptCheckSumKey, COMDAT

; 1472 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1473 : 	WORD wRandom = rand() % 64;

  00003	e8 00 00 00 00	 call	 _rand
  00008	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0000d	79 05		 jns	 SHORT $LN3@EncryptChe
  0000f	48		 dec	 eax
  00010	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00013	40		 inc	 eax
$LN3@EncryptChe:

; 1474 : 	WORD wAcc = ((wSource & 0x3F0) * 64) | (wRandom *16) | (wSource & 0x0F);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _wSource$[ebp]
  00017	8b d1		 mov	 edx, ecx
  00019	81 e2 f0 03 00
	00		 and	 edx, 1008		; 000003f0H
  0001f	c1 e0 04	 shl	 eax, 4
  00022	c1 e2 06	 shl	 edx, 6
  00025	0b c2		 or	 eax, edx
  00027	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0002a	0b c1		 or	 eax, ecx

; 1475 : 	return wAcc ^ 0xB479;

  0002c	35 79 b4 00 00	 xor	 eax, 46201		; 0000b479H

; 1476 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?EncryptCheckSumKey@@YAGG@Z ENDP			; EncryptCheckSumKey
_TEXT	ENDS
PUBLIC	?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ; CGCheckMainRecv
; Function compile flags: /Ogtp
;	COMDAT ?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z PROC ; CGCheckMainRecv, COMDAT

; 1484 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1485 : 	/*if ( strcmp(gObj[aIndex].Ip_addr, "89.28.120.69") == 0 )	// #warning To Prevent HAckrs
; 1486 : 	{
; 1487 : 		gObj[aIndex].CheckSumTime = 0;
; 1488 : 		gObj[aIndex].m_InWebzen = true;
; 1489 : 		return;
; 1490 : 	}*/
; 1491 : 
; 1492 : 	gObj[aIndex].CheckSumTime = 0;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00012	c7 44 08 4c 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+76], 0

; 1493 : 	return;
; 1494 : 
; 1495 : 	if ( gObj[aIndex].CheckSumTableNum < 0 || gObj[aIndex].CheckSumTableNum > MAX_CHECKSUM_KEY-1 )
; 1496 : 	{
; 1497 : 		LogAdd("error-L1 : [%s][%s] CheckSum-Exe error ", gObj[aIndex].AccountID, gObj[aIndex].Name);
; 1498 : 		CloseClient(aIndex);
; 1499 : 		return;
; 1500 : 	}
; 1501 : 
; 1502 : 	if ( dwgCheckSum[gObj[aIndex].CheckSumTableNum] != lpMsg->m_dwKey)
; 1503 : 	{
; 1504 : 		LogAddTD("error-L1 : CheckSum-Exe error %d %d %d [%s]", dwgCheckSum[gObj[aIndex].CheckSumTableNum],
; 1505 : 			lpMsg->m_dwKey, gObj[aIndex].CheckSumTableNum, gObj[aIndex].AccountID);
; 1506 : 		CloseClient(aIndex);
; 1507 : 		return;
; 1508 : 	}
; 1509 : 
; 1510 : 	gObj[aIndex].CheckSumTime = 0;
; 1511 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ENDP ; CGCheckMainRecv
_TEXT	ENDS
PUBLIC	?PEchoProc@@YAXPAEHF@Z				; PEchoProc
; Function compile flags: /Ogtp
;	COMDAT ?PEchoProc@@YAXPAEHF@Z
_TEXT	SEGMENT
_aMsg$ = 8						; size = 4
_aLen$ = 12						; size = 4
_aIndex$ = 16						; size = 2
?PEchoProc@@YAXPAEHF@Z PROC				; PEchoProc, COMDAT

; 1520 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1521 : 	for ( int n = 0 ; n< OBJMAX ; n++)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _aLen$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	33 f6		 xor	 esi, esi
  0000d	8d 49 00	 npad	 3
$LL4@PEchoProc:

; 1522 : 	{
; 1523 : 		if ( gObj[n].Connected >= PLAYER_CONNECTED )

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	83 7c 06 04 01	 cmp	 DWORD PTR [esi+eax+4], 1
  0001a	7c 0e		 jl	 SHORT $LN3@PEchoProc

; 1524 : 		{
; 1525 : 			DataSend(n, aMsg, aLen);

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _aMsg$[ebp]
  0001f	53		 push	 ebx
  00020	51		 push	 ecx
  00021	57		 push	 edi
  00022	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@PEchoProc:

; 1521 : 	for ( int n = 0 ; n< OBJMAX ; n++)

  0002a	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00030	47		 inc	 edi
  00031	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00037	7c d7		 jl	 SHORT $LL4@PEchoProc
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 1526 : 		}
; 1527 : 	}
; 1528 : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?PEchoProc@@YAXPAEHF@Z ENDP				; PEchoProc
_TEXT	ENDS
PUBLIC	?GCResultSend@@YAXHEE@Z				; GCResultSend
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
; Function compile flags: /Ogtp
;	COMDAT ?GCResultSend@@YAXHEE@Z
_TEXT	SEGMENT
_pResult$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_headcode$ = 12						; size = 1
_result$ = 16						; size = 1
?GCResultSend@@YAXHEE@Z PROC				; GCResultSend, COMDAT

; 1540 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1541 : 	PMSG_DEFRESULT pResult;
; 1542 : 
; 1543 : 	PHeadSetB((LPBYTE)&pResult, headcode, sizeof(pResult));

  00004	8b 45 0c	 mov	 eax, DWORD PTR _headcode$[ebp]
  00007	6a 04		 push	 4
  00009	50		 push	 eax
  0000a	8d 4d fc	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1544 : 	pResult.result = result;
; 1545 : 	
; 1546 : 	DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  00013	0f b6 45 fd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00017	8a 55 10	 mov	 dl, BYTE PTR _result$[ebp]
  0001a	50		 push	 eax
  0001b	8d 4d fc	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0001e	88 55 ff	 mov	 BYTE PTR _pResult$[ebp+3], dl
  00021	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00024	51		 push	 ecx
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002b	83 c4 18	 add	 esp, 24			; 00000018H

; 1547 : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?GCResultSend@@YAXHEE@Z ENDP				; GCResultSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z		; ChatSend
; Function compile flags: /Ogtp
;	COMDAT ?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z
_TEXT	SEGMENT
_pMsg$ = -112						; size = 105
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z PROC		; ChatSend, COMDAT

; 1553 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _szChat$[ebp]

; 1554 : 	int len = strlen(szChat);

  00014	8b c6		 mov	 eax, esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0001a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0001d	8d 49 00	 npad	 3
$LL7@ChatSend:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL7@ChatSend
  00027	2b c2		 sub	 eax, edx

; 1555 : 
; 1556 : 	if ( len < 1 )

  00029	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0002c	83 f9 58	 cmp	 ecx, 88			; 00000058H
  0002f	77 48		 ja	 SHORT $LN3@ChatSend

; 1557 : 		return;
; 1558 : 
; 1559 : 	if ( len > MAX_CHAT_LEN-1 )
; 1560 : 		return;
; 1561 : 
; 1562 : /*	char szTempMsg[4096] = {0};
; 1563 : 	MultiByteToWideChar(1258, 0, szChat, len, (unsigned short *)szTempMsg, sizeof(szTempMsg));
; 1564 : 	memcpy(&pMsg.szChatMsg, szTempMsg, sizeof(pMsg.szChatMsg));
; 1565 : 	pMsg.szChatMsg[MAX_CHAT_LEN-2]=0;
; 1566 : 	pMsg.szChatMsg[MAX_CHAT_LEN-1]=0;
; 1567 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, wcslen((unsigned short*)pMsg.szChatMsg)*2 + (sizeof(GC_CHATSEND)-sizeof(pMsg.szChatMsg)));
; 1568 : 	pMsg.sIndex[0] = lpObj->m_Index >> 8;
; 1569 : 	pMsg.sIndex[1] = lpObj->m_Index & 0xFF;*/
; 1570 : 
; 1571 : 	PMSG_CHATDATA_NUMBER pMsg;
; 1572 : 
; 1573 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, len+6);

  00031	83 c0 06	 add	 eax, 6
  00034	50		 push	 eax
  00035	8d 55 90	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00038	6a 01		 push	 1
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1574 : 	strcpy(pMsg.chatmsg, szChat);

  00040	8d 55 95	 lea	 edx, DWORD PTR _pMsg$[ebp+5]
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	8b c6		 mov	 eax, esi
  00048	2b d6		 sub	 edx, esi
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL5@ChatSend:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00055	40		 inc	 eax
  00056	84 c9		 test	 cl, cl
  00058	75 f6		 jne	 SHORT $LL5@ChatSend

; 1575 : 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0005a	8b 07		 mov	 eax, DWORD PTR [edi]

; 1576 : 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 1577 : 
; 1578 : 	MsgSendV2(lpObj, (UCHAR*)&pMsg, pMsg.h.size);

  0005c	0f b6 55 91	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00060	8a 0f		 mov	 cl, BYTE PTR [edi]
  00062	c1 e8 08	 shr	 eax, 8
  00065	88 45 93	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00068	52		 push	 edx
  00069	8d 45 90	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006c	50		 push	 eax
  0006d	57		 push	 edi
  0006e	88 4d 94	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00071	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@ChatSend:

; 1579 : }

  00079	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007c	5f		 pop	 edi
  0007d	33 cd		 xor	 ecx, ebp
  0007f	5e		 pop	 esi
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z ENDP		; ChatSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ		; vChatSend
EXTRN	_vsprintf:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ
_TEXT	SEGMENT
_pMsg$ = -368						; size = 105
_szBuffer$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ PROC		; vChatSend, COMDAT

; 1586 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 1587 : 	char szBuffer[256] = "";

  00017	68 ff 00 00 00	 push	 255			; 000000ffH
  0001c	8d 85 fd fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp+1]
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	c6 85 fc fe ff
	ff 00		 mov	 BYTE PTR _szBuffer$[ebp], 0
  0002c	e8 00 00 00 00	 call	 _memset

; 1588 : 	va_list pArguments;
; 1589 : 
; 1590 : 	va_start(pArguments, szChat);
; 1591 : 	vsprintf(szBuffer, szChat, pArguments);

  00031	8b 55 0c	 mov	 edx, DWORD PTR _szChat$[ebp]
  00034	8d 4d 10	 lea	 ecx, DWORD PTR _szChat$[ebp+4]
  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _vsprintf

; 1592 : 	va_end(pArguments);
; 1593 : 
; 1594 : 	int len = strlen(szBuffer);

  00045	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0004b	83 c4 18	 add	 esp, 24			; 00000018H
  0004e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL7@vChatSend:
  00051	8a 08		 mov	 cl, BYTE PTR [eax]
  00053	40		 inc	 eax
  00054	84 c9		 test	 cl, cl
  00056	75 f9		 jne	 SHORT $LL7@vChatSend
  00058	2b c2		 sub	 eax, edx

; 1595 : 
; 1596 : 	if ( len < 1 )

  0005a	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0005d	83 f9 58	 cmp	 ecx, 88			; 00000058H
  00060	77 5c		 ja	 SHORT $LN3@vChatSend

; 1597 : 		return;
; 1598 : 
; 1599 : 	if ( len > MAX_CHAT_LEN-1 )
; 1600 : 		return;
; 1601 : 
; 1602 : /*	char szTempMsg[4096] = {0};
; 1603 : 	MultiByteToWideChar(1258, 0, szChat, len, (unsigned short*)szTempMsg, sizeof(szTempMsg));
; 1604 : 	memcpy(&pMsg.szChatMsg, szTempMsg, sizeof(pMsg.szChatMsg));
; 1605 : 	pMsg.szChatMsg[MAX_CHAT_LEN-2]=0;
; 1606 : 	pMsg.szChatMsg[MAX_CHAT_LEN-1]=0;
; 1607 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, wcslen((unsigned short*)pMsg.szChatMsg)*2 + (sizeof(GC_CHATSEND)-sizeof(pMsg.szChatMsg)));
; 1608 : 	pMsg.sIndex[0] = lpObj->m_Index >> 8;
; 1609 : 	pMsg.sIndex[1] = lpObj->m_Index & 0xFF;*/
; 1610 : 
; 1611 : 	PMSG_CHATDATA_NUMBER pMsg;
; 1612 : 
; 1613 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, len+6);

  00062	83 c0 06	 add	 eax, 6
  00065	50		 push	 eax
  00066	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  0006c	6a 01		 push	 1
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1614 : 	strcpy(pMsg.chatmsg, szBuffer);

  00077	33 c0		 xor	 eax, eax
  00079	8d a4 24 00 00
	00 00		 npad	 7
$LL5@vChatSend:
  00080	8a 8c 05 fc fe
	ff ff		 mov	 cl, BYTE PTR _szBuffer$[ebp+eax]
  00087	88 8c 05 95 fe
	ff ff		 mov	 BYTE PTR _pMsg$[ebp+eax+5], cl
  0008e	40		 inc	 eax
  0008f	84 c9		 test	 cl, cl
  00091	75 ed		 jne	 SHORT $LL5@vChatSend

; 1615 : 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  00093	8b 06		 mov	 eax, DWORD PTR [esi]

; 1616 : 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 1617 : 
; 1618 : 	MsgSendV2(lpObj, (UCHAR*)&pMsg, pMsg.h.size);

  00095	0f b6 95 91 fe
	ff ff		 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0009c	8a 0e		 mov	 cl, BYTE PTR [esi]
  0009e	c1 e8 08	 shr	 eax, 8
  000a1	88 85 93 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+3], al
  000a7	52		 push	 edx
  000a8	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ae	50		 push	 eax
  000af	56		 push	 esi
  000b0	88 8d 94 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], cl
  000b6	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@vChatSend:

; 1619 : }

  000be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c1	33 cd		 xor	 ecx, ebp
  000c3	5e		 pop	 esi
  000c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ ENDP		; vChatSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?AllSendServerMsg@@YAXPAD@Z			; AllSendServerMsg
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
; Function compile flags: /Ogtp
;	COMDAT ?AllSendServerMsg@@YAXPAD@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_chatmsg$ = 8						; size = 4
?AllSendServerMsg@@YAXPAD@Z PROC			; AllSendServerMsg, COMDAT

; 1628 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _chatmsg$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi

; 1629 : 	PMSG_NOTICE pNotice;
; 1630 : 	
; 1631 : 	TNotice::MakeNoticeMsg((TNotice*)&pNotice, 0x00,  chatmsg);

  00018	50		 push	 eax
  00019	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  0001f	6a 00		 push	 0
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 1634 : 	{
; 1635 : 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  00034	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL5@AllSendSer:
  00040	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  00045	75 24		 jne	 SHORT $LN4@AllSendSer

; 1636 : 		{
; 1637 : 			if ( gObj[n].Type == OBJ_USER )

  00047	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  0004c	75 1d		 jne	 SHORT $LN4@AllSendSer

; 1638 : 			{
; 1639 : 				DataSend(n, (unsigned char*)&pNotice , pNotice.h.size );

  0004e	0f b6 8d ed fe
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$[ebp+1]
  00055	51		 push	 ecx
  00056	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$[ebp]
  0005c	52		 push	 edx
  0005d	57		 push	 edi
  0005e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@AllSendSer:

; 1632 : 
; 1633 : 	for ( int n = OBJ_STARTUSERINDEX ; n < OBJMAX ; n++)

  0006b	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00071	47		 inc	 edi
  00072	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00078	7c c6		 jl	 SHORT $LL5@AllSendSer

; 1640 : 			}
; 1641 : 		}
; 1642 : 	}
; 1643 : }

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007d	5f		 pop	 edi
  0007e	33 cd		 xor	 ecx, ebp
  00080	5e		 pop	 esi
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?AllSendServerMsg@@YAXPAD@Z ENDP			; AllSendServerMsg
_TEXT	ENDS
PUBLIC	?DataSendAll@@YAXPAEH@Z				; DataSendAll
; Function compile flags: /Ogtp
;	COMDAT ?DataSendAll@@YAXPAEH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iMsgSize$ = 12						; size = 4
?DataSendAll@@YAXPAEH@Z PROC				; DataSendAll, COMDAT

; 1650 : {			

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1651 : 	for ( int n = OBJ_STARTUSERINDEX ; n < OBJMAX ; n++)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _iMsgSize$[ebp]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  00013	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL5@DataSendAl:

; 1652 : 	{
; 1653 : 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00018	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0001d	75 1a		 jne	 SHORT $LN4@DataSendAl

; 1654 : 		{
; 1655 : 			if ( gObj[n].Type == OBJ_USER )

  0001f	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00024	75 13		 jne	 SHORT $LN4@DataSendAl

; 1656 : 			{
; 1657 : 				DataSend(n, (unsigned char*)lpMsg , iMsgSize );

  00026	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00029	53		 push	 ebx
  0002a	50		 push	 eax
  0002b	57		 push	 edi
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@DataSendAl:

; 1651 : 	for ( int n = OBJ_STARTUSERINDEX ; n < OBJMAX ; n++)

  00039	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  0003f	47		 inc	 edi
  00040	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00046	7c d0		 jl	 SHORT $LL5@DataSendAl
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1658 : 			}
; 1659 : 		}
; 1660 : 	}
; 1661 : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?DataSendAll@@YAXPAEH@Z ENDP				; DataSendAll
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z	; ChatTargetSend
; Function compile flags: /Ogtp
;	COMDAT ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z
_TEXT	SEGMENT
_pMsg$ = -112						; size = 105
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
_senduser$ = 16						; size = 4
?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z PROC	; ChatTargetSend, COMDAT

; 1669 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _szChat$[ebp]

; 1670 : 	int len = strlen(szChat);

  00018	8b c6		 mov	 eax, esi
  0001a	57		 push	 edi
  0001b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0001e	8b ff		 npad	 2
$LL7@ChatTarget:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL7@ChatTarget
  00027	2b c2		 sub	 eax, edx
  00029	8b f8		 mov	 edi, eax

; 1671 : 
; 1672 : 	if ( len < 1 || len > MAX_CHAT_LEN-1)

  0002b	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0002e	83 f8 58	 cmp	 eax, 88			; 00000058H
  00031	77 4e		 ja	 SHORT $LN1@ChatTarget

; 1673 : 		return;
; 1674 : 
; 1675 : 	/*char szTempMsg[4096] = {0};
; 1676 : 	MultiByteToWideChar(1258, 0, szChat, len, (unsigned short*)szTempMsg, sizeof(szTempMsg));
; 1677 : 	memcpy(&pMsg.szChatMsg, szTempMsg, sizeof(pMsg.szChatMsg));
; 1678 : 	pMsg.szChatMsg[MAX_CHAT_LEN-2]=0;
; 1679 : 	pMsg.szChatMsg[MAX_CHAT_LEN-1]=0;
; 1680 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, wcslen((unsigned short*)pMsg.szChatMsg)*2 + (sizeof(GC_CHATSEND)-sizeof(pMsg.szChatMsg)));
; 1681 : 	pMsg.sIndex[0] = lpObj->m_Index >> 8;
; 1682 : 	pMsg.sIndex[1] = lpObj->m_Index & 0xFF;*/
; 1683 : 
; 1684 : 	PMSG_CHATDATA_NUMBER pMsg;
; 1685 : 
; 1686 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, len+6);

  00033	8d 4f 06	 lea	 ecx, DWORD PTR [edi+6]
  00036	51		 push	 ecx
  00037	8d 55 90	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0003a	6a 01		 push	 1
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1687 : 	strcpy(pMsg.chatmsg, szChat);

  00042	8d 55 95	 lea	 edx, DWORD PTR _pMsg$[ebp+5]
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	8b c6		 mov	 eax, esi
  0004a	2b d6		 sub	 edx, esi
  0004c	8d 64 24 00	 npad	 4
$LL5@ChatTarget:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00055	40		 inc	 eax
  00056	84 c9		 test	 cl, cl
  00058	75 f6		 jne	 SHORT $LL5@ChatTarget

; 1688 : 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0005a	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1689 : 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);

  0005c	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0005e	c1 e8 08	 shr	 eax, 8
  00061	88 45 93	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00064	88 4d 94	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 1690 : 	pMsg.chatmsg[len+1] = 0;
; 1691 : 
; 1692 : 	DataSend(senduser, (UCHAR*)&pMsg, pMsg.h.size);

  00067	8b 4d 10	 mov	 ecx, DWORD PTR _senduser$[ebp]
  0006a	c6 44 3d 96 00	 mov	 BYTE PTR _pMsg$[ebp+edi+6], 0
  0006f	0f b6 55 91	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00073	52		 push	 edx
  00074	8d 45 90	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00077	50		 push	 eax
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ChatTarget:

; 1693 : }

  00081	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	33 cd		 xor	 ecx, ebp
  00088	5b		 pop	 ebx
  00089	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ENDP	; ChatTargetSend
_TEXT	ENDS
PUBLIC	?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z	; CGChatRecv
; Function compile flags: /Ogtp
;	COMDAT ?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z PROC	; CGChatRecv, COMDAT

; 1987 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1988 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	8b f3		 mov	 esi, ebx
  0000a	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00010	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1989 : 
; 1990 : 	if ( PacketCheckTime(lpObj) == FALSE )

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	74 20		 je	 SHORT $LN2@CGChatRecv

; 1991 : 	{
; 1992 : 		return;
; 1993 : 	}
; 1994 : 
; 1995 : 	DataSend(aIndex, (LPBYTE)lpMsg, lpMsg->h.size);

  00023	57		 push	 edi
  00024	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00027	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  0002b	50		 push	 eax
  0002c	57		 push	 edi
  0002d	53		 push	 ebx
  0002e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1996 : 	MsgSendV2(lpObj, (LPBYTE)lpMsg, lpMsg->h.size);

  00033	0f b6 4f 01	 movzx	 ecx, BYTE PTR [edi+1]
  00037	51		 push	 ecx
  00038	57		 push	 edi
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0003f	83 c4 18	 add	 esp, 24			; 00000018H
  00042	5f		 pop	 edi
$LN2@CGChatRecv:
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 1997 : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z ENDP	; CGChatRecv
_TEXT	ENDS
PUBLIC	?GCServerMsgSend@@YAXEH@Z			; GCServerMsgSend
; Function compile flags: /Ogtp
;	COMDAT ?GCServerMsgSend@@YAXEH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_msg$ = 8						; size = 1
_aIndex$ = 12						; size = 4
?GCServerMsgSend@@YAXEH@Z PROC				; GCServerMsgSend, COMDAT

; 2011 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2012 : 	PMSG_SERVERMSG pMsg;
; 2013 : 
; 2014 : 	PHeadSetB((LPBYTE)&pMsg, 0x0C, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 0c		 push	 12			; 0000000cH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2015 : 	pMsg.MsgNumber = msg;
; 2016 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 08	 mov	 cl, BYTE PTR _msg$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 2017 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GCServerMsgSend@@YAXEH@Z ENDP				; GCServerMsgSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCServerMsgStringSend@@YAXPADHE@Z		; GCServerMsgStringSend
; Function compile flags: /Ogtp
;	COMDAT ?GCServerMsgStringSend@@YAXPADHE@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_szMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 1
?GCServerMsgStringSend@@YAXPADHE@Z PROC			; GCServerMsgStringSend, COMDAT

; 2025 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _szMsg$[ebp]

; 2026 : 	PMSG_NOTICE pNotice;
; 2027 : 	
; 2028 : 	TNotice::MakeNoticeMsg((TNotice*)&pNotice, type, szMsg);

  00016	50		 push	 eax
  00017	8b 45 10	 mov	 eax, DWORD PTR _type$[ebp]
  0001a	50		 push	 eax
  0001b	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 2029 : 	DataSend(aIndex, (UCHAR*)&pNotice, pNotice.h.size);

  00027	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$[ebp+1]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00031	52		 push	 edx
  00032	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00038	50		 push	 eax
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2030 : }

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	83 c4 18	 add	 esp, 24			; 00000018H
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?GCServerMsgStringSend@@YAXPADHE@Z ENDP			; GCServerMsgStringSend
_TEXT	ENDS
PUBLIC	?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
; Function compile flags: /Ogtp
;	COMDAT ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z
_TEXT	SEGMENT
_lpNode$ = 8						; size = 4
_szMsg$ = 12						; size = 4
_type$ = 16						; size = 1
?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z PROC ; GCServerMsgStringSendGuild, COMDAT

; 2037 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2038 : 	if ( lpNode == NULL )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpNode$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	74 3b		 je	 SHORT $LN2@GCServerMs

; 2039 : 	{
; 2040 : 		return;
; 2041 : 	}
; 2042 : 
; 2043 : 	for ( int n = 0; n<MAX_USER_GUILD ; n++)

  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	33 f6		 xor	 esi, esi
  0000f	8d bb a0 03 00
	00		 lea	 edi, DWORD PTR [ebx+928]
$LL10@GCServerMs:

; 2044 : 	{
; 2045 : 		if (lpNode->Use[n] > 0 && lpNode->Index[n] >= 0 )

  00015	80 bc 33 40 04
	00 00 00	 cmp	 BYTE PTR [ebx+esi+1088], 0
  0001d	76 1c		 jbe	 SHORT $LN3@GCServerMs
  0001f	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00022	66 85 c0	 test	 ax, ax
  00025	78 14		 js	 SHORT $LN3@GCServerMs

; 2046 : 		{
; 2047 : 			GCServerMsgStringSend((char*)szMsg, lpNode->Index[n], type);

  00027	8b 4d 10	 mov	 ecx, DWORD PTR _type$[ebp]
  0002a	0f bf d0	 movsx	 edx, ax
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _szMsg$[ebp]
  00030	51		 push	 ecx
  00031	52		 push	 edx
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCServerMs:

; 2039 : 	{
; 2040 : 		return;
; 2041 : 	}
; 2042 : 
; 2043 : 	for ( int n = 0; n<MAX_USER_GUILD ; n++)

  0003b	46		 inc	 esi
  0003c	83 c7 02	 add	 edi, 2
  0003f	83 fe 50	 cmp	 esi, 80			; 00000050H
  00042	7c d1		 jl	 SHORT $LL10@GCServerMs
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
$LN2@GCServerMs:
  00046	5b		 pop	 ebx

; 2048 : 		}
; 2049 : 	}
; 2050 : }

  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ENDP ; GCServerMsgStringSendGuild
_TEXT	ENDS
PUBLIC	?GCEventStateSend@@YAXHEE@Z			; GCEventStateSend
; Function compile flags: /Ogtp
;	COMDAT ?GCEventStateSend@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_state$ = 12						; size = 1
_event$ = 16						; size = 1
?GCEventStateSend@@YAXHEE@Z PROC			; GCEventStateSend, COMDAT

; 2064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2065 : 	PMSG_EVENT pMsg;
; 2066 : 
; 2067 : 	PHeadSetB((LPBYTE)&pMsg, 0x0B, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 0b		 push	 11			; 0000000bH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2068 : 	pMsg.Event = event;
; 2069 : 	pMsg.State = state;
; 2070 : 
; 2071 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00013	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00017	8a 4d 10	 mov	 cl, BYTE PTR _event$[ebp]
  0001a	8a 55 0c	 mov	 dl, BYTE PTR _state$[ebp]
  0001d	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00020	50		 push	 eax
  00021	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00024	88 55 fb	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  00027	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 18	 add	 esp, 24			; 00000018H

; 2072 : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?GCEventStateSend@@YAXHEE@Z ENDP			; GCEventStateSend
_TEXT	ENDS
PUBLIC	?GCMapEventStateSend@@YAXHEE@Z			; GCMapEventStateSend
; Function compile flags: /Ogtp
;	COMDAT ?GCMapEventStateSend@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_map$ = 8						; size = 4
_state$ = 12						; size = 1
_event$ = 16						; size = 1
?GCMapEventStateSend@@YAXHEE@Z PROC			; GCMapEventStateSend, COMDAT

; 2079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 2080 : 	PMSG_EVENT pMsg;
; 2081 : 
; 2082 : 	PHeadSetB((LPBYTE)&pMsg, 0x0B, sizeof(pMsg));

  00008	6a 05		 push	 5
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	6a 0b		 push	 11			; 0000000bH
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2083 : 	pMsg.Event = event;

  00015	8a 4d 10	 mov	 cl, BYTE PTR _event$[ebp]

; 2084 : 	pMsg.State = state;

  00018	8a 55 0c	 mov	 dl, BYTE PTR _state$[ebp]
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2085 : 
; 2086 : 	for ( int n=0; n<OBJMAX ; n++ )

  00023	33 ff		 xor	 edi, edi
  00025	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00028	88 55 fb	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  0002b	33 f6		 xor	 esi, esi
  0002d	8d 49 00	 npad	 3
$LL4@GCMapEvent:

; 2087 : 	{
; 2088 : 		if ( gObj[n].Connected == PLAYER_PLAYING && gObj[n].Type == OBJ_USER && map == gObj[n].MapNumber )

  00030	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  00035	75 2b		 jne	 SHORT $LN3@GCMapEvent
  00037	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  0003c	75 24		 jne	 SHORT $LN3@GCMapEvent
  0003e	0f b6 8c 06 23
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+291]
  00046	39 4d 08	 cmp	 DWORD PTR _map$[ebp], ecx
  00049	75 17		 jne	 SHORT $LN3@GCMapEvent

; 2089 : 		{
; 2090 : 			DataSend(n, (UCHAR*)&pMsg, pMsg.h.size);

  0004b	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0004f	52		 push	 edx
  00050	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00053	50		 push	 eax
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCMapEvent:

; 2085 : 
; 2086 : 	for ( int n=0; n<OBJMAX ; n++ )

  00062	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00068	47		 inc	 edi
  00069	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  0006f	7c bf		 jl	 SHORT $LL4@GCMapEvent
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi

; 2091 : 		}
; 2092 : 	}
; 2093 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?GCMapEventStateSend@@YAXHEE@Z ENDP			; GCMapEventStateSend
_TEXT	ENDS
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ; CGChatWhisperRecv
EXTRN	?AddCash@CWhisperCash@@QAEHPAD@Z:PROC		; CWhisperCash::AddCash
EXTRN	?WhisperCash@@3VCWhisperCash@@A:BYTE		; WhisperCash
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
; Function compile flags: /Ogtp
;	COMDAT ?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$ = -136					; size = 4
_index$ = -136						; size = 4
_pWhisper$ = -132					; size = 113
_tid$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z PROC ; CGChatWhisperRecv, COMDAT

; 2099 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2100 : 	char tid[11];
; 2101 : 	PMSG_CHATDATA_WHISPER pWhisper;
; 2102 : 	int len;
; 2103 : 	LPOBJ lpObj = &gObj[aIndex];

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0001c	53		 push	 ebx
  0001d	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00020	56		 push	 esi
  00021	8b f3		 mov	 esi, ebx
  00023	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00029	57		 push	 edi
  0002a	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]

; 2104 : 	int index;
; 2105 : 
; 2106 : 	if ( PacketCheckTime(lpObj) == FALSE )

  0002d	57		 push	 edi

; 2127 : 	{
; 2128 : 		GCServerMsgSend(0, aIndex);

  0002e	89 85 78 ff ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax
  00034	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00039	83 c4 04	 add	 esp, 4
  0003c	85 c0		 test	 eax, eax
  0003e	0f 84 13 01 00
	00		 je	 $LN1@CGChatWhis

; 2107 : 	{
; 2108 : 		return;
; 2109 : 	}
; 2110 : 
; 2111 : 	if ( lpObj->ChatLimitTime > 0 )

  00044	0f b7 87 f8 00
	00 00		 movzx	 eax, WORD PTR [edi+248]
  0004b	66 85 c0	 test	 ax, ax
  0004e	74 2d		 je	 SHORT $LN4@CGChatWhis

; 2112 : 	{
; 2113 : 		MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(4, 223)), lpObj->ChatLimitTime);

  00050	50		 push	 eax
  00051	68 df 04 00 00	 push	 1247			; 000004dfH
  00056	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0005b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00060	50		 push	 eax
  00061	8b 07		 mov	 eax, DWORD PTR [edi]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 2141 : 		DataSend(index, (UCHAR*)&pWhisper, pWhisper.h.size);

  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx

; 2142 : 	}
; 2143 : }

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00072	33 cd		 xor	 ecx, ebp
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN4@CGChatWhis:

; 2114 : 		return;
; 2115 : 	}
; 2116 : 
; 2117 : 	if ( (lpObj->Penalty & 2) == 2 )

  0007d	f6 87 c0 01 00
	00 02		 test	 BYTE PTR [edi+448], 2
  00084	0f 85 cd 00 00
	00		 jne	 $LN1@CGChatWhis

; 2118 : 	{
; 2119 : 		return;
; 2120 : 	}
; 2121 : 
; 2122 : 	tid[10]=0;
; 2123 : 	memcpy(tid, lpMsg->id, sizeof(lpMsg->id));

  0008a	8b bd 78 ff ff
	ff		 mov	 edi, DWORD PTR _lpMsg$GSCopy$[ebp]
  00090	8b 4f 03	 mov	 ecx, DWORD PTR [edi+3]
  00093	8b 57 07	 mov	 edx, DWORD PTR [edi+7]
  00096	66 8b 47 0b	 mov	 ax, WORD PTR [edi+11]
  0009a	89 4d f0	 mov	 DWORD PTR _tid$[ebp], ecx

; 2124 : 	index = WhisperCash.AddCash(tid);

  0009d	8d 4d f0	 lea	 ecx, DWORD PTR _tid$[ebp]
  000a0	51		 push	 ecx
  000a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?WhisperCash@@3VCWhisperCash@@A ; WhisperCash
  000a6	c6 45 fa 00	 mov	 BYTE PTR _tid$[ebp+10], 0
  000aa	89 55 f4	 mov	 DWORD PTR _tid$[ebp+4], edx
  000ad	66 89 45 f8	 mov	 WORD PTR _tid$[ebp+8], ax
  000b1	e8 00 00 00 00	 call	 ?AddCash@CWhisperCash@@QAEHPAD@Z ; CWhisperCash::AddCash
  000b6	89 85 78 ff ff
	ff		 mov	 DWORD PTR _index$[ebp], eax

; 2125 : 
; 2126 : 	if ( index < 0 )

  000bc	85 c0		 test	 eax, eax
  000be	79 1c		 jns	 SHORT $LN2@CGChatWhis

; 2127 : 	{
; 2128 : 		GCServerMsgSend(0, aIndex);

  000c0	53		 push	 ebx
  000c1	6a 00		 push	 0
  000c3	e8 00 00 00 00	 call	 ?GCServerMsgSend@@YAXEH@Z ; GCServerMsgSend
  000c8	83 c4 08	 add	 esp, 8
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx

; 2142 : 	}
; 2143 : }

  000ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d1	33 cd		 xor	 ecx, ebp
  000d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
$LN2@CGChatWhis:

; 2129 : 		return;
; 2130 : 	}
; 2131 : 
; 2132 : 	PHeadSetB((LPBYTE)&pWhisper, 0x02, sizeof(pWhisper));

  000dc	6a 71		 push	 113			; 00000071H
  000de	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _pWhisper$[ebp]
  000e4	6a 02		 push	 2
  000e6	52		 push	 edx
  000e7	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2133 : 	strcpy(pWhisper.id, gObj[aIndex].Name);

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f1	8d 44 06 5d	 lea	 eax, DWORD PTR [esi+eax+93]
  000f5	8d 95 7f ff ff
	ff		 lea	 edx, DWORD PTR _pWhisper$[ebp+3]
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fe	2b d0		 sub	 edx, eax
$LL8@CGChatWhis:
  00100	8a 08		 mov	 cl, BYTE PTR [eax]
  00102	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00105	40		 inc	 eax
  00106	84 c9		 test	 cl, cl
  00108	75 f6		 jne	 SHORT $LL8@CGChatWhis

; 2134 : 	memcpy(pWhisper.chatmsg, lpMsg->chatmsg, sizeof(lpMsg->chatmsg));

  0010a	8d 77 0d	 lea	 esi, DWORD PTR [edi+13]
  0010d	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00112	8d 7d 89	 lea	 edi, DWORD PTR _pWhisper$[ebp+13]

; 2135 : 	len = strlen(pWhisper.chatmsg);

  00115	8d 45 89	 lea	 eax, DWORD PTR _pWhisper$[ebp+13]
  00118	f3 a5		 rep movsd
  0011a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0011d	8d 49 00	 npad	 3
$LL10@CGChatWhis:
  00120	8a 08		 mov	 cl, BYTE PTR [eax]
  00122	40		 inc	 eax
  00123	84 c9		 test	 cl, cl
  00125	75 f9		 jne	 SHORT $LL10@CGChatWhis
  00127	2b c2		 sub	 eax, edx

; 2136 : 
; 2137 : 	if ( len > 0 )

  00129	85 c0		 test	 eax, eax
  0012b	7e 2a		 jle	 SHORT $LN1@CGChatWhis

; 2138 : 	{
; 2139 : 		pWhisper.h.size -= sizeof(pWhisper.chatmsg);
; 2140 : 		pWhisper.h.size += len + 1;

  0012d	8a 8d 7d ff ff
	ff		 mov	 cl, BYTE PTR _pWhisper$[ebp+1]
  00133	2c 63		 sub	 al, 99			; 00000063H
  00135	02 c8		 add	 cl, al

; 2141 : 		DataSend(index, (UCHAR*)&pWhisper, pWhisper.h.size);

  00137	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  0013d	88 8d 7d ff ff
	ff		 mov	 BYTE PTR _pWhisper$[ebp+1], cl
  00143	0f b6 c9	 movzx	 ecx, cl
  00146	51		 push	 ecx
  00147	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _pWhisper$[ebp]
  0014d	52		 push	 edx
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00154	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGChatWhis:

; 2142 : 	}
; 2143 : }

  00157	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	33 cd		 xor	 ecx, ebp
  0015e	5b		 pop	 ebx
  0015f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c3		 ret	 0
?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ENDP ; CGChatWhisperRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SCPJoinResultSend@@YAXHE@Z			; SCPJoinResultSend
EXTRN	?szClientVersion@@3PADA:QWORD			; szClientVersion
; Function compile flags: /Ogtp
;	COMDAT ?SCPJoinResultSend@@YAXHE@Z
_TEXT	SEGMENT
_pResult$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?SCPJoinResultSend@@YAXHE@Z PROC			; SCPJoinResultSend, COMDAT

; 2162 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2163 : 	PMSG_JOINRESULT pResult;
; 2164 : 
; 2165 : 	memset(&pResult, 0, sizeof(pResult));
; 2166 : 
; 2167 : 	pResult.h.size = sizeof(pResult);
; 2168 : 	pResult.h.c = 0xC1;
; 2169 : 	pResult.h.headcode = 0xF1;
; 2170 : 	pResult.scode = 0x00;
; 2171 : 	pResult.result = result;
; 2172 : 	pResult.NumberH = SET_NUMBERH(aIndex);
; 2173 : 	pResult.NumberL = SET_NUMBERL(aIndex);
; 2174 : 	pResult.CliVersion[0] = szClientVersion[0];

  00010	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?szClientVersion@@3PADA
  00017	33 c0		 xor	 eax, eax
  00019	89 45 f4	 mov	 DWORD PTR _pResult$[ebp+4], eax
  0001c	89 45 f8	 mov	 DWORD PTR _pResult$[ebp+8], eax
  0001f	53		 push	 ebx
  00020	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00023	89 45 f0	 mov	 DWORD PTR _pResult$[ebp], eax
  00026	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00029	8b cb		 mov	 ecx, ebx
  0002b	c1 e9 08	 shr	 ecx, 8
  0002e	88 45 f4	 mov	 BYTE PTR _pResult$[ebp+4], al

; 2175 : 	pResult.CliVersion[1] = szClientVersion[1];

  00031	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR ?szClientVersion@@3PADA+1
  00038	88 4d f5	 mov	 BYTE PTR _pResult$[ebp+5], cl

; 2176 : 	pResult.CliVersion[2] = szClientVersion[2];

  0003b	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR ?szClientVersion@@3PADA+2
  00041	88 4d f9	 mov	 BYTE PTR _pResult$[ebp+9], cl
  00044	88 55 f7	 mov	 BYTE PTR _pResult$[ebp+7], dl

; 2177 : 	pResult.CliVersion[3] = szClientVersion[3];

  00047	0f b6 15 03 00
	00 00		 movzx	 edx, BYTE PTR ?szClientVersion@@3PADA+3
  0004e	88 45 f8	 mov	 BYTE PTR _pResult$[ebp+8], al

; 2178 : 	pResult.CliVersion[4] = szClientVersion[4];

  00051	0f b6 05 04 00
	00 00		 movzx	 eax, BYTE PTR ?szClientVersion@@3PADA+4

; 2179 : 
; 2180 : 	DataSend(aIndex, (unsigned char*)&pResult, pResult.h.size);

  00058	6a 0c		 push	 12			; 0000000cH
  0005a	8d 4d f0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0005d	51		 push	 ecx
  0005e	53		 push	 ebx
  0005f	c7 45 f0 c1 0c
	f1 00		 mov	 DWORD PTR _pResult$[ebp], 15797441 ; 00f10cc1H
  00066	88 5d f6	 mov	 BYTE PTR _pResult$[ebp+6], bl
  00069	88 55 fa	 mov	 BYTE PTR _pResult$[ebp+10], dl
  0006c	88 45 fb	 mov	 BYTE PTR _pResult$[ebp+11], al
  0006f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2181 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();

  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0007d	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00083	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2182 : }

  00089	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008c	89 44 13 3c	 mov	 DWORD PTR [ebx+edx+60], eax
  00090	33 cd		 xor	 ecx, ebp
  00092	5b		 pop	 ebx
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?SCPJoinResultSend@@YAXHE@Z ENDP			; SCPJoinResultSend
_TEXT	ENDS
PUBLIC	??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_04FLFDNKBN@m321?$AA@			; `string'
PUBLIC	??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z ; CSPJoinIdPassRequestTEST
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?wsJServerCli@@3VwsJoinServerCli@@A:BYTE	; wsJServerCli
EXTRN	?BuxConvert@@YAXPADH@Z:PROC			; BuxConvert
EXTRN	__imp__wsprintfA:PROC
;	COMDAT ??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@ DB 'login send : %s'
	DB	' %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04FLFDNKBN@m321?$AA@
CONST	SEGMENT
??_C@_04FLFDNKBN@m321?$AA@ DB 'm321', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@
CONST	SEGMENT
??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@ DB 0bdH, 0b8H, 0b5H, 0b9H
	DB	0c0H, 0ccH, '%d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z
_TEXT	SEGMENT
_spMsg$ = -84						; size = 54
_szId$ = -28						; size = 11
_szPass$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z PROC	; CSPJoinIdPassRequestTEST, COMDAT

; 2298 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 2299 : 	char szId[11];
; 2300 : 	char szPass[11];
; 2301 : 	LPOBJ lpObj = &gObj[aIndex];
; 2302 : 	SDHP_IDPASS spMsg;
; 2303 : 
; 2304 : 	PHeadSetB((LPBYTE)&spMsg, 0x11, sizeof(spMsg));

  00014	6a 36		 push	 54			; 00000036H
  00016	8d 45 ac	 lea	 eax, DWORD PTR _spMsg$[ebp]
  00019	6a 11		 push	 17			; 00000011H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2305 : 	spMsg.Number = aIndex;
; 2306 : 	wsprintf(szId, "%d", logincounttest);

  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?logincounttest@@3HA ; logincounttest
  00027	51		 push	 ecx
  00028	8d 55 e4	 lea	 edx, DWORD PTR _szId$[ebp]
  0002b	66 89 75 ce	 mov	 WORD PTR _spMsg$[ebp+34], si
  0002f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wsprintfA
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@
  0003a	52		 push	 edx
  0003b	ff d6		 call	 esi

; 2307 : 	wsprintf(szPass, "m321", rand()%9);

  0003d	e8 00 00 00 00	 call	 _rand
  00042	99		 cdq
  00043	b9 09 00 00 00	 mov	 ecx, 9
  00048	f7 f9		 idiv	 ecx
  0004a	52		 push	 edx
  0004b	8d 55 f0	 lea	 edx, DWORD PTR _szPass$[ebp]
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_04FLFDNKBN@m321?$AA@
  00053	52		 push	 edx
  00054	ff d6		 call	 esi

; 2308 : 	LogAdd("login send : %s %s", szId, szPass);

  00056	8d 45 f0	 lea	 eax, DWORD PTR _szPass$[ebp]
  00059	50		 push	 eax
  0005a	8d 4d e4	 lea	 ecx, DWORD PTR _szId$[ebp]
  0005d	51		 push	 ecx
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2309 : 	
; 2310 : 	BuxConvert(szId, MAX_ACCOUNT_LEN);

  00069	8d 55 e4	 lea	 edx, DWORD PTR _szId$[ebp]
  0006c	6a 0a		 push	 10			; 0000000aH
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert

; 2311 : 	BuxConvert(szPass, MAX_ACCOUNT_LEN);

  00074	8d 45 f0	 lea	 eax, DWORD PTR _szPass$[ebp]
  00077	6a 0a		 push	 10			; 0000000aH
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert

; 2312 : 	memcpy(spMsg.Id, szId, MAX_ACCOUNT_LEN);

  0007f	0f b7 45 ec	 movzx	 eax, WORD PTR _szId$[ebp+8]
  00083	8b 4d e4	 mov	 ecx, DWORD PTR _szId$[ebp]
  00086	8b 55 e8	 mov	 edx, DWORD PTR _szId$[ebp+4]

; 2313 : 	memcpy(spMsg.Pass, szPass, MAX_ACCOUNT_LEN);
; 2314 : 	logincounttest++;
; 2315 : 	
; 2316 : 	if ( (GetTickCount()-ltesttime) > 1000 )

  00089	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  0008f	ff 05 00 00 00
	00		 inc	 DWORD PTR ?logincounttest@@3HA ; logincounttest
  00095	66 89 45 b7	 mov	 WORD PTR _spMsg$[ebp+11], ax
  00099	0f b7 45 f8	 movzx	 eax, WORD PTR _szPass$[ebp+8]
  0009d	89 4d af	 mov	 DWORD PTR _spMsg$[ebp+3], ecx
  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _szPass$[ebp]
  000a3	89 55 b3	 mov	 DWORD PTR _spMsg$[ebp+7], edx
  000a6	8b 55 f4	 mov	 edx, DWORD PTR _szPass$[ebp+4]
  000a9	83 c4 40	 add	 esp, 64			; 00000040H
  000ac	89 4d b9	 mov	 DWORD PTR _spMsg$[ebp+13], ecx
  000af	89 55 bd	 mov	 DWORD PTR _spMsg$[ebp+17], edx
  000b2	66 89 45 c1	 mov	 WORD PTR _spMsg$[ebp+21], ax
  000b6	ff d6		 call	 esi
  000b8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ltesttime@@3HA ; ltesttime
  000be	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  000c3	76 11		 jbe	 SHORT $LN1@CSPJoinIdP

; 2317 : 	{
; 2318 : 		ltesttime = GetTickCount();

  000c5	ff d6		 call	 esi
  000c7	a3 00 00 00 00	 mov	 DWORD PTR ?ltesttime@@3HA, eax ; ltesttime

; 2319 : 		logincounttest=0;

  000cc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?logincounttest@@3HA, 0 ; logincounttest
$LN1@CSPJoinIdP:

; 2320 : 	}
; 2321 : 
; 2322 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  000d6	0f b6 4d ad	 movzx	 ecx, BYTE PTR _spMsg$[ebp+1]
  000da	51		 push	 ecx
  000db	8d 55 ac	 lea	 edx, DWORD PTR _spMsg$[ebp]
  000de	52		 push	 edx
  000df	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  000e4	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 2323 : 	spMsg.h.headcode = 0x01;
; 2324 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  000e9	0f b6 45 ad	 movzx	 eax, BYTE PTR _spMsg$[ebp+1]
  000ed	50		 push	 eax
  000ee	8d 4d ac	 lea	 ecx, DWORD PTR _spMsg$[ebp]
  000f1	51		 push	 ecx
  000f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  000f7	c6 45 ae 01	 mov	 BYTE PTR _spMsg$[ebp+2], 1
  000fb	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 2325 : }

  00100	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00103	33 cd		 xor	 ecx, ebp
  00105	5e		 pop	 esi
  00106	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z ENDP	; CSPJoinIdPassRequestTEST
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCJoinBillCheckSend@@YAXPADH@Z			; GCJoinBillCheckSend
; Function compile flags: /Ogtp
;	COMDAT ?GCJoinBillCheckSend@@YAXPADH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_AccountId$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCJoinBillCheckSend@@YAXPADH@Z PROC			; GCJoinBillCheckSend, COMDAT

; 2343 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _AccountId$[ebp]

; 2344 : 	SDHP_BILLSEARCH pMsg;
; 2345 : 
; 2346 : 	PHeadSetB((LPBYTE)&pMsg, 0x06, sizeof(pMsg));

  00014	6a 10		 push	 16			; 00000010H
  00016	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 06		 push	 6
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2347 : 	memcpy(pMsg.Id, AccountId, sizeof(pMsg.Id));

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00026	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]
  0002a	89 55 f3	 mov	 DWORD PTR _pMsg$[ebp+7], edx

; 2348 : 	pMsg.Number = aIndex;
; 2349 : 
; 2350 : 	wsJServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  0002d	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	89 4d ef	 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  00037	66 8b 4d 0c	 mov	 cx, WORD PTR _aIndex$[ebp]
  0003b	66 89 45 f7	 mov	 WORD PTR _pMsg$[ebp+11], ax
  0003f	52		 push	 edx
  00040	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00043	66 89 4d fa	 mov	 WORD PTR _pMsg$[ebp+14], cx
  00047	50		 push	 eax
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  0004d	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 2351 : }

  00052	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00055	33 cd		 xor	 ecx, ebp
  00057	5e		 pop	 esi
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?GCJoinBillCheckSend@@YAXPADH@Z ENDP			; GCJoinBillCheckSend
_TEXT	ENDS
PUBLIC	?GCJoinResult@@YAXEH@Z				; GCJoinResult
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
; Function compile flags: /Ogtp
;	COMDAT ?GCJoinResult@@YAXEH@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 5
_result$ = 8						; size = 1
_aIndex$ = 12						; size = 4
?GCJoinResult@@YAXEH@Z PROC				; GCJoinResult, COMDAT

; 2359 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2360 : 	PMSG_RESULT  pResult;
; 2361 : 
; 2362 : 	PHeadSubSetB((LPBYTE)&pResult, 0xF1, 0x01, sizeof(pResult));

  00006	6a 05		 push	 5
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2363 : 	pResult.result = result;
; 2364 : 	DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0001c	8a 4d 08	 mov	 cl, BYTE PTR _result$[ebp]
  0001f	52		 push	 edx
  00020	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00023	88 4d fc	 mov	 BYTE PTR _pResult$[ebp+4], cl
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00029	50		 push	 eax
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2365 : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCJoinResult@@YAXEH@Z ENDP				; GCJoinResult
_TEXT	ENDS
PUBLIC	?GCJoinSocketResult@@YAXEI@Z			; GCJoinSocketResult
EXTRN	?DataSocketSend@CwsGameServer@@QAEHIPADH@Z:PROC	; CwsGameServer::DataSocketSend
EXTRN	?wsGServer@@3VCwsGameServer@@A:BYTE		; wsGServer
; Function compile flags: /Ogtp
;	COMDAT ?GCJoinSocketResult@@YAXEI@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 5
_result$ = 8						; size = 1
_Socket$ = 12						; size = 4
?GCJoinSocketResult@@YAXEI@Z PROC			; GCJoinSocketResult, COMDAT

; 2371 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2372 : 	PMSG_RESULT pResult;
; 2373 : 
; 2374 : 	PHeadSubSetB((LPBYTE)&pResult , 0xF1, 0x01, sizeof(pResult) );

  00006	6a 05		 push	 5
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2375 : 	pResult.result= result;
; 2376 : 
; 2377 : 	wsGServer.DataSocketSend(Socket, (char*)&pResult, pResult.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0001c	8a 4d 08	 mov	 cl, BYTE PTR _result$[ebp]
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
  00022	52		 push	 edx
  00023	88 4d fc	 mov	 BYTE PTR _pResult$[ebp+4], cl
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _Socket$[ebp]
  00029	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsGServer@@3VCwsGameServer@@A ; wsGServer
  00033	e8 00 00 00 00	 call	 ?DataSocketSend@CwsGameServer@@QAEHIPADH@Z ; CwsGameServer::DataSocketSend

; 2378 : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?GCJoinSocketResult@@YAXEI@Z ENDP			; GCJoinSocketResult
_TEXT	ENDS
PUBLIC	??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@ ; `string'
PUBLIC	?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z	; CGClientCloseMsg
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObjCloseSet@@YAXHH@Z:PROC			; gObjCloseSet
;	COMDAT ??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'UserSelClose] Go Exit [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@ DB '['
	DB	'UserSelClose] Go CharSelect [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@ DB '['
	DB	'UserSelClose] Go ServerList [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z PROC	; CGClientCloseMsg, COMDAT

; 2386 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2387 : 	switch ( lpMsg->Flag )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0000a	83 e8 00	 sub	 eax, 0
  0000d	56		 push	 esi
  0000e	0f 84 c0 00 00
	00		 je	 $LN9@CGClientCl
  00014	48		 dec	 eax
  00015	74 62		 je	 SHORT $LN3@CGClientCl
  00017	48		 dec	 eax
  00018	0f 85 09 01 00
	00		 jne	 $LN7@CGClientCl

; 2400 : 			break;
; 2401 : 
; 2402 : 		case 2:	// ServerList
; 2403 : 			gObjCloseSet(aIndex, 2);

  0001e	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00021	6a 02		 push	 2
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  00029	83 c4 08	 add	 esp, 8

; 2404 : 
; 2405 : 			if ( aIndex < 0 || aIndex > OBJMAX-1)

  0002c	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00032	0f 87 ef 00 00
	00		 ja	 $LN7@CGClientCl

; 2406 : 			{
; 2407 : 				return;
; 2408 : 			}
; 2409 : 
; 2410 : 			LogAddTD("[UserSelClose] Go ServerList [%s][%s] Map:[%d][%d/%d]",
; 2411 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2412 : 				gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);

  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003e	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00044	0f b6 94 0e 21
	01 00 00	 movzx	 edx, BYTE PTR [esi+ecx+289]
  0004c	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0004f	0f b6 88 20 01
	00 00		 movzx	 ecx, BYTE PTR [eax+288]
  00056	52		 push	 edx
  00057	0f b6 90 23 01
	00 00		 movzx	 edx, BYTE PTR [eax+291]
  0005e	51		 push	 ecx
  0005f	52		 push	 edx
  00060	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  00063	51		 push	 ecx
  00064	83 c0 52	 add	 eax, 82			; 00000052H
  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00073	83 c4 18	 add	 esp, 24			; 00000018H
  00076	5e		 pop	 esi

; 2426 : 			break;
; 2427 : 	}
; 2428 : }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN3@CGClientCl:

; 2413 : 			break;
; 2414 : 
; 2415 : 		case 1:	// Select Character
; 2416 : 			gObjCloseSet(aIndex, 1);

  00079	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0007c	6a 01		 push	 1
  0007e	56		 push	 esi
  0007f	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  00084	83 c4 08	 add	 esp, 8

; 2417 : 
; 2418 : 			if ( aIndex < 0 || aIndex > OBJMAX-1)

  00087	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0008d	0f 87 94 00 00
	00		 ja	 $LN7@CGClientCl

; 2419 : 			{
; 2420 : 				return;
; 2421 : 			}
; 2422 : 
; 2423 : 			LogAddTD("[UserSelClose] Go CharSelect [%s][%s] Map:[%d][%d/%d]",
; 2424 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2425 : 				gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);

  00093	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00099	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0009f	0f b6 8c 16 21
	01 00 00	 movzx	 ecx, BYTE PTR [esi+edx+289]
  000a7	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  000aa	0f b6 90 20 01
	00 00		 movzx	 edx, BYTE PTR [eax+288]
  000b1	51		 push	 ecx
  000b2	0f b6 88 23 01
	00 00		 movzx	 ecx, BYTE PTR [eax+291]
  000b9	52		 push	 edx
  000ba	51		 push	 ecx
  000bb	8d 50 5d	 lea	 edx, DWORD PTR [eax+93]
  000be	52		 push	 edx
  000bf	83 c0 52	 add	 eax, 82			; 00000052H
  000c2	50		 push	 eax
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ce	83 c4 18	 add	 esp, 24			; 00000018H
  000d1	5e		 pop	 esi

; 2426 : 			break;
; 2427 : 	}
; 2428 : }

  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN9@CGClientCl:

; 2388 : 	{
; 2389 : 		case 0:	// Close Game
; 2390 : 			gObjCloseSet(aIndex, 0);

  000d4	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  000d7	6a 00		 push	 0
  000d9	56		 push	 esi
  000da	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  000df	83 c4 08	 add	 esp, 8

; 2391 : 
; 2392 : 			if ( aIndex < 0 || aIndex > OBJMAX-1)

  000e2	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  000e8	77 3d		 ja	 SHORT $LN7@CGClientCl

; 2393 : 			{
; 2394 : 				return;
; 2395 : 			}
; 2396 : 
; 2397 : 			LogAddTD("[UserSelClose] Go Exit [%s][%s] Map:[%d][%d/%d]",
; 2398 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2399 : 				gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);

  000ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ef	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  000f5	0f b6 8c 30 21
	01 00 00	 movzx	 ecx, BYTE PTR [eax+esi+289]
  000fd	0f b6 94 30 20
	01 00 00	 movzx	 edx, BYTE PTR [eax+esi+288]
  00105	03 c6		 add	 eax, esi
  00107	51		 push	 ecx
  00108	0f b6 88 23 01
	00 00		 movzx	 ecx, BYTE PTR [eax+291]
  0010f	52		 push	 edx
  00110	51		 push	 ecx
  00111	8d 50 5d	 lea	 edx, DWORD PTR [eax+93]
  00114	52		 push	 edx
  00115	83 c0 52	 add	 eax, 82			; 00000052H
  00118	50		 push	 eax
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00124	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@CGClientCl:
  00127	5e		 pop	 esi

; 2426 : 			break;
; 2427 : 	}
; 2428 : }

  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z ENDP	; CGClientCloseMsg
_TEXT	ENDS
PUBLIC	?GCCloseMsgSend@@YAXHE@Z			; GCCloseMsgSend
EXTRN	?PHeadSubSetBE@@YAXPAEEEH@Z:PROC		; PHeadSubSetBE
; Function compile flags: /Ogtp
;	COMDAT ?GCCloseMsgSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?GCCloseMsgSend@@YAXHE@Z PROC				; GCCloseMsgSend, COMDAT

; 2436 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2437 : 	PMSG_RESULT pMsg;
; 2438 : 
; 2439 : 	PHeadSubSetBE((LPBYTE)&pMsg, 0xF1, 0x02, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 02		 push	 2
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetBE@@YAXPAEEEH@Z ; PHeadSubSetBE

; 2440 : 	pMsg.result = result;
; 2441 : 	
; 2442 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001c	8a 4d 0c	 mov	 cl, BYTE PTR _result$[ebp]
  0001f	52		 push	 edx
  00020	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00023	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00029	50		 push	 eax
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2443 : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCCloseMsgSend@@YAXHE@Z ENDP				; GCCloseMsgSend
_TEXT	ENDS
PUBLIC	??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@ ; `string'
PUBLIC	?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z		; CGClientMsg
;	COMDAT ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@
CONST	SEGMENT
??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@ DB 'e'
	DB	'rror-L1 : HackCheck [%s][%s] 0x%x 0x%x', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z PROC		; CGClientMsg, COMDAT

; 2450 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2451 : 	if ( lpMsg->Flag )

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00006	8a 4a 04	 mov	 cl, BYTE PTR [edx+4]
  00009	56		 push	 esi
  0000a	84 c9		 test	 cl, cl
  0000c	74 33		 je	 SHORT $LN4@CGClientMs

; 2452 : 	{
; 2453 : 		LogAddC(2,"error-L1 : HackCheck [%s][%s] 0x%x 0x%x",
; 2454 : 			gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2455 : 			lpMsg->Flag, lpMsg->subFlag);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00011	0f b6 52 05	 movzx	 edx, BYTE PTR [edx+5]
  00015	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0001b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00021	52		 push	 edx
  00022	0f b6 c9	 movzx	 ecx, cl
  00025	51		 push	 ecx
  00026	8d 50 5d	 lea	 edx, DWORD PTR [eax+93]
  00029	52		 push	 edx
  0002a	83 c0 52	 add	 eax, 82			; 00000052H
  0002d	50		 push	 eax
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@
  00033	6a 02		 push	 2
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0003b	83 c4 18	 add	 esp, 24			; 00000018H
  0003e	5e		 pop	 esi

; 2470 : 	}
; 2471 : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN4@CGClientMs:

; 2456 : 	}
; 2457 : 	else 
; 2458 : 	{
; 2459 : 		if ( gObj[aIndex].m_ClientHackLogCount < 100 )

  00041	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00049	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0004f	80 bc 06 77 14
	00 00 64	 cmp	 BYTE PTR [esi+eax+5239], 100 ; 00000064H
  00057	73 26		 jae	 SHORT $LN2@CGClientMs

; 2460 : 		{
; 2461 : 			LogAddC(2, "error-L1 : HackCheck [%s][%s] 0x%x 0x%x",
; 2462 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2463 : 				lpMsg->Flag, lpMsg->subFlag);

  00059	0f b6 4a 05	 movzx	 ecx, BYTE PTR [edx+5]
  0005d	51		 push	 ecx
  0005e	6a 00		 push	 0
  00060	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  00064	52		 push	 edx
  00065	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00069	50		 push	 eax
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@
  0006f	6a 02		 push	 2
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007c	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@CGClientMs:

; 2464 : 		}
; 2465 : 
; 2466 : 		gObj[aIndex].m_ClientHackLogCount++;

  0007f	fe 84 06 77 14
	00 00		 inc	 BYTE PTR [esi+eax+5239]

; 2467 : 
; 2468 : 		if ( gObj[aIndex].m_ClientHackLogCount >= 100 )

  00086	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008b	80 bc 06 77 14
	00 00 64	 cmp	 BYTE PTR [esi+eax+5239], 100 ; 00000064H
  00093	72 08		 jb	 SHORT $LN1@CGClientMs

; 2469 : 			gObj[aIndex].m_ClientHackLogCount = 100;

  00095	c6 84 06 77 14
	00 00 64	 mov	 BYTE PTR [esi+eax+5239], 100 ; 00000064H
$LN1@CGClientMs:
  0009d	5e		 pop	 esi

; 2470 : 	}
; 2471 : }

  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z ENDP		; CGClientMsg
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@ ; `string'
PUBLIC	??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@ ; `string'
PUBLIC	??_C@_0DN@NJBNDAEI@?$FL?$CFs?$FN?5Create?5character?5error?5?$CIReq@ ; `string'
PUBLIC	??_C@_0CA@LCMJGFID@Character?5creation?5is?5disabled?$CB?$AA@ ; `string'
PUBLIC	??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z	; CGPCharacterCreate
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	_isalnum:PROC
EXTRN	?g_MultilangCharacterName@@3EA:BYTE		; g_MultilangCharacterName
EXTRN	?g_CreateCharLevelRF@@3FA:WORD			; g_CreateCharLevelRF
EXTRN	?g_CreateCharLevelSUM@@3FA:WORD			; g_CreateCharLevelSUM
EXTRN	?g_CreateCharLevelDL@@3FA:WORD			; g_CreateCharLevelDL
EXTRN	?g_CreateCharLevelMG@@3FA:WORD			; g_CreateCharLevelMG
EXTRN	?gCreateCharacter@@3HA:DWORD			; gCreateCharacter
EXTRN	?JGCharacterCreateFailSend@@YAXHPAD@Z:PROC	; JGCharacterCreateFailSend
;	COMDAT ??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@
CONST	SEGMENT
??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@ DB 'Character'
	DB	' create : %s,%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@
CONST	SEGMENT
??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@ DB 'error-L1: D'
	DB	'arklord Character create error [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@
CONST	SEGMENT
??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@ DB 'error-L1: M'
	DB	'agumsa Character create error [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@NJBNDAEI@?$FL?$CFs?$FN?5Create?5character?5error?5?$CIReq@
CONST	SEGMENT
??_C@_0DN@NJBNDAEI@?$FL?$CFs?$FN?5Create?5character?5error?5?$CIReq@ DB '['
	DB	'%s] Create character error (ReqLevel: %d, AccountLevel: %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LCMJGFID@Character?5creation?5is?5disabled?$CB?$AA@
CONST	SEGMENT
??_C@_0CA@LCMJGFID@Character?5creation?5is?5disabled?$CB?$AA@ DB 'Charact'
	DB	'er creation is disabled!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@
CONST	SEGMENT
??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@ DB '[A'
	DB	'nti-HACK][CGPCharacterCreate] Attempted Character Create duri'
	DB	'ng GamePlay. [%s][%s]', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z
_TEXT	SEGMENT
tv297 = -136						; size = 4
_i$217885 = -132					; size = 4
tv463 = -125						; size = 1
_pResult$217890 = -124					; size = 44
_sCreate$ = -80						; size = 36
_szTemp2$ = -44						; size = 20
_szTemp$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z PROC	; CGPCharacterCreate, COMDAT

; 2490 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2491 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001c	56		 push	 esi
  0001d	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00020	57		 push	 edi
  00021	8b fb		 mov	 edi, ebx
  00023	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00029	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	75 1e		 jne	 SHORT $LN22@CGPCharact
$LN38@CGPCharact:

; 2492 : 	{
; 2493 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  00039	83 c6 04	 add	 esi, 4
  0003c	56		 push	 esi
  0003d	53		 push	 ebx
  0003e	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  00043	83 c4 08	 add	 esp, 8
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx

; 2634 : }

  00049	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004c	33 cd		 xor	 ecx, ebp
  0004e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN22@CGPCharact:

; 2494 : 		return;
; 2495 : 	}
; 2496 : 
; 2497 : 	if ( gObj[aIndex].Connected < PLAYER_LOGGED )

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005c	8b 4c 07 04	 mov	 ecx, DWORD PTR [edi+eax+4]
  00060	83 f9 02	 cmp	 ecx, 2
  00063	7d 36		 jge	 SHORT $LN21@CGPCharact

; 2498 : 	{
; 2499 : 		LogAdd(lMsg.Get(MSGGET(1, 220)), aIndex, gObj[aIndex].Ip_addr);

  00065	8d 54 07 1c	 lea	 edx, DWORD PTR [edi+eax+28]
  00069	52		 push	 edx
  0006a	53		 push	 ebx
  0006b	68 dc 01 00 00	 push	 476			; 000001dcH
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00075	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0007a	50		 push	 eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2500 : 		CloseClient(aIndex);

  00081	53		 push	 ebx
  00082	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00087	83 c4 10	 add	 esp, 16			; 00000010H
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx

; 2634 : }

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00090	33 cd		 xor	 ecx, ebp
  00092	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN21@CGPCharact:

; 2501 : 
; 2502 : 		return;
; 2503 : 	}
; 2504 : 
; 2505 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  0009b	83 f9 03	 cmp	 ecx, 3
  0009e	75 2f		 jne	 SHORT $LN20@CGPCharact

; 2506 : 	{
; 2507 : 		LogAddTD("[Anti-HACK][CGPCharacterCreate] Attempted Character Create during GamePlay. [%s][%s]",
; 2508 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);

  000a0	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  000a4	51		 push	 ecx
  000a5	8d 54 07 52	 lea	 edx, DWORD PTR [edi+eax+82]
  000a9	52		 push	 edx
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2509 : 		CloseClient(aIndex);

  000b5	53		 push	 ebx
  000b6	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000bb	83 c4 10	 add	 esp, 16			; 00000010H
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx

; 2634 : }

  000c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c4	33 cd		 xor	 ecx, ebp
  000c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
$LN20@CGPCharact:

; 2510 : 
; 2511 : 		return;
; 2512 : 	}
; 2513 : 
; 2514 : 	if ( !gCreateCharacter )

  000cf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCreateCharacter@@3HA, 0 ; gCreateCharacter
  000d6	75 2b		 jne	 SHORT $LN19@CGPCharact

; 2515 : 	{
; 2516 : 		GCServerMsgStringSend("Character creation is disabled!", aIndex, 1);

  000d8	6a 01		 push	 1
  000da	53		 push	 ebx
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LCMJGFID@Character?5creation?5is?5disabled?$CB?$AA@
  000e0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 2517 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  000e5	83 c6 04	 add	 esi, 4
  000e8	56		 push	 esi
  000e9	53		 push	 ebx
  000ea	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  000ef	83 c4 14	 add	 esp, 20			; 00000014H
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx

; 2634 : }

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f8	33 cd		 xor	 ecx, ebp
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN19@CGPCharact:

; 2518 : 		return;
; 2519 : 	}
; 2520 : 
; 2521 : 
; 2522 : 	if ( lpMsg->ClassSkin == 0x00 ||
; 2523 : 		 lpMsg->ClassSkin == 0x10 ||
; 2524 : 		 lpMsg->ClassSkin == 0x20 ||
; 2525 : 		 lpMsg->ClassSkin == 0x30 ||
; 2526 : 		 lpMsg->ClassSkin == 0x40 ||
; 2527 : 		 lpMsg->ClassSkin == 0x50 ||
; 2528 : 		 lpMsg->ClassSkin == 0x60 )

  00103	8a 4e 0e	 mov	 cl, BYTE PTR [esi+14]
  00106	84 c9		 test	 cl, cl
  00108	74 22		 je	 SHORT $LN17@CGPCharact
  0010a	80 f9 10	 cmp	 cl, 16			; 00000010H
  0010d	74 1d		 je	 SHORT $LN17@CGPCharact
  0010f	80 f9 20	 cmp	 cl, 32			; 00000020H
  00112	74 18		 je	 SHORT $LN17@CGPCharact
  00114	80 f9 30	 cmp	 cl, 48			; 00000030H
  00117	74 1c		 je	 SHORT $LN37@CGPCharact
  00119	80 f9 40	 cmp	 cl, 64			; 00000040H
  0011c	74 0e		 je	 SHORT $LN17@CGPCharact
  0011e	80 f9 50	 cmp	 cl, 80			; 00000050H
  00121	74 09		 je	 SHORT $LN17@CGPCharact
  00123	80 f9 60	 cmp	 cl, 96			; 00000060H

; 2529 : 	{
; 2530 : 
; 2531 : 	}
; 2532 : 	else
; 2533 : 	{
; 2534 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2535 : 		return;

  00126	0f 85 0d ff ff
	ff		 jne	 $LN38@CGPCharact
$LN17@CGPCharact:

; 2536 : 	}
; 2537 : 
; 2538 : 	
; 2539 : 
; 2540 : 	if( lpMsg->ClassSkin == 0x30 ) // MG

  0012c	80 f9 30	 cmp	 cl, 48			; 00000030H
  0012f	0f 85 83 00 00
	00		 jne	 $LN13@CGPCharact
$LN37@CGPCharact:

; 2541 : 	{
; 2542 : 		if( gObj[aIndex].m_AccountMaxLevel < g_CreateCharLevelMG )

  00135	0f b7 4c 07 08	 movzx	 ecx, WORD PTR [edi+eax+8]
  0013a	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?g_CreateCharLevelMG@@3FA ; g_CreateCharLevelMG
  00141	66 3b ca	 cmp	 cx, dx
  00144	7d 38		 jge	 SHORT $LN14@CGPCharact
$LN39@CGPCharact:

; 2543 : 		{
; 2544 : 			LogAddC(2, "[%s] Create character error (ReqLevel: %d, AccountLevel: %d)", 
; 2545 : 				gObj[aIndex].AccountID, g_CreateCharLevelMG, gObj[aIndex].m_AccountMaxLevel);

  00146	0f bf c9	 movsx	 ecx, cx
  00149	51		 push	 ecx
  0014a	0f bf d2	 movsx	 edx, dx
  0014d	52		 push	 edx
  0014e	8d 44 07 52	 lea	 eax, DWORD PTR [edi+eax+82]
  00152	50		 push	 eax
  00153	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@NJBNDAEI@?$FL?$CFs?$FN?5Create?5character?5error?5?$CIReq@
  00158	6a 02		 push	 2
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 2546 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  00160	83 c6 04	 add	 esi, 4
  00163	56		 push	 esi
  00164	53		 push	 ebx
  00165	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  0016a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi
  0016f	5b		 pop	 ebx

; 2634 : }

  00170	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00173	33 cd		 xor	 ecx, ebp
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
$LN14@CGPCharact:

; 2547 : 			return;
; 2548 : 		}
; 2549 : 
; 2550 : 		if ( gObj[aIndex].Magumsa == 0 )

  0017e	80 7c 07 34 00	 cmp	 BYTE PTR [edi+eax+52], 0
  00183	75 30		 jne	 SHORT $LN30@CGPCharact

; 2551 : 		{
; 2552 : 			LogAddC(2, "error-L1: Magumsa Character create error [%s]", gObj[aIndex].AccountID);

  00185	8d 4c 07 52	 lea	 ecx, DWORD PTR [edi+eax+82]
  00189	51		 push	 ecx
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@
$LN40@CGPCharact:
  0018f	6a 02		 push	 2
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 2553 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  00197	83 c6 04	 add	 esi, 4
  0019a	56		 push	 esi
  0019b	53		 push	 ebx
  0019c	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  001a1	83 c4 14	 add	 esp, 20			; 00000014H
  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	5b		 pop	 ebx

; 2634 : }

  001a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001aa	33 cd		 xor	 ecx, ebp
  001ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b1	8b e5		 mov	 esp, ebp
  001b3	5d		 pop	 ebp
  001b4	c3		 ret	 0
$LN30@CGPCharact:

; 2554 : 			return;

  001b5	8a 4e 0e	 mov	 cl, BYTE PTR [esi+14]
$LN13@CGPCharact:

; 2555 : 		}
; 2556 : 	}
; 2557 : 
; 2558 : 	if ( lpMsg->ClassSkin == 0x40 ) // DL

  001b8	80 f9 40	 cmp	 cl, 64			; 00000040H
  001bb	75 2b		 jne	 SHORT $LN10@CGPCharact

; 2559 : 	{
; 2560 : 		if( gObj[aIndex].m_AccountMaxLevel < g_CreateCharLevelDL )

  001bd	0f b7 4c 07 08	 movzx	 ecx, WORD PTR [edi+eax+8]
  001c2	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?g_CreateCharLevelDL@@3FA ; g_CreateCharLevelDL
  001c9	66 3b ca	 cmp	 cx, dx

; 2561 : 		{
; 2562 : 			LogAddC(2, "[%s] Create character error (ReqLevel: %d, AccountLevel: %d)", 
; 2563 : 				gObj[aIndex].AccountID, g_CreateCharLevelDL, gObj[aIndex].m_AccountMaxLevel);
; 2564 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2565 : 			return;

  001cc	0f 8c 74 ff ff
	ff		 jl	 $LN39@CGPCharact

; 2566 : 		}
; 2567 : 
; 2568 : 		if ( gObj[aIndex].Magumsa != 2 )

  001d2	80 7c 07 34 02	 cmp	 BYTE PTR [edi+eax+52], 2
  001d7	74 0c		 je	 SHORT $LN31@CGPCharact

; 2569 : 		{
; 2570 : 			LogAddC(2, "error-L1: Darklord Character create error [%s]", gObj[aIndex].AccountID);

  001d9	8d 4c 07 52	 lea	 ecx, DWORD PTR [edi+eax+82]
  001dd	51		 push	 ecx
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@

; 2571 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2572 : 			return;

  001e3	eb aa		 jmp	 SHORT $LN40@CGPCharact
$LN31@CGPCharact:
  001e5	8a 4e 0e	 mov	 cl, BYTE PTR [esi+14]
$LN10@CGPCharact:

; 2573 : 		}
; 2574 : 	}
; 2575 : 	
; 2576 : 	if ( lpMsg->ClassSkin == 0x50 ) // SUM

  001e8	80 f9 50	 cmp	 cl, 80			; 00000050H
  001eb	75 18		 jne	 SHORT $LN8@CGPCharact

; 2577 : 	{
; 2578 : 		if( gObj[aIndex].m_AccountMaxLevel < g_CreateCharLevelSUM )

  001ed	0f b7 4c 07 08	 movzx	 ecx, WORD PTR [edi+eax+8]
  001f2	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?g_CreateCharLevelSUM@@3FA ; g_CreateCharLevelSUM
  001f9	66 3b ca	 cmp	 cx, dx

; 2579 : 		{
; 2580 : 			LogAddC(2, "[%s] Create character error (ReqLevel: %d, AccountLevel: %d)", 
; 2581 : 				gObj[aIndex].AccountID, g_CreateCharLevelSUM, gObj[aIndex].m_AccountMaxLevel);
; 2582 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2583 : 			return;

  001fc	0f 8c 44 ff ff
	ff		 jl	 $LN39@CGPCharact
  00202	8a 4e 0e	 mov	 cl, BYTE PTR [esi+14]
$LN8@CGPCharact:

; 2584 : 		}
; 2585 : 	}
; 2586 : 
; 2587 : 	if ( lpMsg->ClassSkin == 0x60 ) // RF

  00205	80 f9 60	 cmp	 cl, 96			; 00000060H
  00208	75 15		 jne	 SHORT $LN33@CGPCharact

; 2588 : 	{
; 2589 : 		if( gObj[aIndex].m_AccountMaxLevel < g_CreateCharLevelRF )

  0020a	0f b7 4c 07 08	 movzx	 ecx, WORD PTR [edi+eax+8]
  0020f	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?g_CreateCharLevelRF@@3FA ; g_CreateCharLevelRF
  00216	66 3b ca	 cmp	 cx, dx

; 2590 : 		{
; 2591 : 			LogAddC(2, "[%s] Create character error (ReqLevel: %d, AccountLevel: %d)", 
; 2592 : 				gObj[aIndex].AccountID, g_CreateCharLevelRF, gObj[aIndex].m_AccountMaxLevel);
; 2593 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2594 : 			return;

  00219	0f 8c 27 ff ff
	ff		 jl	 $LN39@CGPCharact
$LN33@CGPCharact:

; 2595 : 		}
; 2596 : 	}
; 2597 : 
; 2598 : 	if( g_MultilangCharacterName == 0 )

  0021f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_MultilangCharacterName@@3EA, 0 ; g_MultilangCharacterName
  00226	75 59		 jne	 SHORT $LN35@CGPCharact

; 2599 : 	{
; 2600 : 		for(int i = 0; i < strlen(lpMsg->Name); i++)

  00228	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0022b	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$217885[ebp], 0
  00235	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL28@CGPCharact:
  00238	8a 08		 mov	 cl, BYTE PTR [eax]
  0023a	40		 inc	 eax
  0023b	84 c9		 test	 cl, cl
  0023d	75 f9		 jne	 SHORT $LL28@CGPCharact
  0023f	2b c2		 sub	 eax, edx
  00241	74 3e		 je	 SHORT $LN35@CGPCharact
$LL34@CGPCharact:

; 2601 : 		{
; 2602 : 			if( !isalnum(lpMsg->Name[i]) )	

  00243	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _i$217885[ebp]
  00249	0f be 54 0e 04	 movsx	 edx, BYTE PTR [esi+ecx+4]
  0024e	52		 push	 edx
  0024f	e8 00 00 00 00	 call	 _isalnum
  00254	83 c4 04	 add	 esp, 4
  00257	85 c0		 test	 eax, eax
  00259	0f 84 e6 00 00
	00		 je	 $LN26@CGPCharact

; 2599 : 	{
; 2600 : 		for(int i = 0; i < strlen(lpMsg->Name); i++)

  0025f	ff 85 7c ff ff
	ff		 inc	 DWORD PTR _i$217885[ebp]
  00265	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00268	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0026b	eb 03 8d 49 00	 npad	 5
$LL29@CGPCharact:
  00270	8a 08		 mov	 cl, BYTE PTR [eax]
  00272	40		 inc	 eax
  00273	84 c9		 test	 cl, cl
  00275	75 f9		 jne	 SHORT $LL29@CGPCharact
  00277	2b c2		 sub	 eax, edx
  00279	39 85 7c ff ff
	ff		 cmp	 DWORD PTR _i$217885[ebp], eax
  0027f	72 c2		 jb	 SHORT $LL34@CGPCharact
$LN35@CGPCharact:

; 2611 : 				return;
; 2612 : 			}
; 2613 : 		}
; 2614 : 	}
; 2615 : 
; 2616 : 	SDHP_CREATECHAR sCreate;
; 2617 : 
; 2618 : 	memset(&sCreate, 0, sizeof(sCreate));

  00281	33 c0		 xor	 eax, eax

; 2619 : 	PHeadSetB((LPBYTE)&sCreate, 0x04, sizeof(sCreate));

  00283	6a 24		 push	 36			; 00000024H
  00285	8d 55 b0	 lea	 edx, DWORD PTR _sCreate$[ebp]
  00288	6a 04		 push	 4
  0028a	52		 push	 edx
  0028b	89 45 b0	 mov	 DWORD PTR _sCreate$[ebp], eax
  0028e	89 45 b4	 mov	 DWORD PTR _sCreate$[ebp+4], eax
  00291	89 45 b8	 mov	 DWORD PTR _sCreate$[ebp+8], eax
  00294	89 45 bc	 mov	 DWORD PTR _sCreate$[ebp+12], eax
  00297	89 45 c0	 mov	 DWORD PTR _sCreate$[ebp+16], eax
  0029a	89 45 c4	 mov	 DWORD PTR _sCreate$[ebp+20], eax
  0029d	89 45 c8	 mov	 DWORD PTR _sCreate$[ebp+24], eax
  002a0	89 45 cc	 mov	 DWORD PTR _sCreate$[ebp+28], eax
  002a3	89 45 d0	 mov	 DWORD PTR _sCreate$[ebp+32], eax
  002a6	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2620 : 	sCreate.ClassSkin = lpMsg->ClassSkin;

  002ab	8a 46 0e	 mov	 al, BYTE PTR [esi+14]
  002ae	88 45 d2	 mov	 BYTE PTR _sCreate$[ebp+34], al

; 2621 : 	sCreate.Number = aIndex;
; 2622 : 	memcpy(sCreate.AccountId, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);

  002b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b6	66 89 5d bc	 mov	 WORD PTR _sCreate$[ebp+12], bx
  002ba	8b 4c 07 52	 mov	 ecx, DWORD PTR [edi+eax+82]
  002be	89 4d be	 mov	 DWORD PTR _sCreate$[ebp+14], ecx
  002c1	8b 54 07 56	 mov	 edx, DWORD PTR [edi+eax+86]
  002c5	89 55 c2	 mov	 DWORD PTR _sCreate$[ebp+18], edx
  002c8	66 8b 44 07 5a	 mov	 ax, WORD PTR [edi+eax+90]

; 2623 : 	memcpy(sCreate.Name, lpMsg->Name, MAX_ACCOUNT_LEN);

  002cd	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  002d0	89 7d c8	 mov	 DWORD PTR _sCreate$[ebp+24], edi
  002d3	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  002d6	89 7d cc	 mov	 DWORD PTR _sCreate$[ebp+28], edi
  002d9	66 8b 7e 0c	 mov	 di, WORD PTR [esi+12]
  002dd	66 89 7d d0	 mov	 WORD PTR _sCreate$[ebp+32], di

; 2624 : 	char szTemp[20];
; 2625 : 	char szTemp2[20];
; 2626 : 	szTemp[10]=0;
; 2627 : 	szTemp2[10]=0;
; 2628 : 	memcpy(szTemp, sCreate.Name, MAX_ACCOUNT_LEN);

  002e1	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 2629 : 	memcpy(szTemp2, sCreate.AccountId, MAX_ACCOUNT_LEN);

  002e4	89 4d d4	 mov	 DWORD PTR _szTemp2$[ebp], ecx

; 2630 : 
; 2631 : 	LogAddTD("Character create : %s,%s", szTemp2, szTemp);

  002e7	8d 4d e8	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  002ea	89 55 d8	 mov	 DWORD PTR _szTemp2$[ebp+4], edx
  002ed	51		 push	 ecx
  002ee	8d 55 d4	 lea	 edx, DWORD PTR _szTemp2$[ebp]
  002f1	89 7d e8	 mov	 DWORD PTR _szTemp$[ebp], edi
  002f4	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  002f7	66 8b 76 0c	 mov	 si, WORD PTR [esi+12]
  002fb	52		 push	 edx
  002fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@
  00301	66 89 45 c6	 mov	 WORD PTR _sCreate$[ebp+22], ax
  00305	c6 45 f2 00	 mov	 BYTE PTR _szTemp$[ebp+10], 0
  00309	c6 45 de 00	 mov	 BYTE PTR _szTemp2$[ebp+10], 0
  0030d	89 7d ec	 mov	 DWORD PTR _szTemp$[ebp+4], edi
  00310	66 89 75 f0	 mov	 WORD PTR _szTemp$[ebp+8], si
  00314	66 89 45 dc	 mov	 WORD PTR _szTemp2$[ebp+8], ax
  00318	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2632 : 
; 2633 : 	cDBSMng.Send((char*)&sCreate, sCreate.h.size);

  0031e	0f b6 45 b1	 movzx	 eax, BYTE PTR _sCreate$[ebp+1]
  00322	83 c4 18	 add	 esp, 24			; 00000018H
  00325	50		 push	 eax
  00326	8d 4d b0	 lea	 ecx, DWORD PTR _sCreate$[ebp]
  00329	51		 push	 ecx
  0032a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0032f	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00334	5f		 pop	 edi
  00335	5e		 pop	 esi
  00336	5b		 pop	 ebx

; 2634 : }

  00337	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033a	33 cd		 xor	 ecx, ebp
  0033c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00341	8b e5		 mov	 esp, ebp
  00343	5d		 pop	 ebp
  00344	c3		 ret	 0
$LN26@CGPCharact:

; 2603 : 			{
; 2604 : 				PMSG_CHARCREATERESULT pResult = { 0 };

  00345	6a 2b		 push	 43			; 0000002bH
  00347	8d 45 85	 lea	 eax, DWORD PTR _pResult$217890[ebp+1]
  0034a	6a 00		 push	 0
  0034c	50		 push	 eax
  0034d	e8 00 00 00 00	 call	 _memset

; 2605 : 				pResult.h.c = 0xC1;
; 2606 : 				pResult.h.size = sizeof(PMSG_CHARCREATERESULT);
; 2607 : 				pResult.h.headcode = 0xF3;
; 2608 : 				pResult.subcode = 0x01;
; 2609 : 				pResult.Result = 2;
; 2610 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00352	6a 2c		 push	 44			; 0000002cH
  00354	8d 4d 84	 lea	 ecx, DWORD PTR _pResult$217890[ebp]
  00357	51		 push	 ecx
  00358	53		 push	 ebx
  00359	c7 45 84 c1 2c
	f3 01		 mov	 DWORD PTR _pResult$217890[ebp], 32713921 ; 01f32cc1H
  00360	c6 45 88 02	 mov	 BYTE PTR _pResult$217890[ebp+4], 2
  00364	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2634 : }

  00369	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0036c	83 c4 18	 add	 esp, 24			; 00000018H
  0036f	5f		 pop	 edi
  00370	5e		 pop	 esi
  00371	33 cd		 xor	 ecx, ebp
  00373	5b		 pop	 ebx
  00374	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00379	8b e5		 mov	 esp, ebp
  0037b	5d		 pop	 ebp
  0037c	c3		 ret	 0
?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z ENDP	; CGPCharacterCreate
_TEXT	ENDS
PUBLIC	??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ ; `string'
PUBLIC	??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z		; CGPCharDel
EXTRN	?GDReqPeriodItemDelete@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CCashItemPeriodSystem::GDReqPeriodItemDelete
EXTRN	?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A:BYTE ; g_CashItemPeriodSystem
EXTRN	?gObjJoominCheck@@YAHHPAD@Z:PROC		; gObjJoominCheck
EXTRN	?gc_bPersonalID@@3HA:DWORD			; gc_bPersonalID
EXTRN	?gGuildDestroy@@3HA:DWORD			; gGuildDestroy
;	COMDAT ??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@
CONST	SEGMENT
??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@ DB 'Character'
	DB	' delete : %s,%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
CONST	SEGMENT
??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ DB '[A'
	DB	'nti-HACK][CGPCharDel] Attempted Character Delete during Preve'
	DB	'nted Time. [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
CONST	SEGMENT
??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ DB '[An'
	DB	'ti-HACK][CGPCharDel] Attempted Character Delete during GamePl'
	DB	'ay. [%s][%s]', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z
_TEXT	SEGMENT
_pResult$ = -112					; size = 5
_pCDel$ = -104						; size = 36
_szTemp$ = -68						; size = 20
_szTemp2$ = -48						; size = 20
_szJoomin$ = -28					; size = 21
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z PROC		; CGPCharDel, COMDAT

; 2655 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2656 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001e	8b f7		 mov	 esi, edi
  00020	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00026	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002f	83 c4 04	 add	 esp, 4
  00032	85 c0		 test	 eax, eax
  00034	0f 84 9d 02 00
	00		 je	 $LN11@CGPCharDel

; 2657 : 		return;
; 2658 : 
; 2659 : 	if ( gObj[aIndex].Connected < PLAYER_LOGGED )

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003f	8b 4c 06 04	 mov	 ecx, DWORD PTR [esi+eax+4]
  00043	83 f9 02	 cmp	 ecx, 2
  00046	7d 1a		 jge	 SHORT $LN9@CGPCharDel

; 2660 : 	{
; 2661 : 		CloseClient(aIndex);

  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0004e	83 c4 04	 add	 esp, 4
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx

; 2749 : }

  00054	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00057	33 cd		 xor	 ecx, ebp
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN9@CGPCharDel:

; 2662 : 		return;
; 2663 : 	}
; 2664 : 
; 2665 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  00062	83 f9 03	 cmp	 ecx, 3
  00065	75 2f		 jne	 SHORT $LN8@CGPCharDel

; 2666 : 	{
; 2667 : 		LogAddTD("[Anti-HACK][CGPCharDel] Attempted Character Delete during GamePlay. [%s][%s]",
; 2668 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);

  00067	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  0006b	52		 push	 edx
  0006c	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00070	50		 push	 eax
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2669 : 		CloseClient(aIndex);

  0007c	57		 push	 edi
  0007d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00082	83 c4 10	 add	 esp, 16			; 00000010H
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx

; 2749 : }

  00088	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008b	33 cd		 xor	 ecx, ebp
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
$LN8@CGPCharDel:

; 2670 : 		return;
; 2671 : 	}
; 2672 : 
; 2673 : 	if ( gObj[aIndex].bEnableDelCharacter == FALSE )

  00096	83 7c 06 10 00	 cmp	 DWORD PTR [esi+eax+16], 0
  0009b	75 2f		 jne	 SHORT $LN7@CGPCharDel

; 2674 : 	{
; 2675 : 		LogAddTD("[Anti-HACK][CGPCharDel] Attempted Character Delete during Prevented Time. [%s][%s]",
; 2676 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);

  0009d	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  000a1	51		 push	 ecx
  000a2	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  000a6	52		 push	 edx
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2677 : 		CloseClient(aIndex);

  000b2	57		 push	 edi
  000b3	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000b8	83 c4 10	 add	 esp, 16			; 00000010H
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx

; 2749 : }

  000be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c1	33 cd		 xor	 ecx, ebp
  000c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN7@CGPCharDel:

; 2678 : 		return;
; 2679 : 	}
; 2680 : 
; 2681 : 	SDHP_CHARDELETE pCDel;
; 2682 : 	PMSG_RESULT pResult;
; 2683 : 
; 2684 : 	PHeadSubSetB((LPBYTE)&pResult, 0xF3, 0x02, sizeof(pResult));

  000cc	6a 05		 push	 5
  000ce	6a 02		 push	 2
  000d0	8d 45 90	 lea	 eax, DWORD PTR _pResult$[ebp]
  000d3	68 f3 00 00 00	 push	 243			; 000000f3H
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2685 : 	pResult.result = 0;
; 2686 : 
; 2687 : 	if ( gObj[aIndex].m_cAccountItemBlock )

  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e4	83 c4 10	 add	 esp, 16			; 00000010H
  000e7	c6 45 94 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  000eb	80 bc 0e c4 01
	00 00 00	 cmp	 BYTE PTR [esi+ecx+452], 0
  000f3	74 27		 je	 SHORT $LN6@CGPCharDel

; 2688 : 	{
; 2689 : 		pResult.result = 3;
; 2690 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000f5	0f b6 55 91	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  000f9	52		 push	 edx
  000fa	8d 45 90	 lea	 eax, DWORD PTR _pResult$[ebp]
  000fd	50		 push	 eax
  000fe	57		 push	 edi
  000ff	c6 45 94 03	 mov	 BYTE PTR _pResult$[ebp+4], 3
  00103	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx

; 2749 : }

  0010e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00111	33 cd		 xor	 ecx, ebp
  00113	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
$LN6@CGPCharDel:

; 2691 : 		return;
; 2692 : 	}
; 2693 : 
; 2694 : 	if ( !gGuildDestroy )

  0011c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGuildDestroy@@3HA, 0 ; gGuildDestroy
  00123	75 27		 jne	 SHORT $LN5@CGPCharDel

; 2695 : 	{
; 2696 : 		pResult.result = 0;
; 2697 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00125	0f b6 4d 91	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00129	51		 push	 ecx
  0012a	8d 55 90	 lea	 edx, DWORD PTR _pResult$[ebp]
  0012d	52		 push	 edx
  0012e	57		 push	 edi
  0012f	c6 45 94 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  00133	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx

; 2749 : }

  0013e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00141	33 cd		 xor	 ecx, ebp
  00143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
$LN5@CGPCharDel:

; 2698 : 		return;
; 2699 : 	}
; 2700 : 
; 2701 : 	char szJoomin[21];
; 2702 : 	char szTemp[20];
; 2703 : 	char szTemp2[20];
; 2704 : 
; 2705 : 	memset(szJoomin, 0, sizeof(szJoomin));
; 2706 : 	memcpy(szJoomin, lpMsg->LastJoominNumber, 20);

  0014c	8b 4b 12	 mov	 ecx, DWORD PTR [ebx+18]
  0014f	8b 53 16	 mov	 edx, DWORD PTR [ebx+22]
  00152	33 c0		 xor	 eax, eax

; 2707 : 
; 2708 : #if (__CUSTOM__ == 1)
; 2709 : 	if (gc_bPersonalID == TRUE && gObjJoominCheck(aIndex, szJoomin) == FALSE )

  00154	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gc_bPersonalID@@3HA, 1 ; gc_bPersonalID
  0015b	89 45 e4	 mov	 DWORD PTR _szJoomin$[ebp], eax
  0015e	89 45 e8	 mov	 DWORD PTR _szJoomin$[ebp+4], eax
  00161	89 45 ec	 mov	 DWORD PTR _szJoomin$[ebp+8], eax
  00164	89 45 f0	 mov	 DWORD PTR _szJoomin$[ebp+12], eax
  00167	89 45 f4	 mov	 DWORD PTR _szJoomin$[ebp+16], eax
  0016a	88 45 f8	 mov	 BYTE PTR _szJoomin$[ebp+20], al
  0016d	8b 43 0e	 mov	 eax, DWORD PTR [ebx+14]
  00170	89 45 e4	 mov	 DWORD PTR _szJoomin$[ebp], eax
  00173	8b 43 1a	 mov	 eax, DWORD PTR [ebx+26]
  00176	89 4d e8	 mov	 DWORD PTR _szJoomin$[ebp+4], ecx
  00179	8b 4b 1e	 mov	 ecx, DWORD PTR [ebx+30]
  0017c	89 55 ec	 mov	 DWORD PTR _szJoomin$[ebp+8], edx
  0017f	89 45 f0	 mov	 DWORD PTR _szJoomin$[ebp+12], eax
  00182	89 4d f4	 mov	 DWORD PTR _szJoomin$[ebp+16], ecx
  00185	75 38		 jne	 SHORT $LN4@CGPCharDel
  00187	8d 55 e4	 lea	 edx, DWORD PTR _szJoomin$[ebp]
  0018a	52		 push	 edx
  0018b	57		 push	 edi
  0018c	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  00191	83 c4 08	 add	 esp, 8
  00194	85 c0		 test	 eax, eax
  00196	75 27		 jne	 SHORT $LN4@CGPCharDel

; 2710 : #else
; 2711 : 	if (gObjJoominCheck(aIndex, szJoomin) == FALSE )
; 2712 : #endif
; 2713 : 	{
; 2714 : 		pResult.result = 2;
; 2715 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00198	0f b6 45 91	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0019c	50		 push	 eax
  0019d	8d 4d 90	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001a0	51		 push	 ecx
  001a1	57		 push	 edi
  001a2	c6 45 94 02	 mov	 BYTE PTR _pResult$[ebp+4], 2
  001a6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ae	5f		 pop	 edi
  001af	5e		 pop	 esi
  001b0	5b		 pop	 ebx

; 2749 : }

  001b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b4	33 cd		 xor	 ecx, ebp
  001b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bb	8b e5		 mov	 esp, ebp
  001bd	5d		 pop	 ebp
  001be	c3		 ret	 0
$LN4@CGPCharDel:

; 2716 : 		return;
; 2717 : 	}
; 2718 : 
; 2719 : 	PHeadSetB((LPBYTE)&pCDel, 0x05, sizeof(pCDel));

  001bf	6a 24		 push	 36			; 00000024H
  001c1	8d 55 98	 lea	 edx, DWORD PTR _pCDel$[ebp]
  001c4	6a 05		 push	 5
  001c6	52		 push	 edx
  001c7	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2720 : 	pCDel.Number = aIndex;
; 2721 : 	memcpy(pCDel.AccountID, gObj[aIndex].AccountID, sizeof(pCDel.AccountID));

  001cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d1	03 c6		 add	 eax, esi
  001d3	66 89 7d 9c	 mov	 WORD PTR _pCDel$[ebp+4], di
  001d7	8b 48 52	 mov	 ecx, DWORD PTR [eax+82]
  001da	89 4d 9e	 mov	 DWORD PTR _pCDel$[ebp+6], ecx
  001dd	8b 50 56	 mov	 edx, DWORD PTR [eax+86]

; 2722 : 	memcpy(pCDel.Name, lpMsg->Name, sizeof(pCDel.Name));

  001e0	83 c3 04	 add	 ebx, 4
  001e3	89 55 a2	 mov	 DWORD PTR _pCDel$[ebp+10], edx
  001e6	66 8b 48 5a	 mov	 cx, WORD PTR [eax+90]
  001ea	8b 13		 mov	 edx, DWORD PTR [ebx]
  001ec	66 89 4d a6	 mov	 WORD PTR _pCDel$[ebp+14], cx
  001f0	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001f3	89 55 a8	 mov	 DWORD PTR _pCDel$[ebp+16], edx
  001f6	66 8b 53 08	 mov	 dx, WORD PTR [ebx+8]
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fd	89 4d ac	 mov	 DWORD PTR _pCDel$[ebp+20], ecx
  00200	66 89 55 b0	 mov	 WORD PTR _pCDel$[ebp+24], dx

; 2723 : 	pCDel.Guild = 0;

  00204	c6 45 b2 00	 mov	 BYTE PTR _pCDel$[ebp+26], 0

; 2724 : 
; 2725 : 	if ( gObj[aIndex].GuildNumber > 0 && gObj[aIndex].lpGuild != NULL)

  00208	83 b8 14 06 00
	00 00		 cmp	 DWORD PTR [eax+1556], 0
  0020f	7e 51		 jle	 SHORT $LN3@CGPCharDel
  00211	8b b8 18 06 00
	00		 mov	 edi, DWORD PTR [eax+1560]
  00217	85 ff		 test	 edi, edi
  00219	74 47		 je	 SHORT $LN3@CGPCharDel

; 2726 : 	{
; 2727 : 		if ( !strcmp(gObj[aIndex].Name, gObj[aIndex].lpGuild->Names[0] ))

  0021b	83 c7 2f	 add	 edi, 47			; 0000002fH
  0021e	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
$LL13@CGPCharDel:
  00221	8a 11		 mov	 dl, BYTE PTR [ecx]
  00223	3a 17		 cmp	 dl, BYTE PTR [edi]
  00225	75 1a		 jne	 SHORT $LN14@CGPCharDel
  00227	84 d2		 test	 dl, dl
  00229	74 12		 je	 SHORT $LN15@CGPCharDel
  0022b	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0022e	3a 57 01	 cmp	 dl, BYTE PTR [edi+1]
  00231	75 0e		 jne	 SHORT $LN14@CGPCharDel
  00233	83 c1 02	 add	 ecx, 2
  00236	83 c7 02	 add	 edi, 2
  00239	84 d2		 test	 dl, dl
  0023b	75 e4		 jne	 SHORT $LL13@CGPCharDel
$LN15@CGPCharDel:
  0023d	33 c9		 xor	 ecx, ecx
  0023f	eb 05		 jmp	 SHORT $LN16@CGPCharDel
$LN14@CGPCharDel:
  00241	1b c9		 sbb	 ecx, ecx
  00243	83 d9 ff	 sbb	 ecx, -1
$LN16@CGPCharDel:
  00246	85 c9		 test	 ecx, ecx
  00248	0f 95 c1	 setne	 cl
  0024b	fe c1		 inc	 cl
  0024d	88 4d b2	 mov	 BYTE PTR _pCDel$[ebp+26], cl

; 2728 : 		{
; 2729 : 			pCDel.Guild = 1;	// Master
; 2730 : 		}
; 2731 : 		else
; 2732 : 		{
; 2733 : 			pCDel.Guild = 2;	// Member
; 2734 : 		}
; 2735 : 
; 2736 : 		memcpy(pCDel.GuildName, gObj[aIndex].lpGuild->Name, MAX_GUILD_LEN);

  00250	8b 88 18 06 00
	00		 mov	 ecx, DWORD PTR [eax+1560]
  00256	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00259	89 55 b3	 mov	 DWORD PTR _pCDel$[ebp+27], edx
  0025c	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0025f	89 4d b7	 mov	 DWORD PTR _pCDel$[ebp+31], ecx
$LN3@CGPCharDel:

; 2737 : 	}
; 2738 : 
; 2739 : 	g_CashItemPeriodSystem.GDReqPeriodItemDelete(&gObj[aIndex], lpMsg->Name);

  00262	53		 push	 ebx
  00263	50		 push	 eax
  00264	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00269	e8 00 00 00 00	 call	 ?GDReqPeriodItemDelete@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CCashItemPeriodSystem::GDReqPeriodItemDelete

; 2740 : 	szTemp[10]=0;
; 2741 : 	szTemp2[10]=0;
; 2742 : 	memcpy(szTemp, pCDel.Name, MAX_ACCOUNT_LEN);

  0026e	8b 55 a8	 mov	 edx, DWORD PTR _pCDel$[ebp+16]
  00271	8b 45 ac	 mov	 eax, DWORD PTR _pCDel$[ebp+20]
  00274	0f b7 4d b0	 movzx	 ecx, WORD PTR _pCDel$[ebp+24]
  00278	89 55 bc	 mov	 DWORD PTR _szTemp$[ebp], edx

; 2743 : 	memcpy(szTemp2, pCDel.AccountID, MAX_ACCOUNT_LEN);

  0027b	8b 55 9e	 mov	 edx, DWORD PTR _pCDel$[ebp+6]
  0027e	89 45 c0	 mov	 DWORD PTR _szTemp$[ebp+4], eax
  00281	8b 45 a2	 mov	 eax, DWORD PTR _pCDel$[ebp+10]
  00284	89 55 d0	 mov	 DWORD PTR _szTemp2$[ebp], edx

; 2744 : 
; 2745 : 	LogAddTD("Character delete : %s,%s", szTemp2, szTemp);

  00287	8d 55 bc	 lea	 edx, DWORD PTR _szTemp$[ebp]
  0028a	89 45 d4	 mov	 DWORD PTR _szTemp2$[ebp+4], eax
  0028d	52		 push	 edx
  0028e	66 89 4d c4	 mov	 WORD PTR _szTemp$[ebp+8], cx
  00292	0f b7 4d a6	 movzx	 ecx, WORD PTR _pCDel$[ebp+14]
  00296	8d 45 d0	 lea	 eax, DWORD PTR _szTemp2$[ebp]
  00299	50		 push	 eax
  0029a	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@
  0029f	c6 45 c6 00	 mov	 BYTE PTR _szTemp$[ebp+10], 0
  002a3	c6 45 da 00	 mov	 BYTE PTR _szTemp2$[ebp+10], 0
  002a7	66 89 4d d8	 mov	 WORD PTR _szTemp2$[ebp+8], cx
  002ab	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2746 : 
; 2747 : 	cDBSMng.Send((PCHAR)&pCDel, pCDel.h.size);

  002b1	0f b6 4d 99	 movzx	 ecx, BYTE PTR _pCDel$[ebp+1]
  002b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b8	51		 push	 ecx
  002b9	8d 55 98	 lea	 edx, DWORD PTR _pCDel$[ebp]
  002bc	52		 push	 edx
  002bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  002c2	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2748 : 	gObj[aIndex].Level = 0;

  002c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002cd	33 c0		 xor	 eax, eax
  002cf	66 89 84 0e 96
	00 00 00	 mov	 WORD PTR [esi+ecx+150], ax
$LN11@CGPCharDel:

; 2749 : }

  002d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002da	5f		 pop	 edi
  002db	5e		 pop	 esi
  002dc	33 cd		 xor	 ecx, ebp
  002de	5b		 pop	 ebx
  002df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e4	8b e5		 mov	 esp, ebp
  002e6	5d		 pop	 ebp
  002e7	c3		 ret	 0
?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z ENDP		; CGPCharDel
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ; CGPCharacterMapJoinRequest
EXTRN	?gGensSystem@@3VCGensSystem@@A:BYTE		; gGensSystem
EXTRN	?gObjIsAccontConnect@@YAHHPAD@Z:PROC		; gObjIsAccontConnect
; Function compile flags: /Ogtp
;	COMDAT ?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z
_TEXT	SEGMENT
_lpInfo$ = -72						; size = 26
_pCRequest$ = -44					; size = 28
__name$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z PROC ; CGPCharacterMapJoinRequest, COMDAT

; 2756 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2757 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00019	56		 push	 esi
  0001a	8b f3		 mov	 esi, ebx
  0001c	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00022	57		 push	 edi
  00023	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00026	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002f	83 c4 04	 add	 esp, 4
  00032	85 c0		 test	 eax, eax
  00034	0f 84 02 01 00
	00		 je	 $LN7@CGPCharact@2

; 2758 : 	{
; 2759 : 		//JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2760 : 		return;
; 2761 : 	}
; 2762 : 
; 2763 : 	if ( !gObjIsAccontConnect(aIndex, gObj[aIndex].AccountID))

  0003a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00040	8d 44 16 52	 lea	 eax, DWORD PTR [esi+edx+82]
  00044	50		 push	 eax
  00045	53		 push	 ebx
  00046	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0004b	83 c4 08	 add	 esp, 8
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 e6 00 00
	00		 je	 $LN7@CGPCharact@2

; 2764 : 		return;
; 2765 : 
; 2766 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005b	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  00060	0f 84 d6 00 00
	00		 je	 $LN7@CGPCharact@2

; 2767 : 		return;
; 2768 : 
; 2769 : 	gObj[aIndex].bEnableDelCharacter = FALSE;
; 2770 : 
; 2771 : 	char _name[MAX_ACCOUNT_LEN+1];
; 2772 : 	SDHP_DBCHARINFOREQUEST pCRequest;
; 2773 : 
; 2774 : 	PHeadSetB((LPBYTE)&pCRequest, 0x06, sizeof(pCRequest));

  00066	6a 1c		 push	 28			; 0000001cH
  00068	8d 4d d4	 lea	 ecx, DWORD PTR _pCRequest$[ebp]
  0006b	6a 06		 push	 6
  0006d	51		 push	 ecx
  0006e	c7 44 06 10 00
	00 00 00	 mov	 DWORD PTR [esi+eax+16], 0
  00076	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2775 : 	memset(_name, 0, MAX_ACCOUNT_LEN);
; 2776 : 	memcpy(_name, lpMsg->Name, MAX_ACCOUNT_LEN);

  0007b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007e	66 8b 4f 0c	 mov	 cx, WORD PTR [edi+12]
  00082	33 c0		 xor	 eax, eax
  00084	89 45 f0	 mov	 DWORD PTR __name$[ebp], eax
  00087	89 45 f4	 mov	 DWORD PTR __name$[ebp+4], eax
  0008a	66 89 45 f8	 mov	 WORD PTR __name$[ebp+8], ax
  0008e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00091	89 55 f0	 mov	 DWORD PTR __name$[ebp], edx

; 2777 : #if( ENABLE_ZMULTISERVER_UPDATE_3 == 0 )
; 2778 : 	BuxConvert(_name, MAX_ACCOUNT_LEN);

  00094	8d 55 f0	 lea	 edx, DWORD PTR __name$[ebp]
  00097	6a 0a		 push	 10			; 0000000aH
  00099	52		 push	 edx
  0009a	89 45 f4	 mov	 DWORD PTR __name$[ebp+4], eax
  0009d	66 89 4d f8	 mov	 WORD PTR __name$[ebp+8], cx
  000a1	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert

; 2779 : #endif
; 2780 : 	memcpy(pCRequest.Name, _name, MAX_ACCOUNT_LEN);

  000a6	8b 45 f0	 mov	 eax, DWORD PTR __name$[ebp]
  000a9	66 8b 55 f8	 mov	 dx, WORD PTR __name$[ebp+8]
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR __name$[ebp+4]
  000b0	89 45 e2	 mov	 DWORD PTR _pCRequest$[ebp+14], eax

; 2781 : 	strcpy(pCRequest.AccountID, gObj[aIndex].AccountID);

  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b8	66 89 55 ea	 mov	 WORD PTR _pCRequest$[ebp+22], dx
  000bc	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  000c0	8d 55 d7	 lea	 edx, DWORD PTR _pCRequest$[ebp+3]
  000c3	83 c4 14	 add	 esp, 20			; 00000014H
  000c6	89 4d e6	 mov	 DWORD PTR _pCRequest$[ebp+18], ecx
  000c9	2b d0		 sub	 edx, eax
  000cb	eb 03 8d 49 00	 npad	 5
$LL9@CGPCharact@2:
  000d0	8a 08		 mov	 cl, BYTE PTR [eax]
  000d2	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000d5	40		 inc	 eax
  000d6	84 c9		 test	 cl, cl
  000d8	75 f6		 jne	 SHORT $LL9@CGPCharact@2

; 2782 : 	pCRequest.Number = aIndex;
; 2783 : 	cDBSMng.Send((char*)&pCRequest, pCRequest.h.size);

  000da	0f b6 4d d5	 movzx	 ecx, BYTE PTR _pCRequest$[ebp+1]
  000de	51		 push	 ecx
  000df	8d 55 d4	 lea	 edx, DWORD PTR _pCRequest$[ebp]
  000e2	52		 push	 edx
  000e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000e8	66 89 5d ee	 mov	 WORD PTR _pCRequest$[ebp+26], bx
  000ec	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2784 : 	
; 2785 : 	USER_GET_BATTLEINFO lpInfo;
; 2786 : 	PHeadSubSetB((LPBYTE)&lpInfo, 0xFD, 0x01, sizeof(USER_GET_BATTLEINFO));

  000f1	6a 1a		 push	 26			; 0000001aH
  000f3	6a 01		 push	 1
  000f5	8d 45 b8	 lea	 eax, DWORD PTR _lpInfo$[ebp]
  000f8	68 fd 00 00 00	 push	 253			; 000000fdH
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00103	83 c4 10	 add	 esp, 16			; 00000010H

; 2787 : 	// ----
; 2788 : 	for(int i = 0; i < 11; i++ )

  00106	33 c0		 xor	 eax, eax
  00108	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL3@CGPCharact@2:

; 2789 : 	{
; 2790 : 		lpInfo.BattleMapList[i] = gGensSystem.m_MapList[i];

  00110	8a 88 53 00 00
	00		 mov	 cl, BYTE PTR ?gGensSystem@@3VCGensSystem@@A[eax+83]

; 2791 : 		lpInfo.BattleZoneList[i] = gGensSystem.m_ZoneList[i];

  00116	8a 90 5e 00 00
	00		 mov	 dl, BYTE PTR ?gGensSystem@@3VCGensSystem@@A[eax+94]
  0011c	88 4c 05 bc	 mov	 BYTE PTR _lpInfo$[ebp+eax+4], cl
  00120	88 54 05 c7	 mov	 BYTE PTR _lpInfo$[ebp+eax+15], dl
  00124	40		 inc	 eax
  00125	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00128	7c e6		 jl	 SHORT $LL3@CGPCharact@2

; 2792 : 	}
; 2793 : 	// ----
; 2794 : 	DataSend(aIndex, (LPBYTE)&lpInfo, lpInfo.h.size);

  0012a	0f b6 45 b9	 movzx	 eax, BYTE PTR _lpInfo$[ebp+1]
  0012e	50		 push	 eax
  0012f	8d 4d b8	 lea	 ecx, DWORD PTR _lpInfo$[ebp]
  00132	51		 push	 ecx
  00133	53		 push	 ebx
  00134	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00139	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CGPCharact@2:

; 2795 : }

  0013c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	33 cd		 xor	 ecx, ebp
  00143	5b		 pop	 ebx
  00144	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ENDP ; CGPCharacterMapJoinRequest
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z	; CGLevelUpPointAdd
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?gObjLevelUpPointAdd@@YAHEPAUOBJECTSTRUCT@@@Z:PROC ; gObjLevelUpPointAdd
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z
_TEXT	SEGMENT
tv292 = -36						; size = 4
tv290 = -36						; size = 4
tv276 = -36						; size = 4
tv274 = -36						; size = 4
tv295 = -30						; size = 2
tv280 = -30						; size = 2
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z PROC	; CGLevelUpPointAdd, COMDAT

; 2863 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 2864 : 	if ( !gObjIsConnected(aIndex))

  00018	53		 push	 ebx
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	75 19		 jne	 SHORT $LN6@CGLevelUpP

; 2865 : 	{
; 2866 : 		CloseClient(aIndex);

  00025	53		 push	 ebx
  00026	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0002b	83 c4 04	 add	 esp, 4
  0002e	5f		 pop	 edi
  0002f	5b		 pop	 ebx

; 2906 : 
; 2907 : }

  00030	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00033	33 cd		 xor	 ecx, ebp
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN6@CGLevelUpP:
  0003e	56		 push	 esi

; 2867 : 		return;
; 2868 : 	}
; 2869 : 
; 2870 : 	PMSG_LVPOINTADDRESULT pMsg;
; 2871 : 
; 2872 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x06, sizeof(pMsg));

  0003f	6a 18		 push	 24			; 00000018H
  00041	6a 06		 push	 6
  00043	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00046	68 f3 00 00 00	 push	 243			; 000000f3H
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2873 : 	pMsg.ResultType = 0;
; 2874 : 	
; 2875 : 	if (::gObjLevelUpPointAdd(lpMsg->Type, &gObj[aIndex]) == TRUE )

  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00057	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0005b	8b f3		 mov	 esi, ebx
  0005d	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00063	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00066	52		 push	 edx
  00067	50		 push	 eax
  00068	c6 45 e8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  0006c	e8 00 00 00 00	 call	 ?gObjLevelUpPointAdd@@YAHEPAUOBJECTSTRUCT@@@Z ; gObjLevelUpPointAdd
  00071	83 c4 18	 add	 esp, 24			; 00000018H
  00074	83 f8 01	 cmp	 eax, 1
  00077	0f 85 e7 00 00
	00		 jne	 $LN5@CGLevelUpP

; 2876 : 	{
; 2877 : 		pMsg.ResultType = 0x10;
; 2878 : 		pMsg.ResultType += lpMsg->Type;

  0007d	8a 47 04	 mov	 al, BYTE PTR [edi+4]

; 2879 : 
; 2880 : 		switch ( lpMsg->Type )

  00080	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00086	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00089	0f b6 c0	 movzx	 eax, al
  0008c	83 e8 02	 sub	 eax, 2
  0008f	88 4d e8	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00092	74 45		 je	 SHORT $LN2@CGLevelUpP
  00094	48		 dec	 eax
  00095	0f 85 82 00 00
	00		 jne	 $LN3@CGLevelUpP

; 2886 : #endif
; 2887 : 				break;
; 2888 : 
; 2889 : 			case 3:	// Energy
; 2890 : 				pMsg.MaxLifeAndMana = (WORD)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana);

  0009b	db 84 3e 28 01
	00 00		 fild	 DWORD PTR [esi+edi+296]
  000a2	d9 7d e2	 fnstcw	 WORD PTR tv295[ebp]
  000a5	0f b7 45 e2	 movzx	 eax, WORD PTR tv295[ebp]
  000a9	d8 84 3e f0 00
	00 00		 fadd	 DWORD PTR [esi+edi+240]
  000b0	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000b5	89 45 dc	 mov	 DWORD PTR tv292[ebp], eax
  000b8	d9 6d dc	 fldcw	 WORD PTR tv292[ebp]
  000bb	db 5d dc	 fistp	 DWORD PTR tv290[ebp]
  000be	66 8b 55 dc	 mov	 dx, WORD PTR tv290[ebp]
  000c2	66 89 55 ea	 mov	 WORD PTR _pMsg$[ebp+6], dx
  000c6	d9 6d e2	 fldcw	 WORD PTR tv295[ebp]

; 2891 : #if (FIX_HP==1)
; 2892 : 				pMsg.MAXHPANDMANA = (int)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana);

  000c9	db 84 3e 28 01
	00 00		 fild	 DWORD PTR [esi+edi+296]
  000d0	d8 84 3e f0 00
	00 00		 fadd	 DWORD PTR [esi+edi+240]

; 2893 : #endif
; 2894 : 				break;

  000d7	eb 3c		 jmp	 SHORT $LN9@CGLevelUpP
$LN2@CGLevelUpP:

; 2881 : 		{
; 2882 : 			case 2:	// Vit
; 2883 : 				pMsg.MaxLifeAndMana = (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife);

  000d9	db 84 3e 24 01
	00 00		 fild	 DWORD PTR [esi+edi+292]
  000e0	d9 7d e2	 fnstcw	 WORD PTR tv280[ebp]
  000e3	0f b7 45 e2	 movzx	 eax, WORD PTR tv280[ebp]
  000e7	d8 84 3e dc 00
	00 00		 fadd	 DWORD PTR [esi+edi+220]
  000ee	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000f3	89 45 dc	 mov	 DWORD PTR tv276[ebp], eax
  000f6	d9 6d dc	 fldcw	 WORD PTR tv276[ebp]
  000f9	db 5d dc	 fistp	 DWORD PTR tv274[ebp]
  000fc	66 8b 45 dc	 mov	 ax, WORD PTR tv274[ebp]
  00100	66 89 45 ea	 mov	 WORD PTR _pMsg$[ebp+6], ax
  00104	d9 6d e2	 fldcw	 WORD PTR tv280[ebp]

; 2884 : #if (FIX_HP==1)
; 2885 : 				pMsg.MAXHPANDMANA = (int)(gObj[aIndex].MaxLife+gObj[aIndex].AddLife);

  00107	db 84 3e 24 01
	00 00		 fild	 DWORD PTR [esi+edi+292]
  0010e	d8 84 3e dc 00
	00 00		 fadd	 DWORD PTR [esi+edi+220]
$LN9@CGLevelUpP:
  00115	e8 00 00 00 00	 call	 __ftol2_sse
  0011a	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+16], eax
$LN3@CGLevelUpP:

; 2895 : 		}
; 2896 : 		pMsg.wMaxShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  0011d	66 8b 8c 3e 34
	01 00 00	 mov	 cx, WORD PTR [esi+edi+308]
  00125	66 03 8c 3e 30
	01 00 00	 add	 cx, WORD PTR [esi+edi+304]

; 2897 : 		gObjSetBP(aIndex);

  0012d	53		 push	 ebx
  0012e	66 89 4d ec	 mov	 WORD PTR _pMsg$[ebp+8], cx
  00132	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 2898 : 		pMsg.MaxBP = gObj[aIndex].MaxBP + gObj[aIndex].AddBP;

  00137	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013c	66 8b 94 06 0c
	01 00 00	 mov	 dx, WORD PTR [esi+eax+268]
  00144	66 03 94 06 08
	01 00 00	 add	 dx, WORD PTR [esi+eax+264]
  0014c	83 c4 04	 add	 esp, 4
  0014f	66 89 55 ee	 mov	 WORD PTR _pMsg$[ebp+10], dx

; 2899 : 
; 2900 : #if (FIX_HP==1)
; 2901 : 		pMsg.MAXSD = gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield;

  00153	8b 8c 06 34 01
	00 00		 mov	 ecx, DWORD PTR [esi+eax+308]
  0015a	03 8c 06 30 01
	00 00		 add	 ecx, DWORD PTR [esi+eax+304]
  00161	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+20], ecx
$LN5@CGLevelUpP:

; 2902 : #endif
; 2903 : 	}
; 2904 : 
; 2905 : 	DataSend(aIndex, (UCHAR *)&pMsg, pMsg.h.size);

  00164	0f b6 55 e5	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00168	52		 push	 edx
  00169	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0016c	50		 push	 eax
  0016d	53		 push	 ebx
  0016e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2906 : 
; 2907 : }

  00173	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00176	83 c4 0c	 add	 esp, 12			; 0000000cH
  00179	5e		 pop	 esi
  0017a	5f		 pop	 edi
  0017b	33 cd		 xor	 ecx, ebp
  0017d	5b		 pop	 ebx
  0017e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c3		 ret	 0
?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z ENDP	; CGLevelUpPointAdd
_TEXT	ENDS
PUBLIC	_pos$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCInventoryItemOneSend@@YAXHH@Z		; GCInventoryItemOneSend
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
;	COMDAT ?GCInventoryItemOneSend@@YAXHH@Z
_TEXT	SEGMENT
_pos$GSCopy$ = -28					; size = 4
_pMsg$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 4
?GCInventoryItemOneSend@@YAXHH@Z PROC			; GCInventoryItemOneSend, COMDAT

; 2922 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2923 : 	if ( !gObj[aIndex].pInventory[pos].IsItem())

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _pos$[ebp]
  0001e	8b f3		 mov	 esi, ebx
  00020	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00026	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]

; 2924 : 		return;
; 2925 : 
; 2926 : 	PMSG_INVENTORYITEMMODIFY pMsg;
; 2927 : 
; 2928 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x14, sizeof(pMsg));

  0002d	89 7d e4	 mov	 DWORD PTR _pos$GSCopy$[ebp], edi
  00030	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  00036	03 cf		 add	 ecx, edi
  00038	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003d	85 c0		 test	 eax, eax
  0003f	74 53		 je	 SHORT $LN2@GCInventor
  00041	6a 11		 push	 17			; 00000011H
  00043	6a 14		 push	 20			; 00000014H
  00045	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00048	68 f3 00 00 00	 push	 243			; 000000f3H
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2929 : 	pMsg.Pos = pos;

  00053	8a 55 e4	 mov	 dl, BYTE PTR _pos$GSCopy$[ebp]

; 2930 : 	ItemByteConvert(pMsg.ItemInfo, gObj[aIndex].pInventory[pos]);

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005b	88 55 ec	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  0005e	8b b4 06 c0 11
	00 00		 mov	 esi, DWORD PTR [esi+eax+4544]
  00065	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  0006b	03 f7		 add	 esi, edi
  0006d	8b fc		 mov	 edi, esp
  0006f	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00074	f3 a5		 rep movsd
  00076	8d 4d ed	 lea	 ecx, DWORD PTR _pMsg$[ebp+5]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 2931 : 
; 2932 : 	DataSend(aIndex, (UCHAR *)&pMsg, pMsg.h.size);

  0007f	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00083	52		 push	 edx
  00084	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00087	50		 push	 eax
  00088	53		 push	 ebx
  00089	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008e	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
$LN2@GCInventor:

; 2933 : }

  00094	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	33 cd		 xor	 ecx, ebp
  0009b	5b		 pop	 ebx
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?GCInventoryItemOneSend@@YAXHH@Z ENDP			; GCInventoryItemOneSend
_TEXT	ENDS
PUBLIC	?GCPkLevelSend@@YAXHE@Z				; GCPkLevelSend
; Function compile flags: /Ogtp
;	COMDAT ?GCPkLevelSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_pklevel$ = 12						; size = 1
?GCPkLevelSend@@YAXHE@Z PROC				; GCPkLevelSend, COMDAT

; 2948 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2949 : 	PMSG_PKLEVEL pMsg;
; 2950 : 
; 2951 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x08, sizeof(pMsg));

  00007	6a 07		 push	 7
  00009	6a 08		 push	 8
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	68 f3 00 00 00	 push	 243			; 000000f3H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2952 : 	pMsg.NumberH = SET_NUMBERH(aIndex);

  00019	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 2953 : 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 2954 : 	pMsg.PkLevel = pklevel;
; 2955 : 
; 2956 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0001c	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00020	8a 55 0c	 mov	 dl, BYTE PTR _pklevel$[ebp]
  00023	8b cb		 mov	 ecx, ebx
  00025	c1 e9 08	 shr	 ecx, 8
  00028	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0002b	50		 push	 eax
  0002c	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002f	51		 push	 ecx
  00030	53		 push	 ebx
  00031	88 5d fd	 mov	 BYTE PTR _pMsg$[ebp+5], bl
  00034	88 55 fe	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  00037	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2957 : 	MsgSendV2(&gObj[aIndex], (UCHAR*)&pMsg, pMsg.h.size);

  0003c	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00042	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00046	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	52		 push	 edx
  0004d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00050	50		 push	 eax
  00051	53		 push	 ebx
  00052	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00057	83 c4 28	 add	 esp, 40			; 00000028H
  0005a	5b		 pop	 ebx

; 2958 : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?GCPkLevelSend@@YAXHE@Z ENDP				; GCPkLevelSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMagicListOneSend@@YAXHDGEEE@Z		; GCMagicListOneSend
; Function compile flags: /Ogtp
;	COMDAT ?GCMagicListOneSend@@YAXHDGEEE@Z
_TEXT	SEGMENT
_pList$ = -1016						; size = 4
_pCount$ = -1012					; size = 6
_sendbuf$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Pos$ = 12						; size = 1
_type$ = 16						; size = 2
_level$ = 20						; size = 1
_skill$ = 24						; size = 1
_btListType$ = 28					; size = 1
?GCMagicListOneSend@@YAXHDGEEE@Z PROC			; GCMagicListOneSend, COMDAT

; 2982 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 03 00
	00		 sub	 esp, 1016		; 000003f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2983 : 	PMSG_MAGICLISTCOUNT pCount;
; 2984 : 	PMSG_MAGICLIST pList;
; 2985 : 	BYTE sendbuf[1000];
; 2986 : 	int lOfs = sizeof(pCount);
; 2987 : 
; 2988 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0);

  00013	6a 00		 push	 0
  00015	6a 11		 push	 17			; 00000011H
  00017	8d 85 0c fc ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0001d	68 f3 00 00 00	 push	 243			; 000000f3H
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2989 : 	pCount.Count = 0xFE;
; 2990 : 	pCount.btListType = btListType;

  00028	8a 4d 1c	 mov	 cl, BYTE PTR _btListType$[ebp]

; 2991 : 	pList.Pos = Pos;

  0002b	8a 55 0c	 mov	 dl, BYTE PTR _Pos$[ebp]

; 2992 : 	pList.m_Skill = type;

  0002e	66 8b 45 10	 mov	 ax, WORD PTR _type$[ebp]
  00032	88 8d 11 fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], cl

; 2993 : 
; 2994 : 	pList.m_Level = level<<3;

  00038	8a 4d 14	 mov	 cl, BYTE PTR _level$[ebp]
  0003b	02 c9		 add	 cl, cl
  0003d	88 95 08 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp], dl

; 2995 : 	pList.m_Level |= skill & 0x07;

  00043	8a 55 18	 mov	 dl, BYTE PTR _skill$[ebp]
  00046	02 c9		 add	 cl, cl
  00048	02 c9		 add	 cl, cl
  0004a	80 e2 07	 and	 dl, 7
  0004d	0a ca		 or	 cl, dl
  0004f	88 8d 0b fc ff
	ff		 mov	 BYTE PTR _pList$[ebp+3], cl
  00055	66 89 85 09 fc
	ff ff		 mov	 WORD PTR _pList$[ebp+1], ax

; 2996 : 
; 2997 : 	memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  0005c	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp]

; 2998 : 	lOfs+= sizeof(pList);
; 2999 : 	pCount.h.size = lOfs;

  00062	c6 85 0d fc ff
	ff 0a		 mov	 BYTE PTR _pCount$[ebp+1], 10 ; 0000000aH

; 3000 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  00069	8b 8d 0c fc ff
	ff		 mov	 ecx, DWORD PTR _pCount$[ebp]
  0006f	89 85 1a fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+6], eax

; 3001 : 
; 3002 : 	DataSend(aIndex, sendbuf, lOfs);

  00075	6a 0a		 push	 10			; 0000000aH
  00077	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  0007d	89 8d 14 fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], ecx
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00086	c6 85 10 fc ff
	ff fe		 mov	 BYTE PTR _pCount$[ebp+4], 254 ; 000000feH
  0008d	66 8b 95 10 fc
	ff ff		 mov	 dx, WORD PTR _pCount$[ebp+4]
  00094	50		 push	 eax
  00095	51		 push	 ecx
  00096	66 89 95 18 fc
	ff ff		 mov	 WORD PTR _sendbuf$[ebp+4], dx
  0009d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3003 : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	83 c4 1c	 add	 esp, 28			; 0000001cH
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?GCMagicListOneSend@@YAXHDGEEE@Z ENDP			; GCMagicListOneSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMagicListOneDelSend@@YAXHDGEEE@Z		; GCMagicListOneDelSend
; Function compile flags: /Ogtp
;	COMDAT ?GCMagicListOneDelSend@@YAXHDGEEE@Z
_TEXT	SEGMENT
_pList$ = -1016						; size = 4
_pCount$ = -1012					; size = 6
_sendbuf$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Pos$ = 12						; size = 1
_type$ = 16						; size = 2
_level$ = 20						; size = 1
_skill$ = 24						; size = 1
_btListType$ = 28					; size = 1
?GCMagicListOneDelSend@@YAXHDGEEE@Z PROC		; GCMagicListOneDelSend, COMDAT

; 3008 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 03 00
	00		 sub	 esp, 1016		; 000003f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3009 : 	PMSG_MAGICLISTCOUNT pCount;
; 3010 : 	PMSG_MAGICLIST pList;
; 3011 : 
; 3012 : 	BYTE sendbuf[1000];
; 3013 : 	int lOfs = sizeof(pCount);
; 3014 : 
; 3015 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0);

  00013	6a 00		 push	 0
  00015	6a 11		 push	 17			; 00000011H
  00017	8d 85 0c fc ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0001d	68 f3 00 00 00	 push	 243			; 000000f3H
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3016 : 	pCount.h.size = 0;
; 3017 : 	pCount.Count = 0xFF;
; 3018 : 	pCount.btListType = btListType;

  00028	8a 4d 1c	 mov	 cl, BYTE PTR _btListType$[ebp]

; 3019 : 	pList.Pos = Pos;

  0002b	8a 55 0c	 mov	 dl, BYTE PTR _Pos$[ebp]

; 3020 : 
; 3021 : 	pList.m_Skill = type;

  0002e	66 8b 45 10	 mov	 ax, WORD PTR _type$[ebp]
  00032	88 8d 11 fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], cl

; 3022 : 
; 3023 : 	pList.m_Level = level<<3;

  00038	8a 4d 14	 mov	 cl, BYTE PTR _level$[ebp]
  0003b	02 c9		 add	 cl, cl
  0003d	88 95 08 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp], dl

; 3024 : 	pList.m_Level |= skill & 0x07;

  00043	8a 55 18	 mov	 dl, BYTE PTR _skill$[ebp]
  00046	02 c9		 add	 cl, cl
  00048	02 c9		 add	 cl, cl
  0004a	80 e2 07	 and	 dl, 7
  0004d	0a ca		 or	 cl, dl
  0004f	88 8d 0b fc ff
	ff		 mov	 BYTE PTR _pList$[ebp+3], cl
  00055	66 89 85 09 fc
	ff ff		 mov	 WORD PTR _pList$[ebp+1], ax

; 3025 : 
; 3026 : 	memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  0005c	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp]

; 3027 : 	lOfs+= sizeof(pList);
; 3028 : 	pCount.h.size = lOfs;

  00062	c6 85 0d fc ff
	ff 0a		 mov	 BYTE PTR _pCount$[ebp+1], 10 ; 0000000aH

; 3029 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  00069	8b 8d 0c fc ff
	ff		 mov	 ecx, DWORD PTR _pCount$[ebp]
  0006f	89 85 1a fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+6], eax

; 3030 : 
; 3031 : 	DataSend(aIndex, sendbuf, lOfs);

  00075	6a 0a		 push	 10			; 0000000aH
  00077	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  0007d	89 8d 14 fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], ecx
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00086	c6 85 10 fc ff
	ff ff		 mov	 BYTE PTR _pCount$[ebp+4], 255 ; 000000ffH
  0008d	66 8b 95 10 fc
	ff ff		 mov	 dx, WORD PTR _pCount$[ebp+4]
  00094	50		 push	 eax
  00095	51		 push	 ecx
  00096	66 89 95 18 fc
	ff ff		 mov	 WORD PTR _sendbuf$[ebp+4], dx
  0009d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3032 : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	83 c4 1c	 add	 esp, 28			; 0000001cH
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?GCMagicListOneDelSend@@YAXHDGEEE@Z ENDP		; GCMagicListOneDelSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z	; GCMagicListMultiSend
EXTRN	?IsExistMLSBasedSkill@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMasterLevelSkillTreeSystem::IsExistMLSBasedSkill
EXTRN	?GetSkillUseType@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::GetSkillUseType
EXTRN	?MagicDamageC@@3VCMagicDamage@@A:BYTE		; MagicDamageC
EXTRN	?CheckMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z:PROC ; CMasterLevelSkillTreeSystem::CheckMasterLevelSkill
EXTRN	?CheckUsableWeaponSkill@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMasterLevelSkillTreeSystem::CheckUsableWeaponSkill
EXTRN	?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A:BYTE ; g_MasterSkillSystem
EXTRN	?IsMagic@CMagicInf@@QAEHXZ:PROC			; CMagicInf::IsMagic
; Function compile flags: /Ogtp
;	COMDAT ?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_Count$ = -1024						; size = 4
_pList$ = -1020						; size = 4
_pCount$ = -1016					; size = 6
_lOfs$ = -1008						; size = 4
_sendbuf$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_btListType$ = 12					; size = 1
?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z PROC	; GCMagicListMultiSend, COMDAT

; 3037 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 04 00
	00		 sub	 esp, 1024		; 00000400H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3038 : 	PMSG_MAGICLISTCOUNT pCount;
; 3039 : 	PMSG_MAGICLIST pList;
; 3040 : 	BYTE sendbuf[1000];
; 3041 : 	int lOfs = sizeof(pCount);
; 3042 : 	int Count = 0;
; 3043 : 	pCount.btListType = btListType;

  00013	8a 45 0c	 mov	 al, BYTE PTR _btListType$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0001c	33 f6		 xor	 esi, esi

; 3044 : 
; 3045 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0);

  0001e	56		 push	 esi
  0001f	6a 11		 push	 17			; 00000011H
  00021	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _pCount$[ebp]
  00027	68 f3 00 00 00	 push	 243			; 000000f3H
  0002c	51		 push	 ecx
  0002d	c7 85 10 fc ff
	ff 06 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 6
  00037	89 b5 00 fc ff
	ff		 mov	 DWORD PTR _Count$[ebp], esi
  0003d	88 85 0d fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], al
  00043	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 3046 : 
; 3047 : 	for ( int n=0;n<MAX_MAGIC;n++)

  0004b	33 db		 xor	 ebx, ebx
  0004d	8d 49 00	 npad	 3
$LL8@GCMagicLis:

; 3048 : 	{
; 3049 : 		if ( lpObj->Magic[n].IsMagic() == TRUE )

  00050	8b 8f a8 06 00
	00		 mov	 ecx, DWORD PTR [edi+1704]
  00056	03 ce		 add	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0005d	83 f8 01	 cmp	 eax, 1
  00060	0f 85 b8 00 00
	00		 jne	 $LN7@GCMagicLis

; 3050 : 		{
; 3051 : 			if( !g_MasterSkillSystem.CheckUsableWeaponSkill(lpObj,n) )

  00066	53		 push	 ebx
  00067	57		 push	 edi
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0006d	e8 00 00 00 00	 call	 ?CheckUsableWeaponSkill@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMasterLevelSkillTreeSystem::CheckUsableWeaponSkill
  00072	85 c0		 test	 eax, eax
  00074	0f 84 a4 00 00
	00		 je	 $LN7@GCMagicLis

; 3052 : 				continue;
; 3053 : 
; 3054 : 			if( g_MasterSkillSystem.CheckMasterLevelSkill(lpObj->Magic[n].m_Skill) &&
; 3055 : 				MagicDamageC.GetSkillUseType(lpObj->Magic[n].m_Skill) == 3 )

  0007a	8b 97 a8 06 00
	00		 mov	 edx, DWORD PTR [edi+1704]
  00080	8b 44 16 08	 mov	 eax, DWORD PTR [esi+edx+8]
  00084	50		 push	 eax
  00085	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0008a	e8 00 00 00 00	 call	 ?CheckMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterLevelSkill
  0008f	85 c0		 test	 eax, eax
  00091	74 1a		 je	 SHORT $LN3@GCMagicLis
  00093	8b 8f a8 06 00
	00		 mov	 ecx, DWORD PTR [edi+1704]
  00099	8b 54 0e 08	 mov	 edx, DWORD PTR [esi+ecx+8]
  0009d	52		 push	 edx
  0009e	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  000a3	e8 00 00 00 00	 call	 ?GetSkillUseType@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetSkillUseType
  000a8	83 f8 03	 cmp	 eax, 3
  000ab	74 71		 je	 SHORT $LN7@GCMagicLis
$LN3@GCMagicLis:

; 3056 : 				continue;
; 3057 : 
; 3058 : 			if( g_MasterSkillSystem.IsExistMLSBasedSkill(lpObj,lpObj->Magic[n].m_Skill) )

  000ad	8b 87 a8 06 00
	00		 mov	 eax, DWORD PTR [edi+1704]
  000b3	8b 4c 06 08	 mov	 ecx, DWORD PTR [esi+eax+8]
  000b7	51		 push	 ecx
  000b8	57		 push	 edi
  000b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  000be	e8 00 00 00 00	 call	 ?IsExistMLSBasedSkill@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMasterLevelSkillTreeSystem::IsExistMLSBasedSkill
  000c3	85 c0		 test	 eax, eax
  000c5	75 57		 jne	 SHORT $LN7@GCMagicLis

; 3059 : 				continue;
; 3060 : 
; 3061 : 			if( lpObj->Magic[n].m_bBrand )

  000c7	8b 97 a8 06 00
	00		 mov	 edx, DWORD PTR [edi+1704]
  000cd	38 44 16 14	 cmp	 BYTE PTR [esi+edx+20], al
  000d1	75 4b		 jne	 SHORT $LN7@GCMagicLis

; 3062 : 				continue;
; 3063 : 
; 3064 : 			pList.Pos = n;
; 3065 : 			pList.m_Skill = lpObj->Magic[n].m_Skill;

  000d3	8b c2		 mov	 eax, edx

; 3066 : 			pList.m_Level = lpObj->Magic[n].m_Level << 3;

  000d5	8a 54 30 04	 mov	 dl, BYTE PTR [eax+esi+4]
  000d9	66 8b 4c 30 08	 mov	 cx, WORD PTR [eax+esi+8]

; 3067 : 			pList.m_Level |= lpObj->Magic[n].m_Skill & 7;
; 3068 : 			memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  000de	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  000e4	02 d2		 add	 dl, dl
  000e6	02 d2		 add	 dl, dl
  000e8	66 89 8d 05 fc
	ff ff		 mov	 WORD PTR _pList$[ebp+1], cx
  000ef	80 e1 07	 and	 cl, 7
  000f2	02 d2		 add	 dl, dl
  000f4	0a d1		 or	 dl, cl
  000f6	88 9d 04 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp], bl
  000fc	88 95 07 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp+3], dl
  00102	8b 8d 04 fc ff
	ff		 mov	 ecx, DWORD PTR _pList$[ebp]
  00108	89 8c 05 14 fc
	ff ff		 mov	 DWORD PTR _sendbuf$[ebp+eax], ecx

; 3069 : 			lOfs+= sizeof(pList);

  0010f	83 c0 04	 add	 eax, 4

; 3070 : 			Count++;

  00112	ff 85 00 fc ff
	ff		 inc	 DWORD PTR _Count$[ebp]
  00118	89 85 10 fc ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax
$LN7@GCMagicLis:

; 3046 : 
; 3047 : 	for ( int n=0;n<MAX_MAGIC;n++)

  0011e	83 c6 18	 add	 esi, 24			; 00000018H
  00121	43		 inc	 ebx
  00122	81 fe 10 0e 00
	00		 cmp	 esi, 3600		; 00000e10H
  00128	0f 8c 22 ff ff
	ff		 jl	 $LL8@GCMagicLis

; 3071 : 		}
; 3072 : 	}
; 3073 : 
; 3074 : 	pCount.Count = Count;
; 3075 : 	pCount.h.size = lOfs;

  0012e	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00134	8a 95 00 fc ff
	ff		 mov	 dl, BYTE PTR _Count$[ebp]
  0013a	88 85 09 fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], al

; 3076 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  00140	8b 8d 08 fc ff
	ff		 mov	 ecx, DWORD PTR _pCount$[ebp]

; 3077 : 
; 3078 : 	DataSend(lpObj->m_Index, sendbuf, lOfs);

  00146	50		 push	 eax
  00147	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  0014d	89 8d 14 fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], ecx
  00153	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00155	88 95 0c fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], dl
  0015b	66 8b 95 0c fc
	ff ff		 mov	 dx, WORD PTR _pCount$[ebp+4]
  00162	50		 push	 eax
  00163	51		 push	 ecx
  00164	66 89 95 18 fc
	ff ff		 mov	 WORD PTR _sendbuf$[ebp+4], dx
  0016b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3079 : }

  00170	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH
  00176	5f		 pop	 edi
  00177	5e		 pop	 esi
  00178	33 cd		 xor	 ecx, ebp
  0017a	5b		 pop	 ebx
  0017b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z ENDP	; GCMagicListMultiSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCEquipmentSend@@YAXH@Z			; GCEquipmentSend
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
; Function compile flags: /Ogtp
;	COMDAT ?GCEquipmentSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCEquipmentSend@@YAXH@Z PROC				; GCEquipmentSend, COMDAT

; 3095 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 3096 : 	PMSG_EQUIPMENTLIST pMsg;
; 3097 : 
; 3098 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x13, sizeof(pMsg));

  00014	6a 18		 push	 24			; 00000018H
  00016	6a 13		 push	 19			; 00000013H
  00018	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001b	68 f3 00 00 00	 push	 243			; 000000f3H
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3099 : 	pMsg.NumberH = SET_NUMBERH(aIndex);

  00026	8b cb		 mov	 ecx, ebx
  00028	c1 e9 08	 shr	 ecx, 8

; 3100 : 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 3101 : 	gObjMakePreviewCharSet(aIndex);

  0002b	53		 push	 ebx
  0002c	88 4d e8	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0002f	88 5d e9	 mov	 BYTE PTR _pMsg$[ebp+5], bl
  00032	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 3102 : 	LPOBJ lpObj = &gObj[aIndex];

  00037	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  0003d	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3103 : 
; 3104 : 	memcpy(pMsg.Equipment, lpObj->CharSet, sizeof(lpObj->CharSet));

  00043	8b 93 84 08 00
	00		 mov	 edx, DWORD PTR [ebx+2180]
  00049	89 55 ea	 mov	 DWORD PTR _pMsg$[ebp+6], edx
  0004c	8b 83 88 08 00
	00		 mov	 eax, DWORD PTR [ebx+2184]
  00052	89 45 ee	 mov	 DWORD PTR _pMsg$[ebp+10], eax
  00055	8b 8b 8c 08 00
	00		 mov	 ecx, DWORD PTR [ebx+2188]
  0005b	89 4d f2	 mov	 DWORD PTR _pMsg$[ebp+14], ecx
  0005e	8b 93 90 08 00
	00		 mov	 edx, DWORD PTR [ebx+2192]

; 3105 : 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00064	0f b6 4d e5	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00068	89 55 f6	 mov	 DWORD PTR _pMsg$[ebp+18], edx
  0006b	66 8b 83 94 08
	00 00		 mov	 ax, WORD PTR [ebx+2196]
  00072	51		 push	 ecx
  00073	8d 55 e4	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00076	52		 push	 edx
  00077	53		 push	 ebx
  00078	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+22], ax
  0007c	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 3106 : }

  00081	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00084	83 c4 20	 add	 esp, 32			; 00000020H
  00087	33 cd		 xor	 ecx, ebp
  00089	5b		 pop	 ebx
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?GCEquipmentSend@@YAXH@Z ENDP				; GCEquipmentSend
_TEXT	ENDS
PUBLIC	?GCRecallMonLife@@YAXHHH@Z			; GCRecallMonLife
; Function compile flags: /Ogtp
;	COMDAT ?GCRecallMonLife@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_maxlife$ = 12						; size = 4
_life$ = 16						; size = 4
?GCRecallMonLife@@YAXHHH@Z PROC				; GCRecallMonLife, COMDAT

; 3119 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 3120 : 	if ( maxlife <= 0 )

  00007	8b 75 0c	 mov	 esi, DWORD PTR _maxlife$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	7e 33		 jle	 SHORT $LN2@GCRecallMo

; 3121 : 		return;
; 3122 : 	
; 3123 : 	PMSG_RECALLMONLIFE pMsg;
; 3124 : 	BYTE per = life * 100 / maxlife;
; 3125 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x20, sizeof(pMsg));

  0000e	6a 05		 push	 5
  00010	6a 20		 push	 32			; 00000020H
  00012	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	68 f3 00 00 00	 push	 243			; 000000f3H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00020	8b 45 10	 mov	 eax, DWORD PTR _life$[ebp]
  00023	6b c0 64	 imul	 eax, 100		; 00000064H
  00026	99		 cdq
  00027	f7 fe		 idiv	 esi

; 3126 : 	pMsg.Life = per;
; 3127 : 
; 3128 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00029	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0002d	51		 push	 ecx
  0002e	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00031	52		 push	 edx
  00032	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00035	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003e	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@GCRecallMo:
  00041	5e		 pop	 esi

; 3129 : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?GCRecallMonLife@@YAXHHH@Z ENDP				; GCRecallMonLife
_TEXT	ENDS
PUBLIC	?GCTimeViewSend@@YAXHH@Z			; GCTimeViewSend
; Function compile flags: /Ogtp
;	COMDAT ?GCTimeViewSend@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_second$ = 12						; size = 4
?GCTimeViewSend@@YAXHH@Z PROC				; GCTimeViewSend, COMDAT

; 3144 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3145 : 	PMSG_TIMEVIEW pMsg;
; 3146 : 
; 3147 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x22, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	6a 22		 push	 34			; 00000022H
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 f3 00 00 00	 push	 243			; 000000f3H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3148 : 	pMsg.Second = second;
; 3149 : 
; 3150 : 	DataSend(aIndex, (UCHAR *)&pMsg, pMsg.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001c	66 8b 4d 0c	 mov	 cx, WORD PTR _second$[ebp]
  00020	52		 push	 edx
  00021	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00024	66 89 4d fc	 mov	 WORD PTR _pMsg$[ebp+4], cx
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3151 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?GCTimeViewSend@@YAXHH@Z ENDP				; GCTimeViewSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCGoalSend@@YAXHPADE0E@Z			; GCGoalSend
; Function compile flags: /Ogtp
;	COMDAT ?GCGoalSend@@YAXHPADE0E@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 22
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Name1$ = 12						; size = 4
_score1$ = 16						; size = 1
_Name2$ = 20						; size = 4
_score2$ = 24						; size = 1
?GCGoalSend@@YAXHPADE0E@Z PROC				; GCGoalSend, COMDAT

; 3168 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _Name1$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 14	 mov	 edi, DWORD PTR _Name2$[ebp]

; 3169 : 	PMSG_GOALSEND pMsg;
; 3170 : 
; 3171 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x23, sizeof(pMsg));

  00018	6a 16		 push	 22			; 00000016H
  0001a	6a 23		 push	 35			; 00000023H
  0001c	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	68 f3 00 00 00	 push	 243			; 000000f3H
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3172 : 	memcpy(pMsg.RedTeamName, Name1, sizeof(pMsg.RedTeamName));

  0002a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]

; 3173 : 	pMsg.RedTeamScore = score1;

  0002f	8a 45 10	 mov	 al, BYTE PTR _score1$[ebp]
  00032	89 4d e8	 mov	 DWORD PTR _pMsg$[ebp+4], ecx

; 3174 : 	memcpy(pMsg.BlueTeamName, Name2, sizeof(pMsg.BlueTeamName));

  00035	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00037	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  0003a	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0003d	89 4d f1	 mov	 DWORD PTR _pMsg$[ebp+13], ecx

; 3175 : 	pMsg.BlueTeamScore = score2;
; 3176 : 
; 3177 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00040	0f b6 4d e5	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00044	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+12], al
  00047	8a 45 18	 mov	 al, BYTE PTR _score2$[ebp]
  0004a	89 55 f5	 mov	 DWORD PTR _pMsg$[ebp+17], edx
  0004d	51		 push	 ecx
  0004e	8d 55 e4	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00051	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+21], al
  00054	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00057	52		 push	 edx
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3178 : }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	83 c4 1c	 add	 esp, 28			; 0000001cH
  00064	5f		 pop	 edi
  00065	33 cd		 xor	 ecx, ebp
  00067	5e		 pop	 esi
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?GCGoalSend@@YAXHPADE0E@Z ENDP				; GCGoalSend
_TEXT	ENDS
PUBLIC	??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z	; GCSkillKeyRecv
EXTRN	?LogAddL@@3P6AXPADZZA:DWORD			; LogAddL
EXTRN	?DGOptionDataSend@@YAXHPADPAEEEEEEEKD@Z:PROC	; DGOptionDataSend
EXTRN	__imp__ntohl@4:PROC
EXTRN	?gObjIsGamePlaing@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsGamePlaing
;	COMDAT ??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB 'O'
	DB	'ption Recv %d %d %d %d %d %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z
_TEXT	SEGMENT
_RkeyDefine$ = -4					; size = 1
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z PROC		; GCSkillKeyRecv, COMDAT

; 3184 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3185 : 	if ( !gObjIsGamePlaing(&gObj[aIndex]))

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000d	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00013	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?gObjIsGamePlaing@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsGamePlaing
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	0f 84 9b 00 00
	00		 je	 $LN3@GCSkillKey

; 3186 : 		return;
; 3187 : 
; 3188 : 	if ( gObj[aIndex].iOptionRecv == TRUE )

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	b1 01		 mov	 cl, 1
  0002e	38 8c 07 7c 24
	00 00		 cmp	 BYTE PTR [edi+eax+9340], cl
  00035	0f 84 87 00 00
	00		 je	 $LN3@GCSkillKey

; 3189 : 		return;
; 3190 : 
; 3191 : 	gObj[aIndex].iOptionRecv = TRUE;
; 3192 : 
; 3193 : 	BYTE RkeyDefine = 0;
; 3194 : 	RkeyDefine = lpMsg->RkeyDefine;

  0003b	53		 push	 ebx
  0003c	56		 push	 esi
  0003d	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00040	88 8c 07 7c 24
	00 00		 mov	 BYTE PTR [edi+eax+9340], cl

; 3195 : 
; 3196 : 	DWORD QWERLevel = 0;
; 3197 : 	QWERLevel = ntohl(lpMsg->QWERLevel);

  00047	8b 56 1e	 mov	 edx, DWORD PTR [esi+30]
  0004a	8a 5e 1d	 mov	 bl, BYTE PTR [esi+29]
  0004d	52		 push	 edx
  0004e	88 5d fc	 mov	 BYTE PTR _RkeyDefine$[ebp], bl
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ntohl@4

; 3198 : 
; 3199 : 	DGOptionDataSend(aIndex, gObj[aIndex].Name,
; 3200 : 		lpMsg->SKillKey, lpMsg->GameOption,
; 3201 : 		lpMsg->QkeyDefine,  lpMsg->WkeyDefine, lpMsg->EkeyDefine,lpMsg->ChatWindow,RkeyDefine,QWERLevel, gObj[aIndex].m_EnableUseChangeSkin);

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005d	0f b6 94 0f 12
	27 00 00	 movzx	 edx, BYTE PTR [edi+ecx+10002]
  00065	52		 push	 edx
  00066	0f b6 56 1c	 movzx	 edx, BYTE PTR [esi+28]
  0006a	50		 push	 eax
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _RkeyDefine$[ebp]
  0006e	50		 push	 eax
  0006f	0f b6 46 1b	 movzx	 eax, BYTE PTR [esi+27]
  00073	52		 push	 edx
  00074	0f b6 56 1a	 movzx	 edx, BYTE PTR [esi+26]
  00078	50		 push	 eax
  00079	0f b6 46 19	 movzx	 eax, BYTE PTR [esi+25]
  0007d	52		 push	 edx
  0007e	0f b6 56 18	 movzx	 edx, BYTE PTR [esi+24]
  00082	50		 push	 eax
  00083	52		 push	 edx
  00084	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00087	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0008a	50		 push	 eax
  0008b	8d 4c 0f 5d	 lea	 ecx, DWORD PTR [edi+ecx+93]
  0008f	51		 push	 ecx
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 ?DGOptionDataSend@@YAXHPADPAEEEEEEEKD@Z ; DGOptionDataSend

; 3202 : 
; 3203 : 	LogAddL("Option Recv %d %d %d %d %d %d", lpMsg->GameOption,
; 3204 : 		lpMsg->QkeyDefine,  lpMsg->WkeyDefine, lpMsg->EkeyDefine, RkeyDefine, lpMsg->QWERLevel);

  00096	8b 46 1e	 mov	 eax, DWORD PTR [esi+30]
  00099	0f b6 56 1b	 movzx	 edx, BYTE PTR [esi+27]
  0009d	50		 push	 eax
  0009e	0f b6 46 1a	 movzx	 eax, BYTE PTR [esi+26]
  000a2	0f b6 cb	 movzx	 ecx, bl
  000a5	51		 push	 ecx
  000a6	0f b6 4e 19	 movzx	 ecx, BYTE PTR [esi+25]
  000aa	52		 push	 edx
  000ab	0f b6 56 18	 movzx	 edx, BYTE PTR [esi+24]
  000af	50		 push	 eax
  000b0	51		 push	 ecx
  000b1	52		 push	 edx
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  000bd	83 c4 48	 add	 esp, 72			; 00000048H
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
$LN3@GCSkillKey:
  000c2	5f		 pop	 edi

; 3205 : }

  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z ENDP		; GCSkillKeyRecv
_TEXT	ENDS
PUBLIC	??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCSkillKeySend@@YAXHPAEEEEEEEK@Z		; GCSkillKeySend
;	COMDAT ??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB 'O'
	DB	'ption Send %d %d %d %d %d %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCSkillKeySend@@YAXHPAEEEEEEEK@Z
_TEXT	SEGMENT
_pMsg$ = -40						; size = 34
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_keybuffer$ = 12					; size = 4
_GO$ = 16						; size = 1
_Qk$ = 20						; size = 1
_Wk$ = 24						; size = 1
_Ek$ = 28						; size = 1
_ChatWnd$ = 32						; size = 1
_Rk$ = 36						; size = 1
_QWERLevel$ = 40					; size = 4
?GCSkillKeySend@@YAXHPAEEEEEEEK@Z PROC			; GCSkillKeySend, COMDAT

; 3215 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR _keybuffer$[ebp]

; 3216 : 	PMSG_SKILLKEY pMsg;
; 3217 : 
; 3218 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x30, sizeof(pMsg));

  00015	6a 22		 push	 34			; 00000022H
  00017	6a 30		 push	 48			; 00000030H
  00019	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	68 f3 00 00 00	 push	 243			; 000000f3H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3219 : 	memcpy(pMsg.SKillKey, keybuffer, sizeof(pMsg.SKillKey));

  00027	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 3220 : 	pMsg.GameOption = GO;

  0002f	8a 5d 10	 mov	 bl, BYTE PTR _GO$[ebp]
  00032	89 55 e0	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00035	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00038	89 4d dc	 mov	 DWORD PTR _pMsg$[ebp+4], ecx
  0003b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]

; 3221 : 	pMsg.QkeyDefine = Qk;
; 3222 : 	pMsg.WkeyDefine = Wk;
; 3223 : 	pMsg.EkeyDefine = Ek;
; 3224 : 	pMsg.ChatWindow = ChatWnd;
; 3225 : 	pMsg.RkeyDefine = Rk;
; 3226 : 	pMsg.QWERLevel = QWERLevel;

  0003e	8b 75 28	 mov	 esi, DWORD PTR _QWERLevel$[ebp]
  00041	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00044	8a 45 14	 mov	 al, BYTE PTR _Qk$[ebp]
  00047	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+20], edx
  0004a	8a 55 1c	 mov	 dl, BYTE PTR _Ek$[ebp]
  0004d	89 4d e8	 mov	 DWORD PTR _pMsg$[ebp+16], ecx
  00050	8a 4d 18	 mov	 cl, BYTE PTR _Wk$[ebp]
  00053	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+25], al
  00056	8a 45 20	 mov	 al, BYTE PTR _ChatWnd$[ebp]
  00059	88 55 f3	 mov	 BYTE PTR _pMsg$[ebp+27], dl

; 3227 : 
; 3228 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0005c	0f b6 55 d9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00060	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+26], cl
  00063	8a 4d 24	 mov	 cl, BYTE PTR _Rk$[ebp]
  00066	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+28], al
  00069	52		 push	 edx
  0006a	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006d	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+29], cl
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00073	50		 push	 eax
  00074	51		 push	 ecx
  00075	88 5d f0	 mov	 BYTE PTR _pMsg$[ebp+24], bl
  00078	89 75 f6	 mov	 DWORD PTR _pMsg$[ebp+30], esi
  0007b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3229 : 	LogAddL("Option Send %d %d %d %d %d %d", GO, Qk, Wk, Ek, Rk, QWERLevel);

  00080	0f b6 55 24	 movzx	 edx, BYTE PTR _Rk$[ebp]
  00084	0f b6 45 1c	 movzx	 eax, BYTE PTR _Ek$[ebp]
  00088	0f b6 4d 18	 movzx	 ecx, BYTE PTR _Wk$[ebp]
  0008c	56		 push	 esi
  0008d	52		 push	 edx
  0008e	0f b6 55 14	 movzx	 edx, BYTE PTR _Qk$[ebp]
  00092	50		 push	 eax
  00093	51		 push	 ecx
  00094	0f b6 c3	 movzx	 eax, bl
  00097	52		 push	 edx
  00098	50		 push	 eax
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL

; 3230 : }

  000a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a7	83 c4 38	 add	 esp, 56			; 00000038H
  000aa	5e		 pop	 esi
  000ab	33 cd		 xor	 ecx, ebp
  000ad	5b		 pop	 ebx
  000ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
?GCSkillKeySend@@YAXHPAEEEEEEEK@Z ENDP			; GCSkillKeySend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMoneySend@@YAXHK@Z				; GCMoneySend
; Function compile flags: /Ogtp
;	COMDAT ?GCMoneySend@@YAXHK@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_money$ = 12						; size = 4
?GCMoneySend@@YAXHK@Z PROC				; GCMoneySend, COMDAT

; 3243 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3244 : 	PMSG_ITEMGETRESULT pMsg;
; 3245 : 
; 3246 : 	pMsg.h.c = 0xC3;
; 3247 : 	pMsg.h.headcode = 0x22;
; 3248 : 	pMsg.h.size = sizeof(pMsg);
; 3249 : 	pMsg.result = 0xFE;
; 3250 : 
; 3251 : 	WORD hiWord = SET_NUMBERHW(money);

  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _money$[ebp]
  00013	8b c1		 mov	 eax, ecx
  00015	c1 e8 10	 shr	 eax, 16			; 00000010H

; 3252 : 	WORD loWord = SET_NUMBERLW(money);
; 3253 : 	pMsg.Data[0] = SET_NUMBERH(hiWord);

  00018	8b d0		 mov	 edx, eax

; 3254 : 	pMsg.Data[1] = SET_NUMBERL(hiWord);

  0001a	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0001d	c1 ea 08	 shr	 edx, 8

; 3255 : 	pMsg.Data[2] = SET_NUMBERH(loWord);

  00020	8b c1		 mov	 eax, ecx

; 3256 : 	pMsg.Data[3] = SET_NUMBERL(loWord);

  00022	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 3257 : 
; 3258 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00025	6a 10		 push	 16			; 00000010H
  00027	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002a	88 55 f0	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  0002d	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00030	51		 push	 ecx
  00031	c1 e8 08	 shr	 eax, 8
  00034	52		 push	 edx
  00035	c6 45 ec c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H
  00039	66 c7 45 ed 10
	22		 mov	 WORD PTR _pMsg$[ebp+1], 8720 ; 00002210H
  0003f	c6 45 ef fe	 mov	 BYTE PTR _pMsg$[ebp+3], 254 ; 000000feH
  00043	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al
  00046	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3259 : }

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?GCMoneySend@@YAXHK@Z ENDP				; GCMoneySend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCItemInventoryPutSend@@YAXHEEE@Z		; GCItemInventoryPutSend
; Function compile flags: /Ogtp
;	COMDAT ?GCItemInventoryPutSend@@YAXHEEE@Z
_TEXT	SEGMENT
_pResult$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_iteminfo1$ = 16					; size = 1
_iteminfo2$ = 20					; size = 1
?GCItemInventoryPutSend@@YAXHEEE@Z PROC			; GCItemInventoryPutSend, COMDAT

; 3264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3265 : 	PMSG_ITEMGETRESULT pResult;
; 3266 : 
; 3267 : 	pResult.h.c = 0xC3;
; 3268 : 	pResult.h.headcode = 0x22;
; 3269 : 	pResult.h.size = sizeof(pResult);
; 3270 : 	pResult.result = result;

  00010	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]

; 3271 : 	pResult.Data[0] = iteminfo1;

  00013	8a 4d 10	 mov	 cl, BYTE PTR _iteminfo1$[ebp]

; 3272 : 	pResult.Data[1] = iteminfo2;

  00016	8a 55 14	 mov	 dl, BYTE PTR _iteminfo2$[ebp]
  00019	88 45 ef	 mov	 BYTE PTR _pResult$[ebp+3], al

; 3273 : 	pResult.h.size -= 2;
; 3274 : 
; 3275 : 	DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  0001c	6a 0e		 push	 14			; 0000000eH
  0001e	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  00021	88 4d f0	 mov	 BYTE PTR _pResult$[ebp+4], cl
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00027	50		 push	 eax
  00028	51		 push	 ecx
  00029	c6 45 ec c3	 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H
  0002d	88 55 f1	 mov	 BYTE PTR _pResult$[ebp+5], dl
  00030	66 c7 45 ed 0e
	22		 mov	 WORD PTR _pResult$[ebp+1], 8718 ; 0000220eH
  00036	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3276 : }

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	33 cd		 xor	 ecx, ebp
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?GCItemInventoryPutSend@@YAXHEEE@Z ENDP			; GCItemInventoryPutSend
_TEXT	ENDS
PUBLIC	??_C@_0EM@HPFBFIFH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Fireworks@ ; `string'
PUBLIC	??_C@_0CP@KAEBPCMA@?$FLSnakeBegins?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5t@ ; `string'
PUBLIC	??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@ ; `string'
PUBLIC	??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0EM@LPMBPPDG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0ED@PDKMNGPH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0FC@GOMPGJDH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@ ; `string'
PUBLIC	??_C@_04BGCMBJDA@Item?$AA@			; `string'
PUBLIC	??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@ ; `string'
PUBLIC	??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@ ; `string'
PUBLIC	??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@		; `string'
PUBLIC	??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z	; CGItemDropRequest
EXTRN	?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEPAEE@Z:PROC ; MapClass::ItemDrop
EXTRN	?procCreate@MonsterSpawnerMng@@QAE_NFH@Z:PROC	; MonsterSpawnerMng::procCreate
EXTRN	?isKeyItem@MonsterSpawnerMng@@QAE_NH@Z:PROC	; MonsterSpawnerMng::isKeyItem
EXTRN	?DropScroll@SnakeBegins@@QAE_NPAUOBJECTSTRUCT@@G@Z:PROC ; SnakeBegins::DropScroll
EXTRN	?g_SnakeBegins@@3VSnakeBegins@@A:BYTE		; g_SnakeBegins
EXTRN	?CreateLifeStone@CLifeStone@@QAEHH@Z:PROC	; CLifeStone::CreateLifeStone
EXTRN	?g_CsNPC_LifeStone@@3VCLifeStone@@A:DWORD	; g_CsNPC_LifeStone
EXTRN	?CreateGuardian@CGuardian@@QAEHH@Z:PROC		; CGuardian::CreateGuardian
EXTRN	?g_CsNPC_Guardian@@3VCGuardian@@A:DWORD		; g_CsNPC_Guardian
EXTRN	?CreateMercenary@CMercenary@@QAEHHHEE@Z:PROC	; CMercenary::CreateMercenary
EXTRN	?g_CsNPC_Mercenary@@3VCMercenary@@A:QWORD	; g_CsNPC_Mercenary
EXTRN	?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z:PROC	; CKalimaGate::CreateKalimaGate
EXTRN	?g_KalimaGate@@3VCKalimaGate@@A:BYTE		; g_KalimaGate
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z:PROC ; ItemSerialCreateSend
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?OpenBox@EventItemBagManager@@QAEEHHE@Z:PROC	; EventItemBagManager::OpenBox
EXTRN	?g_EventItemBagManager@@3VEventItemBagManager@@A:BYTE ; g_EventItemBagManager
EXTRN	?LevelSmallConvert@@YAEHH@Z:PROC		; LevelSmallConvert
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?GCItemListSend@@YAXH@Z:PROC			; GCItemListSend
EXTRN	?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z:PROC ; gObjInventorySearchSerialNumber
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z:PROC	; gObjCheckSerial0ItemList
EXTRN	?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemOptionLevel
EXTRN	?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemStrengthenOption
EXTRN	?GetItemOptions@CSocketItems@@QAEXPAVCItem@@PAE1@Z:PROC ; CSocketItems::GetItemOptions
EXTRN	?g_SocketItem@@3VCSocketItems@@A:BYTE		; g_SocketItem
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?g_NewPVP@@3VCNewPVP@@A:BYTE			; g_NewPVP
EXTRN	?IsElementalItem@CElementalSystem@@QAEHH@Z:PROC	; CElementalSystem::IsElementalItem
EXTRN	?g_ElementalSystem@@3VCElementalSystem@@A:BYTE	; g_ElementalSystem
EXTRN	?IsCashSpecialItem@@YAHH@Z:PROC			; IsCashSpecialItem
EXTRN	?IsCashItem@@YAHH@Z:PROC			; IsCashItem
EXTRN	?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z:PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
EXTRN	?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z:PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
EXTRN	?IsJewelOfHarmonyOriginal@CJewelOfHarmonySystem@@QAEHF@Z:PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonyOriginal
EXTRN	?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
EXTRN	?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A:BYTE ; g_kJewelOfHarmonySystem
EXTRN	?IsExtItem@CItem@@QAEHXZ:PROC			; CItem::IsExtItem
EXTRN	?IsSetItem@CItem@@QAEHXZ:PROC			; CItem::IsSetItem
EXTRN	?gPkLimitFree@@3HA:DWORD			; gPkLimitFree
EXTRN	?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z:PROC	; gObjCanItemTouch
EXTRN	?gObjFixInventoryPointer@@YA_NH@Z:PROC		; gObjFixInventoryPointer
;	COMDAT ??_C@_0EM@HPFBFIFH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Fireworks@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\snakebegins.h
CONST	SEGMENT
??_C@_0EM@HPFBFIFH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Fireworks@ DB '['
	DB	'%s][%s][%d]%d/%d Used Fireworks:%u (%s:%d/level:%d/skill:%d/o'
	DB	'p2:%d/op3:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@KAEBPCMA@?$FLSnakeBegins?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5t@
CONST	SEGMENT
??_C@_0CP@KAEBPCMA@?$FLSnakeBegins?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5t@ DB '['
	DB	'SnakeBegins] [%s][%s] Success to create Snake', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@
CONST	SEGMENT
??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@ DB '['
	DB	'Kalima] [%s][%s] Success to Make Kalima Gate (Lost Kalima Map'
	DB	' Serial:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Event ZenDrop : %d : (%d)('
	DB	'%d/%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@LPMBPPDG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0EM@LPMBPPDG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Throw Surprise Treasure Bo'
	DB	'x - serial:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@PDKMNGPH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0ED@PDKMNGPH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Throw Crystal (%d) - seria'
	DB	'l:%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@GOMPGJDH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0FC@GOMPGJDH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Throw Mysterious Bead : Dr'
	DB	'op (%d) - serial:%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@
CONST	SEGMENT
??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [ItemDrop] (%s)(%s) Item(%s) Pos(%d'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGCMBJDA@Item?$AA@
CONST	SEGMENT
??_C@_04BGCMBJDA@Item?$AA@ DB 'Item', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@ DB 'error:%s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@
CONST	SEGMENT
??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@ DB '['
	DB	'%s][%s] CGItemDropRequest() Failed : Transaction == 1, IF_TYP'
	DB	'E : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
CONST	SEGMENT
??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@ DB '['
	DB	'Fix Inv.Ptr] False Location - %s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
CONST	SEGMENT
??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@ DB 'protocol.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@
CONST	SEGMENT
??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@ DB '['
	DB	'ANTI-HACK][Item Duplication] - Item Drop during MapServer Mov'
	DB	'e [%s][%s]', 00H				; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z
_TEXT	SEGMENT
_PetExp$218651 = -192					; size = 4
_PetLevel$218650 = -188					; size = 4
_SocketBonus$218655 = -184				; size = 1
tv1739 = -180						; size = 4
_NOption$218648 = -176					; size = 1
_bIsItem$218644 = -172					; size = 4
_lpMsg$GSCopy$ = -168					; size = 4
_serial2$218656 = -164					; size = 4
tv1696 = -160						; size = 4
_CopyItem$ = -156					; size = 4
_SOption$218652 = -152					; size = 1
_dur$218643 = -148					; size = 4
_btItemEffectEx$218653 = -144				; size = 1
_Option1$218645 = -140					; size = 1
_Option3$218647 = -136					; size = 1
_Option2$218646 = -132					; size = 1
_serial$218649 = -128					; size = 4
_ServerCmd$218694 = -124				; size = 7
_ServerCmd$218673 = -124				; size = 7
_map$218640 = -124					; size = 4
_JOHOption$218659 = -113				; size = 1
_level$218642 = -112					; size = 4
_JOHOptionLevel$218660 = -105				; size = 1
_aIndex$GSCopy$ = -104					; size = 4
_pResult$ = -100					; size = 5
_pChange$218756 = -92					; size = 17
_szItemName$218657 = -72				; size = 50
_SocketOptions$218654 = -20				; size = 5
_NewOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_drop_type$ = 16					; size = 4
?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z PROC	; CGItemDropRequest, COMDAT

; 4043 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4044 : 	BOOL CopyItem = FALSE;
; 4045 : 	BYTE NewOption[MAX_EXOPTION_SIZE];
; 4046 : 
; 4047 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001c	56		 push	 esi
  0001d	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00020	57		 push	 edi
  00021	8b fb		 mov	 edi, ebx
  00023	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00029	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0002c	51		 push	 ecx

; 4586 : 			}
; 4587 : 
; 4588 : 
; 4589 : 			::gObjMakePreviewCharSet(aIndex);

  0002d	89 b5 58 ff ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], esi
  00033	89 5d 98	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00036	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _CopyItem$[ebp], 0
  00040	89 bd 60 ff ff
	ff		 mov	 DWORD PTR tv1696[ebp], edi
  00046	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0004b	83 c4 04	 add	 esp, 4
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 cb 00 00
	00		 je	 $LN129@CGItemDrop

; 4048 : 		return FALSE;
; 4049 : 
; 4050 : 	PMSG_ITEMTHROW_RESULT pResult;
; 4051 : 
; 4052 : 	PHeadSetB((LPBYTE)&pResult, 0x23, sizeof(pResult));

  00056	6a 05		 push	 5
  00058	8d 55 9c	 lea	 edx, DWORD PTR _pResult$[ebp]
  0005b	6a 23		 push	 35			; 00000023H
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 4053 : 	pResult.Result = true;
; 4054 : 	pResult.Ipos = lpMsg->Ipos;

  00063	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00066	88 45 a0	 mov	 BYTE PTR _pResult$[ebp+4], al

; 4055 : 
; 4056 : 	if ( gObj[aIndex].m_IfState.use != 0 )

  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006e	c6 45 9f 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00072	8b 8c 07 b8 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4536]
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007c	f6 c1 03	 test	 cl, 3
  0007f	74 12		 je	 SHORT $LN109@CGItemDrop

; 4057 : 	{
; 4058 : 		if ( gObj[aIndex].m_IfState.type != 3 )

  00081	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00087	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H

; 4059 : 		{
; 4060 : 			pResult.Result = false;
; 4061 : 			return FALSE;

  0008d	0f 85 8e 00 00
	00		 jne	 $LN129@CGItemDrop
$LN109@CGItemDrop:

; 4062 : 		}
; 4063 : 	}
; 4064 : 
; 4065 : 	if ( gObj[aIndex].CloseType != -1 )

  00093	80 7c 07 0d ff	 cmp	 BYTE PTR [edi+eax+13], -1
  00098	74 04		 je	 SHORT $LN108@CGItemDrop

; 4066 : 		pResult.Result = false;

  0009a	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN108@CGItemDrop:

; 4067 : 
; 4068 : 	if ( gObj[aIndex].m_bMapSvrMoveQuit == true )

  0009e	80 bc 07 3c 20
	00 00 01	 cmp	 BYTE PTR [edi+eax+8252], 1
  000a6	75 1c		 jne	 SHORT $LN107@CGItemDrop

; 4069 : 	{
; 4070 : 		LogAddTD("[ANTI-HACK][Item Duplication] - Item Drop during MapServer Move [%s][%s]",
; 4071 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);

  000a8	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  000ac	51		 push	 ecx
  000ad	8d 54 07 52	 lea	 edx, DWORD PTR [edi+eax+82]
  000b1	52		 push	 edx
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4072 : 		pResult.Result = false;

  000c0	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN107@CGItemDrop:

; 4073 : 	}
; 4074 : 
; 4075 : 
; 4076 : 	if ( !::gObjFixInventoryPointer(aIndex))

  000c4	53		 push	 ebx
  000c5	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  000ca	83 c4 04	 add	 esp, 4
  000cd	84 c0		 test	 al, al
  000cf	75 18		 jne	 SHORT $LN106@CGItemDrop

; 4077 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  000d1	68 ed 0f 00 00	 push	 4077			; 00000fedH
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN106@CGItemDrop:

; 4078 : 
; 4079 : 	if ( gObj[aIndex].pTransaction == 1 )

  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ee	80 bc 07 cc 11
	00 00 01	 cmp	 BYTE PTR [edi+eax+4556], 1
  000f6	8d 1c 07	 lea	 ebx, DWORD PTR [edi+eax]
  000f9	75 39		 jne	 SHORT $LN105@CGItemDrop

; 4080 : 	{
; 4081 : 		LogAddTD("[%s][%s] CGItemDropRequest() Failed : Transaction == 1, IF_TYPE : %d",
; 4082 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  000fb	8b 8b b8 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4536]
  00101	c1 e9 06	 shr	 ecx, 6
  00104	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0010a	51		 push	 ecx
  0010b	8d 53 5d	 lea	 edx, DWORD PTR [ebx+93]
  0010e	52		 push	 edx
  0010f	83 c3 52	 add	 ebx, 82			; 00000052H
  00112	53		 push	 ebx
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0011e	83 c4 10	 add	 esp, 16			; 00000010H
$LN129@CGItemDrop:

; 4083 : 		pResult.Result = false;
; 4084 : 		
; 4085 : 		return false;

  00121	33 c0		 xor	 eax, eax

; 4606 : }

  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00129	33 cd		 xor	 ecx, ebp
  0012b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
$LN105@CGItemDrop:

; 4086 : 	}
; 4087 : 
; 4088 : 	LPOBJ lpObj = &gObj[aIndex];
; 4089 : 
; 4090 : 	if ( lpMsg->Ipos == 0xFF )	// Null Position

  00134	80 7e 05 ff	 cmp	 BYTE PTR [esi+5], 255	; 000000ffH
  00138	75 1c		 jne	 SHORT $LN104@CGItemDrop

; 4091 : 	{
; 4092 : 		LogAdd("error:%s %d", __FILE__, __LINE__);

  0013a	68 fc 0f 00 00	 push	 4092			; 00000ffcH
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4093 : 		pResult.Result = false;

  00152	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN104@CGItemDrop:

; 4094 : 	}
; 4095 : 
; 4096 : 	if ( lpMsg->Ipos < 0 || lpMsg->Ipos > MAIN_INVENTORY_SIZE-1)	// Out of Bounds

  00156	80 7e 05 cb	 cmp	 BYTE PTR [esi+5], 203	; 000000cbH
  0015a	76 04		 jbe	 SHORT $LN103@CGItemDrop

; 4097 : 		pResult.Result = false;

  0015c	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN103@CGItemDrop:

; 4098 : 
; 4099 : 	if (!::gObjCanItemTouch(lpObj, 0))

  00160	6a 00		 push	 0
  00162	53		 push	 ebx
  00163	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  00168	83 c4 08	 add	 esp, 8
  0016b	85 c0		 test	 eax, eax
  0016d	75 03		 jne	 SHORT $LN101@CGItemDrop

; 4100 : 		pResult.Result = false;

  0016f	88 45 9f	 mov	 BYTE PTR _pResult$[ebp+3], al
$LN101@CGItemDrop:

; 4101 : 
; 4102 : 	// Icarus Preventions about Dinorant
; 4103 : 	if ( gObj[aIndex].MapNumber == MAP_INDEX_ICARUS)

  00172	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00177	80 bc 07 23 01
	00 00 0a	 cmp	 BYTE PTR [edi+eax+291], 10 ; 0000000aH
  0017f	75 48		 jne	 SHORT $LN94@CGItemDrop

; 4104 : 	{
; 4105 : 		if ( lpMsg->Ipos == 8 )

  00181	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00184	3c 08		 cmp	 al, 8
  00186	75 25		 jne	 SHORT $LN99@CGItemDrop

; 4106 : 		{
; 4107 : 			if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,3) ) // Dinorant

  00188	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  0018e	b9 03 1a 00 00	 mov	 ecx, 6659		; 00001a03H
  00193	66 39 88 a6 06
	00 00		 cmp	 WORD PTR [eax+1702], cx
  0019a	75 2d		 jne	 SHORT $LN94@CGItemDrop

; 4108 : 			{
; 4109 : 				if( lpObj->pInventory[7].IsItem() == FALSE )

  0019c	8d 88 cc 05 00
	00		 lea	 ecx, DWORD PTR [eax+1484]
  001a2	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001a7	85 c0		 test	 eax, eax
  001a9	75 1e		 jne	 SHORT $LN94@CGItemDrop

; 4110 : 				{
; 4111 : 					pResult.Result = false;
; 4112 : 				}
; 4113 : 			}
; 4114 : 		}

  001ab	eb 18		 jmp	 SHORT $LN127@CGItemDrop
$LN99@CGItemDrop:

; 4115 : 		else if ( lpMsg->Ipos == 7 )

  001ad	3c 07		 cmp	 al, 7
  001af	75 18		 jne	 SHORT $LN94@CGItemDrop

; 4116 : 		{
; 4117 : 			if ( lpObj->pInventory[8].m_Type != ITEMGET(13,3) ) // Dinorant 

  001b1	8b 93 c0 11 00
	00		 mov	 edx, DWORD PTR [ebx+4544]
  001b7	b8 03 1a 00 00	 mov	 eax, 6659		; 00001a03H
  001bc	66 39 82 a6 06
	00 00		 cmp	 WORD PTR [edx+1702], ax
  001c3	74 04		 je	 SHORT $LN94@CGItemDrop
$LN127@CGItemDrop:

; 4118 : 			{
; 4119 : 				pResult.Result = false;

  001c5	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN94@CGItemDrop:

; 4120 : 			}
; 4121 : 		}
; 4122 : 	}
; 4123 : 
; 4124 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,30) ||
; 4125 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,31) ||
; 4126 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,36) ||
; 4127 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,37) )

  001c9	0f b6 7e 05	 movzx	 edi, BYTE PTR [esi+5]
  001cd	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  001d3	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  001d9	0f b7 44 0f 06	 movzx	 eax, WORD PTR [edi+ecx+6]
  001de	ba 1e 18 00 00	 mov	 edx, 6174		; 0000181eH
  001e3	66 3b c2	 cmp	 ax, dx
  001e6	74 1e		 je	 SHORT $LN92@CGItemDrop
  001e8	b9 1f 18 00 00	 mov	 ecx, 6175		; 0000181fH
  001ed	66 3b c1	 cmp	 ax, cx
  001f0	74 14		 je	 SHORT $LN92@CGItemDrop
  001f2	ba 24 1a 00 00	 mov	 edx, 6692		; 00001a24H
  001f7	66 3b c2	 cmp	 ax, dx
  001fa	74 0a		 je	 SHORT $LN92@CGItemDrop
  001fc	b9 25 1a 00 00	 mov	 ecx, 6693		; 00001a25H
  00201	66 3b c1	 cmp	 ax, cx
  00204	75 04		 jne	 SHORT $LN93@CGItemDrop
$LN92@CGItemDrop:

; 4128 : 	{
; 4129 : 		pResult.Result = false;

  00206	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN93@CGItemDrop:

; 4130 : 	}
; 4131 : 
; 4132 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,42) )

  0020a	8b 93 c0 11 00
	00		 mov	 edx, DWORD PTR [ebx+4544]
  00210	b8 2a 1a 00 00	 mov	 eax, 6698		; 00001a2aH
  00215	66 39 44 17 06	 cmp	 WORD PTR [edi+edx+6], ax
  0021a	75 04		 jne	 SHORT $LN91@CGItemDrop

; 4133 : 	{
; 4134 : 		pResult.Result = false;

  0021c	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN91@CGItemDrop:

; 4135 : 	}
; 4136 : 
; 4137 : 	if ( IT_MAP_RANGE( lpObj->MapNumber ) )

  00220	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  00227	3c 2d		 cmp	 al, 45			; 0000002dH
  00229	72 1f		 jb	 SHORT $LN126@CGItemDrop
  0022b	b1 32		 mov	 cl, 50			; 00000032H
  0022d	3a c8		 cmp	 cl, al
  0022f	1b c0		 sbb	 eax, eax
  00231	40		 inc	 eax
  00232	74 16		 je	 SHORT $LN126@CGItemDrop

; 4138 : 	{
; 4139 : 		if( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,51) )

  00234	8b 93 c0 11 00
	00		 mov	 edx, DWORD PTR [ebx+4544]
  0023a	b8 33 1a 00 00	 mov	 eax, 6707		; 00001a33H
  0023f	66 39 44 17 06	 cmp	 WORD PTR [edi+edx+6], ax
  00244	75 04		 jne	 SHORT $LN126@CGItemDrop

; 4140 : 		{
; 4141 : 			pResult.Result = false;

  00246	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN126@CGItemDrop:

; 4142 : 		}
; 4143 : 	}
; 4144 : 
; 4145 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,64) )

  0024a	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  00250	ba 40 1c 00 00	 mov	 edx, 7232		; 00001c40H
  00255	66 39 54 0f 06	 cmp	 WORD PTR [edi+ecx+6], dx
  0025a	75 04		 jne	 SHORT $LN88@CGItemDrop

; 4146 : 	{
; 4147 : 		pResult.Result = false;

  0025c	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN88@CGItemDrop:

; 4148 : 	}
; 4149 : 
; 4150 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEMGET(12,36) &&
; 4151 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEMGET(12,40) )

  00260	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00266	0f b7 44 07 06	 movzx	 eax, WORD PTR [edi+eax+6]
  0026b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gPkLimitFree@@3HA ; gPkLimitFree
  00271	b9 24 18 00 00	 mov	 ecx, 6180		; 00001824H
  00276	66 3b c1	 cmp	 ax, cx
  00279	7c 11		 jl	 SHORT $LN86@CGItemDrop
  0027b	b9 28 18 00 00	 mov	 ecx, 6184		; 00001828H
  00280	66 3b c1	 cmp	 ax, cx
  00283	7f 07		 jg	 SHORT $LN86@CGItemDrop

; 4152 : 	{
; 4153 : 		if ( gPkLimitFree == FALSE )

  00285	85 d2		 test	 edx, edx
  00287	75 03		 jne	 SHORT $LN86@CGItemDrop

; 4154 : 		{
; 4155 : 			pResult.Result = false;

  00289	88 55 9f	 mov	 BYTE PTR _pResult$[ebp+3], dl
$LN86@CGItemDrop:

; 4156 : 		}
; 4157 : 	}
; 4158 : 
; 4159 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,49) ||
; 4160 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,50) )

  0028c	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00292	0f b7 44 07 06	 movzx	 eax, WORD PTR [edi+eax+6]
  00297	b9 31 18 00 00	 mov	 ecx, 6193		; 00001831H
  0029c	66 3b c1	 cmp	 ax, cx
  0029f	74 0a		 je	 SHORT $LN84@CGItemDrop
  002a1	b9 32 18 00 00	 mov	 ecx, 6194		; 00001832H
  002a6	66 3b c1	 cmp	 ax, cx
  002a9	75 07		 jne	 SHORT $LN83@CGItemDrop
$LN84@CGItemDrop:

; 4161 : 	{
; 4162 : 		if ( gPkLimitFree == FALSE )

  002ab	85 d2		 test	 edx, edx
  002ad	75 03		 jne	 SHORT $LN83@CGItemDrop

; 4163 : 		{
; 4164 : 			pResult.Result = false;

  002af	88 55 9f	 mov	 BYTE PTR _pResult$[ebp+3], dl
$LN83@CGItemDrop:

; 4165 : 		}
; 4166 : 	}
; 4167 : 
; 4168 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEMGET(12,130) &&
; 4169 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEMGET(12,135) )

  002b2	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  002b8	0f b7 44 07 06	 movzx	 eax, WORD PTR [edi+eax+6]
  002bd	b9 82 18 00 00	 mov	 ecx, 6274		; 00001882H
  002c2	66 3b c1	 cmp	 ax, cx
  002c5	7c 11		 jl	 SHORT $LN81@CGItemDrop
  002c7	b9 87 18 00 00	 mov	 ecx, 6279		; 00001887H
  002cc	66 3b c1	 cmp	 ax, cx
  002cf	7f 07		 jg	 SHORT $LN81@CGItemDrop

; 4170 : 	{
; 4171 : 		if ( gPkLimitFree == FALSE )

  002d1	85 d2		 test	 edx, edx
  002d3	75 03		 jne	 SHORT $LN81@CGItemDrop

; 4172 : 		{
; 4173 : 			pResult.Result = false;

  002d5	88 55 9f	 mov	 BYTE PTR _pResult$[ebp+3], dl
$LN81@CGItemDrop:

; 4174 : 		}
; 4175 : 	}
; 4176 : 
; 4177 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEMGET(12,262) &&
; 4178 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEMGET(12,267) )

  002d8	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  002de	0f b7 44 07 06	 movzx	 eax, WORD PTR [edi+eax+6]
  002e3	b9 06 19 00 00	 mov	 ecx, 6406		; 00001906H
  002e8	66 3b c1	 cmp	 ax, cx
  002eb	7c 11		 jl	 SHORT $LN79@CGItemDrop
  002ed	b9 0b 19 00 00	 mov	 ecx, 6411		; 0000190bH
  002f2	66 3b c1	 cmp	 ax, cx
  002f5	7f 07		 jg	 SHORT $LN79@CGItemDrop

; 4179 : 	{
; 4180 : 		if ( gPkLimitFree == FALSE )

  002f7	85 d2		 test	 edx, edx
  002f9	75 03		 jne	 SHORT $LN79@CGItemDrop

; 4181 : 		{
; 4182 : 			pResult.Result = false;

  002fb	88 55 9f	 mov	 BYTE PTR _pResult$[ebp+3], dl
$LN79@CGItemDrop:

; 4183 : 		}
; 4184 : 	}
; 4185 : 
; 4186 : 
; 4187 : #if (CUSTOM_WINGS == 1)
; 4188 : 
; 4189 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEMGET(12,440) &&
; 4190 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEMGET(12,445) )
; 4191 : 	{
; 4192 : 		if ( gPkLimitFree == FALSE )
; 4193 : 		{
; 4194 : 			pResult.Result = false;
; 4195 : 		}
; 4196 : 	}
; 4197 : 
; 4198 : #endif
; 4199 : 
; 4200 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,52) ||
; 4201 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,53) )

  002fe	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00304	0f b7 44 07 06	 movzx	 eax, WORD PTR [edi+eax+6]
  00309	b9 34 1a 00 00	 mov	 ecx, 6708		; 00001a34H
  0030e	66 3b c1	 cmp	 ax, cx
  00311	74 0a		 je	 SHORT $LN77@CGItemDrop
  00313	b9 35 1a 00 00	 mov	 ecx, 6709		; 00001a35H
  00318	66 3b c1	 cmp	 ax, cx
  0031b	75 04		 jne	 SHORT $LN78@CGItemDrop
$LN77@CGItemDrop:

; 4202 : 	{
; 4203 : 		pResult.Result = false;

  0031d	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN78@CGItemDrop:

; 4204 : 	}
; 4205 : 
; 4206 : 	if (	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,13) 
; 4207 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,14) 
; 4208 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,16)
; 4209 : 		||	(lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEMGET(12,0) && lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEMGET(12,6)) 
; 4210 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,15) 
; 4211 : 		||	(lpObj->pInventory[lpMsg->Ipos].m_Level >= 7  && lpObj->pInventory[lpMsg->Ipos].m_Type < ITEMGET(12,0)) 
; 4212 : 		||	lpObj->pInventory[lpMsg->Ipos].IsSetItem() != FALSE 
; 4213 : 		||	lpObj->pInventory[lpMsg->Ipos].IsExtItem() != FALSE
; 4214 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,14)
; 4215 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,19)
; 4216 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,15) 
; 4217 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,34) 
; 4218 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,31)
; 4219 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,41)
; 4220 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,42)
; 4221 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,43) 
; 4222 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,44) 
; 4223 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,41)
; 4224 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,42)
; 4225 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,43) )

  00321	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00327	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0032a	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  0032e	bf 0d 1c 00 00	 mov	 edi, 7181		; 00001c0dH
  00333	66 3b c7	 cmp	 ax, di
  00336	0f 84 14 01 00
	00		 je	 $LN75@CGItemDrop
  0033c	bf 0e 1c 00 00	 mov	 edi, 7182		; 00001c0eH
  00341	66 3b c7	 cmp	 ax, di
  00344	0f 84 06 01 00
	00		 je	 $LN75@CGItemDrop
  0034a	bf 10 1c 00 00	 mov	 edi, 7184		; 00001c10H
  0034f	66 3b c7	 cmp	 ax, di
  00352	0f 84 f8 00 00
	00		 je	 $LN75@CGItemDrop
  00358	bf 00 18 00 00	 mov	 edi, 6144		; 00001800H
  0035d	66 3b c7	 cmp	 ax, di
  00360	7c 0e		 jl	 SHORT $LN74@CGItemDrop
  00362	bf 06 18 00 00	 mov	 edi, 6150		; 00001806H
  00367	66 3b c7	 cmp	 ax, di
  0036a	0f 8e e0 00 00
	00		 jle	 $LN75@CGItemDrop
$LN74@CGItemDrop:
  00370	bf 0f 18 00 00	 mov	 edi, 6159		; 0000180fH
  00375	66 3b c7	 cmp	 ax, di
  00378	0f 84 d2 00 00
	00		 je	 $LN75@CGItemDrop
  0037e	66 83 79 08 07	 cmp	 WORD PTR [ecx+8], 7
  00383	7c 0e		 jl	 SHORT $LN73@CGItemDrop
  00385	bf 00 18 00 00	 mov	 edi, 6144		; 00001800H
  0038a	66 3b c7	 cmp	 ax, di
  0038d	0f 8c bd 00 00
	00		 jl	 $LN75@CGItemDrop
$LN73@CGItemDrop:
  00393	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00398	85 c0		 test	 eax, eax
  0039a	0f 85 aa 00 00
	00		 jne	 $LN123@CGItemDrop
  003a0	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  003a4	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  003aa	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  003b0	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  003b5	85 c0		 test	 eax, eax
  003b7	0f 85 8d 00 00
	00		 jne	 $LN123@CGItemDrop
  003bd	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  003c1	8b 93 c0 11 00
	00		 mov	 edx, DWORD PTR [ebx+4544]
  003c7	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  003cd	0f b7 44 11 06	 movzx	 eax, WORD PTR [ecx+edx+6]
  003d2	b9 0e 1a 00 00	 mov	 ecx, 6670		; 00001a0eH
  003d7	66 3b c1	 cmp	 ax, cx
  003da	74 6e		 je	 SHORT $LN123@CGItemDrop
  003dc	ba 13 1a 00 00	 mov	 edx, 6675		; 00001a13H
  003e1	66 3b c2	 cmp	 ax, dx
  003e4	74 64		 je	 SHORT $LN123@CGItemDrop
  003e6	b9 0f 1a 00 00	 mov	 ecx, 6671		; 00001a0fH
  003eb	66 3b c1	 cmp	 ax, cx
  003ee	74 5a		 je	 SHORT $LN123@CGItemDrop
  003f0	ba 22 1a 00 00	 mov	 edx, 6690		; 00001a22H
  003f5	66 3b c2	 cmp	 ax, dx
  003f8	74 50		 je	 SHORT $LN123@CGItemDrop
  003fa	b9 1f 1c 00 00	 mov	 ecx, 7199		; 00001c1fH
  003ff	66 3b c1	 cmp	 ax, cx
  00402	74 46		 je	 SHORT $LN123@CGItemDrop
  00404	ba 29 1c 00 00	 mov	 edx, 7209		; 00001c29H
  00409	66 3b c2	 cmp	 ax, dx
  0040c	74 3c		 je	 SHORT $LN123@CGItemDrop
  0040e	b9 2a 1c 00 00	 mov	 ecx, 7210		; 00001c2aH
  00413	66 3b c1	 cmp	 ax, cx
  00416	74 32		 je	 SHORT $LN123@CGItemDrop
  00418	ba 2b 1c 00 00	 mov	 edx, 7211		; 00001c2bH
  0041d	66 3b c2	 cmp	 ax, dx
  00420	74 28		 je	 SHORT $LN123@CGItemDrop
  00422	b9 2c 1c 00 00	 mov	 ecx, 7212		; 00001c2cH
  00427	66 3b c1	 cmp	 ax, cx
  0042a	74 1e		 je	 SHORT $LN123@CGItemDrop
  0042c	ba 29 18 00 00	 mov	 edx, 6185		; 00001829H
  00431	66 3b c2	 cmp	 ax, dx
  00434	74 14		 je	 SHORT $LN123@CGItemDrop
  00436	b9 2a 18 00 00	 mov	 ecx, 6186		; 0000182aH
  0043b	66 3b c1	 cmp	 ax, cx
  0043e	74 0a		 je	 SHORT $LN123@CGItemDrop
  00440	ba 2b 18 00 00	 mov	 edx, 6187		; 0000182bH
  00445	66 3b c2	 cmp	 ax, dx
  00448	75 0d		 jne	 SHORT $LN72@CGItemDrop
$LN123@CGItemDrop:
  0044a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gPkLimitFree@@3HA ; gPkLimitFree
$LN75@CGItemDrop:

; 4226 : 	{
; 4227 : 		if ( gPkLimitFree == FALSE )

  00450	85 d2		 test	 edx, edx
  00452	75 03		 jne	 SHORT $LN72@CGItemDrop

; 4228 : 		{
; 4229 : 			pResult.Result = false;

  00454	88 55 9f	 mov	 BYTE PTR _pResult$[ebp+3], dl
$LN72@CGItemDrop:

; 4230 : 		}
; 4231 : 	}
; 4232 : 
; 4233 : 	if ( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony(&lpObj->pInventory[lpMsg->Ipos]) == TRUE )

  00457	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  0045b	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00461	03 83 c0 11 00
	00		 add	 eax, DWORD PTR [ebx+4544]
  00467	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0046c	50		 push	 eax
  0046d	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  00472	83 f8 01	 cmp	 eax, 1
  00475	75 20		 jne	 SHORT $LN71@CGItemDrop

; 4234 : 	{
; 4235 : 		pResult.Result = false;

  00477	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 4236 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 43)), lpObj->m_Index, 1);

  0047b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0047d	50		 push	 eax
  0047e	51		 push	 ecx
  0047f	68 2b 0d 00 00	 push	 3371			; 00000d2bH
  00484	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00489	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0048e	50		 push	 eax
  0048f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00494	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN71@CGItemDrop:

; 4237 : 	}
; 4238 : 
; 4239 : 	if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonyOriginal(lpObj->pInventory[lpMsg->Ipos].m_Type) ||
; 4240 : 		 g_kJewelOfHarmonySystem.IsJewelOfHarmonyPurity(lpObj->pInventory[lpMsg->Ipos].m_Type)   ||
; 4241 : 		 g_kJewelOfHarmonySystem.IsJewelOfHarmonySmeltingItems(lpObj->pInventory[lpMsg->Ipos].m_Type) )

  00497	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  0049b	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  004a1	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  004a7	0f b7 4c 02 06	 movzx	 ecx, WORD PTR [edx+eax+6]
  004ac	51		 push	 ecx
  004ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  004b2	e8 00 00 00 00	 call	 ?IsJewelOfHarmonyOriginal@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonyOriginal
  004b7	85 c0		 test	 eax, eax
  004b9	75 48		 jne	 SHORT $LN69@CGItemDrop
  004bb	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  004bf	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  004c5	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  004cb	0f b7 4c 02 06	 movzx	 ecx, WORD PTR [edx+eax+6]
  004d0	51		 push	 ecx
  004d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  004d6	e8 00 00 00 00	 call	 ?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
  004db	85 c0		 test	 eax, eax
  004dd	75 24		 jne	 SHORT $LN69@CGItemDrop
  004df	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  004e3	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  004e9	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  004ef	0f b7 4c 02 06	 movzx	 ecx, WORD PTR [edx+eax+6]
  004f4	51		 push	 ecx
  004f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  004fa	e8 00 00 00 00	 call	 ?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
  004ff	85 c0		 test	 eax, eax
  00501	74 04		 je	 SHORT $LN70@CGItemDrop
$LN69@CGItemDrop:

; 4242 : 	{
; 4243 : 		pResult.Result = false;

  00503	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN70@CGItemDrop:

; 4244 : 	}
; 4245 : 
; 4246 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,39) )

  00507	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  0050b	8b 93 c0 11 00
	00		 mov	 edx, DWORD PTR [ebx+4544]
  00511	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00517	b9 27 1a 00 00	 mov	 ecx, 6695		; 00001a27H
  0051c	66 39 4c 10 06	 cmp	 WORD PTR [eax+edx+6], cx
  00521	75 04		 jne	 SHORT $LN68@CGItemDrop

; 4247 : 	{
; 4248 : 		pResult.Result = false;

  00523	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN68@CGItemDrop:

; 4249 : 	}
; 4250 : 
; 4251 : 	if ( IsCashItem(lpObj->pInventory[lpMsg->Ipos].m_Type) == TRUE )

  00527	8b 93 c0 11 00
	00		 mov	 edx, DWORD PTR [ebx+4544]
  0052d	0f bf 44 10 06	 movsx	 eax, WORD PTR [eax+edx+6]
  00532	50		 push	 eax
  00533	e8 00 00 00 00	 call	 ?IsCashItem@@YAHH@Z	; IsCashItem
  00538	83 c4 04	 add	 esp, 4
  0053b	83 f8 01	 cmp	 eax, 1
  0053e	75 04		 jne	 SHORT $LN67@CGItemDrop

; 4252 : 	{
; 4253 : 		pResult.Result = false;

  00540	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN67@CGItemDrop:

; 4254 : 	}
; 4255 : 
; 4256 : 	if ( IsCashSpecialItem(lpObj->pInventory[lpMsg->Ipos].m_Type) == TRUE )

  00544	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  00548	8b 93 c0 11 00
	00		 mov	 edx, DWORD PTR [ebx+4544]
  0054e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00554	0f bf 44 11 06	 movsx	 eax, WORD PTR [ecx+edx+6]
  00559	50		 push	 eax
  0055a	e8 00 00 00 00	 call	 ?IsCashSpecialItem@@YAHH@Z ; IsCashSpecialItem
  0055f	83 c4 04	 add	 esp, 4
  00562	83 f8 01	 cmp	 eax, 1
  00565	75 04		 jne	 SHORT $LN66@CGItemDrop

; 4257 : 	{
; 4258 : 		pResult.Result = false;

  00567	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN66@CGItemDrop:

; 4259 : 	}
; 4260 : 
; 4261 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_bLOCKED )

  0056b	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  0056f	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  00575	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0057b	80 bc 08 d1 00
	00 00 00	 cmp	 BYTE PTR [eax+ecx+209], 0
  00583	74 04		 je	 SHORT $LN65@CGItemDrop

; 4262 : 	{
; 4263 : 		pResult.Result = false;

  00585	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN65@CGItemDrop:

; 4264 : 	}
; 4265 : 
; 4266 : 	if ( g_ElementalSystem.IsElementalItem(lpObj->pInventory[lpMsg->Ipos].m_Type) )

  00589	8b 93 c0 11 00
	00		 mov	 edx, DWORD PTR [ebx+4544]
  0058f	0f bf 44 10 06	 movsx	 eax, WORD PTR [eax+edx+6]
  00594	50		 push	 eax
  00595	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  0059a	e8 00 00 00 00	 call	 ?IsElementalItem@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsElementalItem
  0059f	85 c0		 test	 eax, eax
  005a1	74 04		 je	 SHORT $LN124@CGItemDrop

; 4267 : 	{
; 4268 : 		pResult.Result = false;

  005a3	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN124@CGItemDrop:

; 4269 : 	}
; 4270 : 
; 4271 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_QuestItem != FALSE )

  005a7	0f b6 7e 05	 movzx	 edi, BYTE PTR [esi+5]
  005ab	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  005b1	03 bb c0 11 00
	00		 add	 edi, DWORD PTR [ebx+4544]
  005b7	80 bf a9 00 00
	00 00		 cmp	 BYTE PTR [edi+169], 0
  005be	74 16		 je	 SHORT $LN63@CGItemDrop

; 4272 : 	{
; 4273 : 		return 0xFF;

  005c0	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH

; 4606 : }

  005c5	5f		 pop	 edi
  005c6	5e		 pop	 esi
  005c7	5b		 pop	 ebx
  005c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005cb	33 cd		 xor	 ecx, ebp
  005cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d2	8b e5		 mov	 esp, ebp
  005d4	5d		 pop	 ebp
  005d5	c3		 ret	 0
$LN63@CGItemDrop:

; 4274 : 	}
; 4275 : 
; 4276 : #if (ENABLETEST_NEWPVP == 1)
; 4277 : 	// portal?
; 4278 : 	if (drop_type == 0 && lpObj->pInventory[lpMsg->Ipos].m_Type == (512 * 14) + 28 && g_NewPVP.IsDuel(*lpObj)) {

  005d6	83 7d 10 00	 cmp	 DWORD PTR _drop_type$[ebp], 0
  005da	75 1e		 jne	 SHORT $LN125@CGItemDrop
  005dc	b8 1c 1c 00 00	 mov	 eax, 7196		; 00001c1cH
  005e1	66 39 47 06	 cmp	 WORD PTR [edi+6], ax
  005e5	75 13		 jne	 SHORT $LN125@CGItemDrop
  005e7	53		 push	 ebx
  005e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  005ed	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  005f2	85 c0		 test	 eax, eax

; 4279 : 		pResult.Result = 0x00;
; 4280 : 	}
; 4281 : #endif
; 4282 : 
; 4283 : 	if ( pResult.Result == 1 )

  005f4	0f 85 12 02 00
	00		 jne	 $LN128@CGItemDrop
$LN125@CGItemDrop:
  005fa	80 7d 9f 01	 cmp	 BYTE PTR _pResult$[ebp+3], 1
  005fe	0f 85 0c 02 00
	00		 jne	 $LN6@CGItemDrop

; 4284 : 	{
; 4285 : 		::ItemIsBufExOption(NewOption, &lpObj->pInventory[lpMsg->Ipos]);

  00604	8d 4d f4	 lea	 ecx, DWORD PTR _NewOption$[ebp]
  00607	57		 push	 edi
  00608	51		 push	 ecx
  00609	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 4286 : 
; 4287 : 		int map = lpObj->MapNumber;
; 4288 : 		int type = lpObj->pInventory[lpMsg->Ipos].m_Type;

  0060e	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00612	0f b6 93 23 01
	00 00		 movzx	 edx, BYTE PTR [ebx+291]
  00619	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0061f	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  00625	0f bf 7c 01 06	 movsx	 edi, WORD PTR [ecx+eax+6]

; 4289 : 		int level = lpObj->pInventory[lpMsg->Ipos].m_Level;
; 4290 : 		float dur = lpObj->pInventory[lpMsg->Ipos].m_Durability;

  0062a	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  0062e	03 c8		 add	 ecx, eax
  00630	d9 9d 6c ff ff
	ff		 fstp	 DWORD PTR _dur$218643[ebp]
  00636	89 55 84	 mov	 DWORD PTR _map$218640[ebp], edx
  00639	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  0063d	83 c4 08	 add	 esp, 8
  00640	89 55 90	 mov	 DWORD PTR _level$218642[ebp], edx

; 4291 : 		BOOL bIsItem = lpObj->pInventory[lpMsg->Ipos].IsItem();

  00643	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00648	89 85 54 ff ff
	ff		 mov	 DWORD PTR _bIsItem$218644[ebp], eax

; 4292 : 		BYTE Option1 = lpObj->pInventory[lpMsg->Ipos].m_Option1;

  0064e	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00652	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00658	03 83 c0 11 00
	00		 add	 eax, DWORD PTR [ebx+4544]
  0065e	0f b6 90 90 00
	00 00		 movzx	 edx, BYTE PTR [eax+144]

; 4293 : 		BYTE Option2 = lpObj->pInventory[lpMsg->Ipos].m_Option2;

  00665	0f b6 88 91 00
	00 00		 movzx	 ecx, BYTE PTR [eax+145]
  0066c	88 95 74 ff ff
	ff		 mov	 BYTE PTR _Option1$218645[ebp], dl

; 4294 : 		BYTE Option3 = lpObj->pInventory[lpMsg->Ipos].m_Option3;

  00672	0f b6 90 92 00
	00 00		 movzx	 edx, BYTE PTR [eax+146]
  00679	88 8d 7c ff ff
	ff		 mov	 BYTE PTR _Option2$218646[ebp], cl

; 4295 : 		BYTE NOption = lpObj->pInventory[lpMsg->Ipos].m_NewOption;

  0067f	0f b6 88 93 00
	00 00		 movzx	 ecx, BYTE PTR [eax+147]
  00686	88 95 78 ff ff
	ff		 mov	 BYTE PTR _Option3$218647[ebp], dl

; 4296 : 		DWORD serial = lpObj->pInventory[lpMsg->Ipos].m_Number;

  0068c	8b 10		 mov	 edx, DWORD PTR [eax]
  0068e	88 8d 50 ff ff
	ff		 mov	 BYTE PTR _NOption$218648[ebp], cl

; 4297 : 		int PetLevel = lpObj->pInventory[lpMsg->Ipos].m_PetItem_Level;

  00694	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [eax+184]
  0069a	89 55 80	 mov	 DWORD PTR _serial$218649[ebp], edx

; 4298 : 		int PetExp = lpObj->pInventory[lpMsg->Ipos].m_PetItem_Exp;

  0069d	8b 90 bc 00 00
	00		 mov	 edx, DWORD PTR [eax+188]
  006a3	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _PetLevel$218650[ebp], ecx

; 4299 : 		BYTE SOption = lpObj->pInventory[lpMsg->Ipos].m_SetOption;

  006a9	0f b6 88 aa 00
	00 00		 movzx	 ecx, BYTE PTR [eax+170]
  006b0	89 95 40 ff ff
	ff		 mov	 DWORD PTR _PetExp$218651[ebp], edx

; 4300 : 		BYTE btItemEffectEx = lpObj->pInventory[lpMsg->Ipos].m_ItemOptionEx;

  006b6	0f b6 90 c6 00
	00 00		 movzx	 edx, BYTE PTR [eax+198]
  006bd	88 8d 68 ff ff
	ff		 mov	 BYTE PTR _SOption$218652[ebp], cl

; 4301 : 
; 4302 : 
; 4303 : 		BYTE SocketOptions[MAX_SOCKET_COUNT];
; 4304 : 		BYTE SocketBonus;
; 4305 : 		
; 4306 : 
; 4307 : 		g_SocketItem.GetItemOptions(&lpObj->pInventory[lpMsg->Ipos],&SocketOptions[0],&SocketBonus);

  006c3	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _SocketBonus$218655[ebp]
  006c9	51		 push	 ecx
  006ca	88 95 70 ff ff
	ff		 mov	 BYTE PTR _btItemEffectEx$218653[ebp], dl
  006d0	8d 55 ec	 lea	 edx, DWORD PTR _SocketOptions$218654[ebp]
  006d3	52		 push	 edx
  006d4	50		 push	 eax
  006d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketItem@@3VCSocketItems@@A ; g_SocketItem
  006da	e8 00 00 00 00	 call	 ?GetItemOptions@CSocketItems@@QAEXPAVCItem@@PAE1@Z ; CSocketItems::GetItemOptions

; 4308 : 
; 4309 : 		int serial2 = lpObj->pInventory[lpMsg->Ipos].m_Number;

  006df	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]

; 4310 : 		char szItemName[50] = "Item";

  006e3	0f b6 0d 04 00
	00 00		 movzx	 ecx, BYTE PTR ??_C@_04BGCMBJDA@Item?$AA@+4
  006ea	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  006f0	03 83 c0 11 00
	00		 add	 eax, DWORD PTR [ebx+4544]
  006f6	6a 2d		 push	 45			; 0000002dH
  006f8	8b 10		 mov	 edx, DWORD PTR [eax]
  006fa	89 95 5c ff ff
	ff		 mov	 DWORD PTR _serial2$218656[ebp], edx
  00700	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv1739[ebp], eax
  00706	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04BGCMBJDA@Item?$AA@
  0070b	8d 55 bd	 lea	 edx, DWORD PTR _szItemName$218657[ebp+5]
  0070e	6a 00		 push	 0
  00710	52		 push	 edx
  00711	89 45 b8	 mov	 DWORD PTR _szItemName$218657[ebp], eax
  00714	88 4d bc	 mov	 BYTE PTR _szItemName$218657[ebp+4], cl
  00717	e8 00 00 00 00	 call	 _memset

; 4311 : 		BYTE JOHOption = g_kJewelOfHarmonySystem.GetItemStrengthenOption(&lpObj->pInventory[lpMsg->Ipos]);

  0071c	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv1739[ebp]
  00722	83 c4 0c	 add	 esp, 12			; 0000000cH
  00725	50		 push	 eax
  00726	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0072b	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption

; 4312 : 		BYTE JOHOptionLevel = g_kJewelOfHarmonySystem.GetItemOptionLevel(&lpObj->pInventory[lpMsg->Ipos]);

  00730	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  00734	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0073a	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  00740	88 45 8f	 mov	 BYTE PTR _JOHOption$218659[ebp], al
  00743	51		 push	 ecx
  00744	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00749	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel

; 4313 : 
; 4314 : 		if ( gObjCheckSerial0ItemList(&lpObj->pInventory[lpMsg->Ipos]) != FALSE )

  0074e	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  00752	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00758	03 93 c0 11 00
	00		 add	 edx, DWORD PTR [ebx+4544]
  0075e	88 45 97	 mov	 BYTE PTR _JOHOptionLevel$218660[ebp], al
  00761	52		 push	 edx
  00762	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00767	83 c4 04	 add	 esp, 4
  0076a	85 c0		 test	 eax, eax
  0076c	74 60		 je	 SHORT $LN60@CGItemDrop

; 4315 : 		{
; 4316 : 			MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(13, 26)));

  0076e	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  00773	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00778	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0077d	50		 push	 eax
  0077e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00780	50		 push	 eax
  00781	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 4317 : 			LogAddTD("[ANTI-HACK][Serial 0 Item] [ItemDrop] (%s)(%s) Item(%s) Pos(%d)",
; 4318 : 				lpObj->AccountID, lpObj->Name, lpObj->pInventory[lpMsg->Ipos].GetName(),
; 4319 : 				lpMsg->Ipos);

  00786	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  0078a	83 c4 08	 add	 esp, 8
  0078d	51		 push	 ecx
  0078e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00794	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  0079a	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0079f	50		 push	 eax
  007a0	8d 4b 5d	 lea	 ecx, DWORD PTR [ebx+93]
  007a3	51		 push	 ecx
  007a4	8d 53 52	 lea	 edx, DWORD PTR [ebx+82]
  007a7	52		 push	 edx
  007a8	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@
  007ad	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  007b3	83 c4 14	 add	 esp, 20			; 00000014H

; 4320 : 
; 4321 : 			CopyItem = TRUE;

  007b6	c7 85 64 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _CopyItem$[ebp], 1

; 4322 : 			pResult.Result = false;

  007c0	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 4323 : 			bIsItem = FALSE;

  007c4	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _bIsItem$218644[ebp], 0
$LN60@CGItemDrop:

; 4324 : 		}
; 4325 : 
; 4326 : 		
; 4327 : 		if ( !::gObjInventorySearchSerialNumber(lpObj, serial2))	// ANTI DUPE SYSTEM

  007ce	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _serial2$218656[ebp]
  007d4	50		 push	 eax
  007d5	53		 push	 ebx
  007d6	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  007db	83 c4 08	 add	 esp, 8
  007de	85 c0		 test	 eax, eax
  007e0	0f 85 2f 01 00
	00		 jne	 $LN59@CGItemDrop

; 4328 : 		{
; 4329 : 			CopyItem = TRUE;

  007e6	c7 85 64 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _CopyItem$[ebp], 1

; 4330 : 			pResult.Result = false;

  007f0	88 45 9f	 mov	 BYTE PTR _pResult$[ebp+3], al
$LN58@CGItemDrop:

; 4568 : 		{
; 4569 : 			LogAdd(lMsg.Get(MSGGET(1, 225)));

  007f3	68 e1 01 00 00	 push	 481			; 000001e1H
  007f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  007fd	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00802	50		 push	 eax
  00803	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00809	83 c4 04	 add	 esp, 4
$LN128@CGItemDrop:

; 4570 : 			pResult.Result = false;

  0080c	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN6@CGItemDrop:

; 4571 : 		}
; 4572 : 	}
; 4573 : 
; 4574 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00810	0f b6 4d 9d	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00814	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00817	51		 push	 ecx
  00818	8d 55 9c	 lea	 edx, DWORD PTR _pResult$[ebp]
  0081b	52		 push	 edx
  0081c	50		 push	 eax
  0081d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00822	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4575 : 
; 4576 : 	if ( CopyItem != FALSE )

  00825	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _CopyItem$[ebp], 0
  0082c	74 0c		 je	 SHORT $LN5@CGItemDrop

; 4577 : 		::GCItemListSend(aIndex);

  0082e	8b 4d 98	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00831	51		 push	 ecx
  00832	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  00837	83 c4 04	 add	 esp, 4
$LN5@CGItemDrop:

; 4578 : 
; 4579 : 	if ( pResult.Result == 1 )

  0083a	80 7d 9f 01	 cmp	 BYTE PTR _pResult$[ebp+3], 1
  0083e	0f 85 bc 00 00
	00		 jne	 $LN3@CGItemDrop

; 4580 : 	{
; 4581 : 		if ( lpMsg->Ipos < 12 )

  00844	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00847	3c 0c		 cmp	 al, 12			; 0000000cH
  00849	0f 83 b1 00 00
	00		 jae	 $LN3@CGItemDrop

; 4582 : 		{
; 4583 : 			if ( lpMsg->Ipos == 10 || lpMsg->Ipos == 11 )

  0084f	3c 0a		 cmp	 al, 10			; 0000000aH
  00851	74 04		 je	 SHORT $LN1@CGItemDrop
  00853	3c 0b		 cmp	 al, 11			; 0000000bH
  00855	75 0e		 jne	 SHORT $LN2@CGItemDrop
$LN1@CGItemDrop:

; 4584 : 			{
; 4585 : 				gObjUseSkill.SkillChangeUse(aIndex);

  00857	8b 55 98	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0085a	52		 push	 edx
  0085b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00860	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN2@CGItemDrop:

; 4586 : 			}
; 4587 : 
; 4588 : 
; 4589 : 			::gObjMakePreviewCharSet(aIndex);

  00865	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00868	50		 push	 eax
  00869	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 4590 : 
; 4591 : 			PMSG_USEREQUIPMENTCHANGED pChange;
; 4592 : 
; 4593 : 			PHeadSetB((LPBYTE)&pChange, 0x25, sizeof(pChange));

  0086e	6a 11		 push	 17			; 00000011H
  00870	8d 4d a4	 lea	 ecx, DWORD PTR _pChange$218756[ebp]
  00873	6a 25		 push	 37			; 00000025H
  00875	51		 push	 ecx
  00876	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 4594 : 			pChange.NumberH = SET_NUMBERH(aIndex);

  0087b	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0087e	8b d0		 mov	 edx, eax

; 4595 : 			pChange.NumberL = SET_NUMBERL(aIndex);

  00880	88 45 a8	 mov	 BYTE PTR _pChange$218756[ebp+4], al

; 4596 : 			ItemByteConvert(pChange.ItemInfo, lpObj->pInventory[lpMsg->Ipos]);

  00883	8b c6		 mov	 eax, esi
  00885	0f b6 70 05	 movzx	 esi, BYTE PTR [eax+5]
  00889	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  0088f	03 b3 c0 11 00
	00		 add	 esi, DWORD PTR [ebx+4544]
  00895	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  0089b	c1 ea 08	 shr	 edx, 8
  0089e	8b fc		 mov	 edi, esp
  008a0	88 55 a7	 mov	 BYTE PTR _pChange$218756[ebp+3], dl
  008a3	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  008a8	f3 a5		 rep movsd
  008aa	8d 4d a9	 lea	 ecx, DWORD PTR _pChange$218756[ebp+5]
  008ad	51		 push	 ecx
  008ae	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 4597 : 			pChange.ItemInfo[I_OPTION] = lpMsg->Ipos <<  4;

  008b3	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  008b9	8a 42 05	 mov	 al, BYTE PTR [edx+5]

; 4598 : 			pChange.ItemInfo[I_OPTION] |= LevelSmallConvert(aIndex, lpMsg->Ipos) & 0x0F;

  008bc	0f b6 d0	 movzx	 edx, al
  008bf	8a c8		 mov	 cl, al
  008c1	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  008c4	52		 push	 edx
  008c5	c0 e1 04	 shl	 cl, 4
  008c8	50		 push	 eax
  008c9	88 4d aa	 mov	 BYTE PTR _pChange$218756[ebp+6], cl
  008cc	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert

; 4599 : 
; 4600 : 			DataSend(aIndex, (LPBYTE)&pChange, pChange.h.size);

  008d1	0f b6 4d a5	 movzx	 ecx, BYTE PTR _pChange$218756[ebp+1]
  008d5	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  008db	24 0f		 and	 al, 15			; 0000000fH
  008dd	08 45 aa	 or	 BYTE PTR _pChange$218756[ebp+6], al
  008e0	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  008e3	51		 push	 ecx
  008e4	8d 55 a4	 lea	 edx, DWORD PTR _pChange$218756[ebp]
  008e7	52		 push	 edx
  008e8	50		 push	 eax
  008e9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4601 : 			MsgSendV2(lpObj, (LPBYTE)&pChange, pChange.h.size);

  008ee	0f b6 4d a5	 movzx	 ecx, BYTE PTR _pChange$218756[ebp+1]
  008f2	51		 push	 ecx
  008f3	8d 55 a4	 lea	 edx, DWORD PTR _pChange$218756[ebp]
  008f6	52		 push	 edx
  008f7	53		 push	 ebx
  008f8	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  008fd	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@CGItemDrop:

; 4602 : 		}
; 4603 : 	}
; 4604 : 
; 4605 : 	return pResult.Result;

  00900	0f b6 45 9f	 movzx	 eax, BYTE PTR _pResult$[ebp+3]

; 4606 : }

  00904	5f		 pop	 edi
  00905	5e		 pop	 esi
  00906	5b		 pop	 ebx
  00907	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0090a	33 cd		 xor	 ecx, ebp
  0090c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00911	8b e5		 mov	 esp, ebp
  00913	5d		 pop	 ebp
  00914	c3		 ret	 0
$LN59@CGItemDrop:

; 4331 : 			bIsItem = FALSE;
; 4332 : 		}
; 4333 : 
; 4334 : 		if ( bIsItem == TRUE )

  00915	83 bd 54 ff ff
	ff 01		 cmp	 DWORD PTR _bIsItem$218644[ebp], 1
  0091c	0f 85 d1 fe ff
	ff		 jne	 $LN58@CGItemDrop

; 4335 : 		{
; 4336 : 			strcpy(szItemName, lpObj->pInventory[lpMsg->Ipos].GetName());

  00922	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  00926	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0092c	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  00932	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00937	8d 55 b8	 lea	 edx, DWORD PTR _szItemName$218657[ebp]
  0093a	2b d0		 sub	 edx, eax
  0093c	8d 64 24 00	 npad	 4
$LL116@CGItemDrop:
  00940	8a 08		 mov	 cl, BYTE PTR [eax]
  00942	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00945	40		 inc	 eax
  00946	84 c9		 test	 cl, cl
  00948	75 f6		 jne	 SHORT $LL116@CGItemDrop

; 4337 : 			
; 4338 : 			BYTE EventItemBagState = g_EventItemBagManager.OpenBox(aIndex, type, level);

  0094a	8b 4d 90	 mov	 ecx, DWORD PTR _level$218642[ebp]
  0094d	8b 55 98	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00950	51		 push	 ecx
  00951	57		 push	 edi
  00952	52		 push	 edx
  00953	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  00958	e8 00 00 00 00	 call	 ?OpenBox@EventItemBagManager@@QAEEHHE@Z ; EventItemBagManager::OpenBox

; 4339 : 
; 4340 : 			if( EventItemBagState == 1 )

  0095d	3c 01		 cmp	 al, 1
  0095f	75 1a		 jne	 SHORT $LN57@CGItemDrop

; 4341 : 			{
; 4342 : 				::gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00961	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00965	8b 4d 98	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00968	50		 push	 eax
  00969	51		 push	 ecx
  0096a	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  0096f	83 c4 08	 add	 esp, 8

; 4343 : 				pResult.Result = true;

  00972	c6 45 9f 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00976	e9 95 fe ff ff	 jmp	 $LN6@CGItemDrop
$LN57@CGItemDrop:

; 4344 : 			}
; 4345 : 			else if( EventItemBagState == 0 )

  0097b	84 c0		 test	 al, al
  0097d	75 2b		 jne	 SHORT $LN55@CGItemDrop

; 4346 : 			{
; 4347 : 				pResult.Result = false;
; 4348 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0097f	0f b6 55 9d	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00983	8b 4d 98	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00986	88 45 9f	 mov	 BYTE PTR _pResult$[ebp+3], al
  00989	52		 push	 edx
  0098a	8d 45 9c	 lea	 eax, DWORD PTR _pResult$[ebp]
  0098d	50		 push	 eax
  0098e	51		 push	 ecx
  0098f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00994	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4349 : 				return FALSE;

  00997	33 c0		 xor	 eax, eax

; 4606 : }

  00999	5f		 pop	 edi
  0099a	5e		 pop	 esi
  0099b	5b		 pop	 ebx
  0099c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0099f	33 cd		 xor	 ecx, ebp
  009a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009a6	8b e5		 mov	 esp, ebp
  009a8	5d		 pop	 ebp
  009a9	c3		 ret	 0
$LN55@CGItemDrop:

; 4350 : 			}
; 4351 : 			else if( type == ITEMGET(14,51) || type == ITEMGET(14,63) || type == ITEMGET(14,99) )

  009aa	81 ff 33 1c 00
	00		 cmp	 edi, 7219		; 00001c33H
  009b0	0f 84 2d 06 00
	00		 je	 $LN52@CGItemDrop
  009b6	81 ff 3f 1c 00
	00		 cmp	 edi, 7231		; 00001c3fH
  009bc	0f 84 21 06 00
	00		 je	 $LN52@CGItemDrop
  009c2	81 ff 63 1c 00
	00		 cmp	 edi, 7267		; 00001c63H
  009c8	0f 84 15 06 00
	00		 je	 $LN52@CGItemDrop

; 4364 : 			}
; 4365 : 			else if ( type == ITEMGET(12,26) )

  009ce	81 ff 1a 18 00
	00		 cmp	 edi, 6170		; 0000181aH
  009d4	0f 85 aa 01 00
	00		 jne	 $LN50@CGItemDrop

; 4366 : 			{
; 4367 : 				switch ( level )

  009da	83 7d 90 05	 cmp	 DWORD PTR _level$218642[ebp], 5
  009de	0f 87 2c fe ff
	ff		 ja	 $LN6@CGItemDrop
  009e4	8b 55 90	 mov	 edx, DWORD PTR _level$218642[ebp]
  009e7	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN130@CGItemDrop[edx*4]
$LN47@CGItemDrop:

; 4368 : 				{
; 4369 : 					case 0:
; 4370 : 						{
; 4371 : 							gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  009ee	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  009f2	8b 4d 98	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  009f5	50		 push	 eax
  009f6	51		 push	 ecx
  009f7	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  009fc	83 c4 08	 add	 esp, 8

; 4372 : 							pResult.Result = true;

  009ff	c6 45 9f 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 4373 : 							int ltype = ITEMGET(12,26);
; 4374 : 							int randor = rand()%100;

  00a03	e8 00 00 00 00	 call	 _rand
  00a08	99		 cdq
  00a09	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00a0e	f7 f9		 idiv	 ecx

; 4375 : 							int Level;
; 4376 : 
; 4377 : 							if ( randor < 10 )

  00a10	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00a13	7d 05		 jge	 SHORT $LN46@CGItemDrop

; 4378 : 							{
; 4379 : 								Level = 3;

  00a15	8d 79 9f	 lea	 edi, DWORD PTR [ecx-97]
  00a18	eb 0b		 jmp	 SHORT $LN44@CGItemDrop
$LN46@CGItemDrop:

; 4380 : 							}
; 4381 : 							else if ( randor < 45 )

  00a1a	33 c0		 xor	 eax, eax
  00a1c	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  00a1f	0f 9d c0	 setge	 al
  00a22	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$LN44@CGItemDrop:

; 4382 : 							{
; 4383 : 								Level = 1;
; 4384 : 							}
; 4385 : 							else
; 4386 : 							{
; 4387 : 								Level = 2;
; 4388 : 							}
; 4389 : 
; 4390 : 							ItemSerialCreateSend(aIndex, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 4391 : 								ltype, Level, 1, 0, 0, 0, lpObj->m_Index, 0, 0);

  00a25	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00a27	0f b6 93 21 01
	00 00		 movzx	 edx, BYTE PTR [ebx+289]
  00a2e	6a 00		 push	 0
  00a30	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00a37	6a 00		 push	 0
  00a39	6a 00		 push	 0
  00a3b	6a 00		 push	 0
  00a3d	51		 push	 ecx
  00a3e	0f b6 8b 23 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+291]
  00a45	6a 00		 push	 0
  00a47	6a 00		 push	 0
  00a49	6a 00		 push	 0
  00a4b	6a 01		 push	 1
  00a4d	57		 push	 edi
  00a4e	68 1a 18 00 00	 push	 6170			; 0000181aH
  00a53	52		 push	 edx
  00a54	8b 55 98	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00a57	50		 push	 eax
  00a58	51		 push	 ecx
  00a59	52		 push	 edx
  00a5a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 4392 : 							
; 4393 : 							LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Mysterious Bead : Drop (%d) - serial:%d",
; 4394 : 								lpObj->AccountID, lpObj->Name, Level, serial);

  00a5f	8b 45 80	 mov	 eax, DWORD PTR _serial$218649[ebp]
  00a62	50		 push	 eax
  00a63	57		 push	 edi
  00a64	8d 4b 5d	 lea	 ecx, DWORD PTR [ebx+93]
  00a67	51		 push	 ecx
  00a68	8d 53 52	 lea	 edx, DWORD PTR [ebx+82]
  00a6b	52		 push	 edx
  00a6c	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@GOMPGJDH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  00a71	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00a77	83 c4 50	 add	 esp, 80			; 00000050H

; 4395 : 						}
; 4396 : 						break;

  00a7a	e9 91 fd ff ff	 jmp	 $LN6@CGItemDrop
$LN42@CGItemDrop:

; 4397 : 					case 1: case 2: case 3:
; 4398 : 						{
; 4399 : 							gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00a7f	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00a83	8b 4d 98	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00a86	50		 push	 eax
  00a87	51		 push	 ecx
  00a88	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 4400 : 							pResult.Result = true;
; 4401 : 
; 4402 : 							PMSG_SERVERCMD ServerCmd;
; 4403 : 
; 4404 : 							PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  00a8d	6a 07		 push	 7
  00a8f	6a 40		 push	 64			; 00000040H
  00a91	8d 55 84	 lea	 edx, DWORD PTR _ServerCmd$218694[ebp]
  00a94	68 f3 00 00 00	 push	 243			; 000000f3H
  00a99	52		 push	 edx
  00a9a	c6 45 9f 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00a9e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 4405 : 							ServerCmd.CmdType = 0;
; 4406 : 							ServerCmd.X = lpObj->X;

  00aa3	8a 83 20 01 00
	00		 mov	 al, BYTE PTR [ebx+288]

; 4407 : 							ServerCmd.Y = lpObj->Y;

  00aa9	8a 8b 21 01 00
	00		 mov	 cl, BYTE PTR [ebx+289]

; 4408 : 
; 4409 : 							MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00aaf	6a 07		 push	 7
  00ab1	8d 55 84	 lea	 edx, DWORD PTR _ServerCmd$218694[ebp]
  00ab4	52		 push	 edx
  00ab5	53		 push	 ebx
  00ab6	c6 45 88 00	 mov	 BYTE PTR _ServerCmd$218694[ebp+4], 0
  00aba	88 45 89	 mov	 BYTE PTR _ServerCmd$218694[ebp+5], al
  00abd	88 4d 8a	 mov	 BYTE PTR _ServerCmd$218694[ebp+6], cl
  00ac0	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 4410 : 							DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00ac5	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00ac7	6a 07		 push	 7
  00ac9	8d 45 84	 lea	 eax, DWORD PTR _ServerCmd$218694[ebp]
  00acc	50		 push	 eax
  00acd	51		 push	 ecx
  00ace	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4411 : 													
; 4412 : 							LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Crystal (%d) - serial:%d",
; 4413 : 								lpObj->AccountID, lpObj->Name, level, serial);

  00ad3	8b 55 80	 mov	 edx, DWORD PTR _serial$218649[ebp]
  00ad6	8b 45 90	 mov	 eax, DWORD PTR _level$218642[ebp]
  00ad9	52		 push	 edx
  00ada	50		 push	 eax
  00adb	8d 4b 5d	 lea	 ecx, DWORD PTR [ebx+93]
  00ade	51		 push	 ecx
  00adf	8d 53 52	 lea	 edx, DWORD PTR [ebx+82]
  00ae2	52		 push	 edx
  00ae3	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@PDKMNGPH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  00ae8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00aee	83 c4 44	 add	 esp, 68			; 00000044H

; 4414 : 						}
; 4415 : 						break;

  00af1	e9 1a fd ff ff	 jmp	 $LN6@CGItemDrop
$LN41@CGItemDrop:

; 4416 : 					case 5:
; 4417 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Surprise Treasure Box - serial:%d",
; 4418 : 							lpObj->AccountID, lpObj->Name,  serial);

  00af6	8b 4d 80	 mov	 ecx, DWORD PTR _serial$218649[ebp]
  00af9	51		 push	 ecx
  00afa	8d 7b 5d	 lea	 edi, DWORD PTR [ebx+93]
  00afd	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00b00	57		 push	 edi
  00b01	50		 push	 eax
  00b02	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@LPMBPPDG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  00b07	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4419 : 						gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00b0d	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  00b11	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00b14	52		 push	 edx
  00b15	50		 push	 eax
  00b16	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 4420 : 						pResult.Result = true;

  00b1b	c6 45 9f 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 4421 : 
; 4422 : 						int money = 1000000;
; 4423 : 						MapC[lpObj->MapNumber].MoneyItemDrop(money, lpObj->X, lpObj->Y);

  00b1f	0f b6 8b 21 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+289]
  00b26	0f b6 93 20 01
	00 00		 movzx	 edx, BYTE PTR [ebx+288]
  00b2d	83 c4 18	 add	 esp, 24			; 00000018H
  00b30	51		 push	 ecx
  00b31	0f b6 8b 23 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+291]
  00b38	69 c9 28 38 05
	00		 imul	 ecx, 342056		; 00053828H
  00b3e	52		 push	 edx
  00b3f	68 40 42 0f 00	 push	 1000000			; 000f4240H
  00b44	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00b4a	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop

; 4424 : 							
; 4425 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Event ZenDrop : %d : (%d)(%d/%d)",
; 4426 : 							lpObj->AccountID, lpObj->Name, money, lpObj->MapNumber, lpObj->X, lpObj->Y);

  00b4f	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  00b56	0f b6 8b 20 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+288]
  00b5d	0f b6 93 23 01
	00 00		 movzx	 edx, BYTE PTR [ebx+291]
  00b64	50		 push	 eax
  00b65	51		 push	 ecx
  00b66	52		 push	 edx
  00b67	68 40 42 0f 00	 push	 1000000			; 000f4240H
  00b6c	57		 push	 edi
  00b6d	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00b70	50		 push	 eax
  00b71	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  00b76	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00b7c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4427 : 						break;
; 4428 : 				}
; 4429 : 			}
; 4430 : 			else if ( type == ITEMGET(14,28) ) // Lost Map

  00b7f	e9 8c fc ff ff	 jmp	 $LN6@CGItemDrop
$LN50@CGItemDrop:
  00b84	81 ff 1c 1c 00
	00		 cmp	 edi, 7196		; 00001c1cH
  00b8a	0f 85 97 00 00
	00		 jne	 $LN39@CGItemDrop

; 4431 : 			{
; 4432 : 				if ( g_KalimaGate.CreateKalimaGate(aIndex, level, lpMsg->px, lpMsg->py))

  00b90	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00b94	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  00b98	8b 55 90	 mov	 edx, DWORD PTR _level$218642[ebp]
  00b9b	50		 push	 eax
  00b9c	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00b9f	51		 push	 ecx
  00ba0	52		 push	 edx
  00ba1	50		 push	 eax
  00ba2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  00ba7	e8 00 00 00 00	 call	 ?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z ; CKalimaGate::CreateKalimaGate
  00bac	85 c0		 test	 eax, eax
  00bae	74 4b		 je	 SHORT $LN38@CGItemDrop

; 4433 : 				{
; 4434 : 					LogAddTD("[Kalima] [%s][%s] Success to Make Kalima Gate (Lost Kalima Map Serial:%d)",
; 4435 : 						gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pInventory[lpMsg->Ipos].m_Number);

  00bb0	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  00bb4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bb9	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00bbf	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv1696[ebp]
  00bc5	8b bc 01 c0 11
	00 00		 mov	 edi, DWORD PTR [ecx+eax+4544]
  00bcc	8b 14 3a	 mov	 edx, DWORD PTR [edx+edi]
  00bcf	52		 push	 edx
  00bd0	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  00bd4	52		 push	 edx
  00bd5	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  00bd9	50		 push	 eax
  00bda	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@
  00bdf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4436 : 
; 4437 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00be5	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  00be9	8b 55 98	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00bec	51		 push	 ecx
  00bed	52		 push	 edx
  00bee	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00bf3	83 c4 18	 add	 esp, 24			; 00000018H

; 4445 : 				}

  00bf6	e9 15 fc ff ff	 jmp	 $LN6@CGItemDrop
$LN38@CGItemDrop:

; 4438 : 				}
; 4439 : 				else
; 4440 : 				{
; 4441 : 					pResult.Result = false;
; 4442 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00bfb	0f b6 45 9d	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00bff	8b 55 98	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00c02	50		 push	 eax
  00c03	8d 4d 9c	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00c06	51		 push	 ecx
  00c07	52		 push	 edx
  00c08	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  00c0c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00c11	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4443 : 
; 4444 : 					return FALSE;

  00c14	33 c0		 xor	 eax, eax

; 4606 : }

  00c16	5f		 pop	 edi
  00c17	5e		 pop	 esi
  00c18	5b		 pop	 ebx
  00c19	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c1c	33 cd		 xor	 ecx, ebp
  00c1e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c23	8b e5		 mov	 esp, ebp
  00c25	5d		 pop	 ebp
  00c26	c3		 ret	 0
$LN39@CGItemDrop:

; 4446 : 			}
; 4447 : 			else if ( type == ITEMGET(13,7) ) // Contract (Summon)

  00c27	81 ff 07 1a 00
	00		 cmp	 edi, 6663		; 00001a07H
  00c2d	75 76		 jne	 SHORT $LN35@CGItemDrop

; 4448 : 			{
; 4449 : 				int iMonsterID = 0;
; 4450 : 
; 4451 : 				if ( level == 0 )

  00c2f	8b 4d 90	 mov	 ecx, DWORD PTR _level$218642[ebp]
  00c32	33 c0		 xor	 eax, eax
  00c34	85 c9		 test	 ecx, ecx
  00c36	75 07		 jne	 SHORT $LN34@CGItemDrop

; 4452 : 					iMonsterID = 286;

  00c38	b8 1e 01 00 00	 mov	 eax, 286		; 0000011eH
  00c3d	eb 0a		 jmp	 SHORT $LN32@CGItemDrop
$LN34@CGItemDrop:

; 4453 : 				else if ( level == 1 )

  00c3f	83 f9 01	 cmp	 ecx, 1
  00c42	75 05		 jne	 SHORT $LN32@CGItemDrop

; 4454 : 					iMonsterID = 287;

  00c44	b8 1f 01 00 00	 mov	 eax, 287		; 0000011fH
$LN32@CGItemDrop:

; 4455 : 
; 4456 : 
; 4457 : 				if ( g_CsNPC_Mercenary.CreateMercenary(aIndex, iMonsterID, lpMsg->px, lpMsg->py) )

  00c49	0f b6 4e 04	 movzx	 ecx, BYTE PTR [esi+4]
  00c4d	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  00c51	51		 push	 ecx
  00c52	52		 push	 edx
  00c53	50		 push	 eax
  00c54	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00c57	50		 push	 eax
  00c58	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Mercenary@@3VCMercenary@@A ; g_CsNPC_Mercenary
  00c5d	e8 00 00 00 00	 call	 ?CreateMercenary@CMercenary@@QAEHHHEE@Z ; CMercenary::CreateMercenary

; 4458 : 				{
; 4459 : 					::gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00c62	8b 55 98	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00c65	85 c0		 test	 eax, eax
  00c67	74 13		 je	 SHORT $LN31@CGItemDrop
  00c69	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  00c6d	51		 push	 ecx
  00c6e	52		 push	 edx
  00c6f	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00c74	83 c4 08	 add	 esp, 8

; 4467 : 				}

  00c77	e9 94 fb ff ff	 jmp	 $LN6@CGItemDrop
$LN31@CGItemDrop:

; 4460 : 				}
; 4461 : 				else
; 4462 : 				{
; 4463 : 					pResult.Result = false;
; 4464 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00c7c	0f b6 45 9d	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00c80	50		 push	 eax
  00c81	8d 4d 9c	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00c84	51		 push	 ecx
  00c85	52		 push	 edx
  00c86	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  00c8a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00c8f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4465 : 
; 4466 : 					return FALSE;

  00c92	33 c0		 xor	 eax, eax

; 4606 : }

  00c94	5f		 pop	 edi
  00c95	5e		 pop	 esi
  00c96	5b		 pop	 ebx
  00c97	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c9a	33 cd		 xor	 ecx, ebp
  00c9c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ca1	8b e5		 mov	 esp, ebp
  00ca3	5d		 pop	 ebp
  00ca4	c3		 ret	 0
$LN35@CGItemDrop:

; 4468 : 			}
; 4469 : 			else if ( type == ITEMGET(13,11) ) // Guardian / LifeStone

  00ca5	81 ff 0b 1a 00
	00		 cmp	 edi, 6667		; 00001a0bH
  00cab	75 71		 jne	 SHORT $LN28@CGItemDrop

; 4470 : 			{
; 4471 : 				BOOL bResult = FALSE;
; 4472 : 
; 4473 : 				if ( level == 0 )

  00cad	8b 45 90	 mov	 eax, DWORD PTR _level$218642[ebp]
  00cb0	85 c0		 test	 eax, eax
  00cb2	75 10		 jne	 SHORT $LN27@CGItemDrop

; 4474 : 					bResult = g_CsNPC_Guardian.CreateGuardian(aIndex);

  00cb4	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00cb7	50		 push	 eax
  00cb8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Guardian@@3VCGuardian@@A ; g_CsNPC_Guardian
  00cbd	e8 00 00 00 00	 call	 ?CreateGuardian@CGuardian@@QAEHH@Z ; CGuardian::CreateGuardian
  00cc2	eb 13		 jmp	 SHORT $LN25@CGItemDrop
$LN27@CGItemDrop:

; 4475 : #if (GS_CASTLE == 1)
; 4476 : 				else if(level == 1)

  00cc4	83 f8 01	 cmp	 eax, 1
  00cc7	75 29		 jne	 SHORT $LN24@CGItemDrop

; 4477 : 					bResult = g_CsNPC_LifeStone.CreateLifeStone(aIndex);

  00cc9	8b 4d 98	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00ccc	51		 push	 ecx
  00ccd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_LifeStone@@3VCLifeStone@@A ; g_CsNPC_LifeStone
  00cd2	e8 00 00 00 00	 call	 ?CreateLifeStone@CLifeStone@@QAEHH@Z ; CLifeStone::CreateLifeStone
$LN25@CGItemDrop:

; 4478 : #endif
; 4479 : 
; 4480 : 				if ( bResult == TRUE )

  00cd7	83 f8 01	 cmp	 eax, 1
  00cda	75 16		 jne	 SHORT $LN24@CGItemDrop

; 4481 : 					::gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00cdc	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  00ce0	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00ce3	52		 push	 edx
  00ce4	50		 push	 eax
  00ce5	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00cea	83 c4 08	 add	 esp, 8

; 4486 : 
; 4487 : 					return FALSE;
; 4488 : 				}

  00ced	e9 1e fb ff ff	 jmp	 $LN6@CGItemDrop
$LN24@CGItemDrop:

; 4482 : 				else
; 4483 : 				{
; 4484 : 					pResult.Result = false;
; 4485 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00cf2	0f b6 4d 9d	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00cf6	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00cf9	51		 push	 ecx
  00cfa	8d 55 9c	 lea	 edx, DWORD PTR _pResult$[ebp]
  00cfd	52		 push	 edx
  00cfe	50		 push	 eax
  00cff	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  00d03	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4606 : }

  00d08	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d0b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d0e	5f		 pop	 edi
  00d0f	5e		 pop	 esi
  00d10	33 cd		 xor	 ecx, ebp
  00d12	33 c0		 xor	 eax, eax
  00d14	5b		 pop	 ebx
  00d15	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d1a	8b e5		 mov	 esp, ebp
  00d1c	5d		 pop	 ebp
  00d1d	c3		 ret	 0
$LN28@CGItemDrop:

; 4489 : 			}
; 4490 : 			else if( g_SnakeBegins.IsScroll(type) )

  00d1e	8d 8f 2e e3 ff
	ff		 lea	 ecx, DWORD PTR [edi-7378]

; 4491 : 			{
; 4492 : 				if( g_SnakeBegins.DropScroll(lpObj, type) )

  00d24	57		 push	 edi
  00d25	66 83 f9 03	 cmp	 cx, 3
  00d29	77 5e		 ja	 SHORT $LN21@CGItemDrop
  00d2b	53		 push	 ebx
  00d2c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SnakeBegins@@3VSnakeBegins@@A ; g_SnakeBegins
  00d31	e8 00 00 00 00	 call	 ?DropScroll@SnakeBegins@@QAE_NPAUOBJECTSTRUCT@@G@Z ; SnakeBegins::DropScroll
  00d36	84 c0		 test	 al, al
  00d38	0f 84 bd fe ff
	ff		 je	 $LN38@CGItemDrop

; 4493 : 				{
; 4494 : 					LogAddTD("[SnakeBegins] [%s][%s] Success to create Snake",
; 4495 : 						gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pInventory[lpMsg->Ipos].m_Number);

  00d3e	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  00d42	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d47	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00d4d	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv1696[ebp]
  00d53	8b bc 01 c0 11
	00 00		 mov	 edi, DWORD PTR [ecx+eax+4544]
  00d5a	8b 14 3a	 mov	 edx, DWORD PTR [edx+edi]
  00d5d	52		 push	 edx
  00d5e	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  00d62	52		 push	 edx
  00d63	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  00d67	50		 push	 eax
  00d68	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@KAEBPCMA@?$FLSnakeBegins?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5t@
  00d6d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4496 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00d73	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  00d77	8b 55 98	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00d7a	51		 push	 ecx
  00d7b	52		 push	 edx
  00d7c	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00d81	83 c4 18	 add	 esp, 24			; 00000018H

; 4497 : 				}
; 4498 : 				else
; 4499 : 				{
; 4500 : 					pResult.Result = false;
; 4501 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4502 : 					return false;
; 4503 : 				}

  00d84	e9 87 fa ff ff	 jmp	 $LN6@CGItemDrop
$LN21@CGItemDrop:

; 4504 : 			}
; 4505 : #if (ENABLE_CUSTOM_MONSTERSPAWNER == 1)
; 4506 : 			else if (MonsterSpawnerMng::getInstance()->isKeyItem(type)) {

  00d89	e8 00 00 00 00	 call	 ?getInstance@MonsterSpawnerMng@@SAPAV1@XZ ; MonsterSpawnerMng::getInstance
  00d8e	8b c8		 mov	 ecx, eax
  00d90	e8 00 00 00 00	 call	 ?isKeyItem@MonsterSpawnerMng@@QAE_NH@Z ; MonsterSpawnerMng::isKeyItem
  00d95	84 c0		 test	 al, al

; 4507 : 				if (MonsterSpawnerMng::getInstance()->procCreate(aIndex, type)) {

  00d97	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00d9a	74 2c		 je	 SHORT $LN17@CGItemDrop
  00d9c	57		 push	 edi
  00d9d	50		 push	 eax
  00d9e	e8 00 00 00 00	 call	 ?getInstance@MonsterSpawnerMng@@SAPAV1@XZ ; MonsterSpawnerMng::getInstance
  00da3	8b c8		 mov	 ecx, eax
  00da5	e8 00 00 00 00	 call	 ?procCreate@MonsterSpawnerMng@@QAE_NFH@Z ; MonsterSpawnerMng::procCreate

; 4508 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00daa	8b 55 98	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00dad	84 c0		 test	 al, al
  00daf	0f 84 c7 fe ff
	ff		 je	 $LN31@CGItemDrop
  00db5	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  00db9	51		 push	 ecx
  00dba	52		 push	 edx
  00dbb	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00dc0	83 c4 08	 add	 esp, 8

; 4509 : 				} else {
; 4510 : 					pResult.Result = false;
; 4511 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4512 : 					return false;
; 4513 : 				}
; 4514 : 			}
; 4515 : #endif
; 4516 : #ifdef __NOVUS__
; 4517 : 			else if( g_SummonSpot.IsScroll(type) )
; 4518 : 			{
; 4519 : 				if( g_SummonSpot.DropScroll(lpObj, type) )
; 4520 : 				{
; 4521 : 					LogAddTD("[SummonSpot] [%s][%s] Success to create spot",
; 4522 : 						gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pInventory[lpMsg->Ipos].m_Number);
; 4523 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 4524 : 				}
; 4525 : 				else
; 4526 : 				{
; 4527 : 					pResult.Result = false;
; 4528 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4529 : 					return false;
; 4530 : 				}
; 4531 : 			}
; 4532 : #endif
; 4533 : 			else

  00dc3	e9 48 fa ff ff	 jmp	 $LN6@CGItemDrop
$LN17@CGItemDrop:

; 4534 : 			{
; 4535 : 				int OwnerIndex = aIndex;
; 4536 : 
; 4537 : 				if ( (type >= ITEMGET(14,0) && type <= ITEMGET(14,10)) || (type == ITEMGET(4,7) ) || type ==ITEMGET(4,15) )

  00dc8	81 ff 00 1c 00
	00		 cmp	 edi, 7168		; 00001c00H
  00dce	7c 08		 jl	 SHORT $LN11@CGItemDrop
  00dd0	81 ff 0a 1c 00
	00		 cmp	 edi, 7178		; 00001c0aH
  00dd6	7e 10		 jle	 SHORT $LN12@CGItemDrop
$LN11@CGItemDrop:
  00dd8	81 ff 07 08 00
	00		 cmp	 edi, 2055		; 00000807H
  00dde	74 08		 je	 SHORT $LN12@CGItemDrop
  00de0	81 ff 0f 08 00
	00		 cmp	 edi, 2063		; 0000080fH
  00de6	75 03		 jne	 SHORT $LN13@CGItemDrop
$LN12@CGItemDrop:

; 4538 : 					OwnerIndex = -1;

  00de8	83 c8 ff	 or	 eax, -1
$LN13@CGItemDrop:

; 4539 : 
; 4540 : 				if ( MapC[map].ItemDrop( type, level, dur, lpMsg->px, lpMsg->py, Option1, Option2, Option3,
; 4541 : 					NOption, SOption, serial2, OwnerIndex, PetLevel, PetExp, btItemEffectEx,&SocketOptions[0],SocketBonus) == TRUE )

  00deb	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _SocketBonus$218655[ebp]
  00df1	d9 85 6c ff ff
	ff		 fld	 DWORD PTR _dur$218643[ebp]
  00df7	51		 push	 ecx
  00df8	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _btItemEffectEx$218653[ebp]
  00dfe	8d 55 ec	 lea	 edx, DWORD PTR _SocketOptions$218654[ebp]
  00e01	52		 push	 edx
  00e02	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _PetExp$218651[ebp]
  00e08	51		 push	 ecx
  00e09	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _PetLevel$218650[ebp]
  00e0f	52		 push	 edx
  00e10	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _serial2$218656[ebp]
  00e16	51		 push	 ecx
  00e17	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _NOption$218648[ebp]
  00e1d	50		 push	 eax
  00e1e	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _SOption$218652[ebp]
  00e24	52		 push	 edx
  00e25	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _Option3$218647[ebp]
  00e2b	50		 push	 eax
  00e2c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _Option2$218646[ebp]
  00e32	51		 push	 ecx
  00e33	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _Option1$218645[ebp]
  00e39	52		 push	 edx
  00e3a	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  00e3e	50		 push	 eax
  00e3f	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00e43	51		 push	 ecx
  00e44	52		 push	 edx
  00e45	50		 push	 eax
  00e46	51		 push	 ecx
  00e47	8b 4d 90	 mov	 ecx, DWORD PTR _level$218642[ebp]
  00e4a	d9 1c 24	 fstp	 DWORD PTR [esp]
  00e4d	51		 push	 ecx
  00e4e	8b 4d 84	 mov	 ecx, DWORD PTR _map$218640[ebp]
  00e51	69 c9 28 38 05
	00		 imul	 ecx, 342056		; 00053828H
  00e57	57		 push	 edi
  00e58	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00e5e	e8 00 00 00 00	 call	 ?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEPAEE@Z ; MapClass::ItemDrop
  00e63	83 f8 01	 cmp	 eax, 1
  00e66	0f 85 a0 f9 ff
	ff		 jne	 $LN128@CGItemDrop

; 4542 : 				{
; 4543 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00e6c	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  00e70	8b 45 98	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00e73	52		 push	 edx
  00e74	50		 push	 eax
  00e75	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00e7a	83 c4 08	 add	 esp, 8

; 4544 : 					pResult.Result = true;
; 4545 : 
; 4546 : 					if ( drop_type == FALSE )

  00e7d	83 7d 10 00	 cmp	 DWORD PTR _drop_type$[ebp], 0

; 4547 : 					{
; 4548 : 						LogAddTD(lMsg.Get(MSGGET(1, 223)), lpObj->AccountID, lpObj->Name, lpObj->MapNumber,
; 4549 : 							lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2,
; 4550 : 							Option3, (int)dur, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4],
; 4551 : 							NewOption[5], NewOption[6], SOption, btItemEffectEx>>7, JOHOption, JOHOptionLevel);

  00e81	d9 85 6c ff ff
	ff		 fld	 DWORD PTR _dur$218643[ebp]
  00e87	c6 45 9f 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00e8b	0f 85 a9 00 00
	00		 jne	 $LN9@CGItemDrop
  00e91	0f b6 4d 97	 movzx	 ecx, BYTE PTR _JOHOptionLevel$218660[ebp]
  00e95	0f b6 55 8f	 movzx	 edx, BYTE PTR _JOHOption$218659[ebp]
  00e99	0f b6 85 70 ff
	ff ff		 movzx	 eax, BYTE PTR _btItemEffectEx$218653[ebp]
  00ea0	51		 push	 ecx
  00ea1	0f b6 8d 68 ff
	ff ff		 movzx	 ecx, BYTE PTR _SOption$218652[ebp]
  00ea8	52		 push	 edx
  00ea9	0f b6 55 fa	 movzx	 edx, BYTE PTR _NewOption$[ebp+6]
  00ead	c1 e8 07	 shr	 eax, 7
  00eb0	50		 push	 eax
  00eb1	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$[ebp+5]
  00eb5	51		 push	 ecx
  00eb6	0f b6 4d f8	 movzx	 ecx, BYTE PTR _NewOption$[ebp+4]
  00eba	52		 push	 edx
  00ebb	0f b6 55 f7	 movzx	 edx, BYTE PTR _NewOption$[ebp+3]
  00ebf	50		 push	 eax
  00ec0	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$[ebp+2]
  00ec4	51		 push	 ecx
  00ec5	0f b6 4d f5	 movzx	 ecx, BYTE PTR _NewOption$[ebp+1]
  00ec9	52		 push	 edx
  00eca	0f b6 55 f4	 movzx	 edx, BYTE PTR _NewOption$[ebp]
  00ece	50		 push	 eax
  00ecf	51		 push	 ecx
  00ed0	52		 push	 edx
  00ed1	e8 00 00 00 00	 call	 __ftol2_sse
  00ed6	0f b6 8d 7c ff
	ff ff		 movzx	 ecx, BYTE PTR _Option2$218646[ebp]
  00edd	0f b6 95 74 ff
	ff ff		 movzx	 edx, BYTE PTR _Option1$218645[ebp]
  00ee4	50		 push	 eax
  00ee5	0f b6 85 78 ff
	ff ff		 movzx	 eax, BYTE PTR _Option3$218647[ebp]
  00eec	50		 push	 eax
  00eed	8b 45 90	 mov	 eax, DWORD PTR _level$218642[ebp]
  00ef0	51		 push	 ecx
  00ef1	52		 push	 edx
  00ef2	8b 55 80	 mov	 edx, DWORD PTR _serial$218649[ebp]
  00ef5	50		 push	 eax
  00ef6	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  00efd	57		 push	 edi
  00efe	8d 4d b8	 lea	 ecx, DWORD PTR _szItemName$218657[ebp]
  00f01	51		 push	 ecx
  00f02	0f b6 8b 20 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+288]
  00f09	52		 push	 edx
  00f0a	0f b6 93 23 01
	00 00		 movzx	 edx, BYTE PTR [ebx+291]
  00f11	50		 push	 eax
  00f12	51		 push	 ecx
  00f13	52		 push	 edx
  00f14	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00f17	50		 push	 eax
  00f18	8d 4b 52	 lea	 ecx, DWORD PTR [ebx+82]
  00f1b	51		 push	 ecx
  00f1c	68 df 01 00 00	 push	 479			; 000001dfH
  00f21	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00f26	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00f2b	50		 push	 eax
  00f2c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00f32	83 c4 64	 add	 esp, 100		; 00000064H

; 4552 : 					}
; 4553 : 					else

  00f35	e9 d6 f8 ff ff	 jmp	 $LN6@CGItemDrop
$LN9@CGItemDrop:

; 4554 : 					{
; 4555 : 						LogAddTD(lMsg.Get(MSGGET(1, 224)), lpObj->AccountID, lpObj->Name, lpObj->MapNumber,
; 4556 : 							lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2,
; 4557 : 							Option3, (int)dur, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4],
; 4558 : 							NewOption[5], NewOption[6], SOption, btItemEffectEx>>7, JOHOption, JOHOptionLevel );

  00f3a	0f b6 55 97	 movzx	 edx, BYTE PTR _JOHOptionLevel$218660[ebp]
  00f3e	0f b6 45 8f	 movzx	 eax, BYTE PTR _JOHOption$218659[ebp]
  00f42	0f b6 8d 70 ff
	ff ff		 movzx	 ecx, BYTE PTR _btItemEffectEx$218653[ebp]
  00f49	52		 push	 edx
  00f4a	0f b6 95 68 ff
	ff ff		 movzx	 edx, BYTE PTR _SOption$218652[ebp]
  00f51	50		 push	 eax
  00f52	0f b6 45 fa	 movzx	 eax, BYTE PTR _NewOption$[ebp+6]
  00f56	c1 e9 07	 shr	 ecx, 7
  00f59	51		 push	 ecx
  00f5a	0f b6 4d f9	 movzx	 ecx, BYTE PTR _NewOption$[ebp+5]
  00f5e	52		 push	 edx
  00f5f	0f b6 55 f8	 movzx	 edx, BYTE PTR _NewOption$[ebp+4]
  00f63	50		 push	 eax
  00f64	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$[ebp+3]
  00f68	51		 push	 ecx
  00f69	0f b6 4d f6	 movzx	 ecx, BYTE PTR _NewOption$[ebp+2]
  00f6d	52		 push	 edx
  00f6e	0f b6 55 f5	 movzx	 edx, BYTE PTR _NewOption$[ebp+1]
  00f72	50		 push	 eax
  00f73	0f b6 45 f4	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  00f77	51		 push	 ecx
  00f78	52		 push	 edx
  00f79	50		 push	 eax
  00f7a	e8 00 00 00 00	 call	 __ftol2_sse
  00f7f	0f b6 8d 78 ff
	ff ff		 movzx	 ecx, BYTE PTR _Option3$218647[ebp]
  00f86	0f b6 95 7c ff
	ff ff		 movzx	 edx, BYTE PTR _Option2$218646[ebp]
  00f8d	50		 push	 eax
  00f8e	0f b6 85 74 ff
	ff ff		 movzx	 eax, BYTE PTR _Option1$218645[ebp]
  00f95	51		 push	 ecx
  00f96	8b 4d 90	 mov	 ecx, DWORD PTR _level$218642[ebp]
  00f99	52		 push	 edx
  00f9a	50		 push	 eax
  00f9b	8b 45 80	 mov	 eax, DWORD PTR _serial$218649[ebp]
  00f9e	51		 push	 ecx
  00f9f	0f b6 8b 21 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+289]
  00fa6	57		 push	 edi
  00fa7	8d 55 b8	 lea	 edx, DWORD PTR _szItemName$218657[ebp]
  00faa	52		 push	 edx
  00fab	0f b6 93 20 01
	00 00		 movzx	 edx, BYTE PTR [ebx+288]
  00fb2	50		 push	 eax
  00fb3	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  00fba	51		 push	 ecx
  00fbb	52		 push	 edx
  00fbc	50		 push	 eax
  00fbd	8d 4b 5d	 lea	 ecx, DWORD PTR [ebx+93]
  00fc0	51		 push	 ecx
  00fc1	8d 53 52	 lea	 edx, DWORD PTR [ebx+82]
  00fc4	52		 push	 edx
  00fc5	68 e0 01 00 00	 push	 480			; 000001e0H
  00fca	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00fcf	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00fd4	50		 push	 eax
  00fd5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00fdb	83 c4 64	 add	 esp, 100		; 00000064H

; 4559 : 					}
; 4560 : 				}
; 4561 : 				else

  00fde	e9 2d f8 ff ff	 jmp	 $LN6@CGItemDrop
$LN52@CGItemDrop:

; 4352 : 			{
; 4353 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00fe3	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00fe7	8b 4d 98	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00fea	50		 push	 eax
  00feb	51		 push	 ecx
  00fec	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 4354 : 				PMSG_SERVERCMD ServerCmd = { 0 };
; 4355 : 				PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  00ff1	6a 07		 push	 7
  00ff3	6a 40		 push	 64			; 00000040H
  00ff5	33 c0		 xor	 eax, eax
  00ff7	8d 55 84	 lea	 edx, DWORD PTR _ServerCmd$218673[ebp]
  00ffa	68 f3 00 00 00	 push	 243			; 000000f3H
  00fff	52		 push	 edx
  01000	c6 45 84 00	 mov	 BYTE PTR _ServerCmd$218673[ebp], 0
  01004	89 45 85	 mov	 DWORD PTR _ServerCmd$218673[ebp+1], eax
  01007	66 89 45 89	 mov	 WORD PTR _ServerCmd$218673[ebp+5], ax
  0100b	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 4356 : 				ServerCmd.CmdType = 0;
; 4357 : 				ServerCmd.X = lpObj->X;

  01010	8a 83 20 01 00
	00		 mov	 al, BYTE PTR [ebx+288]

; 4358 : 				ServerCmd.Y = lpObj->Y;

  01016	8a 8b 21 01 00
	00		 mov	 cl, BYTE PTR [ebx+289]

; 4359 : 				MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  0101c	6a 07		 push	 7
  0101e	8d 55 84	 lea	 edx, DWORD PTR _ServerCmd$218673[ebp]
  01021	52		 push	 edx
  01022	53		 push	 ebx
  01023	c6 45 88 00	 mov	 BYTE PTR _ServerCmd$218673[ebp+4], 0
  01027	88 45 89	 mov	 BYTE PTR _ServerCmd$218673[ebp+5], al
  0102a	88 4d 8a	 mov	 BYTE PTR _ServerCmd$218673[ebp+6], cl
  0102d	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 4360 : 				DataSend(aIndex, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  01032	8b 4d 98	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  01035	6a 07		 push	 7
  01037	8d 45 84	 lea	 eax, DWORD PTR _ServerCmd$218673[ebp]
  0103a	50		 push	 eax
  0103b	51		 push	 ecx
  0103c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4361 : 				LogAddTD("[%s][%s][%d]%d/%d Used Fireworks:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 4362 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 4363 : 					serial, szItemName, type, level, Option1, Option2, Option3);

  01041	0f b6 95 78 ff
	ff ff		 movzx	 edx, BYTE PTR _Option3$218647[ebp]
  01048	0f b6 85 7c ff
	ff ff		 movzx	 eax, BYTE PTR _Option2$218646[ebp]
  0104f	0f b6 8d 74 ff
	ff ff		 movzx	 ecx, BYTE PTR _Option1$218645[ebp]
  01056	52		 push	 edx
  01057	8b 55 90	 mov	 edx, DWORD PTR _level$218642[ebp]
  0105a	50		 push	 eax
  0105b	51		 push	 ecx
  0105c	8b 4d 80	 mov	 ecx, DWORD PTR _serial$218649[ebp]
  0105f	52		 push	 edx
  01060	0f b6 93 21 01
	00 00		 movzx	 edx, BYTE PTR [ebx+289]
  01067	57		 push	 edi
  01068	8d 45 b8	 lea	 eax, DWORD PTR _szItemName$218657[ebp]
  0106b	50		 push	 eax
  0106c	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  01073	51		 push	 ecx
  01074	0f b6 8b 23 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+291]
  0107b	52		 push	 edx
  0107c	50		 push	 eax
  0107d	51		 push	 ecx
  0107e	8d 53 5d	 lea	 edx, DWORD PTR [ebx+93]
  01081	52		 push	 edx
  01082	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  01085	50		 push	 eax
  01086	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@HPFBFIFH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Fireworks@
  0108b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01091	83 c4 64	 add	 esp, 100		; 00000064H

; 4562 : 				{
; 4563 : 					pResult.Result = false;
; 4564 : 				}
; 4565 : 			}
; 4566 : 		}
; 4567 : 		else	// bIsItem

  01094	e9 77 f7 ff ff	 jmp	 $LN6@CGItemDrop
  01099	8d 49 00	 npad	 3
$LN130@CGItemDrop:

; 4606 : }

  0109c	00 00 00 00	 DD	 $LN47@CGItemDrop
  010a0	00 00 00 00	 DD	 $LN42@CGItemDrop
  010a4	00 00 00 00	 DD	 $LN42@CGItemDrop
  010a8	00 00 00 00	 DD	 $LN42@CGItemDrop
  010ac	00 00 00 00	 DD	 $LN6@CGItemDrop
  010b0	00 00 00 00	 DD	 $LN41@CGItemDrop
?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ENDP	; CGItemDropRequest
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCItemMoveResultSend@@YAXHEEQAE@Z		; GCItemMoveResultSend
EXTRN	?GCSendItemInfo@CCashShop@@QAEXHHHK@Z:PROC	; CCashShop::GCSendItemInfo
EXTRN	?g_CashShop@@3VCCashShop@@A:BYTE		; g_CashShop
; Function compile flags: /Ogtp
;	COMDAT ?GCItemMoveResultSend@@YAXHEEQAE@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_pos$ = 16						; size = 1
_ItemInfo$ = 20						; size = 4
?GCItemMoveResultSend@@YAXHEEQAE@Z PROC			; GCItemMoveResultSend, COMDAT

; 4625 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4626 : 	PMSG_INVENTORYITEMMOVE_RESULT pMsg;
; 4627 : 
; 4628 : 	pMsg.h.c = 0xC3;
; 4629 : 	pMsg.h.headcode = 0x24;
; 4630 : 	pMsg.h.size = sizeof(pMsg);
; 4631 : 	pMsg.result = result;

  00010	53		 push	 ebx
  00011	56		 push	 esi

; 4641 : 
; 4642 : 	pMsg.ItemInfo[7] = ItemInfo[7];
; 4643 : 	pMsg.ItemInfo[8] = ItemInfo[8];
; 4644 : 	pMsg.ItemInfo[9] = ItemInfo[9];

  00012	57		 push	 edi

; 4626 : 	PMSG_INVENTORYITEMMOVE_RESULT pMsg;
; 4627 : 
; 4628 : 	pMsg.h.c = 0xC3;
; 4629 : 	pMsg.h.headcode = 0x24;
; 4630 : 	pMsg.h.size = sizeof(pMsg);
; 4631 : 	pMsg.result = result;

  00013	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00016	8a 5d 10	 mov	 bl, BYTE PTR _pos$[ebp]
  00019	8b 75 14	 mov	 esi, DWORD PTR _ItemInfo$[ebp]

; 4632 : 	pMsg.Pos = pos;
; 4633 : 	pMsg.ItemInfo[I_TYPE] = ItemInfo[I_TYPE];

  0001c	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]

; 4634 : 	pMsg.ItemInfo[I_OPTION] = ItemInfo[I_OPTION];

  0001f	0f b6 56 01	 movzx	 edx, BYTE PTR [esi+1]
  00023	88 4d ed	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 4635 : 	pMsg.ItemInfo[I_DUR] = ItemInfo[I_DUR];
; 4636 : 	pMsg.ItemInfo[I_NOPTION] = ItemInfo[I_NOPTION];

  00026	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  0002a	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  0002d	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00031	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+8], cl

; 4637 : 
; 4638 : 	pMsg.ItemInfo[I_SOPTION] = ItemInfo[I_SOPTION];
; 4639 : 	pMsg.ItemInfo[I_380OPTION] = ItemInfo[I_380OPTION];
; 4640 : 	pMsg.ItemInfo[I_JOHOPTION] = ItemInfo[I_JOHOPTION];

  00034	0f b6 4e 06	 movzx	 ecx, BYTE PTR [esi+6]
  00038	88 55 ee	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  0003b	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  0003f	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+7], al
  00042	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00046	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+11], cl

; 4641 : 
; 4642 : 	pMsg.ItemInfo[7] = ItemInfo[7];
; 4643 : 	pMsg.ItemInfo[8] = ItemInfo[8];
; 4644 : 	pMsg.ItemInfo[9] = ItemInfo[9];

  00049	0f b6 4e 09	 movzx	 ecx, BYTE PTR [esi+9]
  0004d	88 55 f1	 mov	 BYTE PTR _pMsg$[ebp+9], dl
  00050	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  00054	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+10], al
  00057	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  0005b	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0005e	88 4d f6	 mov	 BYTE PTR _pMsg$[ebp+14], cl
  00061	88 55 f4	 mov	 BYTE PTR _pMsg$[ebp+12], dl

; 4645 : 	pMsg.ItemInfo[10] = ItemInfo[10];

  00064	0f b6 56 0a	 movzx	 edx, BYTE PTR [esi+10]
  00068	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+13], al

; 4646 : 	pMsg.ItemInfo[11] = ItemInfo[11];

  0006b	0f b6 46 0b	 movzx	 eax, BYTE PTR [esi+11]

; 4647 : 
; 4648 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0006f	6a 11		 push	 17			; 00000011H
  00071	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00074	51		 push	 ecx
  00075	57		 push	 edi
  00076	c6 45 e8 c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H
  0007a	66 c7 45 e9 11
	24		 mov	 WORD PTR _pMsg$[ebp+1], 9233 ; 00002411H
  00080	88 5d ec	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  00083	88 55 f7	 mov	 BYTE PTR _pMsg$[ebp+15], dl
  00086	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+16], al
  00089	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4649 : 
; 4650 : 	if( result != (BYTE)-1 )

  00091	80 7d 0c ff	 cmp	 BYTE PTR _result$[ebp], 255 ; 000000ffH
  00095	74 3f		 je	 SHORT $LN1@GCItemMove

; 4651 : 	{
; 4652 : 		if( (ItemInfo[I_380OPTION]&2) == 2 && (ItemInfo[I_380OPTION]&4) == 0 )

  00097	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  0009a	a8 02		 test	 al, 2
  0009c	74 38		 je	 SHORT $LN1@GCItemMove
  0009e	a8 04		 test	 al, 4
  000a0	75 34		 jne	 SHORT $LN1@GCItemMove

; 4653 : 		{
; 4654 : 			CItem* lpItem = &gObj[aIndex].pInventory[pos];

  000a2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a8	0f b6 cb	 movzx	 ecx, bl
  000ab	8b c1		 mov	 eax, ecx
  000ad	8b d7		 mov	 edx, edi
  000af	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  000b5	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  000bb	03 84 32 c0 11
	00 00		 add	 eax, DWORD PTR [edx+esi+4544]

; 4655 : 
; 4656 : 			g_CashShop.GCSendItemInfo(aIndex,lpItem->m_Type,pos,lpItem->m_Number);

  000c2	8b 10		 mov	 edx, DWORD PTR [eax]
  000c4	0f bf 40 06	 movsx	 eax, WORD PTR [eax+6]
  000c8	52		 push	 edx
  000c9	51		 push	 ecx
  000ca	50		 push	 eax
  000cb	57		 push	 edi
  000cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  000d1	e8 00 00 00 00	 call	 ?GCSendItemInfo@CCashShop@@QAEXHHHK@Z ; CCashShop::GCSendItemInfo
$LN1@GCItemMove:

; 4657 : 		}
; 4658 : 	}
; 4659 : }

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	33 cd		 xor	 ecx, ebp
  000dd	5b		 pop	 ebx
  000de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
?GCItemMoveResultSend@@YAXHEEQAE@Z ENDP			; GCItemMoveResultSend
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar@2
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar@2:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 485  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 486  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 10	 mov	 esi, DWORD PTR __Count$[ebp]
  0000d	57		 push	 edi
  0000e	83 fe 04	 cmp	 esi, 4
  00011	72 14		 jb	 SHORT $LN11@compare
$LL4@compare:
  00013	8b 02		 mov	 eax, DWORD PTR [edx]
  00015	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00017	75 12		 jne	 SHORT $LN5@compare
  00019	83 ee 04	 sub	 esi, 4
  0001c	83 c1 04	 add	 ecx, 4
  0001f	83 c2 04	 add	 edx, 4
  00022	83 fe 04	 cmp	 esi, 4
  00025	73 ec		 jae	 SHORT $LL4@compare
$LN11@compare:
  00027	85 f6		 test	 esi, esi
  00029	74 45		 je	 SHORT $LN6@compare
$LN5@compare:
  0002b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0002e	0f b6 39	 movzx	 edi, BYTE PTR [ecx]
  00031	2b c7		 sub	 eax, edi
  00033	75 31		 jne	 SHORT $LN7@compare
  00035	83 fe 01	 cmp	 esi, 1
  00038	76 36		 jbe	 SHORT $LN6@compare
  0003a	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  0003e	0f b6 79 01	 movzx	 edi, BYTE PTR [ecx+1]
  00042	2b c7		 sub	 eax, edi
  00044	75 20		 jne	 SHORT $LN7@compare
  00046	83 fe 02	 cmp	 esi, 2
  00049	76 25		 jbe	 SHORT $LN6@compare
  0004b	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0004f	0f b6 79 02	 movzx	 edi, BYTE PTR [ecx+2]
  00053	2b c7		 sub	 eax, edi
  00055	75 0f		 jne	 SHORT $LN7@compare
  00057	83 fe 03	 cmp	 esi, 3
  0005a	76 14		 jbe	 SHORT $LN6@compare
  0005c	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00060	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00064	2b c1		 sub	 eax, ecx
$LN7@compare:
  00066	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  00069	5f		 pop	 edi
  0006a	83 c8 01	 or	 eax, 1
  0006d	5e		 pop	 esi

; 487  : 		}

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN6@compare:
  00070	5f		 pop	 edi

; 486  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00071	33 c0		 xor	 eax, eax
  00073	5e		 pop	 esi

; 487  : 		}

  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogtp
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 490  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 491  : 		return (_CSTD strlen(_First));

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL3@length:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL3@length
  00017	2b c2		 sub	 eax, edx

; 492  : 		}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 496  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 498  : 		}

  00003	5d		 pop	 ebp

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?find@?$char_traits@D@std@@SAPBDPBDIABD@Z	; std::char_traits<char>::find
EXTRN	_memchr:PROC
; Function compile flags: /Ogtp
;	COMDAT ?find@?$char_traits@D@std@@SAPBDPBDIABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT

; 510  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 511  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Ch$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00009	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0000c	50		 push	 eax
  0000d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00010	52		 push	 edx
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memchr
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 512  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
EXTRN	_memmove:PROC
; Function compile flags: /Ogtp
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 516  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 518  : 		}

  00003	5d		 pop	 ebp

; 517  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 526  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 527  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  0000b	88 0a		 mov	 BYTE PTR [edx], cl

; 528  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	_pos$GSCopy$
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCEquipmentChange@@YAXHH@Z			; GCEquipmentChange
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
;	COMDAT ?GCEquipmentChange@@YAXHH@Z
_TEXT	SEGMENT
_pos$GSCopy$ = -32					; size = 4
_aIndex$GSCopy$ = -28					; size = 4
_pChange$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 4
?GCEquipmentChange@@YAXHH@Z PROC			; GCEquipmentChange, COMDAT

; 5144 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 5145 : 	PMSG_USEREQUIPMENTCHANGED pChange;
; 5146 : 	LPOBJ lpObj = &gObj[aIndex];

  00017	89 5d e4	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0001a	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00020	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	56		 push	 esi
  00027	57		 push	 edi

; 5147 : 
; 5148 : 	PHeadSetB((LPBYTE)&pChange, 0x25, sizeof(PMSG_USEREQUIPMENTCHANGED));

  00028	6a 11		 push	 17			; 00000011H
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR _pChange$[ebp]
  0002d	6a 25		 push	 37			; 00000025H
  0002f	51		 push	 ecx
  00030	89 45 e0	 mov	 DWORD PTR _pos$GSCopy$[ebp], eax
  00033	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 5149 : 	pChange.NumberH = SET_NUMBERH(aIndex);

  00038	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]

; 5150 : 	pChange.NumberL = SET_NUMBERL(aIndex);

  0003b	88 45 ec	 mov	 BYTE PTR _pChange$[ebp+4], al
  0003e	8b d0		 mov	 edx, eax

; 5151 : 	ItemByteConvert(pChange.ItemInfo, lpObj->pInventory[pos]);

  00040	8b 45 e0	 mov	 eax, DWORD PTR _pos$GSCopy$[ebp]
  00043	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00049	c1 ea 08	 shr	 edx, 8
  0004c	88 55 eb	 mov	 BYTE PTR _pChange$[ebp+3], dl
  0004f	8b b3 c0 11 00
	00		 mov	 esi, DWORD PTR [ebx+4544]
  00055	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0005b	03 f0		 add	 esi, eax
  0005d	8b fc		 mov	 edi, esp
  0005f	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00064	f3 a5		 rep movsd
  00066	8d 4d ed	 lea	 ecx, DWORD PTR _pChange$[ebp+5]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 5152 : 	pChange.ItemInfo[I_OPTION] = pos << 4;

  0006f	8b 45 e0	 mov	 eax, DWORD PTR _pos$GSCopy$[ebp]
  00072	8a d0		 mov	 dl, al

; 5153 : 	pChange.ItemInfo[I_OPTION] |= LevelSmallConvert(aIndex, pos) & MAX_ITEM_LEVEL;

  00074	50		 push	 eax
  00075	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00078	c0 e2 04	 shl	 dl, 4
  0007b	50		 push	 eax
  0007c	88 55 ee	 mov	 BYTE PTR _pChange$[ebp+6], dl
  0007f	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert

; 5154 : 
; 5155 : 	MsgSendV2(lpObj, (LPBYTE)&pChange, pChange.h.size);

  00084	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pChange$[ebp+1]
  00088	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  0008e	51		 push	 ecx
  0008f	8d 55 e8	 lea	 edx, DWORD PTR _pChange$[ebp]
  00092	52		 push	 edx
  00093	24 0f		 and	 al, 15			; 0000000fH
  00095	08 45 ee	 or	 BYTE PTR _pChange$[ebp+6], al
  00098	53		 push	 ebx
  00099	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 5156 : 
; 5157 : }

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	33 cd		 xor	 ecx, ebp
  000a8	5b		 pop	 ebx
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?GCEquipmentChange@@YAXHH@Z ENDP			; GCEquipmentChange
_TEXT	ENDS
PUBLIC	??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@ ; `string'
PUBLIC	??_C@_0BP@FPLNFNIC@You?5have?5no?5enough?5empty?5space?$AA@ ; `string'
PUBLIC	??_C@_0DP@ONDPGNEF@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5item?5has?5been?5purchase@ ; `string'
PUBLIC	??_C@_0CF@MFLOOBGJ@Item?5has?5been?5purchased?0?5balance@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z	; CGBuyRequestRecv
EXTRN	?BuyRequest@CGamblingEvent@@QAEEHEEEE@Z:PROC	; CGamblingEvent::BuyRequest
EXTRN	?gGamblingEvent@@3VCGamblingEvent@@A:BYTE	; gGamblingEvent
EXTRN	?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; CheckInventoryEmptySpace
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?gObjSearchItem@@YAHPAUOBJECTSTRUCT@@HHH@Z:PROC	; gObjSearchItem
EXTRN	?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateStore
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?GetPrice@ItemPrice@@QAE_NFGEAAKAAE@Z:PROC	; ItemPrice::GetPrice
EXTRN	?g_ItemPrice@@3VItemPrice@@A:BYTE		; g_ItemPrice
EXTRN	?Output@CLogToFile@@QAAXPADZZ:PROC		; CLogToFile::Output
EXTRN	?requestDbUpdateCredits@@YAXPAUOBJECTSTRUCT@@FF@Z:PROC ; requestDbUpdateCredits
EXTRN	_sprintf:PROC
EXTRN	?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z:PROC ; gObjShopBuyInventoryInsertItem
EXTRN	?Get@ShopManager@@QAEPAVCShop@@H@Z:PROC		; ShopManager::Get
EXTRN	?g_ShopManager@@3VShopManager@@A:BYTE		; g_ShopManager
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
;	COMDAT ??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@
CONST	SEGMENT
??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@ DB '['
	DB	'%s][%s] (%d) Shop buy [%d][%d][%d][%s] LEV:%d, DUR:%d, OP:[%d'
	DB	'][%d][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FPLNFNIC@You?5have?5no?5enough?5empty?5space?$AA@
CONST	SEGMENT
??_C@_0BP@FPLNFNIC@You?5have?5no?5enough?5empty?5space?$AA@ DB 'You have '
	DB	'no enough empty space', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@ONDPGNEF@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5item?5has?5been?5purchase@
CONST	SEGMENT
??_C@_0DP@ONDPGNEF@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5item?5has?5been?5purchase@ DB '['
	DB	'%s] [%s] item has been purchased (%s, price: %d), balance: %d'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MFLOOBGJ@Item?5has?5been?5purchased?0?5balance@
CONST	SEGMENT
??_C@_0CF@MFLOOBGJ@Item?5has?5been?5purchased?0?5balance@ DB 'Item has be'
	DB	'en purchased, balance: %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z
_TEXT	SEGMENT
tv672 = -260						; size = 4
_bNoItem$219173 = -256					; size = 4
_lpShop$ = -252						; size = 4
_Divisor$219162 = -245					; size = 1
_iStoreTaxMoney$219161 = -244				; size = 4
_lpMsg$GSCopy$ = -240					; size = 4
_iItemValue$219159 = -236				; size = 4
_tmpPrice$219149 = -232					; size = 4
_tShop$ = -232						; size = 4
_iStorePrice$219160 = -228				; size = 4
_aIndex$GSCopy$ = -224					; size = 4
_pResult$ = -220					; size = 16
_tmpNotice$219153 = -204				; size = 200
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z PROC	; CGBuyRequestRecv, COMDAT

; 5458 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 5459 : 	LPOBJ lpObj = &gObj[aIndex];

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 5666 : 
; 5667 : 					GCMoneySend(aIndex, lpObj->Money);

  0001d	89 b5 20 ff ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  00023	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00029	57		 push	 edi
  0002a	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0002d	6a 10		 push	 16			; 00000010H
  0002f	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00035	6a 32		 push	 50			; 00000032H
  00037	51		 push	 ecx
  00038	89 bd 10 ff ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], edi
  0003e	89 b5 fc fe ff
	ff		 mov	 DWORD PTR tv672[ebp], esi
  00044	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  00047	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0004c	53		 push	 ebx
  0004d	c6 85 27 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00054	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 aa 00 00
	00		 je	 $LN40@CGBuyReque

; 5460 : 	PMSG_BUYRESULT pResult;
; 5461 : 
; 5462 : 	PHeadSetB((LPBYTE)&pResult, 0x32, sizeof(pResult));
; 5463 : 	pResult.Result = -1;
; 5464 : 
; 5465 : 
; 5466 : 	if ( !PacketCheckTime(lpObj))
; 5467 : 	{
; 5468 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5469 : 		return;
; 5470 : 	}
; 5471 : 
; 5472 : 	if ( gObj[aIndex].CloseType != -1 )

  00064	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006a	80 7c 16 0d ff	 cmp	 BYTE PTR [esi+edx+13], -1
  0006f	74 1b		 je	 SHORT $LN44@CGBuyReque
$LN56@CGBuyReque:

; 5473 : 	{
; 5474 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00071	0f b6 85 25 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00078	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0007e	50		 push	 eax
  0007f	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00085	51		 push	 ecx
  00086	52		 push	 edx

; 5475 : 		return;

  00087	e9 7c 06 00 00	 jmp	 $LN54@CGBuyReque
$LN44@CGBuyReque:

; 5476 : 	}
; 5477 : 
; 5478 : 	if ( !::gObjFixInventoryPointer(aIndex))

  0008c	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00098	83 c4 04	 add	 esp, 4
  0009b	84 c0		 test	 al, al
  0009d	75 18		 jne	 SHORT $LN43@CGBuyReque

; 5479 : 	{
; 5480 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0009f	68 68 15 00 00	 push	 5480			; 00001568H
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN43@CGBuyReque:

; 5481 : 	}
; 5482 : 
; 5483 : 	if ( gObj[aIndex].m_ShopTime == 0 )

  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bc	80 bc 06 80 05
	00 00 00	 cmp	 BYTE PTR [esi+eax+1408], 0
  000c4	75 0d		 jne	 SHORT $LN42@CGBuyReque

; 5484 : 		gObj[aIndex].m_ShopTime = 1;

  000c6	c6 84 06 80 05
	00 00 01	 mov	 BYTE PTR [esi+eax+1408], 1
  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN42@CGBuyReque:

; 5485 : 
; 5486 : 	if ( gObj[aIndex].m_ShopTime > 	60 )

  000d3	80 bc 06 80 05
	00 00 3c	 cmp	 BYTE PTR [esi+eax+1408], 60 ; 0000003cH

; 5487 : 	{
; 5488 : 		if ( lpObj->m_IfState.use != 0 && lpObj->m_IfState.type == 3 )

  000db	8b 83 b8 11 00
	00		 mov	 eax, DWORD PTR [ebx+4536]
  000e1	76 46		 jbe	 SHORT $LN41@CGBuyReque
  000e3	a8 03		 test	 al, 3
  000e5	74 27		 je	 SHORT $LN40@CGBuyReque
  000e7	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000ec	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000f1	75 1b		 jne	 SHORT $LN40@CGBuyReque

; 5489 : 		{
; 5490 : 			pResult.Result = (BYTE)-2;
; 5491 : 			lpObj->TargetShopNumber = -1;

  000f3	83 c9 ff	 or	 ecx, -1
  000f6	c6 85 27 ff ff
	ff fe		 mov	 BYTE PTR _pResult$[ebp+3], 254 ; 000000feH

; 5492 : 			lpObj->m_IfState.use = 0;
; 5493 : 			lpObj->m_IfState.type = 0;

  000fd	81 a3 b8 11 00
	00 3c 00 ff ff	 and	 DWORD PTR [ebx+4536], -65476 ; ffff003cH
  00107	66 89 8b 3a 06
	00 00		 mov	 WORD PTR [ebx+1594], cx
$LN40@CGBuyReque:

; 5494 : 		}
; 5495 : 
; 5496 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0010e	0f b6 95 25 ff
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00115	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0011b	52		 push	 edx
  0011c	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00122	50		 push	 eax
  00123	51		 push	 ecx

; 5497 : 		return;

  00124	e9 df 05 00 00	 jmp	 $LN54@CGBuyReque
$LN41@CGBuyReque:

; 5498 : 	}
; 5499 : 
; 5500 : 	if ( lpObj->m_IfState.use > 0 )

  00129	a8 03		 test	 al, 3
  0012b	76 0c		 jbe	 SHORT $LN38@CGBuyReque

; 5501 : 	{
; 5502 : 		if ( lpObj->m_IfState.type != 3 )

  0012d	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00132	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H

; 5503 : 		{
; 5504 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5505 : 			return;

  00137	75 d5		 jne	 SHORT $LN40@CGBuyReque
$LN38@CGBuyReque:

; 5506 : 		}
; 5507 : 	}
; 5508 : 
; 5509 : 	int tShop = lpObj->TargetShopNumber;

  00139	0f bf 83 3a 06
	00 00		 movsx	 eax, WORD PTR [ebx+1594]
  00140	89 85 18 ff ff
	ff		 mov	 DWORD PTR _tShop$[ebp], eax

; 5510 : 
; 5511 : 	if ( tShop < 0 || tShop > MAX_SHOP-1 )

  00146	3d f3 01 00 00	 cmp	 eax, 499		; 000001f3H
  0014b	0f 87 a1 05 00
	00		 ja	 $LN36@CGBuyReque

; 5514 : 		return;
; 5515 : 	}
; 5516 : 
; 5517 : 	if ( lpMsg->Pos > MAX_ITEM_IN_SHOP-1 )

  00151	80 7f 03 77	 cmp	 BYTE PTR [edi+3], 119	; 00000077H

; 5518 : 	{
; 5519 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5520 : 		return;

  00155	77 b7		 ja	 SHORT $LN40@CGBuyReque

; 5521 : 	}
; 5522 : 
; 5523 : 	CShop* lpShop = g_ShopManager.Get(tShop);

  00157	50		 push	 eax
  00158	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopManager@@3VShopManager@@A ; g_ShopManager
  0015d	e8 00 00 00 00	 call	 ?Get@ShopManager@@QAEPAVCShop@@H@Z ; ShopManager::Get
  00162	8b f0		 mov	 esi, eax
  00164	89 b5 04 ff ff
	ff		 mov	 DWORD PTR _lpShop$[ebp], esi

; 5524 : 	if (!lpShop) {

  0016a	85 f6		 test	 esi, esi
  0016c	0f 84 9e 05 00
	00		 je	 $LN46@CGBuyReque

; 5525 : 		return;
; 5526 : 	}
; 5527 : 
; 5528 : 	if (lpShop->m_CreditPrice) {
; 5529 : 		if (!lpShop->m_item[lpMsg->Pos].IsItem()) {

  00172	0f b6 57 03	 movzx	 edx, BYTE PTR [edi+3]
  00176	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0017c	80 be 04 6a 00
	00 00		 cmp	 BYTE PTR [esi+27140], 0
  00183	8d 8c 32 88 00
	00 00		 lea	 ecx, DWORD PTR [edx+esi+136]
  0018a	0f 84 65 01 00
	00		 je	 $LN33@CGBuyReque
  00190	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00195	85 c0		 test	 eax, eax

; 5530 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5531 : 			return;

  00197	0f 84 d4 fe ff
	ff		 je	 $LN56@CGBuyReque

; 5532 : 		}
; 5533 : 		int	tmpPrice = lpShop->m_CreditPriceTable[lpMsg->Pos];

  0019d	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  001a1	0f bf 8c 46 06
	6a 00 00	 movsx	 ecx, WORD PTR [esi+eax*2+27142]

; 5534 : 		if (lpObj->m_Credits < tmpPrice) {

  001a9	8b 83 38 27 00
	00		 mov	 eax, DWORD PTR [ebx+10040]
  001af	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _tmpPrice$219149[ebp], ecx
  001b5	3b c1		 cmp	 eax, ecx
  001b7	73 0c		 jae	 SHORT $LN31@CGBuyReque
$LN55@CGBuyReque:

; 5535 : 			pResult.Result = -1;

  001b9	c6 85 27 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 5536 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5537 : 			return;

  001c0	e9 2d 05 00 00	 jmp	 $LN36@CGBuyReque
$LN31@CGBuyReque:

; 5538 : 		}
; 5539 : 		lpObj->m_Credits -= tmpPrice;

  001c5	2b c1		 sub	 eax, ecx
  001c7	89 83 38 27 00
	00		 mov	 DWORD PTR [ebx+10040], eax

; 5540 : 		pResult.Result = gObjShopBuyInventoryInsertItem(aIndex, lpShop->m_item[lpMsg->Pos]);

  001cd	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  001d1	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  001d7	8d b4 31 88 00
	00 00		 lea	 esi, DWORD PTR [ecx+esi+136]
  001de	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  001e4	8b fc		 mov	 edi, esp
  001e6	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  001eb	f3 a5		 rep movsd
  001ed	8b b5 20 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  001f3	56		 push	 esi
  001f4	e8 00 00 00 00	 call	 ?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjShopBuyInventoryInsertItem
  001f9	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  001ff	88 85 27 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al

; 5541 : 		if (pResult.Result != 0xFF) {

  00205	3c ff		 cmp	 al, 255			; 000000ffH
  00207	0f 84 d3 00 00
	00		 je	 $LN30@CGBuyReque

; 5542 : 			char tmpNotice[200] = { 0 };

  0020d	68 c7 00 00 00	 push	 199			; 000000c7H
  00212	8d 95 35 ff ff
	ff		 lea	 edx, DWORD PTR _tmpNotice$219153[ebp+1]
  00218	6a 00		 push	 0
  0021a	52		 push	 edx
  0021b	c6 85 34 ff ff
	ff 00		 mov	 BYTE PTR _tmpNotice$219153[ebp], 0
  00222	e8 00 00 00 00	 call	 _memset

; 5543 : 			sprintf(tmpNotice, "Item has been purchased, balance: %d", lpObj->m_Credits);

  00227	8b 83 38 27 00
	00		 mov	 eax, DWORD PTR [ebx+10040]
  0022d	50		 push	 eax
  0022e	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _tmpNotice$219153[ebp]
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MFLOOBGJ@Item?5has?5been?5purchased?0?5balance@
  00239	51		 push	 ecx
  0023a	e8 00 00 00 00	 call	 _sprintf

; 5544 : 			GCServerMsgStringSend(tmpNotice, aIndex, 1);

  0023f	6a 01		 push	 1
  00241	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR _tmpNotice$219153[ebp]
  00247	56		 push	 esi
  00248	52		 push	 edx
  00249	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 5545 : 			requestDbUpdateCredits(lpObj, lpObj->m_Credits, tmpPrice);

  0024e	0f b7 83 38 27
	00 00		 movzx	 eax, WORD PTR [ebx+10040]
  00255	8b b5 18 ff ff
	ff		 mov	 esi, DWORD PTR _tmpPrice$219149[ebp]
  0025b	56		 push	 esi
  0025c	50		 push	 eax
  0025d	53		 push	 ebx
  0025e	e8 00 00 00 00	 call	 ?requestDbUpdateCredits@@YAXPAUOBJECTSTRUCT@@FF@Z ; requestDbUpdateCredits

; 5546 : 			g_CreditLog.Output("[%s] [%s] item has been purchased (%s, price: %d), balance: %d",
; 5547 : 				lpObj->AccountID, lpObj->Name, lpShop->m_item[lpMsg->Pos].GetName(), tmpPrice, lpObj->m_Credits);

  00263	8b bd 10 ff ff
	ff		 mov	 edi, DWORD PTR _lpMsg$GSCopy$[ebp]
  00269	0f b6 57 03	 movzx	 edx, BYTE PTR [edi+3]
  0026d	8b 8b 38 27 00
	00		 mov	 ecx, DWORD PTR [ebx+10040]
  00273	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00279	83 c4 30	 add	 esp, 48			; 00000030H
  0027c	51		 push	 ecx
  0027d	56		 push	 esi
  0027e	8b b5 04 ff ff
	ff		 mov	 esi, DWORD PTR _lpShop$[ebp]
  00284	8d 8c 32 88 00
	00 00		 lea	 ecx, DWORD PTR [edx+esi+136]
  0028b	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00290	50		 push	 eax
  00291	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00294	50		 push	 eax
  00295	83 c3 52	 add	 ebx, 82			; 00000052H
  00298	53		 push	 ebx
  00299	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@ONDPGNEF@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5item?5has?5been?5purchase@
  0029e	68 00 00 00 00	 push	 OFFSET ?g_CreditLog@@3VCLogToFile@@A ; g_CreditLog
  002a3	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output

; 5548 : 			ItemByteConvert((LPBYTE)&pResult.ItemInfo, lpShop->m_item[lpMsg->Pos]);

  002a8	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  002ac	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  002b2	8d b4 31 88 00
	00 00		 lea	 esi, DWORD PTR [ecx+esi+136]
  002b9	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  002bf	8d 95 28 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp+4]
  002c5	8b fc		 mov	 edi, esp
  002c7	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  002cc	52		 push	 edx
  002cd	f3 a5		 rep movsd
  002cf	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  002d4	8b b5 20 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  002da	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
$LN30@CGBuyReque:

; 5549 : 		}
; 5550 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  002e0	0f b6 85 25 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  002e7	50		 push	 eax
  002e8	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  002ee	51		 push	 ecx
  002ef	56		 push	 esi

; 5551 : 		return;

  002f0	e9 13 04 00 00	 jmp	 $LN54@CGBuyReque
$LN33@CGBuyReque:

; 5552 : 	}
; 5553 : 
; 5554 : 	if ( lpShop->m_item[lpMsg->Pos].IsItem() == TRUE )

  002f5	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002fa	83 f8 01	 cmp	 eax, 1
  002fd	0f 85 ef 03 00
	00		 jne	 $LN36@CGBuyReque

; 5555 : 	{
; 5556 : 		DWORD iItemValue;
; 5557 : 		DWORD iStorePrice;
; 5558 : 		DWORD iStoreTaxMoney = 0;
; 5559 : 		BYTE Divisor;
; 5560 : 
; 5561 : 		if( g_ItemPrice.GetPrice(tShop, 
; 5562 : 			lpShop->m_item[lpMsg->Pos].m_Type, 
; 5563 : 			lpShop->m_item[lpMsg->Pos].m_Level,
; 5564 : 			iItemValue, Divisor) )

  00303	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00307	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0030d	8d 8d 0b ff ff
	ff		 lea	 ecx, DWORD PTR _Divisor$219162[ebp]
  00313	51		 push	 ecx
  00314	0f b6 8c 30 90
	00 00 00	 movzx	 ecx, BYTE PTR [eax+esi+144]
  0031c	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR _iItemValue$219159[ebp]
  00322	52		 push	 edx
  00323	0f b7 94 30 8e
	00 00 00	 movzx	 edx, WORD PTR [eax+esi+142]
  0032b	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _tShop$[ebp]
  00331	51		 push	 ecx
  00332	52		 push	 edx
  00333	50		 push	 eax
  00334	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemPrice@@3VItemPrice@@A ; g_ItemPrice
  00339	e8 00 00 00 00	 call	 ?GetPrice@ItemPrice@@QAE_NFGEAAKAAE@Z ; ItemPrice::GetPrice
  0033e	84 c0		 test	 al, al
  00340	75 17		 jne	 SHORT $LN49@CGBuyReque

; 5565 : 		{
; 5566 : 			
; 5567 : 		}
; 5568 : 		else
; 5569 : 		{
; 5570 : 			iItemValue = lpShop->m_item[lpMsg->Pos].m_BuyMoney;

  00342	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00346	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0034c	8b 94 31 00 01
	00 00		 mov	 edx, DWORD PTR [ecx+esi+256]
  00353	89 95 14 ff ff
	ff		 mov	 DWORD PTR _iItemValue$219159[ebp], edx
$LN49@CGBuyReque:

; 5571 : 		}
; 5572 : 
; 5573 : 		iStorePrice = iItemValue;
; 5574 : 		iStoreTaxMoney = (int)((__int64)iItemValue * (__int64)g_CastleSiegeSync.GetTaxRateStore(lpObj->m_Index) / (__int64)100);

  00359	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0035b	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _iItemValue$219159[ebp]
  00361	51		 push	 ecx
  00362	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00367	89 85 1c ff ff
	ff		 mov	 DWORD PTR _iStorePrice$219160[ebp], eax
  0036d	e8 00 00 00 00	 call	 ?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateStore
  00372	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _iItemValue$219159[ebp]
  00378	6a 00		 push	 0
  0037a	99		 cdq
  0037b	51		 push	 ecx
  0037c	52		 push	 edx
  0037d	50		 push	 eax
  0037e	e8 00 00 00 00	 call	 __allmul
  00383	6a 00		 push	 0
  00385	6a 64		 push	 100			; 00000064H
  00387	52		 push	 edx
  00388	50		 push	 eax
  00389	e8 00 00 00 00	 call	 __alldiv

; 5575 : 		iStorePrice += iStoreTaxMoney;

  0038e	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _iStorePrice$219160[ebp]
  00394	03 c8		 add	 ecx, eax
  00396	89 85 0c ff ff
	ff		 mov	 DWORD PTR _iStoreTaxMoney$219161[ebp], eax
  0039c	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _iStorePrice$219160[ebp], ecx

; 5576 : 
; 5577 : 		/*if( g_ArcaBattle.IsArcaBattleServer() && iBuyMoney > 0 )
; 5578 : 		{
; 5579 : 			iBuyMoney *= 3;
; 5580 : 		}*/
; 5581 : 			
; 5582 : 		if ( iStorePrice < 0 )
; 5583 : 			iStorePrice  = 0;
; 5584 : 
; 5585 : 		if ( iStoreTaxMoney < 0 )
; 5586 : 			iStoreTaxMoney = 0;
; 5587 : 
; 5588 : 		if ( lpObj->Money < iStorePrice )

  003a2	39 8b cc 00 00
	00		 cmp	 DWORD PTR [ebx+204], ecx

; 5589 : 			pResult.Result = -1;
; 5590 : 		else

  003a8	0f 82 0b fe ff
	ff		 jb	 $LN55@CGBuyReque

; 5591 : 		{
; 5592 : 			BOOL bNoItem = TRUE;
; 5593 : 
; 5594 : 			if ( (lpShop->m_item[lpMsg->Pos].m_Type >= ITEMGET(14,0) && lpShop->m_item[lpMsg->Pos].m_Type <= ITEMGET(14,8)) ||
; 5595 : 				 (lpShop->m_item[lpMsg->Pos].m_Type >= ITEMGET(14,35) && lpShop->m_item[lpMsg->Pos].m_Type <= ITEMGET(14,40)))

  003ae	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  003b2	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  003b8	0f b7 84 31 8e
	00 00 00	 movzx	 eax, WORD PTR [ecx+esi+142]
  003c0	ba 00 1c 00 00	 mov	 edx, 7168		; 00001c00H
  003c5	c7 85 00 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _bNoItem$219173[ebp], 1
  003cf	66 3b c2	 cmp	 ax, dx
  003d2	7c 0a		 jl	 SHORT $LN20@CGBuyReque
  003d4	ba 08 1c 00 00	 mov	 edx, 7176		; 00001c08H
  003d9	66 3b c2	 cmp	 ax, dx
  003dc	7e 1c		 jle	 SHORT $LN21@CGBuyReque
$LN20@CGBuyReque:
  003de	ba 23 1c 00 00	 mov	 edx, 7203		; 00001c23H
  003e3	66 3b c2	 cmp	 ax, dx
  003e6	0f 8c aa 00 00
	00		 jl	 $LN51@CGBuyReque
  003ec	ba 28 1c 00 00	 mov	 edx, 7208		; 00001c28H
  003f1	66 3b c2	 cmp	 ax, dx
  003f4	0f 8f 9c 00 00
	00		 jg	 $LN51@CGBuyReque
$LN21@CGBuyReque:

; 5596 : 			{
; 5597 : 				int dur = (int)lpShop->m_item[lpMsg->Pos].m_Durability;

  003fa	d9 84 31 ac 00
	00 00		 fld	 DWORD PTR [ecx+esi+172]
  00401	e8 00 00 00 00	 call	 __ftol2_sse

; 5598 : 
; 5599 : 				if ( dur == 0 )

  00406	85 c0		 test	 eax, eax
  00408	75 05		 jne	 SHORT $LN19@CGBuyReque

; 5600 : 					dur = 1;

  0040a	b8 01 00 00 00	 mov	 eax, 1
$LN19@CGBuyReque:

; 5601 : 
; 5602 : 				if ( ::gObjSearchItem(&gObj[aIndex], lpShop->m_item[lpMsg->Pos].m_Type,dur, lpShop->m_item[lpMsg->Pos].m_Level) == TRUE )

  0040f	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00413	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00419	0f bf 94 31 90
	00 00 00	 movsx	 edx, WORD PTR [ecx+esi+144]
  00421	52		 push	 edx
  00422	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv672[ebp]
  00428	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0042e	50		 push	 eax
  0042f	0f bf 84 31 8e
	00 00 00	 movsx	 eax, WORD PTR [ecx+esi+142]
  00437	50		 push	 eax
  00438	52		 push	 edx
  00439	e8 00 00 00 00	 call	 ?gObjSearchItem@@YAHPAUOBJECTSTRUCT@@HHH@Z ; gObjSearchItem
  0043e	83 c4 10	 add	 esp, 16			; 00000010H
  00441	83 f8 01	 cmp	 eax, 1
  00444	75 50		 jne	 SHORT $LN51@CGBuyReque

; 5603 : 				{
; 5604 : 					bNoItem = FALSE;
; 5605 : 					lpObj->Money -= iStorePrice;
; 5606 : 					::g_CastleSiegeSync.AddTributeMoney(iStoreTaxMoney);

  00446	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _iStoreTaxMoney$219161[ebp]
  0044c	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _iStorePrice$219160[ebp]
  00452	29 83 cc 00 00
	00		 sub	 DWORD PTR [ebx+204], eax
  00458	51		 push	 ecx
  00459	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0045e	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _bNoItem$219173[ebp], 0
  00468	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 5607 : 
; 5608 : 					if ( lpObj->Money < 0 )

  0046d	83 bb cc 00 00
	00 00		 cmp	 DWORD PTR [ebx+204], 0
  00474	7d 0a		 jge	 SHORT $LN17@CGBuyReque

; 5609 : 						lpObj->Money = 0;

  00476	c7 83 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+204], 0
$LN17@CGBuyReque:

; 5610 : 
; 5611 : 		
; 5612 : 					::GCMoneySend(aIndex, lpObj->Money);

  00480	8b 93 cc 00 00
	00		 mov	 edx, DWORD PTR [ebx+204]
  00486	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0048c	52		 push	 edx
  0048d	50		 push	 eax
  0048e	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00493	83 c4 08	 add	 esp, 8
$LN51@CGBuyReque:

; 5613 : 				}
; 5614 : 			}
; 5615 : 
; 5616 : 			if ( lpShop->m_item[lpMsg->Pos].m_Type >= ITEMGET(13,71) && lpShop->m_item[lpMsg->Pos].m_Type <= ITEMGET(13,75) )

  00496	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0049a	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  004a0	0f b7 8c 30 8e
	00 00 00	 movzx	 ecx, WORD PTR [eax+esi+142]
  004a8	ba 47 1a 00 00	 mov	 edx, 6727		; 00001a47H
  004ad	66 3b ca	 cmp	 cx, dx
  004b0	0f 8c eb 00 00
	00		 jl	 $LN5@CGBuyReque
  004b6	ba 4b 1a 00 00	 mov	 edx, 6731		; 00001a4bH
  004bb	66 3b ca	 cmp	 cx, dx
  004be	0f 8f dd 00 00
	00		 jg	 $LN5@CGBuyReque

; 5617 : 			{
; 5618 : 				bNoItem = FALSE;
; 5619 : 
; 5620 : 				if( CheckInventoryEmptySpace(lpObj,4,2) == FALSE )

  004c4	6a 02		 push	 2
  004c6	6a 04		 push	 4
  004c8	53		 push	 ebx
  004c9	e8 00 00 00 00	 call	 ?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z ; CheckInventoryEmptySpace
  004ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  004d1	85 c0		 test	 eax, eax
  004d3	75 19		 jne	 SHORT $LN15@CGBuyReque

; 5621 : 				{
; 5622 : 					MsgOutput(aIndex,"You have no enough empty space");

  004d5	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  004db	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@FPLNFNIC@You?5have?5no?5enough?5empty?5space?$AA@
  004e0	50		 push	 eax
  004e1	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  004e6	83 c4 08	 add	 esp, 8

; 5623 : 				}
; 5624 : 				else

  004e9	e9 04 02 00 00	 jmp	 $LN36@CGBuyReque
$LN15@CGBuyReque:

; 5625 : 				{
; 5626 : 					int type = -1;
; 5627 : 
; 5628 : 					switch( lpShop->m_item[lpMsg->Pos].m_Type )

  004ee	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  004f2	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  004f8	0f bf 84 31 8e
	00 00 00	 movsx	 eax, WORD PTR [ecx+esi+142]
  00500	05 b9 e5 ff ff	 add	 eax, -6727		; ffffe5b9H
  00505	83 f8 04	 cmp	 eax, 4
  00508	0f 87 e4 01 00
	00		 ja	 $LN36@CGBuyReque
  0050e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN57@CGBuyReque[eax*4]
$LN11@CGBuyReque:

; 5629 : 					{
; 5630 : 					case ITEMGET(13,71):	type = 0;	break;

  00515	33 c0		 xor	 eax, eax
  00517	eb 1a		 jmp	 SHORT $LN48@CGBuyReque
$LN10@CGBuyReque:

; 5631 : 					case ITEMGET(13,72):	type = 1;	break;

  00519	b8 01 00 00 00	 mov	 eax, 1
  0051e	eb 13		 jmp	 SHORT $LN48@CGBuyReque
$LN9@CGBuyReque:

; 5632 : 					case ITEMGET(13,73):	type = 2;	break;

  00520	b8 02 00 00 00	 mov	 eax, 2
  00525	eb 0c		 jmp	 SHORT $LN48@CGBuyReque
$LN8@CGBuyReque:

; 5633 : 					case ITEMGET(13,74):	type = 3;	break;

  00527	b8 03 00 00 00	 mov	 eax, 3
  0052c	eb 05		 jmp	 SHORT $LN48@CGBuyReque
$LN7@CGBuyReque:

; 5634 : 					case ITEMGET(13,75):	type = 4;	break;

  0052e	b8 04 00 00 00	 mov	 eax, 4
$LN48@CGBuyReque:

; 5635 : 					}
; 5636 : 
; 5637 : 					if( type != -1 )
; 5638 : 					{
; 5639 : 						if ( gGamblingEvent.BuyRequest(aIndex,236,0,0,type) == TRUE )

  00533	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00539	50		 push	 eax
  0053a	6a 00		 push	 0
  0053c	6a 00		 push	 0
  0053e	68 ec 00 00 00	 push	 236			; 000000ecH
  00543	52		 push	 edx
  00544	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGamblingEvent@@3VCGamblingEvent@@A ; gGamblingEvent
  00549	e8 00 00 00 00	 call	 ?BuyRequest@CGamblingEvent@@QAEEHEEEE@Z ; CGamblingEvent::BuyRequest
  0054e	3c 01		 cmp	 al, 1
  00550	0f 85 9c 01 00
	00		 jne	 $LN36@CGBuyReque

; 5640 : 						{
; 5641 : 							bNoItem = FALSE;
; 5642 : 							lpObj->Money -= iStorePrice;
; 5643 : 							::g_CastleSiegeSync.AddTributeMoney(iStoreTaxMoney);

  00556	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _iStoreTaxMoney$219161[ebp]
  0055c	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _iStorePrice$219160[ebp]
  00562	29 83 cc 00 00
	00		 sub	 DWORD PTR [ebx+204], eax
  00568	51		 push	 ecx
  00569	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0056e	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 5644 : 		
; 5645 : 							if ( lpObj->Money < 0 )

  00573	83 bb cc 00 00
	00 00		 cmp	 DWORD PTR [ebx+204], 0
  0057a	7d 0a		 jge	 SHORT $LN4@CGBuyReque

; 5646 : 								lpObj->Money = 0;	

  0057c	c7 83 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+204], 0
$LN4@CGBuyReque:

; 5647 : 				
; 5648 : 							::GCMoneySend(aIndex, lpObj->Money);

  00586	8b 93 cc 00 00
	00		 mov	 edx, DWORD PTR [ebx+204]
  0058c	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00592	52		 push	 edx
  00593	50		 push	 eax
  00594	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00599	83 c4 08	 add	 esp, 8

; 5649 : 						}
; 5650 : 					}
; 5651 : 				}
; 5652 : 			}
; 5653 : 
; 5654 : 			if ( bNoItem != FALSE )

  0059c	e9 51 01 00 00	 jmp	 $LN36@CGBuyReque
$LN5@CGBuyReque:
  005a1	83 bd 00 ff ff
	ff 00		 cmp	 DWORD PTR _bNoItem$219173[ebp], 0
  005a8	0f 84 44 01 00
	00		 je	 $LN36@CGBuyReque

; 5655 : 			{
; 5656 : 				pResult.Result = gObjShopBuyInventoryInsertItem(aIndex, lpShop->m_item[lpMsg->Pos]);

  005ae	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  005b4	8d b4 30 88 00
	00 00		 lea	 esi, DWORD PTR [eax+esi+136]
  005bb	8b fc		 mov	 edi, esp
  005bd	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  005c2	f3 a5		 rep movsd
  005c4	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  005ca	51		 push	 ecx
  005cb	e8 00 00 00 00	 call	 ?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjShopBuyInventoryInsertItem
  005d0	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  005d6	88 85 27 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al

; 5657 : 				
; 5658 : 				if ( pResult.Result != 0xFF )

  005dc	3c ff		 cmp	 al, 255			; 000000ffH
  005de	0f 84 0e 01 00
	00		 je	 $LN36@CGBuyReque

; 5659 : 				{
; 5660 : 					ItemByteConvert((LPBYTE)&pResult.ItemInfo, lpShop->m_item[lpMsg->Pos]);

  005e4	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  005ea	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  005ee	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _lpShop$[ebp]
  005f4	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  005fa	8d b4 08 88 00
	00 00		 lea	 esi, DWORD PTR [eax+ecx+136]
  00601	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00607	8d 95 28 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp+4]
  0060d	8b fc		 mov	 edi, esp
  0060f	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00614	52		 push	 edx
  00615	f3 a5		 rep movsd
  00617	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 5661 : 					lpObj->Money -= iStorePrice;

  0061c	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _iStorePrice$219160[ebp]

; 5662 : 					::g_CastleSiegeSync.AddTributeMoney(iStoreTaxMoney);

  00622	8b bd 0c ff ff
	ff		 mov	 edi, DWORD PTR _iStoreTaxMoney$219161[ebp]
  00628	29 83 cc 00 00
	00		 sub	 DWORD PTR [ebx+204], eax
  0062e	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00634	57		 push	 edi
  00635	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0063a	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 5663 : 
; 5664 : 					if ( lpObj->Money < 0 )

  0063f	83 bb cc 00 00
	00 00		 cmp	 DWORD PTR [ebx+204], 0
  00646	7d 0a		 jge	 SHORT $LN1@CGBuyReque

; 5665 : 						lpObj->Money = 0;

  00648	c7 83 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+204], 0
$LN1@CGBuyReque:

; 5666 : 
; 5667 : 					GCMoneySend(aIndex, lpObj->Money);

  00652	8b 8b cc 00 00
	00		 mov	 ecx, DWORD PTR [ebx+204]
  00658	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0065e	51		 push	 ecx
  0065f	52		 push	 edx
  00660	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 5668 : 					int iTaxRate = g_CastleSiegeSync.GetTaxRateStore(lpObj->m_Index);

  00665	8b 03		 mov	 eax, DWORD PTR [ebx]
  00667	83 c4 08	 add	 esp, 8
  0066a	50		 push	 eax
  0066b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00670	e8 00 00 00 00	 call	 ?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateStore

; 5669 : 
; 5670 : 					LogAddTD("[%s][%s] (%d) Shop buy [%d][%d][%d][%s] LEV:%d, DUR:%d, OP:[%d][%d][%d]",
; 5671 : 						lpObj->AccountID, lpObj->Name, tShop, iItemValue, iTaxRate, iItemValue+iStoreTaxMoney, lpShop->m_item[lpMsg->Pos].GetName(),
; 5672 : 						lpShop->m_item[lpMsg->Pos].m_Level, lpShop->m_item[lpMsg->Pos].m_Durability,
; 5673 : 						lpShop->m_item[lpMsg->Pos].m_Option1, lpShop->m_item[lpMsg->Pos].m_Option2,
; 5674 : 						lpShop->m_item[lpMsg->Pos].m_Option3);

  00675	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  0067b	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0067f	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00685	8b f0		 mov	 esi, eax
  00687	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _lpShop$[ebp]
  0068d	0f b6 8c 10 1a
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+282]
  00695	d9 84 10 ac 00
	00 00		 fld	 DWORD PTR [eax+edx+172]
  0069c	03 c2		 add	 eax, edx
  0069e	0f b6 90 19 01
	00 00		 movzx	 edx, BYTE PTR [eax+281]
  006a5	51		 push	 ecx
  006a6	0f b6 88 18 01
	00 00		 movzx	 ecx, BYTE PTR [eax+280]
  006ad	52		 push	 edx
  006ae	0f bf 90 90 00
	00 00		 movsx	 edx, WORD PTR [eax+144]
  006b5	51		 push	 ecx
  006b6	83 ec 08	 sub	 esp, 8
  006b9	8d 88 88 00 00
	00		 lea	 ecx, DWORD PTR [eax+136]
  006bf	dd 1c 24	 fstp	 QWORD PTR [esp]
  006c2	52		 push	 edx
  006c3	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  006c8	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _tShop$[ebp]
  006ce	50		 push	 eax
  006cf	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _iItemValue$219159[ebp]
  006d5	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  006d8	51		 push	 ecx
  006d9	56		 push	 esi
  006da	50		 push	 eax
  006db	52		 push	 edx
  006dc	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  006df	50		 push	 eax
  006e0	83 c3 52	 add	 ebx, 82			; 00000052H
  006e3	53		 push	 ebx
  006e4	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@
  006e9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006ef	83 c4 38	 add	 esp, 56			; 00000038H
$LN36@CGBuyReque:

; 5512 : 	{
; 5513 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  006f2	0f b6 8d 25 ff
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  006f9	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  006ff	51		 push	 ecx
  00700	8d 95 24 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00706	52		 push	 edx
  00707	50		 push	 eax
$LN54@CGBuyReque:
  00708	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0070d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN46@CGBuyReque:

; 5675 : 				}
; 5676 : 			}
; 5677 : 		}
; 5678 : 	}
; 5679 : 
; 5680 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5681 : }

  00710	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00713	5f		 pop	 edi
  00714	5e		 pop	 esi
  00715	33 cd		 xor	 ecx, ebp
  00717	5b		 pop	 ebx
  00718	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0071d	8b e5		 mov	 esp, ebp
  0071f	5d		 pop	 ebp
  00720	c3		 ret	 0
  00721	8d 49 00	 npad	 3
$LN57@CGBuyReque:
  00724	00 00 00 00	 DD	 $LN11@CGBuyReque
  00728	00 00 00 00	 DD	 $LN10@CGBuyReque
  0072c	00 00 00 00	 DD	 $LN9@CGBuyReque
  00730	00 00 00 00	 DD	 $LN8@CGBuyReque
  00734	00 00 00 00	 DD	 $LN7@CGBuyReque
?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z ENDP	; CGBuyRequestRecv
_TEXT	ENDS
PUBLIC	??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@ ; `string'
PUBLIC	??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@ ; `string'
PUBLIC	??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z	; CGSellRequestRecv
EXTRN	?ClearErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z:PROC ; CElementalSystem::ClearErtel
EXTRN	?gObjCheckMaxZen@@YAHHH@Z:PROC			; gObjCheckMaxZen
EXTRN	?PetValue@CItem@@QAEXXZ:PROC			; CItem::PetValue
EXTRN	?Value@CItem@@QAEXXZ:PROC			; CItem::Value
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?IsFullAncient@CItem@@QAEHXZ:PROC		; CItem::IsFullAncient
EXTRN	?gc_bBlockFullAncient@@3HA:DWORD		; gc_bBlockFullAncient
EXTRN	?IsFullExcellent@CItem@@QAE_NXZ:PROC		; CItem::IsFullExcellent
EXTRN	?gc_bBlockFullExcellent@@3HA:DWORD		; gc_bBlockFullExcellent
;	COMDAT ??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@
CONST	SEGMENT
??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@ DB 'ID:%s CharID:%s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@
CONST	SEGMENT
??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [Sell Item] (%s)(%s) Item(%s) Pos(%'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@
CONST	SEGMENT
??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@ DB '['
	DB	'%s][%s] CGSellRequestRecv() Failed : Transaction == 1, IF_TYP'
	DB	'E : %d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z
_TEXT	SEGMENT
_tShop$ = -36						; size = 4
_iAddZen$219273 = -32					; size = 4
_Divisor$219275 = -25					; size = 1
_aIndex$GSCopy$ = -24					; size = 4
_pResult$ = -20						; size = 8
_NewOption$219272 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z PROC	; CGSellRequestRecv, COMDAT

; 5697 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 5698 : 	PMSG_SELLRESULT pResult;
; 5699 : 	LPOBJ lpObj = &gObj[aIndex];

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00019	56		 push	 esi

; 5887 : 		}
; 5888 : 
; 5889 : 		lpObj->Money += iAddZen;

  0001a	89 5d e8	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0001d	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00023	57		 push	 edi
  00024	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00027	6a 08		 push	 8
  00029	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0002c	6a 33		 push	 51			; 00000033H
  0002e	51		 push	 ecx
  0002f	8d 34 03	 lea	 esi, DWORD PTR [ebx+eax]
  00032	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	c6 45 ef 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  00044	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
  0004b	80 7c 13 0d ff	 cmp	 BYTE PTR [ebx+edx+13], -1
  00050	74 12		 je	 SHORT $LN34@CGSellRequ
$LN41@CGSellRequ:

; 5700 : 
; 5701 : 	PHeadSetB((LPBYTE)&pResult, 0x33, sizeof(pResult));
; 5702 : 	pResult.Result = false;
; 5703 : 	pResult.Money = 0;
; 5704 : 
; 5705 : 	if ( gObj[aIndex].CloseType != -1 )
; 5706 : 	{
; 5707 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00052	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00056	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00059	50		 push	 eax
  0005a	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0005d	51		 push	 ecx
  0005e	52		 push	 edx

; 5708 : 		return;

  0005f	e9 a7 05 00 00	 jmp	 $LN37@CGSellRequ
$LN34@CGSellRequ:

; 5709 : 	}
; 5710 : 
; 5711 : 	if ( lpObj->m_IfState.use > 0 && lpObj->m_IfState.type != 3 )

  00064	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  0006a	a8 03		 test	 al, 3
  0006c	76 0c		 jbe	 SHORT $LN33@CGSellRequ
  0006e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00073	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H

; 5712 : 	{
; 5713 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5714 : 		return;

  00078	75 d8		 jne	 SHORT $LN41@CGSellRequ
$LN33@CGSellRequ:

; 5715 : 	}
; 5716 : 
; 5717 : 	if ( !PacketCheckTime(lpObj))

  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00080	83 c4 04	 add	 esp, 4
  00083	85 c0		 test	 eax, eax

; 5718 : 	{
; 5719 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5720 : 		return;

  00085	74 cb		 je	 SHORT $LN41@CGSellRequ

; 5721 : 	}
; 5722 : 
; 5723 : 	if ( !::gObjFixInventoryPointer(aIndex))

  00087	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00090	83 c4 04	 add	 esp, 4
  00093	84 c0		 test	 al, al
  00095	75 18		 jne	 SHORT $LN31@CGSellRequ

; 5724 : 	{
; 5725 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  00097	68 5d 16 00 00	 push	 5725			; 0000165dH
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@CGSellRequ:

; 5726 : 	}
; 5727 : 
; 5728 : 	if ( gObj[aIndex].pTransaction == 1 )

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b4	80 bc 03 cc 11
	00 00 01	 cmp	 BYTE PTR [ebx+eax+4556], 1
  000bc	75 3a		 jne	 SHORT $LN30@CGSellRequ

; 5729 : 	{
; 5730 : 		LogAddTD("[%s][%s] CGSellRequestRecv() Failed : Transaction == 1, IF_TYPE : %d",
; 5731 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  000be	8b 8c 03 b8 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4536]
  000c5	c1 e9 06	 shr	 ecx, 6
  000c8	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  000ce	51		 push	 ecx
  000cf	8d 54 03 5d	 lea	 edx, DWORD PTR [ebx+eax+93]
  000d3	52		 push	 edx
  000d4	8d 44 03 52	 lea	 eax, DWORD PTR [ebx+eax+82]
  000d8	50		 push	 eax
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e4	83 c4 10	 add	 esp, 16			; 00000010H
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 5913 : 	}
; 5914 : 
; 5915 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5916 : }

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ed	33 cd		 xor	 ecx, ebp
  000ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
$LN30@CGSellRequ:

; 5732 : 
; 5733 : 		return;
; 5734 : 	}
; 5735 : 
; 5736 : 	int tShop = lpObj->TargetShopNumber;

  000f8	0f bf 86 3a 06
	00 00		 movsx	 eax, WORD PTR [esi+1594]
  000ff	89 45 dc	 mov	 DWORD PTR _tShop$[ebp], eax

; 5737 : 
; 5738 : 	if ( tShop < 0 || tShop > MAX_SHOP-1 )

  00102	3d f3 01 00 00	 cmp	 eax, 499		; 000001f3H
  00107	0f 87 f1 04 00
	00		 ja	 $LN28@CGSellRequ

; 5741 : 		return;
; 5742 : 	}
; 5743 : 
; 5744 : 	if ( !gObjCanItemTouch(lpObj, 3))

  0010d	6a 03		 push	 3
  0010f	56		 push	 esi
  00110	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  00115	83 c4 08	 add	 esp, 8
  00118	85 c0		 test	 eax, eax

; 5745 : 	{
; 5746 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5747 : 		return;

  0011a	0f 84 de 04 00
	00		 je	 $LN28@CGSellRequ

; 5748 : 	}
; 5749 : 
; 5750 : 	if ( lpMsg->Pos > MAIN_INVENTORY_SIZE-1 )

  00120	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00123	3c cb		 cmp	 al, 203			; 000000cbH
  00125	76 44		 jbe	 SHORT $LN26@CGSellRequ

; 5751 : 	{
; 5752 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00127	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  0012b	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0012e	51		 push	 ecx
  0012f	8d 55 ec	 lea	 edx, DWORD PTR _pResult$[ebp]
  00132	52		 push	 edx
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5753 : 		LogAdd(lMsg.Get(MSGGET(1, 227)), lpMsg->Pos);

  00139	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	51		 push	 ecx
  00141	68 e3 01 00 00	 push	 483			; 000001e3H
  00146	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0014b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00150	50		 push	 eax
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00157	83 c4 08	 add	 esp, 8
  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx

; 5913 : 	}
; 5914 : 
; 5915 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5916 : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN26@CGSellRequ:

; 5754 : 		return;
; 5755 : 	}
; 5756 : 
; 5757 : 	if ( gObjCheckSerial0ItemList(&lpObj->pInventory[lpMsg->Pos]) != FALSE )

  0016b	0f b6 d0	 movzx	 edx, al
  0016e	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00174	03 96 c0 11 00
	00		 add	 edx, DWORD PTR [esi+4544]
  0017a	52		 push	 edx
  0017b	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00180	83 c4 04	 add	 esp, 4
  00183	85 c0		 test	 eax, eax
  00185	74 69		 je	 SHORT $LN25@CGSellRequ

; 5758 : 	{
; 5759 : 		MsgOutput(aIndex, lMsg.Get(MSGGET(13, 26)));

  00187	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  0018c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00191	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00196	8b 5d e8	 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  00199	50		 push	 eax
  0019a	53		 push	 ebx
  0019b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 5760 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001a0	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001a4	50		 push	 eax
  001a5	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001a8	51		 push	 ecx
  001a9	53		 push	 ebx
  001aa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5761 : 
; 5762 : 		LogAddTD("[ANTI-HACK][Serial 0 Item] [Sell Item] (%s)(%s) Item(%s) Pos(%d)",
; 5763 : 			lpObj->AccountID, lpObj->Name, lpObj->pInventory[lpMsg->Pos].GetName(), lpMsg->Pos);

  001af	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  001b3	83 c4 14	 add	 esp, 20			; 00000014H
  001b6	51		 push	 ecx
  001b7	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  001bd	03 8e c0 11 00
	00		 add	 ecx, DWORD PTR [esi+4544]
  001c3	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  001c8	50		 push	 eax
  001c9	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  001cc	52		 push	 edx
  001cd	83 c6 52	 add	 esi, 82			; 00000052H
  001d0	56		 push	 esi
  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@
  001d6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001dc	83 c4 14	 add	 esp, 20			; 00000014H
  001df	5f		 pop	 edi
  001e0	5e		 pop	 esi
  001e1	5b		 pop	 ebx

; 5913 : 	}
; 5914 : 
; 5915 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5916 : }

  001e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e5	33 cd		 xor	 ecx, ebp
  001e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c3		 ret	 0
$LN25@CGSellRequ:

; 5764 : 
; 5765 : 		return;
; 5766 : 	}
; 5767 : 
; 5768 : 	if (gc_bBlockFullExcellent == 1) {

  001f0	bb 01 00 00 00	 mov	 ebx, 1
  001f5	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?gc_bBlockFullExcellent@@3HA, ebx ; gc_bBlockFullExcellent
  001fb	75 1d		 jne	 SHORT $LN23@CGSellRequ

; 5769 : 		if (lpObj->pInventory[lpMsg->Pos].IsFullExcellent()) {

  001fd	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00201	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00207	03 8e c0 11 00
	00		 add	 ecx, DWORD PTR [esi+4544]
  0020d	e8 00 00 00 00	 call	 ?IsFullExcellent@CItem@@QAE_NXZ ; CItem::IsFullExcellent
  00212	84 c0		 test	 al, al

; 5770 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5771 : 			return;

  00214	0f 85 38 fe ff
	ff		 jne	 $LN41@CGSellRequ
$LN23@CGSellRequ:

; 5772 : 		}
; 5773 : 	}
; 5774 : 
; 5775 : 	if (gc_bBlockFullAncient == 1) {

  0021a	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?gc_bBlockFullAncient@@3HA, ebx ; gc_bBlockFullAncient
  00220	75 1d		 jne	 SHORT $LN21@CGSellRequ

; 5776 : 		if (lpObj->pInventory[lpMsg->Pos].IsFullAncient()) {

  00222	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00226	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0022c	03 8e c0 11 00
	00		 add	 ecx, DWORD PTR [esi+4544]
  00232	e8 00 00 00 00	 call	 ?IsFullAncient@CItem@@QAEHXZ ; CItem::IsFullAncient
  00237	85 c0		 test	 eax, eax

; 5777 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5778 : 			return;

  00239	0f 85 13 fe ff
	ff		 jne	 $LN41@CGSellRequ
$LN21@CGSellRequ:

; 5779 : 		}
; 5780 : 	}
; 5781 : 
; 5782 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,11) ) // Box of Luck

  0023f	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00243	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00249	03 86 c0 11 00
	00		 add	 eax, DWORD PTR [esi+4544]
  0024f	ba 0b 1c 00 00	 mov	 edx, 7179		; 00001c0bH
  00254	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00258	66 3b ca	 cmp	 cx, dx

; 5783 : 	{
; 5784 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5785 : 		return;

  0025b	0f 84 f1 fd ff
	ff		 je	 $LN41@CGSellRequ

; 5786 : 	}
; 5787 : 
; 5788 : 	if ( lpObj->pInventory[lpMsg->Pos].m_QuestItem != false) 

  00261	80 b8 a9 00 00
	00 00		 cmp	 BYTE PTR [eax+169], 0

; 5789 : 	{
; 5790 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5791 : 		return;

  00268	0f 85 e4 fd ff
	ff		 jne	 $LN41@CGSellRequ

; 5792 : 	}
; 5793 : 
; 5794 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,20) && lpObj->pInventory[lpMsg->Pos].m_Level == 1) // Wizards Ring +1

  0026e	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  00273	66 3b ca	 cmp	 cx, dx
  00276	75 1a		 jne	 SHORT $LN17@CGSellRequ
  00278	66 39 58 08	 cmp	 WORD PTR [eax+8], bx

; 5795 : 	{
; 5796 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5797 : 		return;

  0027c	0f 84 d0 fd ff
	ff		 je	 $LN41@CGSellRequ

; 5798 : 	}
; 5799 : 
; 5800 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,20) && lpObj->pInventory[lpMsg->Pos].m_Level == 2) // Wizards Ring +2

  00282	66 3b ca	 cmp	 cx, dx
  00285	75 0b		 jne	 SHORT $LN17@CGSellRequ
  00287	66 83 78 08 02	 cmp	 WORD PTR [eax+8], 2

; 5801 : 	{
; 5802 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5803 : 		return;

  0028c	0f 84 c0 fd ff
	ff		 je	 $LN41@CGSellRequ
$LN17@CGSellRequ:

; 5804 : 	}
; 5805 : 
; 5806 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(12,26) &&
; 5807 : 		(lpObj->pInventory[lpMsg->Pos].m_Level == 1 ||
; 5808 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 2 || 
; 5809 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 3 || 
; 5810 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 4 || 
; 5811 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 5 ))

  00292	ba 1a 18 00 00	 mov	 edx, 6170		; 0000181aH
  00297	66 3b ca	 cmp	 cx, dx
  0029a	75 35		 jne	 SHORT $LN16@CGSellRequ
  0029c	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  002a0	66 3b cb	 cmp	 cx, bx
  002a3	0f 84 a9 fd ff
	ff		 je	 $LN41@CGSellRequ
  002a9	66 83 f9 02	 cmp	 cx, 2
  002ad	0f 84 9f fd ff
	ff		 je	 $LN41@CGSellRequ
  002b3	66 83 f9 03	 cmp	 cx, 3
  002b7	0f 84 95 fd ff
	ff		 je	 $LN41@CGSellRequ
  002bd	66 83 f9 04	 cmp	 cx, 4
  002c1	0f 84 8b fd ff
	ff		 je	 $LN41@CGSellRequ
  002c7	66 83 f9 05	 cmp	 cx, 5

; 5812 : 	{
; 5813 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5814 : 		return;

  002cb	0f 84 81 fd ff
	ff		 je	 $LN41@CGSellRequ
$LN16@CGSellRequ:

; 5815 : 	}
; 5816 : 
; 5817 : 	if ( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony(&lpObj->pInventory[lpMsg->Pos]) == TRUE )

  002d1	50		 push	 eax
  002d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  002d7	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  002dc	3b c3		 cmp	 eax, ebx
  002de	75 3f		 jne	 SHORT $LN14@CGSellRequ

; 5818 : 	{
; 5819 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 37)), lpObj->m_Index, 1);

  002e0	8b 06		 mov	 eax, DWORD PTR [esi]
  002e2	53		 push	 ebx
  002e3	50		 push	 eax
  002e4	68 25 0d 00 00	 push	 3365			; 00000d25H
  002e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  002ee	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  002f3	50		 push	 eax
  002f4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 5820 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  002f9	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  002fd	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00300	51		 push	 ecx
  00301	8d 55 ec	 lea	 edx, DWORD PTR _pResult$[ebp]
  00304	52		 push	 edx
  00305	50		 push	 eax
  00306	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0030b	83 c4 18	 add	 esp, 24			; 00000018H
  0030e	5f		 pop	 edi
  0030f	5e		 pop	 esi
  00310	5b		 pop	 ebx

; 5913 : 	}
; 5914 : 
; 5915 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5916 : }

  00311	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00314	33 cd		 xor	 ecx, ebp
  00316	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031b	8b e5		 mov	 esp, ebp
  0031d	5d		 pop	 ebp
  0031e	c3		 ret	 0
$LN14@CGSellRequ:

; 5821 : 		return;
; 5822 : 	}
; 5823 : 
; 5824 : 	if ( IsCashItem(lpObj->pInventory[lpMsg->Pos].m_Type) == TRUE 
; 5825 : 		&& !lpObj->pInventory[lpMsg->Pos].m_bExpired )

  0031f	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00323	8b 96 c0 11 00
	00		 mov	 edx, DWORD PTR [esi+4544]
  00329	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0032f	0f bf 44 11 06	 movsx	 eax, WORD PTR [ecx+edx+6]
  00334	50		 push	 eax
  00335	e8 00 00 00 00	 call	 ?IsCashItem@@YAHH@Z	; IsCashItem
  0033a	83 c4 04	 add	 esp, 4
  0033d	3b c3		 cmp	 eax, ebx
  0033f	75 1e		 jne	 SHORT $LN13@CGSellRequ
  00341	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00345	8b 96 c0 11 00
	00		 mov	 edx, DWORD PTR [esi+4544]
  0034b	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00351	80 bc 11 d0 00
	00 00 00	 cmp	 BYTE PTR [ecx+edx+208], 0

; 5826 : 	{
; 5827 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5828 : 		return;

  00359	0f 84 f3 fc ff
	ff		 je	 $LN41@CGSellRequ
$LN13@CGSellRequ:

; 5829 : 	}
; 5830 : 
; 5831 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,12) && lpObj->pInventory[lpMsg->Pos].m_Level == 1) // Heart+1

  0035f	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00363	8b c8		 mov	 ecx, eax
  00365	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0036b	03 8e c0 11 00
	00		 add	 ecx, DWORD PTR [esi+4544]
  00371	ba 0c 1c 00 00	 mov	 edx, 7180		; 00001c0cH
  00376	66 39 51 06	 cmp	 WORD PTR [ecx+6], dx
  0037a	75 48		 jne	 SHORT $LN12@CGSellRequ
  0037c	66 39 59 08	 cmp	 WORD PTR [ecx+8], bx
  00380	75 42		 jne	 SHORT $LN12@CGSellRequ

; 5832 : 	{
; 5833 : 		pResult.Result = true;

  00382	88 5d ef	 mov	 BYTE PTR _pResult$[ebp+3], bl

; 5834 : 		pResult.Money = lpObj->Money;

  00385	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]

; 5835 : 		gObjInventoryItemSet(aIndex, lpMsg->Pos, -1);

  0038b	8b 5d e8	 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  0038e	68 ff 00 00 00	 push	 255			; 000000ffH
  00393	50		 push	 eax
  00394	53		 push	 ebx
  00395	89 4d f0	 mov	 DWORD PTR _pResult$[ebp+4], ecx
  00398	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 5836 : 		lpObj->pInventory[lpMsg->Pos].Clear();

  0039d	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  003a1	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  003a7	03 8e c0 11 00
	00		 add	 ecx, DWORD PTR [esi+4544]
  003ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b0	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 5837 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  003b5	0f b6 55 ed	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  003b9	52		 push	 edx
  003ba	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  003bd	50		 push	 eax
  003be	53		 push	 ebx

; 5838 : 
; 5839 : 		return;

  003bf	e9 47 02 00 00	 jmp	 $LN37@CGSellRequ
$LN12@CGSellRequ:

; 5840 : 	}
; 5841 : 
; 5842 : #if ( __CUSTOM__ == 1)
; 5843 : 
; 5844 : 	if ( lpObj->pInventory[lpMsg->Pos].m_bLOCKED )

  003c4	80 b9 d1 00 00
	00 00		 cmp	 BYTE PTR [ecx+209], 0
  003cb	74 07		 je	 SHORT $LN11@CGSellRequ

; 5845 : 	{
; 5846 : 		DataSend(lpObj->m_Index,(LPBYTE)&pResult,pResult.h.size);

  003cd	8b 06		 mov	 eax, DWORD PTR [esi]

; 5847 : 		return;

  003cf	e9 2d 02 00 00	 jmp	 $LN39@CGSellRequ
$LN11@CGSellRequ:

; 5848 : 	}
; 5849 : 
; 5850 : #endif
; 5851 : 
; 5852 : 	if ( lpObj->pInventory[lpMsg->Pos].IsItem() == FALSE )

  003d4	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003d9	85 c0		 test	 eax, eax
  003db	75 5f		 jne	 SHORT $LN10@CGSellRequ

; 5853 : 	{
; 5854 : 		pResult.Result = false;
; 5855 : 		pResult.Money = lpObj->Money;
; 5856 : 		LogAdd(lMsg.Get(MSGGET(1, 228)), __FILE__, __LINE__, lpObj->Name, lpMsg->Pos);

  003dd	0f b6 57 03	 movzx	 edx, BYTE PTR [edi+3]
  003e1	52		 push	 edx
  003e2	8d 5e 5d	 lea	 ebx, DWORD PTR [esi+93]
  003e5	53		 push	 ebx
  003e6	68 e0 16 00 00	 push	 5856			; 000016e0H
  003eb	88 45 ef	 mov	 BYTE PTR _pResult$[ebp+3], al
  003ee	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  003f4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  003f9	89 4d f0	 mov	 DWORD PTR _pResult$[ebp+4], ecx
  003fc	68 e4 01 00 00	 push	 484			; 000001e4H
  00401	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00406	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0040b	50		 push	 eax
  0040c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 5857 : 		LogAdd("ID:%s CharID:%s ", lpObj->AccountID, lpObj->Name);

  00412	53		 push	 ebx
  00413	83 c6 52	 add	 esi, 82			; 00000052H
  00416	56		 push	 esi
  00417	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@
  0041c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 5858 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00422	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00426	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00429	50		 push	 eax
  0042a	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0042d	51		 push	 ecx
  0042e	52		 push	 edx
  0042f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00434	83 c4 2c	 add	 esp, 44			; 0000002cH

; 5859 : 
; 5860 : 	}
; 5861 : 	else

  00437	e9 c2 01 00 00	 jmp	 $LN28@CGSellRequ
$LN10@CGSellRequ:

; 5862 : 	{
; 5863 : 		BYTE NewOption[MAX_EXOPTION_SIZE];
; 5864 : 		DWORD iAddZen = 0;
; 5865 : 		int type = lpObj->pInventory[lpMsg->Pos].m_Type;

  0043c	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00440	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00446	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0044c	03 c8		 add	 ecx, eax
  0044e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iAddZen$219273[ebp], 0
  00455	0f bf 59 06	 movsx	 ebx, WORD PTR [ecx+6]

; 5866 : 		BYTE Divisor;
; 5867 : 
; 5868 : 		if ( type == ITEMGET(13,4) || type == ITEMGET(13,5)) // Pets

  00459	81 fb 04 1a 00
	00		 cmp	 ebx, 6660		; 00001a04H
  0045f	74 0f		 je	 SHORT $LN7@CGSellRequ
  00461	81 fb 05 1a 00
	00		 cmp	 ebx, 6661		; 00001a05H
  00467	74 07		 je	 SHORT $LN7@CGSellRequ

; 5870 : 		else
; 5871 : 			lpObj->pInventory[lpMsg->Pos].Value();

  00469	e8 00 00 00 00	 call	 ?Value@CItem@@QAEXXZ	; CItem::Value
  0046e	eb 05		 jmp	 SHORT $LN6@CGSellRequ
$LN7@CGSellRequ:

; 5869 : 			lpObj->pInventory[lpMsg->Pos].PetValue();

  00470	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue
$LN6@CGSellRequ:

; 5872 : 
; 5873 : 		
; 5874 : 		if( g_ItemPrice.GetPrice(tShop, type, lpObj->pInventory[lpMsg->Pos].m_Level, iAddZen, Divisor) )

  00475	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00479	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0047f	8d 55 e7	 lea	 edx, DWORD PTR _Divisor$219275[ebp]
  00482	52		 push	 edx
  00483	8b 96 c0 11 00
	00		 mov	 edx, DWORD PTR [esi+4544]
  00489	8d 45 e0	 lea	 eax, DWORD PTR _iAddZen$219273[ebp]
  0048c	50		 push	 eax
  0048d	0f b6 44 11 08	 movzx	 eax, BYTE PTR [ecx+edx+8]
  00492	8b 4d dc	 mov	 ecx, DWORD PTR _tShop$[ebp]
  00495	50		 push	 eax
  00496	53		 push	 ebx
  00497	51		 push	 ecx
  00498	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemPrice@@3VItemPrice@@A ; g_ItemPrice
  0049d	e8 00 00 00 00	 call	 ?GetPrice@ItemPrice@@QAE_NFGEAAKAAE@Z ; ItemPrice::GetPrice
  004a2	84 c0		 test	 al, al
  004a4	74 0d		 je	 SHORT $LN5@CGSellRequ

; 5875 : 		{
; 5876 : 			iAddZen /= Divisor;

  004a6	0f b6 4d e7	 movzx	 ecx, BYTE PTR _Divisor$219275[ebp]
  004aa	8b 45 e0	 mov	 eax, DWORD PTR _iAddZen$219273[ebp]
  004ad	33 d2		 xor	 edx, edx
  004af	f7 f1		 div	 ecx

; 5877 : 		}
; 5878 : 		else

  004b1	eb 14		 jmp	 SHORT $LN40@CGSellRequ
$LN5@CGSellRequ:

; 5879 : 		{
; 5880 : 			iAddZen = lpObj->pInventory[lpMsg->Pos].m_SellMoney;

  004b3	0f b6 57 03	 movzx	 edx, BYTE PTR [edi+3]
  004b7	8b 86 c0 11 00
	00		 mov	 eax, DWORD PTR [esi+4544]
  004bd	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  004c3	8b 44 02 74	 mov	 eax, DWORD PTR [edx+eax+116]
$LN40@CGSellRequ:

; 5881 : 		}
; 5882 : 
; 5883 : 		if ( gObjCheckMaxZen(aIndex, iAddZen) == FALSE )

  004c7	8b 5d e8	 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  004ca	50		 push	 eax
  004cb	53		 push	 ebx
  004cc	89 45 e0	 mov	 DWORD PTR _iAddZen$219273[ebp], eax
  004cf	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  004d4	83 c4 08	 add	 esp, 8
  004d7	85 c0		 test	 eax, eax
  004d9	75 0f		 jne	 SHORT $LN3@CGSellRequ

; 5884 : 		{
; 5885 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  004db	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  004df	51		 push	 ecx
  004e0	8d 55 ec	 lea	 edx, DWORD PTR _pResult$[ebp]
  004e3	52		 push	 edx
  004e4	53		 push	 ebx

; 5886 : 			return;

  004e5	e9 21 01 00 00	 jmp	 $LN37@CGSellRequ
$LN3@CGSellRequ:

; 5887 : 		}
; 5888 : 
; 5889 : 		lpObj->Money += iAddZen;

  004ea	8b 45 e0	 mov	 eax, DWORD PTR _iAddZen$219273[ebp]
  004ed	01 86 cc 00 00
	00		 add	 DWORD PTR [esi+204], eax

; 5890 : 		pResult.Result =true;
; 5891 : 		pResult.Money = lpObj->Money;
; 5892 : 		
; 5893 : 		ItemIsBufExOption(NewOption, &lpObj->pInventory[lpMsg->Pos]);

  004f3	0f b6 57 03	 movzx	 edx, BYTE PTR [edi+3]
  004f7	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  004fd	c6 45 ef 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00501	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  00507	89 4d f0	 mov	 DWORD PTR _pResult$[ebp+4], ecx
  0050a	03 96 c0 11 00
	00		 add	 edx, DWORD PTR [esi+4544]
  00510	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$219272[ebp]
  00513	52		 push	 edx
  00514	50		 push	 eax
  00515	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 5894 : 
; 5895 : 		LogAddTD(lMsg.Get(MSGGET(1, 229)), lpObj->AccountID, lpObj->Name, tShop,
; 5896 : 			iAddZen, lpObj->pInventory[lpMsg->Pos].GetName(), 
; 5897 : 			lpObj->pInventory[lpMsg->Pos].m_Level, lpObj->pInventory[lpMsg->Pos].m_Option1,
; 5898 : 			lpObj->pInventory[lpMsg->Pos].m_Option2, lpObj->pInventory[lpMsg->Pos].m_Option3,
; 5899 : 			lpObj->pInventory[lpMsg->Pos].m_Number, (int)lpObj->pInventory[lpMsg->Pos].m_Durability,
; 5900 : 			NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], 
; 5901 : 			lpObj->pInventory[lpMsg->Pos].m_SetOption);

  0051a	0f b6 5f 03	 movzx	 ebx, BYTE PTR [edi+3]
  0051e	0f b6 4d fa	 movzx	 ecx, BYTE PTR _NewOption$219272[ebp+6]
  00522	69 db d4 00 00
	00		 imul	 ebx, 212		; 000000d4H
  00528	03 9e c0 11 00
	00		 add	 ebx, DWORD PTR [esi+4544]
  0052e	0f b6 55 f9	 movzx	 edx, BYTE PTR _NewOption$219272[ebp+5]
  00532	0f b6 83 aa 00
	00 00		 movzx	 eax, BYTE PTR [ebx+170]
  00539	d9 43 24	 fld	 DWORD PTR [ebx+36]
  0053c	83 c4 08	 add	 esp, 8
  0053f	50		 push	 eax
  00540	0f b6 45 f8	 movzx	 eax, BYTE PTR _NewOption$219272[ebp+4]
  00544	51		 push	 ecx
  00545	0f b6 4d f7	 movzx	 ecx, BYTE PTR _NewOption$219272[ebp+3]
  00549	52		 push	 edx
  0054a	0f b6 55 f6	 movzx	 edx, BYTE PTR _NewOption$219272[ebp+2]
  0054e	50		 push	 eax
  0054f	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$219272[ebp+1]
  00553	51		 push	 ecx
  00554	0f b6 4d f4	 movzx	 ecx, BYTE PTR _NewOption$219272[ebp]
  00558	52		 push	 edx
  00559	50		 push	 eax
  0055a	51		 push	 ecx
  0055b	e8 00 00 00 00	 call	 __ftol2_sse
  00560	8b 13		 mov	 edx, DWORD PTR [ebx]
  00562	0f b6 8b 91 00
	00 00		 movzx	 ecx, BYTE PTR [ebx+145]
  00569	50		 push	 eax
  0056a	0f b6 83 92 00
	00 00		 movzx	 eax, BYTE PTR [ebx+146]
  00571	52		 push	 edx
  00572	0f b6 93 90 00
	00 00		 movzx	 edx, BYTE PTR [ebx+144]
  00579	50		 push	 eax
  0057a	0f bf 43 08	 movsx	 eax, WORD PTR [ebx+8]
  0057e	51		 push	 ecx
  0057f	52		 push	 edx
  00580	50		 push	 eax
  00581	8b cb		 mov	 ecx, ebx
  00583	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00588	8b 4d e0	 mov	 ecx, DWORD PTR _iAddZen$219273[ebp]
  0058b	8b 55 dc	 mov	 edx, DWORD PTR _tShop$[ebp]
  0058e	50		 push	 eax
  0058f	51		 push	 ecx
  00590	52		 push	 edx
  00591	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00594	50		 push	 eax
  00595	8d 4e 52	 lea	 ecx, DWORD PTR [esi+82]
  00598	51		 push	 ecx
  00599	68 e5 01 00 00	 push	 485			; 000001e5H
  0059e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  005a3	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  005a8	50		 push	 eax
  005a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5902 : 
; 5903 : 
; 5904 : 		g_ElementalSystem.ClearErtel(lpObj,&lpObj->pInventory[lpMsg->Pos]);

  005af	0f b6 57 03	 movzx	 edx, BYTE PTR [edi+3]
  005b3	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  005b9	03 96 c0 11 00
	00		 add	 edx, DWORD PTR [esi+4544]
  005bf	83 c4 50	 add	 esp, 80			; 00000050H
  005c2	52		 push	 edx
  005c3	56		 push	 esi
  005c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  005c9	e8 00 00 00 00	 call	 ?ClearErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z ; CElementalSystem::ClearErtel

; 5905 : 		::gObjInventoryDeleteItem(aIndex, lpMsg->Pos);

  005ce	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  005d2	8b 75 e8	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  005d5	50		 push	 eax
  005d6	56		 push	 esi
  005d7	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5906 : 
; 5907 : 		if ( lpMsg->Pos == 10 || lpMsg->Pos == 11 )

  005dc	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  005df	83 c4 08	 add	 esp, 8
  005e2	3c 0a		 cmp	 al, 10			; 0000000aH
  005e4	74 04		 je	 SHORT $LN1@CGSellRequ
  005e6	3c 0b		 cmp	 al, 11			; 0000000bH
  005e8	75 0b		 jne	 SHORT $LN2@CGSellRequ
$LN1@CGSellRequ:

; 5908 : 		{
; 5909 : 			::gObjUseSkill.SkillChangeUse(aIndex);

  005ea	56		 push	 esi
  005eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  005f0	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN2@CGSellRequ:

; 5910 : 		}
; 5911 : 
; 5912 : 		::gObjMakePreviewCharSet(aIndex);

  005f5	56		 push	 esi
  005f6	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  005fb	83 c4 04	 add	 esp, 4
$LN28@CGSellRequ:

; 5739 : 	{
; 5740 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  005fe	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
$LN39@CGSellRequ:
  00601	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00605	51		 push	 ecx
  00606	8d 55 ec	 lea	 edx, DWORD PTR _pResult$[ebp]
  00609	52		 push	 edx
  0060a	50		 push	 eax
$LN37@CGSellRequ:
  0060b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5913 : 	}
; 5914 : 
; 5915 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5916 : }

  00610	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00613	83 c4 0c	 add	 esp, 12			; 0000000cH
  00616	5f		 pop	 edi
  00617	5e		 pop	 esi
  00618	33 cd		 xor	 ecx, ebp
  0061a	5b		 pop	 ebx
  0061b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00620	8b e5		 mov	 esp, ebp
  00622	5d		 pop	 ebp
  00623	c3		 ret	 0
?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z ENDP	; CGSellRequestRecv
_TEXT	ENDS
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@00000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z	; GetNeedMoneyItemDurRepaire
EXTRN	?GetAllRepairItemRate@@YAMH@Z:PROC		; GetAllRepairItemRate
EXTRN	?HasItemDurability@@YAHH@Z:PROC			; HasItemDurability
EXTRN	__CIsqrt:PROC
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z
_TEXT	SEGMENT
tv256 = -16						; size = 8
_lc6$219300 = -8					; size = 4
_ItemDurability$ = -4					; size = 4
tv235 = 8						; size = 4
tv232 = 8						; size = 4
tv229 = 8						; size = 4
tv226 = 8						; size = 4
_lc7$219301 = 8						; size = 4
_lc4$219297 = 8						; size = 4
_lc5$219298 = 8						; size = 4
_DurItem$ = 8						; size = 4
_RequestPos$ = 12					; size = 4
?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z PROC	; GetNeedMoneyItemDurRepaire, COMDAT

; 5921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 5922 : 	int iMoney = 0;
; 5923 : 	int type = DurItem->m_Type;

  00007	8b 75 08	 mov	 esi, DWORD PTR _DurItem$[ebp]

; 5924 : 	float ItemDurability = DurItem->m_Durability;

  0000a	d9 46 24	 fld	 DWORD PTR [esi+36]
  0000d	57		 push	 edi
  0000e	0f bf 7e 06	 movsx	 edi, WORD PTR [esi+6]
  00012	d9 5d fc	 fstp	 DWORD PTR _ItemDurability$[ebp]

; 5925 : 	float BaseDurability = DurItem->m_BaseDurability;
; 5926 : 
; 5927 : 	if ( type == ITEMGET(13,10) ) // Transformation Ring

  00015	81 ff 0a 1a 00
	00		 cmp	 edi, 6666		; 00001a0aH

; 5928 : 		return 0;

  0001b	74 30		 je	 SHORT $LN28@GetNeedMon

; 5929 : 
; 5930 : 	if ( ::HasItemDurability(type ) != FALSE )

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ?HasItemDurability@@YAHH@Z ; HasItemDurability
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	0f 84 78 01 00
	00		 je	 $LN18@GetNeedMon

; 5931 : 	{
; 5932 : 		float lc4;
; 5933 : 		float lc5 = 0;
; 5934 : 		lc4 = DurItem->m_BaseDurability;

  0002e	d9 46 2c	 fld	 DWORD PTR [esi+44]
  00031	d9 5d 08	 fstp	 DWORD PTR _lc4$219297[ebp]

; 5935 : 
; 5936 : 		if ( ItemDurability == lc4 )

  00034	d9 45 fc	 fld	 DWORD PTR _ItemDurability$[ebp]
  00037	d9 c0		 fld	 ST(0)
  00039	d9 45 08	 fld	 DWORD PTR _lc4$219297[ebp]
  0003c	d9 c0		 fld	 ST(0)
  0003e	dd ea		 fucomp	 ST(2)
  00040	df e0		 fnstsw	 ax
  00042	dd d9		 fstp	 ST(1)
  00044	f6 c4 44	 test	 ah, 68			; 00000044H
  00047	7a 0c		 jp	 SHORT $LN17@GetNeedMon
  00049	dd d9		 fstp	 ST(1)
  0004b	dd d8		 fstp	 ST(0)
$LN28@GetNeedMon:

; 5937 : 			return 0;

  0004d	5f		 pop	 edi
  0004e	33 c0		 xor	 eax, eax
  00050	5e		 pop	 esi

; 5988 : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN17@GetNeedMon:

; 5938 : 
; 5939 : 		float lc6 = 1.0f - ItemDurability / lc4;

  00055	de f9		 fdivp	 ST(1), ST(0)
  00057	d9 e8		 fld1
  00059	de e1		 fsubrp	 ST(1), ST(0)
  0005b	d9 5d f8	 fstp	 DWORD PTR _lc6$219300[ebp]

; 5940 : 		int lc7;
; 5941 : 
; 5942 : 		if ( type == ITEMGET(13,4)|| type ==ITEMGET(13,5) ) // Pets

  0005e	81 ff 04 1a 00
	00		 cmp	 edi, 6660		; 00001a04H
  00064	74 14		 je	 SHORT $LN15@GetNeedMon
  00066	81 ff 05 1a 00
	00		 cmp	 edi, 6661		; 00001a05H
  0006c	74 0c		 je	 SHORT $LN15@GetNeedMon

; 5944 : 		else
; 5945 : 			lc7 = DurItem->m_BuyMoney/3;

  0006e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00073	f7 66 78	 mul	 DWORD PTR [esi+120]
  00076	d1 ea		 shr	 edx, 1
  00078	eb 03		 jmp	 SHORT $LN26@GetNeedMon
$LN15@GetNeedMon:

; 5943 : 			lc7 = DurItem->m_BuyMoney;

  0007a	8b 56 78	 mov	 edx, DWORD PTR [esi+120]
$LN26@GetNeedMon:
  0007d	89 55 08	 mov	 DWORD PTR _lc7$219301[ebp], edx

; 5946 : 
; 5947 : 		if ( lc7 > 400000000 ) lc7 = 400000000;

  00080	81 fa 00 84 d7
	17		 cmp	 edx, 400000000		; 17d78400H
  00086	7e 07		 jle	 SHORT $LN13@GetNeedMon
  00088	ba 00 84 d7 17	 mov	 edx, 400000000		; 17d78400H

; 5948 : 
; 5949 : 		if ( lc7 >= 1000 )

  0008d	eb 08		 jmp	 SHORT $LN22@GetNeedMon
$LN13@GetNeedMon:
  0008f	81 fa e8 03 00
	00		 cmp	 edx, 1000		; 000003e8H
  00095	7c 19		 jl	 SHORT $LN12@GetNeedMon
$LN22@GetNeedMon:

; 5950 : 			lc7 = lc7/100*100;

  00097	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0009c	f7 ea		 imul	 edx
  0009e	c1 fa 05	 sar	 edx, 5
  000a1	8b c2		 mov	 eax, edx
  000a3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000a6	03 c2		 add	 eax, edx
  000a8	6b c0 64	 imul	 eax, 100		; 00000064H
  000ab	89 45 08	 mov	 DWORD PTR _lc7$219301[ebp], eax
  000ae	eb 1e		 jmp	 SHORT $LN10@GetNeedMon
$LN12@GetNeedMon:

; 5951 : 		else if ( lc7 >= 100 )

  000b0	83 fa 64	 cmp	 edx, 100		; 00000064H
  000b3	7c 19		 jl	 SHORT $LN10@GetNeedMon

; 5952 : 			lc7 = lc7/10*10;

  000b5	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  000ba	f7 ea		 imul	 edx
  000bc	c1 fa 02	 sar	 edx, 2
  000bf	8b c2		 mov	 eax, edx
  000c1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c4	03 c2		 add	 eax, edx
  000c6	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000c9	03 c9		 add	 ecx, ecx
  000cb	89 4d 08	 mov	 DWORD PTR _lc7$219301[ebp], ecx
$LN10@GetNeedMon:

; 5953 : 
; 5954 : 		float lc8 = (float)sqrt(double(lc7));
; 5955 : 		float lc9 = (float)sqrt(sqrt(double(lc7))); 

  000ce	db 45 08	 fild	 DWORD PTR _lc7$219301[ebp]
  000d1	e8 00 00 00 00	 call	 __CIsqrt
  000d6	dd 55 f0	 fst	 QWORD PTR tv256[ebp]
  000d9	e8 00 00 00 00	 call	 __CIsqrt

; 5956 : 		lc5 = 3.0f * lc8 * lc9;
; 5957 : 		lc5 *= lc6;
; 5958 : 		lc5 += 1.0f;

  000de	d9 5d 08	 fstp	 DWORD PTR tv235[ebp]
  000e1	d9 45 08	 fld	 DWORD PTR tv235[ebp]
  000e4	dd 45 f0	 fld	 QWORD PTR tv256[ebp]
  000e7	d9 5d 08	 fstp	 DWORD PTR tv232[ebp]
  000ea	d9 45 08	 fld	 DWORD PTR tv232[ebp]
  000ed	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4008000000000000
  000f3	de c9		 fmulp	 ST(1), ST(0)
  000f5	d9 5d 08	 fstp	 DWORD PTR tv229[ebp]
  000f8	d9 45 08	 fld	 DWORD PTR tv229[ebp]
  000fb	d8 4d f8	 fmul	 DWORD PTR _lc6$219300[ebp]
  000fe	d9 5d 08	 fstp	 DWORD PTR tv226[ebp]
  00101	d9 45 08	 fld	 DWORD PTR tv226[ebp]
  00104	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  0010a	d9 5d 08	 fstp	 DWORD PTR _lc5$219298[ebp]

; 5959 : 
; 5960 : 		if ( ItemDurability <= 0.0f )

  0010d	d9 ee		 fldz
  0010f	d8 5d fc	 fcomp	 DWORD PTR _ItemDurability$[ebp]
  00112	df e0		 fnstsw	 ax
  00114	f6 c4 01	 test	 ah, 1
  00117	75 26		 jne	 SHORT $LN6@GetNeedMon

; 5961 : 		{
; 5962 : 			if ( type == ITEMGET(13,4)|| type ==ITEMGET(13,5) ) // Pets

  00119	81 ff 04 1a 00
	00		 cmp	 edi, 6660		; 00001a04H
  0011f	74 16		 je	 SHORT $LN7@GetNeedMon
  00121	81 ff 05 1a 00
	00		 cmp	 edi, 6661		; 00001a05H
  00127	74 0e		 je	 SHORT $LN7@GetNeedMon

; 5964 : 			else
; 5965 : 				lc5 *= ::GetAllRepairItemRate(type);

  00129	57		 push	 edi
  0012a	e8 00 00 00 00	 call	 ?GetAllRepairItemRate@@YAMH@Z ; GetAllRepairItemRate
  0012f	d8 4d 08	 fmul	 DWORD PTR _lc5$219298[ebp]
  00132	83 c4 04	 add	 esp, 4
  00135	eb 05		 jmp	 SHORT $LN27@GetNeedMon
$LN7@GetNeedMon:

; 5963 : 				lc5 *= 2;

  00137	d9 45 08	 fld	 DWORD PTR _lc5$219298[ebp]
  0013a	dc c0		 fadd	 ST(0), ST(0)
$LN27@GetNeedMon:
  0013c	d9 5d 08	 fstp	 DWORD PTR _lc5$219298[ebp]
$LN6@GetNeedMon:

; 5966 : 
; 5967 : 		}
; 5968 : 
; 5969 : 		if ( RequestPos == TRUE )

  0013f	83 7d 0c 01	 cmp	 DWORD PTR _RequestPos$[ebp], 1
  00143	75 10		 jne	 SHORT $LN5@GetNeedMon

; 5970 : 		{
; 5971 : 			lc5 += lc5 * 1.5f;

  00145	d9 45 08	 fld	 DWORD PTR _lc5$219298[ebp]
  00148	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3ff8000000000000
  0014e	d8 c9		 fmul	 ST(0), ST(1)
  00150	de c1		 faddp	 ST(1), ST(0)
  00152	d9 5d 08	 fstp	 DWORD PTR _lc5$219298[ebp]
$LN5@GetNeedMon:

; 5972 : 		}
; 5973 : 
; 5974 : 		iMoney = (int)lc5;

  00155	d9 45 08	 fld	 DWORD PTR _lc5$219298[ebp]
  00158	e8 00 00 00 00	 call	 __ftol2_sse
  0015d	8b c8		 mov	 ecx, eax

; 5975 : 
; 5976 : 		if ( iMoney >= 1000 )

  0015f	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  00165	7c 1c		 jl	 SHORT $LN4@GetNeedMon

; 5977 : 			iMoney = iMoney/100*100;

  00167	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0016c	f7 e9		 imul	 ecx
  0016e	c1 fa 05	 sar	 edx, 5
  00171	8b ca		 mov	 ecx, edx
  00173	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00176	03 ca		 add	 ecx, edx
  00178	6b c9 64	 imul	 ecx, 100		; 00000064H
  0017b	5f		 pop	 edi

; 5985 : 	}
; 5986 : 
; 5987 : 	return iMoney;

  0017c	8b c1		 mov	 eax, ecx
  0017e	5e		 pop	 esi

; 5988 : }

  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
$LN4@GetNeedMon:

; 5978 : 		else if ( iMoney >= 100 )

  00183	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00186	7c 21		 jl	 SHORT $LN1@GetNeedMon

; 5979 : 			iMoney = iMoney/10*10;

  00188	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0018d	f7 e9		 imul	 ecx
  0018f	c1 fa 02	 sar	 edx, 2
  00192	8b c2		 mov	 eax, edx
  00194	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00197	03 c2		 add	 eax, edx
  00199	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0019c	03 c9		 add	 ecx, ecx
  0019e	5f		 pop	 edi

; 5985 : 	}
; 5986 : 
; 5987 : 	return iMoney;

  0019f	8b c1		 mov	 eax, ecx
  001a1	5e		 pop	 esi

; 5988 : }

  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c3		 ret	 0
$LN18@GetNeedMon:

; 5980 : 		
; 5981 : 	}
; 5982 : 	else
; 5983 : 	{
; 5984 : 		iMoney = -1;

  001a6	83 c9 ff	 or	 ecx, -1
$LN1@GetNeedMon:
  001a9	5f		 pop	 edi

; 5985 : 	}
; 5986 : 
; 5987 : 	return iMoney;

  001aa	8b c1		 mov	 eax, ecx
  001ac	5e		 pop	 esi

; 5988 : }

  001ad	8b e5		 mov	 esp, ebp
  001af	5d		 pop	 ebp
  001b0	c3		 ret	 0
?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z ENDP	; GetNeedMoneyItemDurRepaire
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCTradeResponseSend@@YAHEHPADGH@Z		; GCTradeResponseSend
; Function compile flags: /Ogtp
;	COMDAT ?GCTradeResponseSend@@YAHEHPADGH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_response$ = 8						; size = 1
_aIndex$ = 12						; size = 4
_id$ = 16						; size = 4
_level$ = 20						; size = 2
_GuildNumber$ = 24					; size = 4
?GCTradeResponseSend@@YAHEHPADGH@Z PROC			; GCTradeResponseSend, COMDAT

; 6667 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 10	 mov	 esi, DWORD PTR _id$[ebp]

; 6668 : 	PMSG_TRADE_RESPONSE pMsg;
; 6669 : 
; 6670 : 	PHeadSetB((LPBYTE)&pMsg, 0x37, sizeof(pMsg));

  00014	6a 14		 push	 20			; 00000014H
  00016	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 37		 push	 55			; 00000037H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6671 : 	pMsg.Response = response;

  00021	8a 4d 08	 mov	 cl, BYTE PTR _response$[ebp]

; 6672 : 	pMsg.Level = level;

  00024	66 8b 55 14	 mov	 dx, WORD PTR _level$[ebp]

; 6673 : 	pMsg.GuildNumber = GuildNumber;

  00028	8b 45 18	 mov	 eax, DWORD PTR _GuildNumber$[ebp]
  0002b	88 4d eb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 6674 : 	memcpy(pMsg.Id, id, sizeof(pMsg.Id));

  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+14], dx
  00034	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00037	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+4], ecx

; 6675 : 
; 6676 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0003a	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0003e	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00041	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]
  00045	89 55 f0	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00048	51		 push	 ecx
  00049	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0004c	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+12], ax
  00050	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00053	52		 push	 edx
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6677 : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	83 c4 18	 add	 esp, 24			; 00000018H
  00060	33 cd		 xor	 ecx, ebp
  00062	5e		 pop	 esi
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?GCTradeResponseSend@@YAHEHPADGH@Z ENDP			; GCTradeResponseSend
_TEXT	ENDS
PUBLIC	?GCTradeOtherDel@@YAHHE@Z			; GCTradeOtherDel
; Function compile flags: /Ogtp
;	COMDAT ?GCTradeOtherDel@@YAHHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_tradeindex$ = 12					; size = 1
?GCTradeOtherDel@@YAHHE@Z PROC				; GCTradeOtherDel, COMDAT

; 6688 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6689 : 	PMSG_TRADE_OTHER_DEL pMsg;
; 6690 : 
; 6691 : 	PHeadSetB((LPBYTE)&pMsg, 0x38, sizeof(pMsg ));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 38		 push	 56			; 00000038H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6692 : 	pMsg.TradeItemIndex = tradeindex;
; 6693 : 
; 6694 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 0c	 mov	 cl, BYTE PTR _tradeindex$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 6695 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GCTradeOtherDel@@YAHHE@Z ENDP				; GCTradeOtherDel
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCTradeOtherAdd@@YAHHEPAE@Z			; GCTradeOtherAdd
; Function compile flags: /Ogtp
;	COMDAT ?GCTradeOtherAdd@@YAHHEPAE@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_tradeindex$ = 12					; size = 1
_iteminfo$ = 16						; size = 4
?GCTradeOtherAdd@@YAHHEPAE@Z PROC			; GCTradeOtherAdd, COMDAT

; 6708 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 10	 mov	 esi, DWORD PTR _iteminfo$[ebp]

; 6709 : 	PMSG_TRADE_OTHER_MOVE pMsg;
; 6710 : 
; 6711 : 	PHeadSetB((LPBYTE)&pMsg, 0x39, sizeof(pMsg));

  00014	6a 10		 push	 16			; 00000010H
  00016	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 39		 push	 57			; 00000039H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6712 : 	pMsg.TradeItemIndex = tradeindex;
; 6713 : 	pMsg.ItemInfo[I_TYPE] = iteminfo[I_TYPE];

  00021	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  00024	8a 4d 0c	 mov	 cl, BYTE PTR _tradeindex$[ebp]

; 6714 : 	pMsg.ItemInfo[I_OPTION] = iteminfo[I_OPTION];

  00027	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  0002b	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 6715 : 	pMsg.ItemInfo[I_DUR] = iteminfo[I_DUR];

  0002e	0f b6 4e 02	 movzx	 ecx, BYTE PTR [esi+2]
  00032	88 55 f0	 mov	 BYTE PTR _pMsg$[ebp+4], dl

; 6716 : 	pMsg.ItemInfo[I_NOPTION] = iteminfo[I_NOPTION];

  00035	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  00039	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 6717 : 	pMsg.ItemInfo[I_SOPTION] = iteminfo[I_SOPTION];

  0003c	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00040	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+6], cl

; 6718 : 	pMsg.ItemInfo[5] = iteminfo[5];

  00043	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  00047	88 55 f3	 mov	 BYTE PTR _pMsg$[ebp+7], dl

; 6719 : 	pMsg.ItemInfo[6] = iteminfo[6];

  0004a	0f b6 56 06	 movzx	 edx, BYTE PTR [esi+6]
  0004e	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 6720 : 
; 6721 : 	pMsg.ItemInfo[7] = iteminfo[7];

  00051	0f b6 46 07	 movzx	 eax, BYTE PTR [esi+7]
  00055	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+9], cl

; 6722 : 	pMsg.ItemInfo[8] = iteminfo[8];

  00058	0f b6 4e 08	 movzx	 ecx, BYTE PTR [esi+8]
  0005c	88 55 f6	 mov	 BYTE PTR _pMsg$[ebp+10], dl

; 6723 : 	pMsg.ItemInfo[9] = iteminfo[9];

  0005f	0f b6 56 09	 movzx	 edx, BYTE PTR [esi+9]
  00063	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 6724 : 	pMsg.ItemInfo[10] = iteminfo[10];

  00066	0f b6 46 0a	 movzx	 eax, BYTE PTR [esi+10]
  0006a	88 4d f8	 mov	 BYTE PTR _pMsg$[ebp+12], cl

; 6725 : 	pMsg.ItemInfo[11] = iteminfo[11];

  0006d	0f b6 4e 0b	 movzx	 ecx, BYTE PTR [esi+11]
  00071	88 55 f9	 mov	 BYTE PTR _pMsg$[ebp+13], dl

; 6726 : 	
; 6727 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00074	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00078	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+14], al
  0007b	52		 push	 edx
  0007c	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0007f	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+15], cl
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00085	50		 push	 eax
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6728 : }

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008f	83 c4 18	 add	 esp, 24			; 00000018H
  00092	33 cd		 xor	 ecx, ebp
  00094	5e		 pop	 esi
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
?GCTradeOtherAdd@@YAHHEPAE@Z ENDP			; GCTradeOtherAdd
_TEXT	ENDS
PUBLIC	?GCTradeMoneyOther@@YAHHK@Z			; GCTradeMoneyOther
; Function compile flags: /Ogtp
;	COMDAT ?GCTradeMoneyOther@@YAHHK@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_aIndex$ = 8						; size = 4
_money$ = 12						; size = 4
?GCTradeMoneyOther@@YAHHK@Z PROC			; GCTradeMoneyOther, COMDAT

; 6813 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 6814 : 	PMSG_TRADE_OTHER_GOLD pMsg;
; 6815 : 
; 6816 : 	PHeadSetB((LPBYTE)&pMsg, 0x3B, sizeof(pMsg));

  00006	6a 08		 push	 8
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 3b		 push	 59			; 0000003bH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6817 : 	pMsg.Money = money;
; 6818 : 
; 6819 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);	

  00013	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _money$[ebp]
  0001a	52		 push	 edx
  0001b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001e	89 4d fc	 mov	 DWORD PTR _pMsg$[ebp+4], ecx
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002b	83 c4 18	 add	 esp, 24			; 00000018H

; 6820 : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?GCTradeMoneyOther@@YAHHK@Z ENDP			; GCTradeMoneyOther
_TEXT	ENDS
PUBLIC	?GCTradeOkButtonSend@@YAHHE@Z			; GCTradeOkButtonSend
; Function compile flags: /Ogtp
;	COMDAT ?GCTradeOkButtonSend@@YAHHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_flag$ = 12						; size = 1
?GCTradeOkButtonSend@@YAHHE@Z PROC			; GCTradeOkButtonSend, COMDAT

; 6826 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6827 : 	PMSG_TRADE_OKBUTTON pMsg;
; 6828 : 
; 6829 : 	PHeadSetB((LPBYTE)&pMsg, 0x3C, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 3c		 push	 60			; 0000003cH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6830 : 	pMsg.Flag = flag;
; 6831 : 
; 6832 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 0c	 mov	 cl, BYTE PTR _flag$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 6833 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GCTradeOkButtonSend@@YAHHE@Z ENDP			; GCTradeOkButtonSend
_TEXT	ENDS
PUBLIC	??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@ ; `string'
PUBLIC	?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ; CGTradeOkButtonRecv
EXTRN	?gObjTradeOkButton@@YAXH@Z:PROC			; gObjTradeOkButton
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsConnected
;	COMDAT ??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@
CONST	SEGMENT
??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@ DB '[%s'
	DB	'][%s] Trade Accept', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z PROC ; CGTradeOkButtonRecv, COMDAT

; 6838 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6839 : 	int number = gObj[aIndex].TargetNumber;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000d	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00013	0f bf 9c 06 38
	06 00 00	 movsx	 ebx, WORD PTR [esi+eax+1592]

; 6840 : 
; 6841 : 	if ( number < 0 || number > OBJMAX-1 )

  0001b	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00021	0f 87 02 01 00
	00		 ja	 $LN8@CGTradeOkB

; 6842 : 		return;
; 6843 : 
; 6844 : 	if ( !gObjIsConnected(&gObj[number]))

  00027	57		 push	 edi
  00028	8b fb		 mov	 edi, ebx
  0002a	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00030	03 c7		 add	 eax, edi
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00038	83 c4 04	 add	 esp, 4
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 e5 00 00
	00		 je	 $LN17@CGTradeOkB

; 6845 : 		return;
; 6846 : 
; 6847 : 	if ( gObj[aIndex].m_IfState.use < 1 || gObj[aIndex].m_IfState.state != 1 )

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00048	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  0004f	8b d1		 mov	 edx, ecx
  00051	80 e2 03	 and	 dl, 3
  00054	80 fa 01	 cmp	 dl, 1
  00057	0f 82 cb 00 00
	00		 jb	 $LN17@CGTradeOkB
  0005d	80 e1 3c	 and	 cl, 60			; 0000003cH
  00060	80 f9 04	 cmp	 cl, 4
  00063	0f 85 bf 00 00
	00		 jne	 $LN17@CGTradeOkB

; 6848 : 		return;
; 6849 : 
; 6850 : 	if ( gObj[number].m_IfState.use < 1 || gObj[number].m_IfState.state != 1 )

  00069	8b 8c 07 b8 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4536]
  00070	8b d1		 mov	 edx, ecx
  00072	80 e2 03	 and	 dl, 3
  00075	80 fa 01	 cmp	 dl, 1
  00078	0f 82 aa 00 00
	00		 jb	 $LN17@CGTradeOkB
  0007e	80 e1 3c	 and	 cl, 60			; 0000003cH
  00081	80 f9 04	 cmp	 cl, 4
  00084	0f 85 9e 00 00
	00		 jne	 $LN17@CGTradeOkB

; 6851 : 		return;
; 6852 : 
; 6853 : 	if ( gObj[aIndex].CloseType != -1 )

  0008a	80 c9 ff	 or	 cl, -1
  0008d	38 4c 06 0d	 cmp	 BYTE PTR [esi+eax+13], cl
  00091	0f 85 91 00 00
	00		 jne	 $LN17@CGTradeOkB

; 6854 : 		return;
; 6855 : 
; 6856 : 	if ( gObj[number].CloseType != -1 )

  00097	38 4c 07 0d	 cmp	 BYTE PTR [edi+eax+13], cl
  0009b	0f 85 87 00 00
	00		 jne	 $LN17@CGTradeOkB

; 6857 : 		return;
; 6858 : 	
; 6859 : 	if ( lpMsg->Flag == 1 )

  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000a4	8a 49 03	 mov	 cl, BYTE PTR [ecx+3]
  000a7	80 f9 01	 cmp	 cl, 1
  000aa	75 49		 jne	 SHORT $LN5@CGTradeOkB

; 6860 : 	{
; 6861 : 		if ( gObj[aIndex].TradeOk == false )

  000ac	80 bc 06 f4 11
	00 00 00	 cmp	 BYTE PTR [esi+eax+4596], 0
  000b4	8d 84 06 f4 11
	00 00		 lea	 eax, DWORD PTR [esi+eax+4596]
  000bb	75 5f		 jne	 SHORT $LN1@CGTradeOkB

; 6862 : 		{
; 6863 : 			gObj[aIndex].TradeOk = true;

  000bd	88 08		 mov	 BYTE PTR [eax], cl

; 6864 : 			LogAddTD("[%s][%s] Trade Accept", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c4	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  000c8	52		 push	 edx
  000c9	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  000cd	50		 push	 eax
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 6865 : 			GCTradeOkButtonSend(number, 1);

  000d9	6a 01		 push	 1
  000db	53		 push	 ebx
  000dc	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 6874 : 		}
; 6875 : 	}
; 6876 : 
; 6877 : 	gObjTradeOkButton(aIndex);

  000e1	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000e4	83 c4 14	 add	 esp, 20			; 00000014H
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 ?gObjTradeOkButton@@YAXH@Z ; gObjTradeOkButton
  000ed	83 c4 04	 add	 esp, 4
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx

; 6878 : }

  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
$LN5@CGTradeOkB:

; 6866 : 		}
; 6867 : 	}
; 6868 : 	else if ( lpMsg->Flag == 0 )

  000f5	84 c9		 test	 cl, cl
  000f7	75 23		 jne	 SHORT $LN1@CGTradeOkB

; 6869 : 	{
; 6870 : 		if ( gObj[aIndex].TradeOk  == true )

  000f9	80 bc 06 f4 11
	00 00 01	 cmp	 BYTE PTR [esi+eax+4596], 1
  00101	75 19		 jne	 SHORT $LN1@CGTradeOkB

; 6871 : 		{
; 6872 : 			GCTradeOkButtonSend(number, 0);

  00103	6a 00		 push	 0
  00105	53		 push	 ebx
  00106	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 6873 : 			gObj[aIndex].TradeOk = false;

  0010b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00111	83 c4 08	 add	 esp, 8
  00114	c6 84 0e f4 11
	00 00 00	 mov	 BYTE PTR [esi+ecx+4596], 0
$LN1@CGTradeOkB:

; 6874 : 		}
; 6875 : 	}
; 6876 : 
; 6877 : 	gObjTradeOkButton(aIndex);

  0011c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 ?gObjTradeOkButton@@YAXH@Z ; gObjTradeOkButton
  00125	83 c4 04	 add	 esp, 4
$LN17@CGTradeOkB:
  00128	5f		 pop	 edi
$LN8@CGTradeOkB:
  00129	5e		 pop	 esi
  0012a	5b		 pop	 ebx

; 6878 : }

  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ENDP ; CGTradeOkButtonRecv
_TEXT	ENDS
PUBLIC	?CGTradeResult@@YAXHE@Z				; CGTradeResult
; Function compile flags: /Ogtp
;	COMDAT ?CGTradeResult@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?CGTradeResult@@YAXHE@Z PROC				; CGTradeResult, COMDAT

; 6906 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6907 : 	PMSG_TRADE_RESULT pMsg;
; 6908 : 
; 6909 : 	PHeadSetB((LPBYTE)&pMsg, 0x3D, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 3d		 push	 61			; 0000003dH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6910 : 	pMsg.Result = result;
; 6911 : 
; 6912 : 	DataSend(aIndex, (unsigned char*)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 0c	 mov	 cl, BYTE PTR _result$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 6913 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?CGTradeResult@@YAXHE@Z ENDP				; CGTradeResult
_TEXT	ENDS
PUBLIC	?CGPShopAnsSetItemPrice@@YAXHEE@Z		; CGPShopAnsSetItemPrice
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopAnsSetItemPrice@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
_btItemPos$ = 16					; size = 1
?CGPShopAnsSetItemPrice@@YAXHEE@Z PROC			; CGPShopAnsSetItemPrice, COMDAT

; 7053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 7054 : 	PMSG_ANS_PSHOP_SETITEMPRICE pMsg;
; 7055 : 
; 7056 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x01, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 7057 : 	pMsg.btResult = btResult;
; 7058 : 	pMsg.btItemPos = btItemPos;
; 7059 : 
; 7060 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00015	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00019	8a 4d 0c	 mov	 cl, BYTE PTR _btResult$[ebp]
  0001c	8a 55 10	 mov	 dl, BYTE PTR _btItemPos$[ebp]
  0001f	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00022	50		 push	 eax
  00023	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00026	88 55 fd	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  00029	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002c	51		 push	 ecx
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00033	83 c4 1c	 add	 esp, 28			; 0000001cH

; 7061 : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?CGPShopAnsSetItemPrice@@YAXHEE@Z ENDP			; CGPShopAnsSetItemPrice
_TEXT	ENDS
PUBLIC	?CGPShopAnsOpen@@YAXHE@Z			; CGPShopAnsOpen
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopAnsOpen@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
?CGPShopAnsOpen@@YAXHE@Z PROC				; CGPShopAnsOpen, COMDAT

; 7263 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 7264 : 	PMSG_ANS_PSHOP_OPEN pMsg;
; 7265 : 
; 7266 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x02, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 02		 push	 2
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 7267 : 	pMsg.btResult = btResult;
; 7268 : 
; 7269 : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00015	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00018	8a 4d 0c	 mov	 cl, BYTE PTR _btResult$[ebp]
  0001b	6a 05		 push	 5
  0001d	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00020	52		 push	 edx
  00021	50		 push	 eax
  00022	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00025	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 7270 : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?CGPShopAnsOpen@@YAXHE@Z ENDP				; CGPShopAnsOpen
_TEXT	ENDS
PUBLIC	??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@ ; `string'
PUBLIC	?CGPShopAnsClose@@YAXHE@Z			; CGPShopAnsClose
;	COMDAT ??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@
CONST	SEGMENT
??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@ DB '['
	DB	'PShop] [%s][%s] Close PShop', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPShopAnsClose@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
?CGPShopAnsClose@@YAXHE@Z PROC				; CGPShopAnsClose, COMDAT

; 7320 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 7321 : 	LogAddTD("[PShop] [%s][%s] Close PShop", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000b	53		 push	 ebx
  0000c	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000f	56		 push	 esi
  00010	8b f3		 mov	 esi, ebx
  00012	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00018	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0001c	51		 push	 ecx
  0001d	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00021	52		 push	 edx
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7322 : 
; 7323 : 	PMSG_ANS_PSHOP_CLOSE pMsg;
; 7324 : 
; 7325 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x03, sizeof(pMsg));

  0002d	6a 07		 push	 7
  0002f	6a 03		 push	 3
  00031	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00034	6a 3f		 push	 63			; 0000003fH
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 7326 : 	pMsg.btResult = btResult;

  0003c	8a 4d 0c	 mov	 cl, BYTE PTR _btResult$[ebp]

; 7327 : 	pMsg.NumberH = SET_NUMBERH(aIndex);
; 7328 : 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 7329 : 
; 7330 : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0003f	6a 07		 push	 7
  00041	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00044	8b d3		 mov	 edx, ebx
  00046	50		 push	 eax
  00047	c1 ea 08	 shr	 edx, 8
  0004a	53		 push	 ebx
  0004b	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0004e	88 55 fd	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  00051	88 5d fe	 mov	 BYTE PTR _pMsg$[ebp+6], bl
  00054	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00059	83 c4 28	 add	 esp, 40			; 00000028H

; 7331 : 
; 7332 : 	if ( btResult == 1 )

  0005c	80 7d 0c 01	 cmp	 BYTE PTR _btResult$[ebp], 1
  00060	75 18		 jne	 SHORT $LN1@CGPShopAns

; 7333 : 		MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  00062	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00066	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006c	51		 push	 ecx
  0006d	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00070	52		 push	 edx
  00071	56		 push	 esi
  00072	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGPShopAns:
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx

; 7334 : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?CGPShopAnsClose@@YAXHE@Z ENDP				; CGPShopAnsClose
_TEXT	ENDS
PUBLIC	_aTargetIndex$GSCopy$
PUBLIC	_aSourceIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPShopAnsBuyList@@YAXHHE_N@Z			; CGPShopAnsBuyList
EXTRN	?gDoPShopOpen@@3HA:DWORD			; gDoPShopOpen
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopAnsBuyList@@YAXHHE_N@Z
_TEXT	SEGMENT
_aSourceIndex$GSCopy$ = -1136				; size = 4
_aTargetIndex$GSCopy$ = -1132				; size = 4
_pMsgILC$ = -1128					; size = 55
tv341 = -1072						; size = 4
_n$219961 = -1068					; size = 4
_iCount$219960 = -1064					; size = 4
_sOfs$ = -1060						; size = 4
_pMsgIL$ = -1056					; size = 28
_sendBuf$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_btResult$ = 16						; size = 1
_bResend$ = 20						; size = 1
?CGPShopAnsBuyList@@YAXHHE_N@Z PROC			; CGPShopAnsBuyList, COMDAT

; 7470 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 04 00
	00		 sub	 esp, 1136		; 00000470H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 7471 : 	if ( gDoPShopOpen == FALSE )

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0001a	8b 55 08	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  0001d	53		 push	 ebx
  0001e	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  00021	56		 push	 esi
  00022	57		 push	 edi

; 7524 : 			}
; 7525 : 		}
; 7526 : 
; 7527 : 		pMsgILC.h.c = 0xC2;

  00023	89 95 90 fb ff
	ff		 mov	 DWORD PTR _aSourceIndex$GSCopy$[ebp], edx
  00029	89 9d 94 fb ff
	ff		 mov	 DWORD PTR _aTargetIndex$GSCopy$[ebp], ebx
  0002f	0f 84 85 02 00
	00		 je	 $LN7@CGPShopAns@2

; 7472 : 		return;
; 7473 : 	
; 7474 : 
; 7475 : 	PMSG_ANS_BUYLIST_FROM_PSHOP pMsgILC;	// Packet Message Item List Count
; 7476 : 	PMSG_BUYLIST_FROM_PSHOP pMsgIL;
; 7477 : 	BYTE sendBuf[1024];
; 7478 : 	int sOfs = sizeof(pMsgILC);

  00035	8a 4d 10	 mov	 cl, BYTE PTR _btResult$[ebp]
  00038	c7 85 dc fb ff
	ff 37 00 00 00	 mov	 DWORD PTR _sOfs$[ebp], 55 ; 00000037H

; 7479 : 	int pMsgILSize = sizeof(pMsgIL);
; 7480 : 
; 7481 : 	if ( btResult != 1 )

  00042	80 f9 01	 cmp	 cl, 1
  00045	0f 84 92 00 00
	00		 je	 $LN10@CGPShopAns@2

; 7482 : 	{
; 7483 : 		LPOBJ lpObj = &gObj[aSourceIndex];
; 7484 : 		
; 7485 : 		pMsgILC.h.c = 0xC2;
; 7486 : 		pMsgILC.h.headcode = 0x3F;
; 7487 : 
; 7488 : 		if ( bResend == false )

  0004b	8a 45 14	 mov	 al, BYTE PTR _bResend$[ebp]
  0004e	f6 d8		 neg	 al
  00050	1a c0		 sbb	 al, al
  00052	24 0e		 and	 al, 14			; 0000000eH
  00054	04 05		 add	 al, 5
  00056	88 85 9c fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+4], al

; 7489 : 			pMsgILC.h.subcode = 0x05;
; 7490 : 		else
; 7491 : 			pMsgILC.h.subcode = 0x13;
; 7492 : 
; 7493 : 		pMsgILC.h.sizeH = SET_NUMBERH(sOfs);

  0005c	33 c0		 xor	 eax, eax

; 7494 : 		pMsgILC.h.sizeL = SET_NUMBERL(sOfs);
; 7495 : 		pMsgILC.btCount = 0;
; 7496 : 		pMsgILC.Result = btResult;

  0005e	88 8d 9d fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+5], cl
  00064	88 85 ce fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+54], al

; 7497 : 		pMsgILC.NumberH = SET_NUMBERH(aTargetIndex);
; 7498 : 		pMsgILC.NumberL = SET_NUMBERL(aTargetIndex);
; 7499 : 		memset(pMsgILC.btName, 0, sizeof(pMsgILC.btName));

  0006a	89 85 a0 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+8], eax
  00070	89 85 a4 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+12], eax
  00076	66 89 85 a8 fb
	ff ff		 mov	 WORD PTR _pMsgILC$[ebp+16], ax

; 7500 : 		memset(pMsgILC.szPShopText, 0, sizeof(pMsgILC.szPShopText));

  0007d	89 85 aa fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+18], eax
  00083	89 85 ae fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+22], eax
  00089	89 85 b2 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+26], eax
  0008f	89 85 b6 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+30], eax
  00095	89 85 ba fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+34], eax
  0009b	89 85 be fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+38], eax
  000a1	89 85 c2 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+42], eax
  000a7	89 85 c6 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+46], eax
  000ad	89 85 ca fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+50], eax

; 7501 : 		memcpy(sendBuf, &pMsgILC, sizeof(pMsgILC));
; 7502 : 
; 7503 : 		DataSend(aSourceIndex, sendBuf, sOfs);

  000b3	6a 37		 push	 55			; 00000037H
  000b5	8b cb		 mov	 ecx, ebx
  000b7	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sendBuf$[ebp]
  000bd	c1 e9 08	 shr	 ecx, 8
  000c0	50		 push	 eax
  000c1	c7 85 98 fb ff
	ff c2 00 37 3f	 mov	 DWORD PTR _pMsgILC$[ebp], 1060569282 ; 3f3700c2H
  000cb	88 8d 9e fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+6], cl
  000d1	88 9d 9f fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+7], bl
  000d7	52		 push	 edx

; 7504 : 	}
; 7505 : 	else

  000d8	e9 bf 01 00 00	 jmp	 $LN16@CGPShopAns@2
$LN10@CGPShopAns@2:

; 7506 : 	{
; 7507 : 		LPOBJ lpObjSource = &gObj[aSourceIndex];
; 7508 : 		LPOBJ lpObjTarget = &gObj[aTargetIndex];

  000dd	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  000e3	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e9	bf f0 a8 00 00	 mov	 edi, 43248		; 0000a8f0H

; 7509 : 		int iCount = 0;

  000ee	c7 85 d8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _iCount$219960[ebp], 0

; 7510 : 
; 7511 : 		for ( int n=MAIN_INVENTORY_SIZE;n<(INVENTORY_SIZE-1);n++)

  000f8	c7 85 d4 fb ff
	ff cc 00 00 00	 mov	 DWORD PTR _n$219961[ebp], 204 ; 000000ccH
  00102	89 bd d0 fb ff
	ff		 mov	 DWORD PTR tv341[ebp], edi
  00108	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL6@CGPShopAns@2:

; 7512 : 		{
; 7513 : 			if ( lpObjTarget->Inventory1[n].IsItem() == TRUE )

  00110	8b 8b d0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4560]
  00116	03 cf		 add	 ecx, edi
  00118	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0011d	83 f8 01	 cmp	 eax, 1
  00120	0f 85 b9 00 00
	00		 jne	 $LN5@CGPShopAns@2

; 7514 : 			{
; 7515 : 				pMsgIL.Pos = n;

  00126	8a 8d d4 fb ff
	ff		 mov	 cl, BYTE PTR _n$219961[ebp]
  0012c	88 8d e0 fb ff
	ff		 mov	 BYTE PTR _pMsgIL$[ebp], cl

; 7516 : 				ItemByteConvert(pMsgIL.ItemInfo, lpObjTarget->Inventory1[n]);

  00132	8b b3 d0 11 00
	00		 mov	 esi, DWORD PTR [ebx+4560]
  00138	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0013e	03 f7		 add	 esi, edi
  00140	8d 95 e1 fb ff
	ff		 lea	 edx, DWORD PTR _pMsgIL$[ebp+1]
  00146	8b fc		 mov	 edi, esp
  00148	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0014d	52		 push	 edx
  0014e	f3 a5		 rep movsd
  00150	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 7517 : 				pMsgIL.PShopItemValue = lpObjTarget->Inventory1[n].m_iPShopValue;

  00155	8b 8b d0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4560]
  0015b	8b 85 d0 fb ff
	ff		 mov	 eax, DWORD PTR tv341[ebp]
  00161	8b 54 08 7c	 mov	 edx, DWORD PTR [eax+ecx+124]
  00165	89 95 f0 fb ff
	ff		 mov	 DWORD PTR _pMsgIL$[ebp+16], edx

; 7518 : 				pMsgIL.PShopBlessValue = lpObjTarget->Inventory1[n].m_PShopBlessValue;

  0016b	8b 8b d0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4560]
  00171	0f b7 94 08 80
	00 00 00	 movzx	 edx, WORD PTR [eax+ecx+128]
  00179	66 89 95 f4 fb
	ff ff		 mov	 WORD PTR _pMsgIL$[ebp+20], dx

; 7519 : 				pMsgIL.PShopSoulValue = lpObjTarget->Inventory1[n].m_PShopSoulValue;

  00180	8b 8b d0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4560]
  00186	0f b7 94 08 82
	00 00 00	 movzx	 edx, WORD PTR [eax+ecx+130]
  0018e	66 89 95 f6 fb
	ff ff		 mov	 WORD PTR _pMsgIL$[ebp+22], dx

; 7520 : 				pMsgIL.PShopChaosValue = lpObjTarget->Inventory1[n].m_PShopChaosValue;

  00195	8b 8b d0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4560]
  0019b	0f b7 94 08 84
	00 00 00	 movzx	 edx, WORD PTR [eax+ecx+132]
  001a3	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _sOfs$[ebp]

; 7521 : 				memcpy(&sendBuf[sOfs], &pMsgIL, pMsgILSize);

  001a9	6a 1c		 push	 28			; 0000001cH
  001ab	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _pMsgIL$[ebp]
  001b1	66 89 95 f8 fb
	ff ff		 mov	 WORD PTR _pMsgIL$[ebp+24], dx
  001b8	50		 push	 eax
  001b9	8d 94 0d fc fb
	ff ff		 lea	 edx, DWORD PTR _sendBuf$[ebp+ecx]
  001c0	52		 push	 edx
  001c1	e8 00 00 00 00	 call	 _memcpy

; 7522 : 				iCount++;

  001c6	ff 85 d8 fb ff
	ff		 inc	 DWORD PTR _iCount$219960[ebp]

; 7523 : 				sOfs += pMsgILSize;

  001cc	8b bd d0 fb ff
	ff		 mov	 edi, DWORD PTR tv341[ebp]
  001d2	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  001d8	83 85 dc fb ff
	ff 1c		 add	 DWORD PTR _sOfs$[ebp], 28 ; 0000001cH
$LN5@CGPShopAns@2:

; 7510 : 
; 7511 : 		for ( int n=MAIN_INVENTORY_SIZE;n<(INVENTORY_SIZE-1);n++)

  001df	ff 85 d4 fb ff
	ff		 inc	 DWORD PTR _n$219961[ebp]
  001e5	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  001eb	89 bd d0 fb ff
	ff		 mov	 DWORD PTR tv341[ebp], edi
  001f1	81 ff 70 c3 00
	00		 cmp	 edi, 50032		; 0000c370H
  001f7	0f 8c 13 ff ff
	ff		 jl	 $LL6@CGPShopAns@2

; 7528 : 		pMsgILC.h.headcode = 0x3F;
; 7529 : 
; 7530 : 		if ( bResend == false )

  001fd	8a 45 14	 mov	 al, BYTE PTR _bResend$[ebp]

; 7531 : 			pMsgILC.h.subcode = 0x05;
; 7532 : 		else
; 7533 : 			pMsgILC.h.subcode = 0x13;
; 7534 : 
; 7535 : 		pMsgILC.h.sizeH = SET_NUMBERH(sOfs);
; 7536 : 		pMsgILC.h.sizeL = SET_NUMBERL(sOfs);
; 7537 : 		pMsgILC.btCount = iCount;

  00200	8a 95 d8 fb ff
	ff		 mov	 dl, BYTE PTR _iCount$219960[ebp]
  00206	f6 d8		 neg	 al
  00208	1a c0		 sbb	 al, al
  0020a	24 0e		 and	 al, 14			; 0000000eH
  0020c	04 05		 add	 al, 5
  0020e	88 85 9c fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+4], al
  00214	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _sOfs$[ebp]
  0021a	8b c8		 mov	 ecx, eax
  0021c	c1 e9 08	 shr	 ecx, 8
  0021f	88 8d 99 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+1], cl

; 7538 : 		pMsgILC.Result = btResult;
; 7539 : 		pMsgILC.NumberH = SET_NUMBERH(aTargetIndex);

  00225	8b 8d 94 fb ff
	ff		 mov	 ecx, DWORD PTR _aTargetIndex$GSCopy$[ebp]
  0022b	88 95 ce fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+54], dl
  00231	8b d1		 mov	 edx, ecx
  00233	c1 ea 08	 shr	 edx, 8

; 7540 : 		pMsgILC.NumberL = SET_NUMBERL(aTargetIndex);

  00236	88 8d 9f fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+7], cl

; 7541 : 		memcpy(pMsgILC.btName, lpObjTarget->Name, sizeof(pMsgILC.btName));

  0023c	8b 4b 5d	 mov	 ecx, DWORD PTR [ebx+93]
  0023f	88 95 9e fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+6], dl
  00245	8b 53 61	 mov	 edx, DWORD PTR [ebx+97]
  00248	89 8d a0 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+8], ecx
  0024e	66 8b 4b 65	 mov	 cx, WORD PTR [ebx+101]
  00252	89 95 a4 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+12], edx

; 7544 : 
; 7545 : 		DataSend(aSourceIndex, sendBuf, sOfs);

  00258	50		 push	 eax
  00259	88 85 9a fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+2], al
  0025f	8b 85 90 fb ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00265	66 89 8d a8 fb
	ff ff		 mov	 WORD PTR _pMsgILC$[ebp+16], cx
  0026c	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _sendBuf$[ebp]
  00272	8d b3 60 12 00
	00		 lea	 esi, DWORD PTR [ebx+4704]
  00278	b9 09 00 00 00	 mov	 ecx, 9
  0027d	8d bd aa fb ff
	ff		 lea	 edi, DWORD PTR _pMsgILC$[ebp+18]
  00283	52		 push	 edx
  00284	c6 85 98 fb ff
	ff c2		 mov	 BYTE PTR _pMsgILC$[ebp], 194 ; 000000c2H
  0028b	c6 85 9b fb ff
	ff 3f		 mov	 BYTE PTR _pMsgILC$[ebp+3], 63 ; 0000003fH
  00292	c6 85 9d fb ff
	ff 01		 mov	 BYTE PTR _pMsgILC$[ebp+5], 1
  00299	f3 a5		 rep movsd
  0029b	50		 push	 eax
$LN16@CGPShopAns@2:

; 7542 : 		memcpy(pMsgILC.szPShopText, lpObjTarget->m_szPShopText, sizeof(pMsgILC.szPShopText));
; 7543 : 		memcpy(sendBuf, &pMsgILC, sizeof(pMsgILC));

  0029c	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  002a1	8d bd fc fb ff
	ff		 lea	 edi, DWORD PTR _sendBuf$[ebp]
  002a7	8d b5 98 fb ff
	ff		 lea	 esi, DWORD PTR _pMsgILC$[ebp]
  002ad	f3 a5		 rep movsd
  002af	66 a5		 movsw
  002b1	a4		 movsb

; 7544 : 
; 7545 : 		DataSend(aSourceIndex, sendBuf, sOfs);

  002b2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002b7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CGPShopAns@2:

; 7546 : 
; 7547 : 	}
; 7548 : }

  002ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bd	5f		 pop	 edi
  002be	5e		 pop	 esi
  002bf	33 cd		 xor	 ecx, ebp
  002c1	5b		 pop	 ebx
  002c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c7	8b e5		 mov	 esp, ebp
  002c9	5d		 pop	 ebp
  002ca	c3		 ret	 0
?CGPShopAnsBuyList@@YAXHHE_N@Z ENDP			; CGPShopAnsBuyList
_TEXT	ENDS
PUBLIC	_aSourceIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPShopAnsBuyItem@@YAXHHHE@Z			; CGPShopAnsBuyItem
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopAnsBuyItem@@YAXHHHE@Z
_TEXT	SEGMENT
_aSourceIndex$GSCopy$ = -28				; size = 4
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_iItemPos$ = 16						; size = 4
_btResult$ = 20						; size = 1
?CGPShopAnsBuyItem@@YAXHHHE@Z PROC			; CGPShopAnsBuyItem, COMDAT

; 8078 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 10	 mov	 ebx, DWORD PTR _iItemPos$[ebp]
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _aSourceIndex$[ebp]
  00018	57		 push	 edi

; 8079 : 	PMSG_ANS_BUYITEM_FROM_PSHOP pMsg;
; 8080 : 
; 8081 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x06, sizeof(pMsg));

  00019	6a 14		 push	 20			; 00000014H
  0001b	6a 06		 push	 6
  0001d	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00020	6a 3f		 push	 63			; 0000003fH
  00022	50		 push	 eax
  00023	89 75 e4	 mov	 DWORD PTR _aSourceIndex$GSCopy$[ebp], esi
  00026	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 8082 : 	pMsg.NumberH = SET_NUMBERH(aTargetIndex);
; 8083 : 	pMsg.NumberL = SET_NUMBERL(aTargetIndex);
; 8084 : 	pMsg.btItemPos = iItemPos;
; 8085 : 	pMsg.Result = btResult;
; 8086 : 	ItemByteConvert(pMsg.cItemInfo, gObj[aSourceIndex].Inventory1[iItemPos]);

  0002b	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00031	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00034	8a 55 14	 mov	 dl, BYTE PTR _btResult$[ebp]
  00037	88 5d fb	 mov	 BYTE PTR _pMsg$[ebp+19], bl
  0003a	69 db d4 00 00
	00		 imul	 ebx, 212		; 000000d4H
  00040	8b c8		 mov	 ecx, eax
  00042	c1 e9 08	 shr	 ecx, 8
  00045	88 45 ee	 mov	 BYTE PTR _pMsg$[ebp+6], al
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004d	88 4d ed	 mov	 BYTE PTR _pMsg$[ebp+5], cl
  00050	88 55 ec	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  00053	8b b4 06 d0 11
	00 00		 mov	 esi, DWORD PTR [esi+eax+4560]
  0005a	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00060	8b fc		 mov	 edi, esp
  00062	03 f3		 add	 esi, ebx
  00064	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00069	f3 a5		 rep movsd
  0006b	8d 4d ef	 lea	 ecx, DWORD PTR _pMsg$[ebp+7]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 8087 : 
; 8088 : 	DataSend(aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00074	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00078	8b 4d e4	 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0007b	52		 push	 edx
  0007c	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0007f	50		 push	 eax
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 8089 : }

  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	33 cd		 xor	 ecx, ebp
  00093	5b		 pop	 ebx
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?CGPShopAnsBuyItem@@YAXHHHE@Z ENDP			; CGPShopAnsBuyItem
_TEXT	ENDS
PUBLIC	?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z ; CGPShopReqCloseDeal
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z PROC ; CGPShopReqCloseDeal, COMDAT

; 8103 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 8104 : 	if ( !gObjIsConnected(aIndex))

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 3e		 je	 SHORT $LN2@CGPShopReq

; 8105 : 		return;
; 8106 : 
; 8107 : 	gObj[aIndex].m_bPShopWantDeal = false;

  00014	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001a	8b c6		 mov	 eax, esi
  0001c	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00022	33 c9		 xor	 ecx, ecx
  00024	88 8c 10 84 12
	00 00		 mov	 BYTE PTR [eax+edx+4740], cl

; 8108 : 	gObj[aIndex].m_iPShopDealerIndex =-1;

  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00031	c7 84 10 88 12
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [eax+edx+4744], -1

; 8109 : 	memset(gObj[aIndex].m_szPShopDealerName , 0, MAX_ACCOUNT_LEN);

  0003c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00042	8d 84 10 8c 12
	00 00		 lea	 eax, DWORD PTR [eax+edx+4748]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
  0004b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0004e	66 89 48 08	 mov	 WORD PTR [eax+8], cx
$LN2@CGPShopReq:
  00052	5e		 pop	 esi

; 8110 : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z ENDP ; CGPShopReqCloseDeal
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGPShopAnsSoldItem@@YAXHHH@Z			; CGPShopAnsSoldItem
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopAnsSoldItem@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 15
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_iItemPos$ = 16						; size = 4
?CGPShopAnsSoldItem@@YAXHHH@Z PROC			; CGPShopAnsSoldItem, COMDAT

; 8116 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]

; 8117 : 	PMSG_ANS_SOLDITEM_FROM_PSHOP pMsg;
; 8118 : 
; 8119 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x08, sizeof(pMsg));

  00014	6a 0f		 push	 15			; 0000000fH
  00016	6a 08		 push	 8
  00018	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001b	6a 3f		 push	 63			; 0000003fH
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 8120 : 	pMsg.btItemPos = iItemPos;
; 8121 : 	memcpy(pMsg.btName, gObj[aTargetIndex].Name, MAX_ACCOUNT_LEN);

  00023	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00029	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	8a 4d 10	 mov	 cl, BYTE PTR _iItemPos$[ebp]
  00032	8d 44 16 5d	 lea	 eax, DWORD PTR [esi+edx+93]
  00036	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 4d f1	 mov	 DWORD PTR _pMsg$[ebp+5], ecx
  0003e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 8122 : 
; 8123 : 	DataSend(aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00041	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00045	89 55 f5	 mov	 DWORD PTR _pMsg$[ebp+9], edx
  00048	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  0004c	51		 push	 ecx
  0004d	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00050	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+13], ax
  00054	8b 45 08	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  00057	52		 push	 edx
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 8124 : }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	83 c4 1c	 add	 esp, 28			; 0000001cH
  00064	33 cd		 xor	 ecx, ebp
  00066	5e		 pop	 esi
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?CGPShopAnsSoldItem@@YAXHHH@Z ENDP			; CGPShopAnsSoldItem
_TEXT	ENDS
PUBLIC	?CGPShopAnsDealerClosedShop@@YAXHH@Z		; CGPShopAnsDealerClosedShop
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopAnsDealerClosedShop@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
?CGPShopAnsDealerClosedShop@@YAXHH@Z PROC		; CGPShopAnsDealerClosedShop, COMDAT

; 8138 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 8139 : 	PMSG_REQ_DEALER_CLOSED_SHOP pMsg;
; 8140 : 
; 8141 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x12, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	6a 12		 push	 18			; 00000012H
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 8142 : 	pMsg.NumberH = SET_NUMBERH(aTargetIndex);

  00015	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]

; 8143 : 	pMsg.NumberL = SET_NUMBERL(aTargetIndex);
; 8144 : 
; 8145 : 	DataSend(aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001c	8b c8		 mov	 ecx, eax
  0001e	c1 e9 08	 shr	 ecx, 8
  00021	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00024	52		 push	 edx
  00025	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00028	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  0002e	50		 push	 eax
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00035	83 c4 1c	 add	 esp, 28			; 0000001cH

; 8146 : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?CGPShopAnsDealerClosedShop@@YAXHH@Z ENDP		; CGPShopAnsDealerClosedShop
_TEXT	ENDS
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@ ; `string'
PUBLIC	??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@ ; `string'
PUBLIC	??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@ ; `string'
PUBLIC	?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ; CGPartyRequestRecv
EXTRN	?GetIndexUser@PartyClass@@QAEHHHAAH0@Z:PROC	; PartyClass::GetIndexUser
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z:PROC ; CNewPVP::IsObserver
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@ DB '%s %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB 'P'
	DB	'arty result : %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@
CONST	SEGMENT
??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@ DB 'Party not a'
	DB	'llowed in Imperial Fort.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@
CONST	SEGMENT
??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@ DB 'Party not al'
	DB	'lowed in Doppelganger.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@
CONST	SEGMENT
??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@ DB 'Party not a'
	DB	'llowed in Illusion Temple.', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 5
_iDbNumber$220272 = -8					; size = 4
tv526 = -4						; size = 4
_iUserIndex$220271 = -4					; size = 4
_number$ = 8						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z PROC	; CGPartyRequestRecv, COMDAT

; 8160 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8161 : 	int number =  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00006	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00009	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0000d	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00011	66 c1 e1 08	 shl	 cx, 8
  00015	57		 push	 edi
  00016	0f b7 f9	 movzx	 edi, cx
  00019	0b fa		 or	 edi, edx
  0001b	89 7d 08	 mov	 DWORD PTR _number$[ebp], edi

; 8162 : 	PMSG_PARTYREQUESTSEND pMsg;
; 8163 : 
; 8164 : 	if ( number < 0 || number > OBJMAX-1)

  0001e	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00024	0f 87 ae 03 00
	00		 ja	 $LN23@CGPartyReq

; 8165 : 		return;
; 8166 : 
; 8167 : 	if (!PacketCheckTime(&gObj[aIndex]))

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	53		 push	 ebx
  00030	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00033	56		 push	 esi
  00034	8b f3		 mov	 esi, ebx
  00036	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0003c	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00045	83 c4 04	 add	 esp, 4
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 86 03 00
	00		 je	 $LN45@CGPartyReq

; 8168 : 		return;
; 8169 : 
; 8170 : 	if ( !gObjIsConnected(&gObj[number]))

  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  0005c	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00065	83 c4 04	 add	 esp, 4
  00068	85 c0		 test	 eax, eax
  0006a	75 14		 jne	 SHORT $LN21@CGPartyReq

; 8171 : 	{
; 8172 : 		::GCResultSend(aIndex, 0x41, 0x03);

  0006c	6a 03		 push	 3

; 8177 : 	{
; 8178 : 		::GCResultSend(aIndex, 0x41, 0x00);

  0006e	6a 41		 push	 65			; 00000041H
  00070	53		 push	 ebx
  00071	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	5f		 pop	 edi

; 8327 : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN21@CGPartyReq:

; 8173 : 		return;
; 8174 : 	}
; 8175 : 
; 8176 : 	if ( gObj[aIndex].CloseCount >= 0 || gObj[number].CloseCount >= 0 )

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00085	80 7c 06 0c 00	 cmp	 BYTE PTR [esi+eax+12], 0
  0008a	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0008d	89 4d fc	 mov	 DWORD PTR tv526[ebp], ecx
  00090	0f 8d 33 03 00
	00		 jge	 $LN19@CGPartyReq
  00096	80 7c 07 0c 00	 cmp	 BYTE PTR [edi+eax+12], 0
  0009b	0f 8d 28 03 00
	00		 jge	 $LN19@CGPartyReq

; 8179 : 		return;
; 8180 : 	}
; 8181 : 
; 8182 : #if (ENABLETEST_NEWPVP == 1)
; 8183 : 	if (g_NewPVP.IsDuel(gObj[aIndex])) {

  000a1	51		 push	 ecx
  000a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000a7	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  000ac	85 c0		 test	 eax, eax
  000ae	74 22		 je	 SHORT $LN18@CGPartyReq

; 8184 : 		 GCServerMsgStringSend(lMsg.Get(3429), aIndex, 1);

  000b0	6a 01		 push	 1
  000b2	53		 push	 ebx
  000b3	68 65 0d 00 00	 push	 3429			; 00000d65H
$LN50@CGPartyReq:
  000b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000bd	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	5f		 pop	 edi

; 8327 : }

  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
$LN18@CGPartyReq:

; 8185 : 		 return;
; 8186 : 	}
; 8187 : 	
; 8188 : 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  000d2	8b 4d fc	 mov	 ecx, DWORD PTR tv526[ebp]
  000d5	51		 push	 ecx
  000d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000db	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  000e0	85 c0		 test	 eax, eax
  000e2	74 0a		 je	 SHORT $LN17@CGPartyReq

; 8189 : 		 GCServerMsgStringSend(lMsg.Get(3430), aIndex, 1);

  000e4	6a 01		 push	 1
  000e6	53		 push	 ebx
  000e7	68 66 0d 00 00	 push	 3430			; 00000d66H

; 8190 : 		 return;

  000ec	eb ca		 jmp	 SHORT $LN50@CGPartyReq
$LN17@CGPartyReq:

; 8191 : 	}
; 8192 : #endif
; 8193 : 
; 8194 : 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  000ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f3	8a 8c 06 23 01
	00 00		 mov	 cl, BYTE PTR [esi+eax+291]
  000fa	80 f9 35	 cmp	 cl, 53			; 00000035H
  000fd	74 11		 je	 SHORT $LN37@CGPartyReq
  000ff	80 f9 12	 cmp	 cl, 18			; 00000012H
  00102	72 16		 jb	 SHORT $LN39@CGPartyReq
  00104	ba 17 00 00 00	 mov	 edx, 23			; 00000017H
  00109	3a d1		 cmp	 dl, cl
  0010b	1b d2		 sbb	 edx, edx
  0010d	42		 inc	 edx
  0010e	74 0a		 je	 SHORT $LN39@CGPartyReq
$LN37@CGPartyReq:

; 8195 : 	{
; 8196 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 198)), aIndex, 1);

  00110	6a 01		 push	 1
  00112	53		 push	 ebx
  00113	68 c6 04 00 00	 push	 1222			; 000004c6H

; 8197 : 		return;

  00118	eb 9e		 jmp	 SHORT $LN50@CGPartyReq
$LN39@CGPartyReq:

; 8198 : 	}
; 8199 : 
; 8200 : 	if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) )

  0011a	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  0011d	72 23		 jb	 SHORT $LN42@CGPartyReq
  0011f	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  00124	3a d1		 cmp	 dl, cl
  00126	1b d2		 sbb	 edx, edx
  00128	42		 inc	 edx
  00129	74 17		 je	 SHORT $LN42@CGPartyReq

; 8201 : 	{
; 8202 : 		::GCServerMsgStringSend("Party not allowed in Illusion Temple.", aIndex, 1);

  0012b	6a 01		 push	 1
  0012d	53		 push	 ebx
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@
  00133	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	5e		 pop	 esi
  0013c	5b		 pop	 ebx
  0013d	5f		 pop	 edi

; 8327 : }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
$LN42@CGPartyReq:

; 8203 : 		return;
; 8204 : 	}
; 8205 : 
; 8206 : 	if ( DG_MAP_RANGE(gObj[aIndex].MapNumber) )

  00142	80 f9 41	 cmp	 cl, 65			; 00000041H
  00145	72 23		 jb	 SHORT $LN43@CGPartyReq
  00147	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  0014c	3a d1		 cmp	 dl, cl
  0014e	1b d2		 sbb	 edx, edx
  00150	42		 inc	 edx
  00151	74 17		 je	 SHORT $LN43@CGPartyReq

; 8207 : 	{
; 8208 : 		::GCServerMsgStringSend("Party not allowed in Doppelganger.", aIndex, 1);

  00153	6a 01		 push	 1
  00155	53		 push	 ebx
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@
  0015b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx
  00165	5f		 pop	 edi

; 8327 : }

  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
$LN43@CGPartyReq:

; 8209 : 		return;
; 8210 : 	}
; 8211 : 
; 8212 : 	if ( IF_MAP_RANGE(gObj[aIndex].MapNumber) )

  0016a	80 f9 45	 cmp	 cl, 69			; 00000045H
  0016d	72 20		 jb	 SHORT $LN44@CGPartyReq
  0016f	b2 48		 mov	 dl, 72			; 00000048H
  00171	3a d1		 cmp	 dl, cl
  00173	1b c9		 sbb	 ecx, ecx
  00175	41		 inc	 ecx
  00176	74 17		 je	 SHORT $LN44@CGPartyReq

; 8213 : 	{
; 8214 : 		::GCServerMsgStringSend("Party not allowed in Imperial Fort.", aIndex, 1);

  00178	6a 01		 push	 1
  0017a	53		 push	 ebx
  0017b	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@
  00180	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00185	83 c4 0c	 add	 esp, 12			; 0000000cH
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx
  0018a	5f		 pop	 edi

; 8327 : }

  0018b	8b e5		 mov	 esp, ebp
  0018d	5d		 pop	 ebp
  0018e	c3		 ret	 0
$LN44@CGPartyReq:

; 8215 : 		return;
; 8216 : 	}
; 8217 : 
; 8218 : #if (__GENS_SYSTEM__ == 1 )
; 8219 : 
; 8220 : 	/*if ( gObj[aIndex].m_GensInfo.btFamily == GENS_NONE )
; 8221 : 	{
; 8222 : 		::GCResultSend(aIndex, 0x41, 0x06);
; 8223 : 		return;
; 8224 : 	}*/
; 8225 : 	if( gGensSystem.m_CheckForParty )

  0018f	80 3d 50 00 00
	00 00		 cmp	 BYTE PTR ?gGensSystem@@3VCGensSystem@@A+80, 0
  00196	74 24		 je	 SHORT $LN10@CGPartyReq

; 8226 : 	{
; 8227 : 		if ( gObj[aIndex].m_GensInfo.btFamily != GENS_NONE && gObj[aIndex].m_GensInfo.btFamily != gObj[number].m_GensInfo.btFamily )

  00198	8a 8c 06 ac 26
	00 00		 mov	 cl, BYTE PTR [esi+eax+9900]
  0019f	3a 8c 07 ac 26
	00 00		 cmp	 cl, BYTE PTR [edi+eax+9900]
  001a6	74 14		 je	 SHORT $LN10@CGPartyReq

; 8228 : 		{
; 8229 : 			::GCResultSend(aIndex, 0x41, 0x07);

  001a8	6a 07		 push	 7
  001aa	6a 41		 push	 65			; 00000041H
  001ac	53		 push	 ebx
  001ad	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b5	5e		 pop	 esi
  001b6	5b		 pop	 ebx
  001b7	5f		 pop	 edi

; 8327 : }

  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c3		 ret	 0
$LN10@CGPartyReq:

; 8230 : 			return;
; 8231 : 		}
; 8232 : 
; 8233 : 		if ( gObj[aIndex].m_GensInfo.btFamily != gObj[number].m_GensInfo.btFamily )
; 8234 : 		{
; 8235 : 			::GCResultSend(aIndex, 0x41, 0x07);
; 8236 : 			return;
; 8237 : 		}
; 8238 : 	}
; 8239 : 
; 8240 : 	//if ( gGensSystem.GensMap(gObj[aIndex].MapNumber) )
; 8241 : 	//{
; 8242 : 	//	return;
; 8243 : 	//}
; 8244 : 
; 8245 : #endif
; 8246 : 
; 8247 : 
; 8248 : 	if ( gObj[aIndex].m_IfState.use > 0 )

  001bc	f6 84 06 b8 11
	00 00 03	 test	 BYTE PTR [esi+eax+4536], 3

; 8249 : 	{
; 8250 : 		::GCResultSend(aIndex, 0x41, 0x00);
; 8251 : 		return;

  001c4	0f 87 ff 01 00
	00		 ja	 $LN19@CGPartyReq

; 8252 : 	}
; 8253 : 
; 8254 : 	LogAddL("Party result : %d %d %d %d", gObj[aIndex].CloseCount, gObj[number].CloseCount, gObj[aIndex].Connected, gObj[number].Connected);

  001ca	8b 4c 07 04	 mov	 ecx, DWORD PTR [edi+eax+4]
  001ce	8b 54 06 04	 mov	 edx, DWORD PTR [esi+eax+4]
  001d2	51		 push	 ecx
  001d3	0f be 4c 07 0c	 movsx	 ecx, BYTE PTR [edi+eax+12]
  001d8	52		 push	 edx
  001d9	0f be 54 06 0c	 movsx	 edx, BYTE PTR [esi+eax+12]
  001de	51		 push	 ecx
  001df	52		 push	 edx
  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL

; 8255 : 	LogAddL("%s %s", gObj[aIndex].Name, gObj[number].Name);

  001eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f0	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  001f4	51		 push	 ecx
  001f5	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  001f9	52		 push	 edx
  001fa	68 00 00 00 00	 push	 OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
  001ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL

; 8256 : 		
; 8257 : 	if ( gObj[number].m_IfState.use > 0 )

  00205	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020a	83 c4 20	 add	 esp, 32			; 00000020H
  0020d	f6 84 07 b8 11
	00 00 03	 test	 BYTE PTR [edi+eax+4536], 3

; 8258 : 	{
; 8259 : 		::GCResultSend(aIndex, 0x41, 0x00);
; 8260 : 		return;

  00215	0f 87 ae 01 00
	00		 ja	 $LN19@CGPartyReq

; 8261 : 	}
; 8262 : 
; 8263 : 	if ( (gObj[number].m_Option &1) != TRUE )

  0021b	f6 84 07 24 12
	00 00 01	 test	 BYTE PTR [edi+eax+4644], 1
  00223	75 14		 jne	 SHORT $LN7@CGPartyReq

; 8264 : 	{
; 8265 : 		::GCResultSend(aIndex, 0x41, 0x01);

  00225	6a 01		 push	 1
  00227	6a 41		 push	 65			; 00000041H
  00229	53		 push	 ebx
  0022a	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0022f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00232	5e		 pop	 esi
  00233	5b		 pop	 ebx
  00234	5f		 pop	 edi

; 8327 : }

  00235	8b e5		 mov	 esp, ebp
  00237	5d		 pop	 ebp
  00238	c3		 ret	 0
$LN7@CGPartyReq:

; 8266 : 		return;
; 8267 : 	}
; 8268 : 
; 8269 : 	if ( gObj[aIndex].PartyNumber >= 0 )

  00239	83 bc 06 0c 06
	00 00 00	 cmp	 DWORD PTR [esi+eax+1548], 0
  00241	7c 3d		 jl	 SHORT $LN40@CGPartyReq

; 8270 : 	{
; 8271 : 		int iUserIndex;
; 8272 : 		int iDbNumber;
; 8273 : 		gParty.GetIndexUser(gObj[aIndex].PartyNumber, 0, iUserIndex, iDbNumber);

  00243	8b 84 06 0c 06
	00 00		 mov	 eax, DWORD PTR [esi+eax+1548]
  0024a	8d 4d f8	 lea	 ecx, DWORD PTR _iDbNumber$220272[ebp]
  0024d	51		 push	 ecx
  0024e	8d 55 fc	 lea	 edx, DWORD PTR _iUserIndex$220271[ebp]
  00251	52		 push	 edx
  00252	6a 00		 push	 0
  00254	50		 push	 eax
  00255	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0025a	e8 00 00 00 00	 call	 ?GetIndexUser@PartyClass@@QAEHHHAAH0@Z ; PartyClass::GetIndexUser

; 8274 : 		
; 8275 : 		if ( iUserIndex < 0 || ( iUserIndex != aIndex && gObj[aIndex].DBNumber != iDbNumber )  )

  0025f	8b 45 fc	 mov	 eax, DWORD PTR _iUserIndex$220271[ebp]
  00262	85 c0		 test	 eax, eax
  00264	0f 88 5f 01 00
	00		 js	 $LN19@CGPartyReq
  0026a	3b c3		 cmp	 eax, ebx
  0026c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00271	74 0d		 je	 SHORT $LN40@CGPartyReq
  00273	8b 4c 06 30	 mov	 ecx, DWORD PTR [esi+eax+48]
  00277	3b 4d f8	 cmp	 ecx, DWORD PTR _iDbNumber$220272[ebp]

; 8276 : 		{
; 8277 : 			::GCResultSend(aIndex, 0x41, 0x00);
; 8278 : 			return;

  0027a	0f 85 49 01 00
	00		 jne	 $LN19@CGPartyReq
$LN40@CGPartyReq:

; 8279 : 
; 8280 : 		}
; 8281 : 	}
; 8282 : 
; 8283 : 	if ( gObj[aIndex].PartyTargetUser >= 0 )

  00280	83 bc 06 10 06
	00 00 00	 cmp	 DWORD PTR [esi+eax+1552], 0
  00288	0f 8d 48 01 00
	00		 jge	 $LN45@CGPartyReq

; 8284 : 		return;
; 8285 : 
; 8286 : 	if ( gObj[number].PartyNumber >= 0 )

  0028e	83 bc 07 0c 06
	00 00 00	 cmp	 DWORD PTR [edi+eax+1548], 0
  00296	7c 14		 jl	 SHORT $LN2@CGPartyReq

; 8287 : 	{
; 8288 : 		::GCResultSend(aIndex, 0x41, 0x04);

  00298	6a 04		 push	 4
  0029a	6a 41		 push	 65			; 00000041H
  0029c	53		 push	 ebx
  0029d	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  002a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a5	5e		 pop	 esi
  002a6	5b		 pop	 ebx
  002a7	5f		 pop	 edi

; 8327 : }

  002a8	8b e5		 mov	 esp, ebp
  002aa	5d		 pop	 ebp
  002ab	c3		 ret	 0
$LN2@CGPartyReq:

; 8289 : 		return;
; 8290 : 	}
; 8291 : 
; 8292 : 	if ( gObj[number].PartyTargetUser >= 0 )

  002ac	83 bc 07 10 06
	00 00 00	 cmp	 DWORD PTR [edi+eax+1552], 0

; 8293 : 	{
; 8294 : 		::GCResultSend(aIndex, 0x41, 0x00);
; 8295 : 		return;

  002b4	0f 8d 0f 01 00
	00		 jge	 $LN19@CGPartyReq

; 8296 : 	}
; 8297 : 
; 8298 : #if (ENABLETEST_ARCA == 1)
; 8299 : 	if( g_ArcaBattle.IsArcaBattleServer()
; 8300 : #if (ENABLETEST_ACHERON == 1)
; 8301 : 		&& !g_AcheronGuardianEvent.IsPlayStart()
; 8302 : #endif
; 8303 : 		&& gObj[aIndex].GuildNumber != gObj[number].GuildNumber )
; 8304 :     {
; 8305 :         GCServerMsgStringSend(/*lMsg.Get(3507)*/"You can create party only with your guild", aIndex, 1);
; 8306 : 		return;
; 8307 :     }
; 8308 : #endif
; 8309 : 
; 8310 : 	gObj[aIndex].m_IfState.use = TRUE;

  002ba	8b 94 06 b8 11
	00 00		 mov	 edx, DWORD PTR [esi+eax+4536]
  002c1	8d 84 06 b8 11
	00 00		 lea	 eax, DWORD PTR [esi+eax+4536]
  002c8	83 e2 fd	 and	 edx, -3			; fffffffdH
  002cb	83 ca 01	 or	 edx, 1
  002ce	89 10		 mov	 DWORD PTR [eax], edx

; 8311 : 	gObj[aIndex].m_IfState.type = 2;

  002d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d5	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  002dc	81 e1 bf 00 ff
	ff		 and	 ecx, -65345		; ffff00bfH
  002e2	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  002e8	89 8c 06 b8 11
	00 00		 mov	 DWORD PTR [esi+eax+4536], ecx

; 8312 : 	gObj[aIndex].m_IfState.state = 0;

  002ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f4	b9 c3 ff ff ff	 mov	 ecx, -61		; ffffffc3H
  002f9	21 8c 06 b8 11
	00 00		 and	 DWORD PTR [esi+eax+4536], ecx

; 8313 : 	gObj[number].m_IfState.use = TRUE;

  00300	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00305	8b 94 07 b8 11
	00 00		 mov	 edx, DWORD PTR [edi+eax+4536]
  0030c	83 e2 fd	 and	 edx, -3			; fffffffdH
  0030f	83 ca 01	 or	 edx, 1
  00312	89 94 07 b8 11
	00 00		 mov	 DWORD PTR [edi+eax+4536], edx

; 8314 : 	gObj[number].m_IfState.type = 2;

  00319	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0031e	8b 94 07 b8 11
	00 00		 mov	 edx, DWORD PTR [edi+eax+4536]
  00325	81 e2 bf 00 ff
	ff		 and	 edx, -65345		; ffff00bfH
  0032b	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  00331	89 94 07 b8 11
	00 00		 mov	 DWORD PTR [edi+eax+4536], edx

; 8315 : 	gObj[number].m_IfState.state = 0;

  00338	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0033d	21 8c 07 b8 11
	00 00		 and	 DWORD PTR [edi+eax+4536], ecx

; 8316 : 	gObj[aIndex].TargetNumber = number;

  00344	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00349	66 8b 4d 08	 mov	 cx, WORD PTR _number$[ebp]
  0034d	66 89 8c 06 38
	06 00 00	 mov	 WORD PTR [esi+eax+1592], cx

; 8317 : 	gObj[number].TargetNumber = aIndex;

  00355	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0035b	66 89 9c 17 38
	06 00 00	 mov	 WORD PTR [edi+edx+1592], bx

; 8318 : 	gObj[aIndex].m_InterfaceTime = GetTickCount();

  00363	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00369	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0036f	89 84 0e bc 11
	00 00		 mov	 DWORD PTR [esi+ecx+4540], eax

; 8319 : 	gObj[number].m_InterfaceTime = GetTickCount();

  00376	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0037c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00382	89 84 17 bc 11
	00 00		 mov	 DWORD PTR [edi+edx+4540], eax

; 8320 : 	gObj[aIndex].PartyTargetUser = number;

  00389	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0038e	8b 7d 08	 mov	 edi, DWORD PTR _number$[ebp]

; 8321 : 	
; 8322 : 	PHeadSetB((LPBYTE)&pMsg, 0x40, sizeof(pMsg));

  00391	6a 05		 push	 5
  00393	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00396	6a 40		 push	 64			; 00000040H
  00398	51		 push	 ecx
  00399	89 bc 06 10 06
	00 00		 mov	 DWORD PTR [esi+eax+1552], edi
  003a0	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8323 : 	pMsg.NumberH = SET_NUMBERH(aIndex);
; 8324 : 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 8325 : 
; 8326 : 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  003a5	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  003a9	50		 push	 eax
  003aa	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  003ad	8b d3		 mov	 edx, ebx
  003af	51		 push	 ecx
  003b0	c1 ea 08	 shr	 edx, 8
  003b3	57		 push	 edi
  003b4	88 55 f3	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  003b7	88 5d f4	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  003ba	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003bf	83 c4 18	 add	 esp, 24			; 00000018H
  003c2	5e		 pop	 esi
  003c3	5b		 pop	 ebx
  003c4	5f		 pop	 edi

; 8327 : }

  003c5	8b e5		 mov	 esp, ebp
  003c7	5d		 pop	 ebp
  003c8	c3		 ret	 0
$LN19@CGPartyReq:

; 8177 : 	{
; 8178 : 		::GCResultSend(aIndex, 0x41, 0x00);

  003c9	6a 00		 push	 0
  003cb	6a 41		 push	 65			; 00000041H
  003cd	53		 push	 ebx
  003ce	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  003d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN45@CGPartyReq:
  003d6	5e		 pop	 esi
  003d7	5b		 pop	 ebx
$LN23@CGPartyReq:
  003d8	5f		 pop	 edi

; 8327 : }

  003d9	8b e5		 mov	 esp, ebp
  003db	5d		 pop	 ebp
  003dc	c3		 ret	 0
?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ENDP	; CGPartyRequestRecv
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPartyList@@YAXH@Z				; CGPartyList
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z:PROC	; gObjIsConnected
EXTRN	?GetCount@PartyClass@@QAEHH@Z:PROC		; PartyClass::GetCount
; Function compile flags: /Ogtp
;	COMDAT ?CGPartyList@@YAXH@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -580					; size = 4
_pList$ = -576						; size = 36
tv428 = -540						; size = 4
_n$220364 = -536					; size = 4
tv391 = -532						; size = 4
_lOfs$ = -528						; size = 4
_pCount$ = -524						; size = 5
_sendbuf$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?CGPartyList@@YAXH@Z PROC				; CGPartyList, COMDAT

; 8494 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 02 00
	00		 sub	 esp, 580		; 00000244H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 8495 : 	PMSG_PARTYLISTCOUNT pCount;
; 8496 : 	PMSG_PARTYLIST pList;
; 8497 : 	BYTE sendbuf[512];
; 8498 : 	int lOfs = 0;
; 8499 : 
; 8500 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001d	8b f7		 mov	 esi, edi
  0001f	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00025	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00028	51		 push	 ecx

; 8516 : 	{
; 8517 : 		for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  00029	89 bd bc fd ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], edi
  0002f	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00034	83 c4 04	 add	 esp, 4
  00037	85 c0		 test	 eax, eax
  00039	0f 84 30 02 00
	00		 je	 $LN9@CGPartyLis

; 8501 : 		return;
; 8502 : 
; 8503 : 	PHeadSetB((LPBYTE)&pCount, 0x42, sizeof(pCount));

  0003f	53		 push	 ebx
  00040	6a 05		 push	 5
  00042	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _pCount$[ebp]
  00048	6a 42		 push	 66			; 00000042H
  0004a	52		 push	 edx
  0004b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8504 : 	pCount.Count = 0;
; 8505 : 	pCount.Result = false;
; 8506 : 
; 8507 : 	int number;
; 8508 : 	int pnumber = gObj[aIndex].PartyNumber ;

  00050	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	66 c7 85 f7 fd
	ff ff 00 00	 mov	 WORD PTR _pCount$[ebp+3], 0
  0005f	8b b4 1e 0c 06
	00 00		 mov	 esi, DWORD PTR [esi+ebx+1548]
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	32 c0		 xor	 al, al

; 8509 : 
; 8510 : 	if ( pnumber >= 0 )

  0006b	85 f6		 test	 esi, esi
  0006d	78 17		 js	 SHORT $LN7@CGPartyLis

; 8511 : 		pCount.Count = gParty.GetCount(pnumber);

  0006f	56		 push	 esi
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00075	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  0007a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00080	88 85 f8 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], al
$LN7@CGPartyLis:

; 8512 : 
; 8513 : 	lOfs += sizeof(pCount);

  00086	b9 05 00 00 00	 mov	 ecx, 5
  0008b	89 8d f0 fd ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], ecx

; 8514 : 
; 8515 : 	if ( pCount.Count != 0 )

  00091	84 c0		 test	 al, al
  00093	0f 84 ac 01 00
	00		 je	 $LN6@CGPartyLis

; 8516 : 	{
; 8517 : 		for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  00099	8b ce		 mov	 ecx, esi
  0009b	c1 e1 04	 shl	 ecx, 4
  0009e	2b ce		 sub	 ecx, esi
  000a0	8d 85 01 fe ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp+5]
  000a6	8d 3c 8d 20 00
	00 00		 lea	 edi, DWORD PTR ?gParty@@3VPartyClass@@A[ecx*4+32]
  000ad	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$220364[ebp], 0
  000b7	89 85 ec fd ff
	ff		 mov	 DWORD PTR tv391[ebp], eax
  000bd	89 bd e4 fd ff
	ff		 mov	 DWORD PTR tv428[ebp], edi
$LL5@CGPartyLis:

; 8518 : 		{
; 8519 : 			number = gParty.m_PartyS[pnumber].Number[n];

  000c3	8b 77 ec	 mov	 esi, DWORD PTR [edi-20]

; 8520 : 
; 8521 : 			if ( number >= 0 )

  000c6	85 f6		 test	 esi, esi
  000c8	0f 88 3f 01 00
	00		 js	 $LN4@CGPartyLis

; 8522 : 			{
; 8523 : 				if ( gObjIsConnected(&gObj[number], gParty.m_PartyS[pnumber].DbNumber[n]) == TRUE )

  000ce	8b 17		 mov	 edx, DWORD PTR [edi]
  000d0	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  000d6	52		 push	 edx
  000d7	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjIsConnected

; 8524 : 				{
; 8525 : 					memset(&pList, 0, sizeof(pList));
; 8526 : 					memcpy(pList.szId, gObj[number].Name, MAX_ACCOUNT_LEN);

  000e0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e6	83 c4 08	 add	 esp, 8
  000e9	83 f8 01	 cmp	 eax, 1
  000ec	0f 85 1b 01 00
	00		 jne	 $LN4@CGPartyLis
  000f2	8b 4c 1e 5d	 mov	 ecx, DWORD PTR [esi+ebx+93]

; 8527 : 					pList.Number = n;
; 8528 : 					pList.MapNumber = gObj[number].MapNumber;
; 8529 : 					pList.X = gObj[number].X;
; 8530 : 					pList.Y = gObj[number].Y;
; 8531 : 					pList.Life = (int)gObj[number].Life;

  000f6	d9 84 1e d8 00
	00 00		 fld	 DWORD PTR [esi+ebx+216]
  000fd	8b 54 1e 61	 mov	 edx, DWORD PTR [esi+ebx+97]
  00101	33 c0		 xor	 eax, eax
  00103	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp], eax
  00109	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp], ecx
  0010f	0f b6 8d e8 fd
	ff ff		 movzx	 ecx, BYTE PTR _n$220364[ebp]
  00116	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+8], eax
  0011c	89 85 cc fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+12], eax
  00122	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], eax
  00128	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+16], eax
  0012e	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+20], eax
  00134	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+24], eax
  0013a	89 85 dc fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+28], eax
  00140	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+32], eax
  00146	66 8b 44 1e 65	 mov	 ax, WORD PTR [esi+ebx+101]
  0014b	88 8d ca fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+10], cl
  00151	0f b6 8c 1e 21
	01 00 00	 movzx	 ecx, BYTE PTR [esi+ebx+289]
  00159	89 95 c4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], edx
  0015f	8a 94 1e 23 01
	00 00		 mov	 dl, BYTE PTR [esi+ebx+291]
  00166	66 89 85 c8 fd
	ff ff		 mov	 WORD PTR _pList$[ebp+8], ax
  0016d	8a 84 1e 20 01
	00 00		 mov	 al, BYTE PTR [esi+ebx+288]
  00174	88 95 cb fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], dl
  0017a	88 85 cc fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+12], al
  00180	88 8d cd fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+13], cl
  00186	e8 00 00 00 00	 call	 __ftol2_sse
  0018b	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+16], eax

; 8532 : 					pList.MaxLife = (int)(gObj[number].MaxLife + gObj[number].AddLife);

  00191	db 84 1e 24 01
	00 00		 fild	 DWORD PTR [esi+ebx+292]
  00198	d8 84 1e dc 00
	00 00		 fadd	 DWORD PTR [esi+ebx+220]
  0019f	e8 00 00 00 00	 call	 __ftol2_sse

; 8533 : 					pList.Mana = (int)gObj[number].Mana;

  001a4	d9 84 1e ec 00
	00 00		 fld	 DWORD PTR [esi+ebx+236]
  001ab	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+20], eax
  001b1	e8 00 00 00 00	 call	 __ftol2_sse

; 8534 : 					pList.MaxMana = (int)(gObj[number].MaxMana + gObj[number].AddMana);

  001b6	db 84 1e 28 01
	00 00		 fild	 DWORD PTR [esi+ebx+296]
  001bd	89 85 dc fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+28], eax
  001c3	d8 84 1e f0 00
	00 00		 fadd	 DWORD PTR [esi+ebx+240]
  001ca	e8 00 00 00 00	 call	 __ftol2_sse

; 8535 : 					pList.ServerCode = gGameServerCode+1;

  001cf	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode

; 8536 : 
; 8537 : 					memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  001d6	8b bd ec fd ff
	ff		 mov	 edi, DWORD PTR tv391[ebp]
  001dc	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+32], eax
  001e2	42		 inc	 edx

; 8538 : 					lOfs += sizeof(pList);

  001e3	b8 24 00 00 00	 mov	 eax, 36			; 00000024H
  001e8	01 85 f0 fd ff
	ff		 add	 DWORD PTR _lOfs$[ebp], eax
  001ee	01 85 ec fd ff
	ff		 add	 DWORD PTR tv391[ebp], eax
  001f4	b9 09 00 00 00	 mov	 ecx, 9
  001f9	8d b5 c0 fd ff
	ff		 lea	 esi, DWORD PTR _pList$[ebp]
  001ff	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+24], edx
  00205	f3 a5		 rep movsd
  00207	8b bd e4 fd ff
	ff		 mov	 edi, DWORD PTR tv428[ebp]
$LN4@CGPartyLis:

; 8516 : 	{
; 8517 : 		for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  0020d	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _n$220364[ebp]
  00213	40		 inc	 eax
  00214	83 c7 04	 add	 edi, 4
  00217	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _n$220364[ebp], eax
  0021d	89 bd e4 fd ff
	ff		 mov	 DWORD PTR tv428[ebp], edi
  00223	83 f8 05	 cmp	 eax, 5
  00226	0f 8c 97 fe ff
	ff		 jl	 $LL5@CGPartyLis

; 8539 : 				}
; 8540 : 			}
; 8541 : 		}
; 8542 : 
; 8543 : 		pCount.Result = true;

  0022c	8a 85 f8 fd ff
	ff		 mov	 al, BYTE PTR _pCount$[ebp+4]
  00232	8b bd bc fd ff
	ff		 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  00238	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  0023e	c6 85 f7 fd ff
	ff 01		 mov	 BYTE PTR _pCount$[ebp+3], 1
$LN6@CGPartyLis:

; 8544 : 	}
; 8545 : 
; 8546 : 	pCount.h.size = lOfs;
; 8547 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  00245	88 85 00 fe ff
	ff		 mov	 BYTE PTR _sendbuf$[ebp+4], al

; 8548 : 	
; 8549 : 	DataSend(aIndex, (LPBYTE)&sendbuf, lOfs);

  0024b	51		 push	 ecx
  0024c	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  00252	88 8d f5 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], cl
  00258	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR _pCount$[ebp]
  0025e	50		 push	 eax
  0025f	57		 push	 edi
  00260	89 95 fc fd ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], edx
  00266	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0026b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026e	5b		 pop	 ebx
$LN9@CGPartyLis:

; 8550 : }

  0026f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00272	5f		 pop	 edi
  00273	33 cd		 xor	 ecx, ebp
  00275	5e		 pop	 esi
  00276	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027b	8b e5		 mov	 esp, ebp
  0027d	5d		 pop	 ebp
  0027e	c3		 ret	 0
?CGPartyList@@YAXH@Z ENDP				; CGPartyList
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGPartyListAll@@YAXH@Z				; CGPartyListAll
EXTRN	?IsParty@PartyClass@@QAEHH@Z:PROC		; PartyClass::IsParty
; Function compile flags: /Ogtp
;	COMDAT ?CGPartyListAll@@YAXH@Z
_TEXT	SEGMENT
tv429 = -580						; size = 4
_pList$ = -576						; size = 36
tv411 = -540						; size = 4
tv374 = -536						; size = 4
_n$ = -532						; size = 4
_lOfs$ = -528						; size = 4
_pCount$ = -524						; size = 5
_sendbuf$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_pnumber$ = 8						; size = 4
?CGPartyListAll@@YAXH@Z PROC				; CGPartyListAll, COMDAT

; 8556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 02 00
	00		 sub	 esp, 580		; 00000244H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _pnumber$[ebp]

; 8557 : 	PMSG_PARTYLISTCOUNT pCount;
; 8558 : 	PMSG_PARTYLIST pList;
; 8559 : 	BYTE sendbuf[512];
; 8560 : 	int lOfs = 0;
; 8561 : 	int number;
; 8562 : 	int n;
; 8563 : 
; 8564 : 	if ( pnumber < 0 )

  00017	85 f6		 test	 esi, esi
  00019	0f 88 56 02 00
	00		 js	 $LN2@CGPartyLis@2

; 8565 : 		return;
; 8566 : 
; 8567 : 	if ( gParty.IsParty(pnumber) == FALSE )

  0001f	56		 push	 esi
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00025	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 43 02 00
	00		 je	 $LN2@CGPartyLis@2

; 8568 : 		return;
; 8569 : 
; 8570 : 	PHeadSetB((LPBYTE)&pCount, 0x42, sizeof(pCount));

  00032	6a 05		 push	 5
  00034	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0003a	6a 42		 push	 66			; 00000042H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8571 : 	pCount.Result = false;
; 8572 : 	pCount.Count = gParty.GetCount(pnumber);

  00045	56		 push	 esi
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0004b	c6 85 f7 fd ff
	ff 00		 mov	 BYTE PTR _pCount$[ebp+3], 0
  00052	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  00057	88 85 f8 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], al

; 8573 : 
; 8574 : 	if ( pCount.Count == 0 )

  0005d	84 c0		 test	 al, al
  0005f	0f 84 10 02 00
	00		 je	 $LN2@CGPartyLis@2

; 8575 : 		return;
; 8576 : 
; 8577 : 	pCount.Result = true;

  00065	53		 push	 ebx
  00066	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006c	57		 push	 edi
  0006d	8b fe		 mov	 edi, esi
  0006f	c1 e7 04	 shl	 edi, 4
  00072	2b fe		 sub	 edi, esi
  00074	03 ff		 add	 edi, edi
  00076	03 ff		 add	 edi, edi
  00078	8d 8d 01 fe ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp+5]
  0007e	8d 87 20 00 00
	00		 lea	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[edi+32]
  00084	c6 85 f7 fd ff
	ff 01		 mov	 BYTE PTR _pCount$[ebp+3], 1

; 8578 : 	lOfs += sizeof(pCount);

  0008b	c7 85 f0 fd ff
	ff 05 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 5

; 8579 : 
; 8580 : 	for (n=0;n<MAX_USER_IN_PARTY;n++)

  00095	c7 85 ec fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  0009f	89 8d e8 fd ff
	ff		 mov	 DWORD PTR tv374[ebp], ecx
  000a5	89 bd bc fd ff
	ff		 mov	 DWORD PTR tv429[ebp], edi
  000ab	89 85 e4 fd ff
	ff		 mov	 DWORD PTR tv411[ebp], eax
$LL9@CGPartyLis@2:

; 8581 : 	{
; 8582 : 		number = gParty.m_PartyS[pnumber].Number[n];

  000b1	8b 70 ec	 mov	 esi, DWORD PTR [eax-20]

; 8583 : 
; 8584 : 		if ( number >= 0 )

  000b4	85 f6		 test	 esi, esi
  000b6	0f 88 40 01 00
	00		 js	 $LN8@CGPartyLis@2

; 8585 : 		{
; 8586 : 			if ( gObjIsConnected(&gObj[number], gParty.m_PartyS[pnumber].DbNumber[n]) == TRUE )

  000bc	8b 10		 mov	 edx, DWORD PTR [eax]
  000be	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  000c4	52		 push	 edx
  000c5	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjIsConnected

; 8587 : 			{
; 8588 : 				memset(&pList, 0, sizeof(pList));
; 8589 : 				memcpy(pList.szId, gObj[number].Name, MAX_ACCOUNT_LEN);

  000ce	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d4	83 c4 08	 add	 esp, 8
  000d7	83 f8 01	 cmp	 eax, 1
  000da	0f 85 1c 01 00
	00		 jne	 $LN8@CGPartyLis@2
  000e0	8b 4c 1e 5d	 mov	 ecx, DWORD PTR [esi+ebx+93]

; 8590 : 				pList.Number = n;
; 8591 : 				pList.MapNumber = gObj[number].MapNumber;
; 8592 : 				pList.X = gObj[number].X;
; 8593 : 				pList.Y = gObj[number].Y;
; 8594 : 				pList.Life = (int)gObj[number].Life;

  000e4	d9 84 1e d8 00
	00 00		 fld	 DWORD PTR [esi+ebx+216]
  000eb	8b 54 1e 61	 mov	 edx, DWORD PTR [esi+ebx+97]
  000ef	33 c0		 xor	 eax, eax
  000f1	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp], eax
  000f7	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp], ecx
  000fd	0f b6 8d ec fd
	ff ff		 movzx	 ecx, BYTE PTR _n$[ebp]
  00104	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+8], eax
  0010a	89 85 cc fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+12], eax
  00110	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], eax
  00116	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+16], eax
  0011c	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+20], eax
  00122	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+24], eax
  00128	89 85 dc fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+28], eax
  0012e	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+32], eax
  00134	66 8b 44 1e 65	 mov	 ax, WORD PTR [esi+ebx+101]
  00139	88 8d ca fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+10], cl
  0013f	0f b6 8c 1e 21
	01 00 00	 movzx	 ecx, BYTE PTR [esi+ebx+289]
  00147	89 95 c4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], edx
  0014d	8a 94 1e 23 01
	00 00		 mov	 dl, BYTE PTR [esi+ebx+291]
  00154	66 89 85 c8 fd
	ff ff		 mov	 WORD PTR _pList$[ebp+8], ax
  0015b	8a 84 1e 20 01
	00 00		 mov	 al, BYTE PTR [esi+ebx+288]
  00162	88 95 cb fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], dl
  00168	88 85 cc fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+12], al
  0016e	88 8d cd fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+13], cl
  00174	e8 00 00 00 00	 call	 __ftol2_sse
  00179	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+16], eax

; 8595 : 				pList.MaxLife =  (int)gObj[number].MaxLife;

  0017f	d9 84 1e dc 00
	00 00		 fld	 DWORD PTR [esi+ebx+220]
  00186	e8 00 00 00 00	 call	 __ftol2_sse

; 8596 : 				pList.Mana = (int)gObj[number].Mana;

  0018b	d9 84 1e ec 00
	00 00		 fld	 DWORD PTR [esi+ebx+236]
  00192	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+20], eax
  00198	e8 00 00 00 00	 call	 __ftol2_sse

; 8597 : 				pList.MaxMana = (int)(gObj[number].MaxMana + gObj[number].AddMana);

  0019d	db 84 1e 28 01
	00 00		 fild	 DWORD PTR [esi+ebx+296]
  001a4	89 85 dc fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+28], eax
  001aa	d8 84 1e f0 00
	00 00		 fadd	 DWORD PTR [esi+ebx+240]
  001b1	e8 00 00 00 00	 call	 __ftol2_sse
  001b6	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+32], eax

; 8598 : 				pList.ServerCode = gGameServerCode % 20 + 1;

  001bc	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  001c3	99		 cdq
  001c4	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  001c9	f7 f9		 idiv	 ecx

; 8599 : 
; 8600 : 				memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  001cb	8b bd e8 fd ff
	ff		 mov	 edi, DWORD PTR tv374[ebp]

; 8601 : 				lOfs += sizeof(pList);

  001d1	b8 24 00 00 00	 mov	 eax, 36			; 00000024H
  001d6	01 85 f0 fd ff
	ff		 add	 DWORD PTR _lOfs$[ebp], eax
  001dc	b9 09 00 00 00	 mov	 ecx, 9
  001e1	8d b5 c0 fd ff
	ff		 lea	 esi, DWORD PTR _pList$[ebp]
  001e7	42		 inc	 edx
  001e8	01 85 e8 fd ff
	ff		 add	 DWORD PTR tv374[ebp], eax
  001ee	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+24], edx
  001f4	f3 a5		 rep movsd
  001f6	8b bd bc fd ff
	ff		 mov	 edi, DWORD PTR tv429[ebp]
$LN8@CGPartyLis@2:

; 8579 : 
; 8580 : 	for (n=0;n<MAX_USER_IN_PARTY;n++)

  001fc	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  00202	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR tv411[ebp]
  00208	41		 inc	 ecx
  00209	83 c0 04	 add	 eax, 4
  0020c	89 8d ec fd ff
	ff		 mov	 DWORD PTR _n$[ebp], ecx
  00212	89 85 e4 fd ff
	ff		 mov	 DWORD PTR tv411[ebp], eax
  00218	83 f9 05	 cmp	 ecx, 5
  0021b	0f 8c 90 fe ff
	ff		 jl	 $LL9@CGPartyLis@2

; 8602 : 			}
; 8603 : 		}
; 8604 : 	}
; 8605 : 
; 8606 : 	pCount.h.size = lOfs;

  00221	8a 95 f0 fd ff
	ff		 mov	 dl, BYTE PTR _lOfs$[ebp]

; 8607 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  00227	8a 8d f8 fd ff
	ff		 mov	 cl, BYTE PTR _pCount$[ebp+4]
  0022d	88 95 f5 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], dl
  00233	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _pCount$[ebp]
  00239	89 85 fc fd ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], eax
  0023f	88 8d 00 fe ff
	ff		 mov	 BYTE PTR _sendbuf$[ebp+4], cl
  00245	8d bf 0c 00 00
	00		 lea	 edi, DWORD PTR ?gParty@@3VPartyClass@@A[edi+12]
  0024b	be 05 00 00 00	 mov	 esi, 5
$LL21@CGPartyLis@2:

; 8610 : 	{
; 8611 : 		number = gParty.m_PartyS[pnumber].Number[n];

  00250	8b 07		 mov	 eax, DWORD PTR [edi]

; 8612 : 
; 8613 : 		if ( number >= 0 )

  00252	85 c0		 test	 eax, eax
  00254	78 17		 js	 SHORT $LN3@CGPartyLis@2

; 8614 : 		{
; 8615 : 			DataSend(number, sendbuf, lOfs);

  00256	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _lOfs$[ebp]
  0025c	52		 push	 edx
  0025d	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  00263	51		 push	 ecx
  00264	50		 push	 eax
  00265	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0026a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@CGPartyLis@2:

; 8608 : 
; 8609 : 	for (n=0;n<MAX_USER_IN_PARTY;n++)

  0026d	83 c7 04	 add	 edi, 4
  00270	4e		 dec	 esi
  00271	75 dd		 jne	 SHORT $LL21@CGPartyLis@2
  00273	5f		 pop	 edi
  00274	5b		 pop	 ebx
$LN2@CGPartyLis@2:

; 8616 : 		}
; 8617 : 	}
; 8618 : }

  00275	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00278	33 cd		 xor	 ecx, ebp
  0027a	5e		 pop	 esi
  0027b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00280	8b e5		 mov	 esp, ebp
  00282	5d		 pop	 ebp
  00283	c3		 ret	 0
?CGPartyListAll@@YAXH@Z ENDP				; CGPartyListAll
_TEXT	ENDS
PUBLIC	?GCPartyDelUserSend@@YAXH@Z			; GCPartyDelUserSend
; Function compile flags: /Ogtp
;	COMDAT ?GCPartyDelUserSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?GCPartyDelUserSend@@YAXH@Z PROC			; GCPartyDelUserSend, COMDAT

; 8968 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 8969 : 	PMSG_PARTYDELUSERSEND pMsg;
; 8970 : 
; 8971 : 	PHeadSetB((LPBYTE)&pMsg, 0x43, sizeof(pMsg));

  00004	6a 03		 push	 3
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 43		 push	 67			; 00000043H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8972 : 
; 8973 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 4d fd	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00015	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00018	51		 push	 ecx
  00019	8d 55 fc	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0001c	52		 push	 edx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00023	83 c4 18	 add	 esp, 24			; 00000018H

; 8974 : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?GCPartyDelUserSend@@YAXH@Z ENDP			; GCPartyDelUserSend
_TEXT	ENDS
PUBLIC	??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@ ; `string'
PUBLIC	?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z	; CGGuildRequestRecv
EXTRN	?g_GuildMaxMember@@3HA:DWORD			; g_GuildMaxMember
;	COMDAT ??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@
CONST	SEGMENT
??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@ DB '['
	DB	'%s][%s] Guild Request - Join : %s', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z
_TEXT	SEGMENT
_pMsg$ = -12						; size = 5
_number$ = -4						; size = 4
tv500 = 8						; size = 4
tv465 = 8						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z PROC	; CGGuildRequestRecv, COMDAT

; 8986 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 8987 : 	PMSG_GUILDQUESTSEND pMsg;
; 8988 : 	int number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00006	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00009	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0000d	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00011	66 c1 e1 08	 shl	 cx, 8
  00015	56		 push	 esi
  00016	0f b7 f1	 movzx	 esi, cx
  00019	0b f2		 or	 esi, edx
  0001b	89 75 fc	 mov	 DWORD PTR _number$[ebp], esi

; 8989 : 
; 8990 : 	if ( number < 0 || number > OBJMAX-1 )

  0001e	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00024	0f 87 01 04 00
	00		 ja	 $LN22@CGGuildReq

; 8991 : 		return;
; 8992 : 
; 8993 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	53		 push	 ebx
  00030	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00033	57		 push	 edi
  00034	8b fb		 mov	 edi, ebx
  00036	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  0003c	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00045	83 c4 04	 add	 esp, 4
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 d9 03 00
	00		 je	 $LN32@CGGuildReq

; 8994 : 		return;
; 8995 : 
; 8996 : 	if ( !gObjIsConnected(&gObj[number]))

  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0005c	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00065	83 c4 04	 add	 esp, 4
  00068	85 c0		 test	 eax, eax
  0006a	75 14		 jne	 SHORT $LN20@CGGuildReq

; 8997 : 	{
; 8998 : 		GCResultSend(aIndex, 0x51, 0x03);

  0006c	6a 03		 push	 3
  0006e	6a 51		 push	 81			; 00000051H
  00070	53		 push	 ebx
  00071	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 9022 : 		 GCServerMsgStringSend(lMsg.Get(3426), aIndex, 1);

  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	5f		 pop	 edi
  0007a	5b		 pop	 ebx
  0007b	5e		 pop	 esi

; 9131 : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN20@CGGuildReq:

; 8999 : 		return;
; 9000 : 	}
; 9001 : 
; 9002 : 	if ( gObj[aIndex].m_IfState.use > 0 )

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00085	8d 1c 07	 lea	 ebx, DWORD PTR [edi+eax]
  00088	b1 03		 mov	 cl, 3
  0008a	84 8b b8 11 00
	00		 test	 BYTE PTR [ebx+4536], cl
  00090	76 17		 jbe	 SHORT $LN19@CGGuildReq
$LN36@CGGuildReq:

; 9003 : 	{
; 9004 : 		GCResultSend(aIndex, 0x51, 0x06);

  00092	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00095	6a 06		 push	 6
  00097	6a 51		 push	 81			; 00000051H
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 9022 : 		 GCServerMsgStringSend(lMsg.Get(3426), aIndex, 1);

  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a2	5f		 pop	 edi
  000a3	5b		 pop	 ebx
  000a4	5e		 pop	 esi

; 9131 : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
$LN19@CGGuildReq:

; 9005 : 		return;
; 9006 : 	}
; 9007 : 	
; 9008 : 	if ( gObj[number].m_IfState.use > 0 )

  000a9	03 c6		 add	 eax, esi
  000ab	89 45 08	 mov	 DWORD PTR tv465[ebp], eax
  000ae	84 88 b8 11 00
	00		 test	 BYTE PTR [eax+4536], cl
  000b4	76 17		 jbe	 SHORT $LN18@CGGuildReq

; 9009 : 	{
; 9010 : 		GCResultSend(aIndex, 0x51, 0x06);

  000b6	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000b9	6a 06		 push	 6
  000bb	6a 51		 push	 81			; 00000051H
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 9022 : 		 GCServerMsgStringSend(lMsg.Get(3426), aIndex, 1);

  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	5f		 pop	 edi
  000c7	5b		 pop	 ebx
  000c8	5e		 pop	 esi

; 9131 : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
$LN18@CGGuildReq:

; 9011 : 		return;
; 9012 : 	}
; 9013 : 
; 9014 : 	if ( gObj[aIndex].Level < 6 )

  000cd	66 83 bb 96 00
	00 00 06	 cmp	 WORD PTR [ebx+150], 6
  000d5	7d 17		 jge	 SHORT $LN17@CGGuildReq

; 9015 : 	{
; 9016 : 		GCResultSend(aIndex, 0x51, 0x07);

  000d7	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000da	6a 07		 push	 7
  000dc	6a 51		 push	 81			; 00000051H
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 9022 : 		 GCServerMsgStringSend(lMsg.Get(3426), aIndex, 1);

  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e7	5f		 pop	 edi
  000e8	5b		 pop	 ebx
  000e9	5e		 pop	 esi

; 9131 : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
$LN17@CGGuildReq:

; 9017 : 		return;
; 9018 : 	}
; 9019 : 
; 9020 : #if (ENABLETEST_NEWPVP == 1)
; 9021 : 	if (g_NewPVP.IsDuel(gObj[aIndex]) || g_NewPVP.IsDuel(gObj[number])) {

  000ee	53		 push	 ebx
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000f4	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  000f9	85 c0		 test	 eax, eax
  000fb	0f 85 0a 03 00
	00		 jne	 $LN15@CGGuildReq
  00101	8b 4d 08	 mov	 ecx, DWORD PTR tv465[ebp]
  00104	51		 push	 ecx
  00105	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0010a	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  0010f	85 c0		 test	 eax, eax
  00111	0f 85 f4 02 00
	00		 jne	 $LN15@CGGuildReq

; 9023 : 		 return;
; 9024 : 	}
; 9025 : 
; 9026 : 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  00117	53		 push	 ebx
  00118	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0011d	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00122	85 c0		 test	 eax, eax
  00124	74 10		 je	 SHORT $LN14@CGGuildReq

; 9027 : 		 GCServerMsgStringSend(lMsg.Get(3427), aIndex, 1);

  00126	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00129	6a 01		 push	 1
  0012b	52		 push	 edx
  0012c	68 63 0d 00 00	 push	 3427			; 00000d63H

; 9028 : 		 return;

  00131	e9 e0 02 00 00	 jmp	 $LN35@CGGuildReq
$LN14@CGGuildReq:

; 9029 : 	}
; 9030 : #endif
; 9031 : 
; 9032 : #if (ENABLETEST_ARCA == 1)
; 9033 : 	int iArcaBattleState = g_ArcaBattle.GetState();
; 9034 : 
; 9035 : 	if( iArcaBattleState > AB_STATE_CLOSED && iArcaBattleState < AB_STATE_CLOSE )
; 9036 : 	{
; 9037 : 		GCResultSend(aIndex, 0x51, 0xA4);
; 9038 : 		return;
; 9039 : 	}
; 9040 : #endif
; 9041 : 
; 9042 : 	if ( gObj[aIndex].GuildNumber > 0 )

  00136	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013c	83 bc 0f 14 06
	00 00 00	 cmp	 DWORD PTR [edi+ecx+1556], 0
  00144	7e 17		 jle	 SHORT $LN13@CGGuildReq

; 9043 : 	{
; 9044 : 		GCResultSend(aIndex, 0x51, 0x05);

  00146	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00149	6a 05		 push	 5
  0014b	6a 51		 push	 81			; 00000051H
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH
  00156	5f		 pop	 edi
  00157	5b		 pop	 ebx
  00158	5e		 pop	 esi

; 9131 : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
$LN13@CGGuildReq:

; 9045 : 		return;
; 9046 : 	}
; 9047 : 
; 9048 : 	if ( (gObj[number].m_Option&1 ) != 1 )

  0015d	f6 84 0e 24 12
	00 00 01	 test	 BYTE PTR [esi+ecx+4644], 1
  00165	75 17		 jne	 SHORT $LN12@CGGuildReq

; 9049 : 	{
; 9050 : 		GCResultSend(aIndex, 0x51, 0x00);

  00167	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0016a	6a 00		 push	 0
  0016c	6a 51		 push	 81			; 00000051H
  0016e	51		 push	 ecx
  0016f	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH
  00177	5f		 pop	 edi
  00178	5b		 pop	 ebx
  00179	5e		 pop	 esi

; 9131 : }

  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
$LN12@CGGuildReq:

; 9051 : 		return;
; 9052 : 	}
; 9053 : 
; 9054 : 	if ( gObj[number].GuildNumber > 0 )

  0017e	83 bc 0e 14 06
	00 00 00	 cmp	 DWORD PTR [esi+ecx+1556], 0
  00186	0f 8e 68 02 00
	00		 jle	 $LN11@CGGuildReq

; 9055 : 	{
; 9056 : 		if ( strcmp(gObj[number].lpGuild->Names[0], gObj[number].Name))

  0018c	8b 84 0e 18 06
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1560]
  00193	8d 54 0e 5d	 lea	 edx, DWORD PTR [esi+ecx+93]
  00197	83 c0 2f	 add	 eax, 47			; 0000002fH
  0019a	8d 9b 00 00 00
	00		 npad	 6
$LL26@CGGuildReq:
  001a0	8a 18		 mov	 bl, BYTE PTR [eax]
  001a2	3a 1a		 cmp	 bl, BYTE PTR [edx]
  001a4	75 1a		 jne	 SHORT $LN27@CGGuildReq
  001a6	84 db		 test	 bl, bl
  001a8	74 12		 je	 SHORT $LN30@CGGuildReq
  001aa	8a 58 01	 mov	 bl, BYTE PTR [eax+1]
  001ad	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  001b0	75 0e		 jne	 SHORT $LN27@CGGuildReq
  001b2	83 c0 02	 add	 eax, 2
  001b5	83 c2 02	 add	 edx, 2
  001b8	84 db		 test	 bl, bl
  001ba	75 e4		 jne	 SHORT $LL26@CGGuildReq
$LN30@CGGuildReq:
  001bc	33 c0		 xor	 eax, eax
  001be	eb 05		 jmp	 SHORT $LN29@CGGuildReq
$LN27@CGGuildReq:
  001c0	1b c0		 sbb	 eax, eax
  001c2	83 d8 ff	 sbb	 eax, -1
$LN29@CGGuildReq:
  001c5	85 c0		 test	 eax, eax
  001c7	74 17		 je	 SHORT $LN10@CGGuildReq

; 9057 : 		{
; 9058 : 			GCResultSend(aIndex, 0x51, 0x04);

  001c9	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001cc	6a 04		 push	 4
  001ce	6a 51		 push	 81			; 00000051H
  001d0	52		 push	 edx
  001d1	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d9	5f		 pop	 edi
  001da	5b		 pop	 ebx
  001db	5e		 pop	 esi

; 9131 : }

  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c3		 ret	 0
$LN10@CGGuildReq:

; 9059 : 			return;
; 9060 : 		}
; 9061 : 
; 9062 : 		if ( gObj[number].lpGuild->WarState )

  001e0	8b 84 0e 18 06
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1560]
  001e7	80 b8 91 05 00
	00 00		 cmp	 BYTE PTR [eax+1425], 0

; 9063 : 		{
; 9064 : 			GCResultSend(aIndex, 0x51, 0x06);
; 9065 : 			return;

  001ee	0f 85 9e fe ff
	ff		 jne	 $LN36@CGGuildReq

; 9066 : 		}
; 9067 : 
; 9068 : #if (__GENS_SYSTEM__ == 1)
; 9069 : 
; 9070 : 		if( gGensSystem.m_CheckForGuild )

  001f4	80 3d 51 00 00
	00 00		 cmp	 BYTE PTR ?gGensSystem@@3VCGensSystem@@A+81, 0
  001fb	74 48		 je	 SHORT $LN6@CGGuildReq

; 9071 : 		{
; 9072 : 			if ( gObj[number].m_GensInfo.btFamily == GENS_NONE )

  001fd	8a 84 0e ac 26
	00 00		 mov	 al, BYTE PTR [esi+ecx+9900]
  00204	84 c0		 test	 al, al
  00206	75 1a		 jne	 SHORT $LN7@CGGuildReq

; 9073 : 			{
; 9074 : 				GCResultSend(aIndex,0x51,0xA1);

  00208	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0020b	68 a1 00 00 00	 push	 161			; 000000a1H
  00210	6a 51		 push	 81			; 00000051H
  00212	52		 push	 edx
  00213	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00218	83 c4 0c	 add	 esp, 12			; 0000000cH
  0021b	5f		 pop	 edi
  0021c	5b		 pop	 ebx
  0021d	5e		 pop	 esi

; 9131 : }

  0021e	8b e5		 mov	 esp, ebp
  00220	5d		 pop	 ebp
  00221	c3		 ret	 0
$LN7@CGGuildReq:

; 9075 : 				return;
; 9076 : 			}
; 9077 : 
; 9078 : 			if ( gObj[number].m_GensInfo.btFamily != gObj[aIndex].m_GensInfo.btFamily )

  00222	3a 84 0f ac 26
	00 00		 cmp	 al, BYTE PTR [edi+ecx+9900]
  00229	74 1a		 je	 SHORT $LN6@CGGuildReq

; 9079 : 			{
; 9080 : 				GCResultSend(aIndex,0x51,0xA2);

  0022b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0022e	68 a2 00 00 00	 push	 162			; 000000a2H
  00233	6a 51		 push	 81			; 00000051H
  00235	50		 push	 eax
  00236	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0023b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023e	5f		 pop	 edi
  0023f	5b		 pop	 ebx
  00240	5e		 pop	 esi

; 9131 : }

  00241	8b e5		 mov	 esp, ebp
  00243	5d		 pop	 ebp
  00244	c3		 ret	 0
$LN6@CGGuildReq:

; 9081 : 				return;
; 9082 : 			}
; 9083 : 		}
; 9084 : 
; 9085 : #endif
; 9086 : 
; 9087 : 		int MaxGuildMember;
; 9088 : 
; 9089 : 		if ( gObj[number].Class == CLASS_DARKLORD )

  00245	66 83 bc 0e 90
	00 00 00 04	 cmp	 WORD PTR [esi+ecx+144], 4

; 9090 : 			MaxGuildMember = gObj[number].Level / 10 + gObj[number].Leadership / 10;

  0024e	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00253	75 31		 jne	 SHORT $LN5@CGGuildReq
  00255	0f b7 94 0e f4
	00 00 00	 movzx	 edx, WORD PTR [esi+ecx+244]
  0025d	f7 ea		 imul	 edx
  0025f	c1 fa 02	 sar	 edx, 2
  00262	8b da		 mov	 ebx, edx
  00264	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00267	03 da		 add	 ebx, edx
  00269	0f bf 94 0e 96
	00 00 00	 movsx	 edx, WORD PTR [esi+ecx+150]
  00271	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00276	f7 ea		 imul	 edx
  00278	c1 fa 02	 sar	 edx, 2
  0027b	8b c2		 mov	 eax, edx
  0027d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00280	03 da		 add	 ebx, edx
  00282	03 c3		 add	 eax, ebx

; 9091 : 		else

  00284	eb 14		 jmp	 SHORT $LN4@CGGuildReq
$LN5@CGGuildReq:

; 9092 : 			MaxGuildMember = gObj[number].Level / 10;

  00286	0f bf 94 0e 96
	00 00 00	 movsx	 edx, WORD PTR [esi+ecx+150]
  0028e	f7 ea		 imul	 edx
  00290	c1 fa 02	 sar	 edx, 2
  00293	8b c2		 mov	 eax, edx
  00295	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00298	03 c2		 add	 eax, edx
$LN4@CGGuildReq:

; 9093 : 
; 9094 : 		if ( MaxGuildMember > g_GuildMaxMember )

  0029a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_GuildMaxMember@@3HA ; g_GuildMaxMember
  002a0	3b c2		 cmp	 eax, edx
  002a2	7e 02		 jle	 SHORT $LN3@CGGuildReq

; 9095 : 			MaxGuildMember = g_GuildMaxMember;

  002a4	8b c2		 mov	 eax, edx
$LN3@CGGuildReq:

; 9096 : 
; 9097 : 		if ( gObj[number].lpGuild->TotalCount >= MaxGuildMember )

  002a6	8b 94 0e 18 06
	00 00		 mov	 edx, DWORD PTR [esi+ecx+1560]
  002ad	0f b6 52 2e	 movzx	 edx, BYTE PTR [edx+46]
  002b1	3b d0		 cmp	 edx, eax
  002b3	7c 17		 jl	 SHORT $LN2@CGGuildReq

; 9098 : 		{
; 9099 : 			GCResultSend(aIndex, 0x51, 0x02);

  002b5	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002b8	6a 02		 push	 2
  002ba	6a 51		 push	 81			; 00000051H
  002bc	50		 push	 eax
  002bd	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  002c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c5	5f		 pop	 edi
  002c6	5b		 pop	 ebx
  002c7	5e		 pop	 esi

; 9131 : }

  002c8	8b e5		 mov	 esp, ebp
  002ca	5d		 pop	 ebp
  002cb	c3		 ret	 0
$LN2@CGGuildReq:

; 9106 : 		return;
; 9107 : 	}
; 9108 : 	
; 9109 : 	gObj[aIndex].m_IfState.use = 1;

  002cc	8d 84 0f b8 11
	00 00		 lea	 eax, DWORD PTR [edi+ecx+4536]
  002d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d5	83 e1 fd	 and	 ecx, -3			; fffffffdH
  002d8	83 c9 01	 or	 ecx, 1
  002db	89 08		 mov	 DWORD PTR [eax], ecx

; 9110 : 	gObj[aIndex].m_IfState.type = 4;

  002dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e2	8b 94 07 b8 11
	00 00		 mov	 edx, DWORD PTR [edi+eax+4536]
  002e9	81 e2 3f 01 ff
	ff		 and	 edx, -65217		; ffff013fH
  002ef	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  002f5	89 94 07 b8 11
	00 00		 mov	 DWORD PTR [edi+eax+4536], edx

; 9111 : 	gObj[aIndex].m_IfState.state = 0;

  002fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 9112 : 
; 9113 : 	gObj[number].m_IfState.use = 1;
; 9114 : 	gObj[number].m_IfState.type = 4;
; 9115 : 	gObj[number].m_IfState.state = 0;
; 9116 : 
; 9117 : 	gObj[aIndex].TargetNumber = number;
; 9118 : 	gObj[number].TargetNumber = aIndex;
; 9119 : 	gObj[aIndex].m_InterfaceTime = GetTickCount();

  00301	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  00307	b9 c3 ff ff ff	 mov	 ecx, -61		; ffffffc3H
  0030c	21 8c 07 b8 11
	00 00		 and	 DWORD PTR [edi+eax+4536], ecx
  00313	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00318	8b 94 06 b8 11
	00 00		 mov	 edx, DWORD PTR [esi+eax+4536]
  0031f	83 e2 fd	 and	 edx, -3			; fffffffdH
  00322	83 ca 01	 or	 edx, 1
  00325	89 94 06 b8 11
	00 00		 mov	 DWORD PTR [esi+eax+4536], edx
  0032c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00331	8b 94 06 b8 11
	00 00		 mov	 edx, DWORD PTR [esi+eax+4536]
  00338	81 e2 3f 01 ff
	ff		 and	 edx, -65217		; ffff013fH
  0033e	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  00344	89 94 06 b8 11
	00 00		 mov	 DWORD PTR [esi+eax+4536], edx
  0034b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00350	21 8c 06 b8 11
	00 00		 and	 DWORD PTR [esi+eax+4536], ecx
  00357	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0035c	66 8b 4d fc	 mov	 cx, WORD PTR _number$[ebp]
  00360	66 89 8c 07 38
	06 00 00	 mov	 WORD PTR [edi+eax+1592], cx
  00368	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0036e	66 8b 45 0c	 mov	 ax, WORD PTR _aIndex$[ebp]
  00372	66 89 84 16 38
	06 00 00	 mov	 WORD PTR [esi+edx+1592], ax
  0037a	ff d3		 call	 ebx
  0037c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00382	89 84 0f bc 11
	00 00		 mov	 DWORD PTR [edi+ecx+4540], eax

; 9120 : 	gObj[number].m_InterfaceTime = GetTickCount();

  00389	ff d3		 call	 ebx
  0038b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 9121 : 
; 9122 : 	PHeadSetB((LPBYTE)&pMsg, 0x50, sizeof(pMsg));

  00391	6a 05		 push	 5
  00393	89 84 16 bc 11
	00 00		 mov	 DWORD PTR [esi+edx+4540], eax
  0039a	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0039d	6a 50		 push	 80			; 00000050H
  0039f	50		 push	 eax
  003a0	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9123 : 	pMsg.NumberH = SET_NUMBERH(aIndex);

  003a5	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 9124 : 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 9125 : 
; 9126 : 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  003a8	0f b6 55 f5	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  003ac	8b c8		 mov	 ecx, eax
  003ae	c1 e9 08	 shr	 ecx, 8
  003b1	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+4], al
  003b4	52		 push	 edx
  003b5	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  003b8	88 4d f7	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  003bb	8b 4d fc	 mov	 ecx, DWORD PTR _number$[ebp]
  003be	50		 push	 eax
  003bf	51		 push	 ecx
  003c0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 9127 : 
; 9128 : 	LogAddTD("[%s][%s] Guild Request - Join : %s",
; 9129 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9130 : 		gObj[number].lpGuild->Name);

  003c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ca	8b 94 06 18 06
	00 00		 mov	 edx, DWORD PTR [esi+eax+1560]
  003d1	83 c2 04	 add	 edx, 4
  003d4	52		 push	 edx
  003d5	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  003d9	51		 push	 ecx
  003da	8d 54 07 52	 lea	 edx, DWORD PTR [edi+eax+82]
  003de	52		 push	 edx
  003df	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@
  003e4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003ea	83 c4 28	 add	 esp, 40			; 00000028H
  003ed	5f		 pop	 edi
  003ee	5b		 pop	 ebx
  003ef	5e		 pop	 esi

; 9131 : }

  003f0	8b e5		 mov	 esp, ebp
  003f2	5d		 pop	 ebp
  003f3	c3		 ret	 0
$LN11@CGGuildReq:

; 9100 : 			return;
; 9101 : 		}
; 9102 : 	}
; 9103 : 	else
; 9104 : 	{
; 9105 : 		GCResultSend(aIndex, 0x51, 0x04);

  003f4	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003f7	6a 04		 push	 4
  003f9	6a 51		 push	 81			; 00000051H
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00401	83 c4 0c	 add	 esp, 12			; 0000000cH
  00404	5f		 pop	 edi
  00405	5b		 pop	 ebx
  00406	5e		 pop	 esi

; 9131 : }

  00407	8b e5		 mov	 esp, ebp
  00409	5d		 pop	 ebp
  0040a	c3		 ret	 0
$LN15@CGGuildReq:

; 9022 : 		 GCServerMsgStringSend(lMsg.Get(3426), aIndex, 1);

  0040b	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0040e	6a 01		 push	 1
  00410	51		 push	 ecx
  00411	68 62 0d 00 00	 push	 3426			; 00000d62H
$LN35@CGGuildReq:
  00416	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0041b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00420	50		 push	 eax
  00421	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00426	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN32@CGGuildReq:
  00429	5f		 pop	 edi
  0042a	5b		 pop	 ebx
$LN22@CGGuildReq:
  0042b	5e		 pop	 esi

; 9131 : }

  0042c	8b e5		 mov	 esp, ebp
  0042e	5d		 pop	 ebp
  0042f	c3		 ret	 0
?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z ENDP	; CGGuildRequestRecv
_TEXT	ENDS
PUBLIC	?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ; CGGuildRequestResultRecv
EXTRN	?GDGuildMemberAdd@@YAXHPAD0@Z:PROC		; GDGuildMemberAdd
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z
_TEXT	SEGMENT
_result$ = -1						; size = 1
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z PROC ; CGGuildRequestResultRecv, COMDAT

; 9137 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 9138 : 	int number;
; 9139 : 	BYTE result=0;
; 9140 : 	int pnumber=-1;
; 9141 : 
; 9142 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000d	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00013	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00016	51		 push	 ecx
  00017	c6 45 ff 00	 mov	 BYTE PTR _result$[ebp], 0
  0001b	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	0f 84 eb 00 00
	00		 je	 $LN8@CGGuildReq@2

; 9143 : 		return;
; 9144 : 
; 9145 : 	number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  0002b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002e	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00032	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00036	66 c1 e2 08	 shl	 dx, 8
  0003a	53		 push	 ebx
  0003b	0f b7 da	 movzx	 ebx, dx
  0003e	0b d8		 or	 ebx, eax

; 9146 : 
; 9147 : 	if ( number < 0 || number > OBJMAX-1)

  00040	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00046	0f 87 c9 00 00
	00		 ja	 $LN14@CGGuildReq@2

; 9148 : 		return;
; 9149 : 
; 9150 : 	if ( !gObjIsConnected(&gObj[number]))

  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	57		 push	 edi
  00053	8b fb		 mov	 edi, ebx
  00055	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  0005b	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00064	83 c4 04	 add	 esp, 4
  00067	85 c0		 test	 eax, eax
  00069	75 15		 jne	 SHORT $LN7@CGGuildReq@2

; 9151 : 	{
; 9152 : 		GCResultSend(aIndex, 0x51, 0x02);

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0006e	6a 02		 push	 2
  00070	6a 51		 push	 81			; 00000051H
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 9153 : 	}
; 9154 : 	else

  00078	8a 45 ff	 mov	 al, BYTE PTR _result$[ebp]
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	eb 02		 jmp	 SHORT $LN6@CGGuildReq@2
$LN7@CGGuildReq@2:

; 9155 : 	{
; 9156 : 		result = 1;

  00080	b0 01		 mov	 al, 1
$LN6@CGGuildReq@2:

; 9157 : 	}
; 9158 : 
; 9159 : 	if ( lpMsg->Result == 0 )

  00082	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00085	80 79 03 00	 cmp	 BYTE PTR [ecx+3], 0
  00089	75 0c		 jne	 SHORT $LN5@CGGuildReq@2

; 9160 : 	{
; 9161 : 		result = 0;
; 9162 : 		GCResultSend(number, 0x51, 0x00);

  0008b	6a 00		 push	 0
  0008d	6a 51		 push	 81			; 00000051H
  0008f	53		 push	 ebx
  00090	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 9163 : 	}
; 9164 : 
; 9165 : 	if ( result == 1 )

  00095	eb 29		 jmp	 SHORT $LN16@CGGuildReq@2
$LN5@CGGuildReq@2:
  00097	3c 01		 cmp	 al, 1
  00099	75 28		 jne	 SHORT $LN13@CGGuildReq@2

; 9166 : 	{
; 9167 : 		if ( gObj[aIndex].GuildNumber > 0 )

  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a0	83 bc 06 14 06
	00 00 00	 cmp	 DWORD PTR [esi+eax+1556], 0
  000a8	7e 1e		 jle	 SHORT $LN3@CGGuildReq@2

; 9168 : 		{
; 9169 : 			GDGuildMemberAdd(number, gObj[aIndex].lpGuild->Name, gObj[number].Name);

  000aa	8d 54 07 5d	 lea	 edx, DWORD PTR [edi+eax+93]
  000ae	8b 84 06 18 06
	00 00		 mov	 eax, DWORD PTR [esi+eax+1560]
  000b5	52		 push	 edx
  000b6	83 c0 04	 add	 eax, 4
  000b9	50		 push	 eax
  000ba	53		 push	 ebx
  000bb	e8 00 00 00 00	 call	 ?GDGuildMemberAdd@@YAXHPAD0@Z ; GDGuildMemberAdd
$LN16@CGGuildReq@2:
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@CGGuildReq@2:
  000c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN3@CGGuildReq@2:

; 9170 : 		}
; 9171 : 	}
; 9172 : 
; 9173 : 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 4)

  000c8	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  000cf	ba fc ff ff ff	 mov	 edx, -4			; fffffffcH
  000d4	f6 c1 03	 test	 cl, 3
  000d7	74 1a		 je	 SHORT $LN2@CGGuildReq@2
  000d9	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  000df	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  000e5	75 0c		 jne	 SHORT $LN2@CGGuildReq@2

; 9174 : 		gObj[aIndex].m_IfState.use = 0;

  000e7	21 94 06 b8 11
	00 00		 and	 DWORD PTR [esi+eax+4536], edx
  000ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN2@CGGuildReq@2:

; 9175 : 		
; 9176 : 	if ( gObj[number].m_IfState.use && gObj[number].m_IfState.type == 4)

  000f3	8b 8c 07 b8 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4536]
  000fa	f6 c1 03	 test	 cl, 3
  000fd	74 15		 je	 SHORT $LN15@CGGuildReq@2
  000ff	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00105	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  0010b	75 07		 jne	 SHORT $LN15@CGGuildReq@2

; 9177 : 		gObj[number].m_IfState.use = 0;

  0010d	21 94 07 b8 11
	00 00		 and	 DWORD PTR [edi+eax+4536], edx
$LN15@CGGuildReq@2:
  00114	5f		 pop	 edi
$LN14@CGGuildReq@2:
  00115	5b		 pop	 ebx
$LN8@CGGuildReq@2:
  00116	5e		 pop	 esi

; 9178 : }

  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ENDP ; CGGuildRequestResultRecv
_TEXT	ENDS
PUBLIC	_pnumber$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGGuildListAll@@YAXH@Z				; CGGuildListAll
EXTRN	?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z:PROC ; CGuildClass::SearchGuild
EXTRN	?Guild@@3VCGuildClass@@A:BYTE			; Guild
EXTRN	?PHeadSetW@@YAXPAEEH@Z:PROC			; PHeadSetW
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildListAll@@YAXH@Z
_TEXT	SEGMENT
_pnumber$GSCopy$ = -1596				; size = 4
tv320 = -1592						; size = 4
_pList$ = -1588						; size = 13
tv448 = -1572						; size = 4
_lOfs$ = -1568						; size = 4
_n$ = -1564						; size = 4
_pCount$ = -1560					; size = 56
_sendbuf$ = -1504					; size = 1500
__$ArrayPad$ = -4					; size = 4
_pnumber$ = 8						; size = 4
?CGGuildListAll@@YAXH@Z PROC				; CGGuildListAll, COMDAT

; 9210 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 06 00
	00		 sub	 esp, 1596		; 0000063cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 9211 : 	if ( gObj[pnumber].lpGuild == NULL )

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR _pnumber$[ebp]
  0001d	8b de		 mov	 ebx, esi
  0001f	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00025	83 bc 03 18 06
	00 00 00	 cmp	 DWORD PTR [ebx+eax+1560], 0
  0002d	89 b5 c4 f9 ff
	ff		 mov	 DWORD PTR _pnumber$GSCopy$[ebp], esi
  00033	89 9d c8 f9 ff
	ff		 mov	 DWORD PTR tv320[ebp], ebx
  00039	0f 84 6c 02 00
	00		 je	 $LN11@CGGuildLis

; 9212 : 		return;
; 9213 : 
; 9214 : 	PMSG_GUILDLISTCOUNT pCount;
; 9215 : 	PMSG_GUILDLIST pList;
; 9216 : 	char sendbuf[1500];
; 9217 : 	int lOfs = 0;
; 9218 : 	int number;
; 9219 : 	int n;
; 9220 : 	int guildmaster = 0;
; 9221 : 	
; 9222 : 	PHeadSetW((LPBYTE)&pCount, 0x52, 0);

  0003f	6a 00		 push	 0
  00041	8d 8d e8 f9 ff
	ff		 lea	 ecx, DWORD PTR _pCount$[ebp]
  00047	6a 52		 push	 82			; 00000052H
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 9223 : 	pCount.Result = 0;
; 9224 : 	pCount.Count = 0;
; 9225 : 	lOfs += sizeof(pCount);
; 9226 : 	pCount.h.sizeH = SET_NUMBERH(lOfs);
; 9227 : 	pCount.h.sizeL = SET_NUMBERL(lOfs);
; 9228 : 
; 9229 : 	if ( gObj[pnumber].GuildNumber < 1 )

  0004f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	66 c7 85 ec f9
	ff ff 00 00	 mov	 WORD PTR _pCount$[ebp+4], 0
  00061	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  00066	66 c7 85 e9 f9
	ff ff 00 38	 mov	 WORD PTR _pCount$[ebp+1], 14336 ; 00003800H
  0006f	83 bc 13 14 06
	00 00 01	 cmp	 DWORD PTR [ebx+edx+1556], 1
  00077	89 85 e0 f9 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax
  0007d	7d 21		 jge	 SHORT $LN9@CGGuildLis

; 9230 : 	{
; 9231 : 		DataSend(pnumber, (LPBYTE)&pCount, lOfs);

  0007f	50		 push	 eax
  00080	8d 95 e8 f9 ff
	ff		 lea	 edx, DWORD PTR _pCount$[ebp]
  00086	52		 push	 edx
  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx

; 9286 : }

  00092	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00095	33 cd		 xor	 ecx, ebp
  00097	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN9@CGGuildLis:

; 9232 : 		return;
; 9233 : 	}
; 9234 : 
; 9235 : 	pCount.Count = gObj[pnumber].lpGuild->Count;

  000a0	8b 8c 13 18 06
	00 00		 mov	 ecx, DWORD PTR [ebx+edx+1560]
  000a7	0f b6 49 2d	 movzx	 ecx, BYTE PTR [ecx+45]
  000ab	8d 84 13 18 06
	00 00		 lea	 eax, DWORD PTR [ebx+edx+1560]
  000b2	88 8d ed f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], cl

; 9236 : 	pCount.TotalScore = gObj[pnumber].lpGuild->TotalScore;

  000b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ba	8b 89 98 05 00
	00		 mov	 ecx, DWORD PTR [ecx+1432]
  000c0	89 8d f0 f9 ff
	ff		 mov	 DWORD PTR _pCount$[ebp+8], ecx

; 9237 : 	pCount.Score = gObj[pnumber].lpGuild->PlayScore;

  000c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c8	0f b6 89 95 05
	00 00		 movzx	 ecx, BYTE PTR [ecx+1429]
  000cf	88 8d f4 f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+12], cl

; 9238 : 	memset(pCount.szRivalGuild, 0, sizeof(pCount.szRivalGuild));

  000d5	33 c9		 xor	 ecx, ecx
  000d7	89 8d f5 f9 ff
	ff		 mov	 DWORD PTR _pCount$[ebp+13], ecx
  000dd	89 8d f9 f9 ff
	ff		 mov	 DWORD PTR _pCount$[ebp+17], ecx
  000e3	88 8d fd f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+21], cl

; 9239 : 
; 9240 : 	if ( gObj[pnumber].lpGuild->iGuildRival )

  000e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000eb	83 b9 48 07 00
	00 00		 cmp	 DWORD PTR [ecx+1864], 0
  000f2	57		 push	 edi
  000f3	74 4e		 je	 SHORT $LN7@CGGuildLis

; 9241 : 	{
; 9242 : 		memcpy(pCount.szRivalGuild, gObj[pnumber].lpGuild->szGuildRivalName, MAX_GUILD_LEN);

  000f5	8b 91 50 07 00
	00		 mov	 edx, DWORD PTR [ecx+1872]
  000fb	89 95 f5 f9 ff
	ff		 mov	 DWORD PTR _pCount$[ebp+13], edx
  00101	8b 89 54 07 00
	00		 mov	 ecx, DWORD PTR [ecx+1876]
  00107	89 8d f9 f9 ff
	ff		 mov	 DWORD PTR _pCount$[ebp+17], ecx

; 9243 : 		_GUILD_INFO_STRUCT* lpRivalGuild = Guild.SearchGuild(gObj[pnumber].lpGuild->szGuildRivalName);

  0010d	8b 10		 mov	 edx, DWORD PTR [eax]
  0010f	81 c2 50 07 00
	00		 add	 edx, 1872		; 00000750H
  00115	52		 push	 edx
  00116	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  0011b	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild

; 9248 : 			pCount.btCount = lpRivalGuild->Count;

  00120	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00126	85 c0		 test	 eax, eax
  00128	74 19		 je	 SHORT $LN7@CGGuildLis

; 9244 : 
; 9245 : 		if( lpRivalGuild )
; 9246 : 		{
; 9247 : 			memcpy(pCount.btUnk,lpRivalGuild->Mark,sizeof(lpRivalGuild->Mark));

  0012a	8d 70 0d	 lea	 esi, DWORD PTR [eax+13]
  0012d	b9 08 00 00 00	 mov	 ecx, 8
  00132	8d bd ff f9 ff
	ff		 lea	 edi, DWORD PTR _pCount$[ebp+23]
  00138	f3 a5		 rep movsd

; 9248 : 			pCount.btCount = lpRivalGuild->Count;

  0013a	8a 40 2d	 mov	 al, BYTE PTR [eax+45]
  0013d	88 85 fe f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+22], al
$LN7@CGGuildLis:

; 9249 : 		}
; 9250 : 	}
; 9251 : 
; 9252 : 	pCount.Result = 1;
; 9253 : 	guildmaster = 1;
; 9254 : 
; 9255 : 	if ( pCount.Count == 0 )

  00143	80 bd ed f9 ff
	ff 00		 cmp	 BYTE PTR _pCount$[ebp+5], 0
  0014a	c6 85 ec f9 ff
	ff 01		 mov	 BYTE PTR _pCount$[ebp+4], 1
  00151	0f 84 53 01 00
	00		 je	 $LN18@CGGuildLis

; 9256 : 		return;
; 9257 : 
; 9258 : 	pCount.Count = 0;
; 9259 : 
; 9260 : 	for ( n=0;n<MAX_USER_GUILD;n++)

  00157	33 f6		 xor	 esi, esi
  00159	c6 85 ed f9 ff
	ff 00		 mov	 BYTE PTR _pCount$[ebp+5], 0
  00160	89 b5 e4 f9 ff
	ff		 mov	 DWORD PTR _n$[ebp], esi
  00166	8d bd 58 fa ff
	ff		 lea	 edi, DWORD PTR _sendbuf$[ebp+56]
  0016c	c7 85 dc f9 ff
	ff 00 06 00 00	 mov	 DWORD PTR tv448[ebp], 1536 ; 00000600H
  00176	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL17@CGGuildLis:

; 9261 : 	{
; 9262 : 		number = gObj[pnumber].lpGuild->Use[n];

  00180	8b 8c 13 18 06
	00 00		 mov	 ecx, DWORD PTR [ebx+edx+1560]

; 9263 : 
; 9264 : 		if ( number > 0 )

  00187	8b 85 e4 f9 ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  0018d	80 bc 01 40 04
	00 00 00	 cmp	 BYTE PTR [ecx+eax+1088], 0
  00195	0f 86 ab 00 00
	00		 jbe	 $LN4@CGGuildLis

; 9265 : 		{
; 9266 : 			memset(&pList, 0, sizeof(pList));

  0019b	33 c0		 xor	 eax, eax
  0019d	89 85 d4 f9 ff
	ff		 mov	 DWORD PTR _pList$[ebp+8], eax
  001a3	89 85 d0 f9 ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], eax

; 9267 : 			memcpy(pList.Name, gObj[pnumber].lpGuild->Names[n], sizeof(pList.Name));

  001a9	8b 5c 0e 2f	 mov	 ebx, DWORD PTR [esi+ecx+47]
  001ad	89 85 cc f9 ff
	ff		 mov	 DWORD PTR _pList$[ebp], eax
  001b3	88 85 d8 f9 ff
	ff		 mov	 BYTE PTR _pList$[ebp+12], al
  001b9	8b 44 0e 33	 mov	 eax, DWORD PTR [esi+ecx+51]
  001bd	89 85 d0 f9 ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], eax
  001c3	66 8b 44 0e 37	 mov	 ax, WORD PTR [esi+ecx+55]
  001c8	66 89 85 d4 f9
	ff ff		 mov	 WORD PTR _pList$[ebp+8], ax

; 9268 : 			pList.Number = gObj[pnumber].lpGuild->pServer[n];

  001cf	8b 85 c8 f9 ff
	ff		 mov	 eax, DWORD PTR tv320[ebp]
  001d5	8b 94 10 18 06
	00 00		 mov	 edx, DWORD PTR [eax+edx+1560]
  001dc	8b 85 e4 f9 ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  001e2	8d 84 02 90 04
	00 00		 lea	 eax, DWORD PTR [edx+eax+1168]
  001e9	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  001ec	88 95 d6 f9 ff
	ff		 mov	 BYTE PTR _pList$[ebp+10], dl

; 9269 : 			pList.ConnectAServer = (short)gObj[pnumber].lpGuild->pServer[n] & 0x7F;

  001f2	8a 10		 mov	 dl, BYTE PTR [eax]
  001f4	8a c2		 mov	 al, dl
  001f6	24 7f		 and	 al, 127			; 0000007fH
  001f8	88 85 d7 f9 ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], al

; 9270 : 
; 9271 : 			if ( gObj[pnumber].lpGuild->pServer[n] >= 0 )

  001fe	84 d2		 test	 dl, dl
  00200	78 08		 js	 SHORT $LN1@CGGuildLis

; 9272 : 				pList.ConnectAServer |= 0x80;

  00202	0c 80		 or	 al, 128			; 00000080H
  00204	88 85 d7 f9 ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], al
$LN1@CGGuildLis:

; 9273 : 
; 9274 : 			pList.btGuildStatus = gObj[pnumber].lpGuild->GuildStatus[n];

  0020a	8b 85 dc f9 ff
	ff		 mov	 eax, DWORD PTR tv448[ebp]
  00210	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]

; 9275 : 			memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  00213	8b 95 d0 f9 ff
	ff		 mov	 edx, DWORD PTR _pList$[ebp+4]
  00219	8b 85 d4 f9 ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp+8]

; 9276 : 			lOfs+= sizeof(pList);

  0021f	83 85 e0 f9 ff
	ff 0d		 add	 DWORD PTR _lOfs$[ebp], 13 ; 0000000dH
  00226	89 1f		 mov	 DWORD PTR [edi], ebx

; 9277 : 			pCount.Count++;

  00228	8b 9d c8 f9 ff
	ff		 mov	 ebx, DWORD PTR tv320[ebp]
  0022e	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00231	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00237	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0023a	88 4f 0c	 mov	 BYTE PTR [edi+12], cl
  0023d	83 c7 0d	 add	 edi, 13			; 0000000dH
  00240	fe 85 ed f9 ff
	ff		 inc	 BYTE PTR _pCount$[ebp+5]
$LN4@CGGuildLis:

; 9256 : 		return;
; 9257 : 
; 9258 : 	pCount.Count = 0;
; 9259 : 
; 9260 : 	for ( n=0;n<MAX_USER_GUILD;n++)

  00246	8b 85 dc f9 ff
	ff		 mov	 eax, DWORD PTR tv448[ebp]
  0024c	ff 85 e4 f9 ff
	ff		 inc	 DWORD PTR _n$[ebp]
  00252	83 c0 04	 add	 eax, 4
  00255	83 c6 0b	 add	 esi, 11			; 0000000bH
  00258	89 85 dc f9 ff
	ff		 mov	 DWORD PTR tv448[ebp], eax
  0025e	3d 40 07 00 00	 cmp	 eax, 1856		; 00000740H
  00263	0f 8c 17 ff ff
	ff		 jl	 $LL17@CGGuildLis

; 9278 : 		}
; 9279 : 	}
; 9280 : 
; 9281 : 	pCount.h.sizeH = SET_NUMBERH(lOfs);

  00269	8b 85 e0 f9 ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0026f	8b c8		 mov	 ecx, eax
  00271	c1 e9 08	 shr	 ecx, 8

; 9282 : 	pCount.h.sizeL = SET_NUMBERL(lOfs);
; 9283 : 	memcpy(sendbuf, (LPBYTE)&pCount, sizeof(pCount));
; 9284 : 
; 9285 : 	DataSend(pnumber, (LPBYTE)sendbuf, lOfs);

  00274	50		 push	 eax
  00275	88 85 ea f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+2], al
  0027b	8b 85 c4 f9 ff
	ff		 mov	 eax, DWORD PTR _pnumber$GSCopy$[ebp]
  00281	8d 95 20 fa ff
	ff		 lea	 edx, DWORD PTR _sendbuf$[ebp]
  00287	88 8d e9 f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], cl
  0028d	52		 push	 edx
  0028e	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00293	8d b5 e8 f9 ff
	ff		 lea	 esi, DWORD PTR _pCount$[ebp]
  00299	8d bd 20 fa ff
	ff		 lea	 edi, DWORD PTR _sendbuf$[ebp]
  0029f	50		 push	 eax
  002a0	f3 a5		 rep movsd
  002a2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002a7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@CGGuildLis:
  002aa	5f		 pop	 edi
$LN11@CGGuildLis:

; 9286 : }

  002ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ae	5e		 pop	 esi
  002af	33 cd		 xor	 ecx, ebp
  002b1	5b		 pop	 ebx
  002b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b7	8b e5		 mov	 esp, ebp
  002b9	5d		 pop	 ebp
  002ba	c3		 ret	 0
?CGGuildListAll@@YAXH@Z ENDP				; CGGuildListAll
_TEXT	ENDS
PUBLIC	??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@ ; `string'
PUBLIC	??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z	; CGGuildDelUser
EXTRN	?GDGuildMemberDel@@YAXHPAD0@Z:PROC		; GDGuildMemberDel
EXTRN	?GDGuildDestroySend@@YAXHPAD0@Z:PROC		; GDGuildDestroySend
EXTRN	?gObjGuildWarMasterClose@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjGuildWarMasterClose
;	COMDAT ??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@
CONST	SEGMENT
??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@ DB '['
	DB	'%s][%s] Guild Request - Leave : %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@
CONST	SEGMENT
??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@ DB '['
	DB	'%s][%s] Guild Request - Dismiss All : %s', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z
_TEXT	SEGMENT
tv288 = -64						; size = 4
_aIndex$GSCopy$ = -60					; size = 4
_pMsg$ = -56						; size = 4
_guildname$ = -52					; size = 11
_memberid$ = -40					; size = 11
_joomin$ = -28						; size = 21
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z PROC	; CGGuildDelUser, COMDAT

; 9297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 9298 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0001d	57		 push	 edi
  0001e	8b fb		 mov	 edi, ebx
  00020	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00026	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00029	51		 push	 ecx
  0002a	89 5d c4	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0002d	89 7d c0	 mov	 DWORD PTR tv288[ebp], edi
  00030	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00035	83 c4 04	 add	 esp, 4
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 e2 02 00
	00		 je	 $LN5@CGGuildDel

; 9299 : 		return;
; 9300 : 
; 9301 : 	if ( gObj[aIndex].GuildNumber < 1 )

  00040	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00046	83 bc 17 14 06
	00 00 01	 cmp	 DWORD PTR [edi+edx+1556], 1
  0004e	0f 8c ce 02 00
	00		 jl	 $LN5@CGGuildDel

; 9302 : 		return;
; 9303 : 
; 9304 : 	char joomin[21];
; 9305 : 	char memberid[11];
; 9306 : 	char guildname[11];
; 9307 : 	PMSG_GUILDDELUSER_RESULT pMsg;
; 9308 : 	
; 9309 : 	PHeadSetB((LPBYTE)&pMsg, 0x53, sizeof(pMsg));

  00054	6a 04		 push	 4
  00056	8d 45 c8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00059	6a 53		 push	 83			; 00000053H
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9310 : 	pMsg.Result = 3;
; 9311 : 
; 9312 : 	if ( !gGuildDestroy )

  00064	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGuildDestroy@@3HA, 0 ; gGuildDestroy
  0006b	c6 45 cb 03	 mov	 BYTE PTR _pMsg$[ebp+3], 3
  0006f	75 23		 jne	 SHORT $LN12@CGGuildDel

; 9313 : 	{
; 9314 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00071	0f b6 4d c9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00075	51		 push	 ecx
  00076	8d 55 c8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00079	52		 push	 edx
  0007a	53		 push	 ebx
  0007b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx

; 9392 : 	}
; 9393 : }

  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN12@CGGuildDel:

; 9315 : 		return;
; 9316 : 	}
; 9317 : 
; 9318 : #if (ENABLETEST_ARCA == 1)
; 9319 : 	int iArcaBattleState = g_ArcaBattle.GetState();
; 9320 : 
; 9321 : 	if( iArcaBattleState > AB_STATE_CLOSED && iArcaBattleState < AB_STATE_CLOSE )
; 9322 : 	{
; 9323 : 		pMsg.Result = 6;
; 9324 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 9325 : 		return;
; 9326 : 	}
; 9327 : #endif
; 9328 : 
; 9329 : 	memset(memberid, 0, sizeof(memberid));
; 9330 : 	memset(guildname, 0, sizeof(guildname));
; 9331 : 	memcpy(memberid, lpMsg->Name, MAX_ACCOUNT_LEN);

  00094	66 8b 56 0b	 mov	 dx, WORD PTR [esi+11]
  00098	8b 4e 07	 mov	 ecx, DWORD PTR [esi+7]

; 9332 : 	strcpy(guildname, gObj[aIndex].lpGuild->Name);

  0009b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a1	33 c0		 xor	 eax, eax
  000a3	89 45 d8	 mov	 DWORD PTR _memberid$[ebp], eax
  000a6	89 45 dc	 mov	 DWORD PTR _memberid$[ebp+4], eax
  000a9	66 89 45 e0	 mov	 WORD PTR _memberid$[ebp+8], ax
  000ad	88 45 e2	 mov	 BYTE PTR _memberid$[ebp+10], al
  000b0	89 45 cc	 mov	 DWORD PTR _guildname$[ebp], eax
  000b3	89 45 d0	 mov	 DWORD PTR _guildname$[ebp+4], eax
  000b6	66 89 45 d4	 mov	 WORD PTR _guildname$[ebp+8], ax
  000ba	88 45 d6	 mov	 BYTE PTR _guildname$[ebp+10], al
  000bd	8b 46 03	 mov	 eax, DWORD PTR [esi+3]
  000c0	89 45 d8	 mov	 DWORD PTR _memberid$[ebp], eax
  000c3	66 89 55 e0	 mov	 WORD PTR _memberid$[ebp+8], dx
  000c7	89 4d dc	 mov	 DWORD PTR _memberid$[ebp+4], ecx
  000ca	8b 84 1f 18 06
	00 00		 mov	 eax, DWORD PTR [edi+ebx+1560]
  000d1	83 c0 04	 add	 eax, 4
  000d4	8d 55 cc	 lea	 edx, DWORD PTR _guildname$[ebp]
$LL17@CGGuildDel:
  000d7	8a 08		 mov	 cl, BYTE PTR [eax]
  000d9	88 0a		 mov	 BYTE PTR [edx], cl
  000db	40		 inc	 eax
  000dc	42		 inc	 edx
  000dd	84 c9		 test	 cl, cl
  000df	75 f6		 jne	 SHORT $LL17@CGGuildDel

; 9333 : 
; 9334 : 	if ( !strcmp(gObj[aIndex].lpGuild->Names[0], gObj[aIndex].Name ))

  000e1	8b 45 c0	 mov	 eax, DWORD PTR tv288[ebp]
  000e4	8b 84 18 18 06
	00 00		 mov	 eax, DWORD PTR [eax+ebx+1560]
  000eb	8d 7c 1f 5d	 lea	 edi, DWORD PTR [edi+ebx+93]
  000ef	8b cf		 mov	 ecx, edi
  000f1	83 c0 2f	 add	 eax, 47			; 0000002fH
$LL19@CGGuildDel:
  000f4	8a 10		 mov	 dl, BYTE PTR [eax]
  000f6	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000f8	75 1a		 jne	 SHORT $LN20@CGGuildDel
  000fa	84 d2		 test	 dl, dl
  000fc	74 12		 je	 SHORT $LN21@CGGuildDel
  000fe	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00101	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00104	75 0e		 jne	 SHORT $LN20@CGGuildDel
  00106	83 c0 02	 add	 eax, 2
  00109	83 c1 02	 add	 ecx, 2
  0010c	84 d2		 test	 dl, dl
  0010e	75 e4		 jne	 SHORT $LL19@CGGuildDel
$LN21@CGGuildDel:
  00110	33 c0		 xor	 eax, eax
  00112	eb 05		 jmp	 SHORT $LN22@CGGuildDel
$LN20@CGGuildDel:
  00114	1b c0		 sbb	 eax, eax
  00116	83 d8 ff	 sbb	 eax, -1
$LN22@CGGuildDel:
  00119	85 c0		 test	 eax, eax
  0011b	0f 85 0a 01 00
	00		 jne	 $LN11@CGGuildDel

; 9335 : 	{
; 9336 : 		memset(joomin, 0, sizeof(joomin));
; 9337 : 		memcpy(joomin, lpMsg->JoominNumber, 20);
; 9338 : 
; 9339 : #if (__CUSTOM__ == 1)
; 9340 : 		if ( gc_bPersonalID == FALSE || gObjJoominCheck(aIndex, joomin) == TRUE )

  00121	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gc_bPersonalID@@3HA, 0 ; gc_bPersonalID
  00128	8b 4e 0d	 mov	 ecx, DWORD PTR [esi+13]
  0012b	8b 56 11	 mov	 edx, DWORD PTR [esi+17]
  0012e	89 45 e4	 mov	 DWORD PTR _joomin$[ebp], eax
  00131	89 45 e8	 mov	 DWORD PTR _joomin$[ebp+4], eax
  00134	89 45 ec	 mov	 DWORD PTR _joomin$[ebp+8], eax
  00137	89 45 f0	 mov	 DWORD PTR _joomin$[ebp+12], eax
  0013a	89 45 f4	 mov	 DWORD PTR _joomin$[ebp+16], eax
  0013d	88 45 f8	 mov	 BYTE PTR _joomin$[ebp+20], al
  00140	8b 46 15	 mov	 eax, DWORD PTR [esi+21]
  00143	89 4d e4	 mov	 DWORD PTR _joomin$[ebp], ecx
  00146	8b 4e 19	 mov	 ecx, DWORD PTR [esi+25]
  00149	89 55 e8	 mov	 DWORD PTR _joomin$[ebp+4], edx
  0014c	8b 56 1d	 mov	 edx, DWORD PTR [esi+29]
  0014f	89 45 ec	 mov	 DWORD PTR _joomin$[ebp+8], eax
  00152	89 4d f0	 mov	 DWORD PTR _joomin$[ebp+12], ecx
  00155	89 55 f4	 mov	 DWORD PTR _joomin$[ebp+16], edx
  00158	74 42		 je	 SHORT $LN32@CGGuildDel
  0015a	8b 75 c4	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  0015d	8d 45 e4	 lea	 eax, DWORD PTR _joomin$[ebp]
  00160	50		 push	 eax
  00161	56		 push	 esi
  00162	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  00167	83 c4 08	 add	 esp, 8
  0016a	83 f8 01	 cmp	 eax, 1
  0016d	74 27		 je	 SHORT $LN31@CGGuildDel

; 9357 : 		}
; 9358 : 		else
; 9359 : 		{
; 9360 : 			pMsg.Result = 0;
; 9361 : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0016f	0f b6 4d c9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00173	51		 push	 ecx
  00174	8d 55 c8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00177	52		 push	 edx
  00178	56		 push	 esi
  00179	c6 45 cb 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  0017d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00182	83 c4 0c	 add	 esp, 12			; 0000000cH
  00185	5f		 pop	 edi
  00186	5e		 pop	 esi
  00187	5b		 pop	 ebx

; 9392 : 	}
; 9393 : }

  00188	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018b	33 cd		 xor	 ecx, ebp
  0018d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c3		 ret	 0
$LN31@CGGuildDel:

; 9362 : 			return;

  00196	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN32@CGGuildDel:

; 9341 : #else
; 9342 : 		if ( gObjJoominCheck(aIndex, joomin) == TRUE )
; 9343 : #endif
; 9344 : 		{
; 9345 : 			if ( !strcmp(memberid, gObj[aIndex].Name ))

  0019c	8b 7d c0	 mov	 edi, DWORD PTR tv288[ebp]
  0019f	8d 34 1f	 lea	 esi, DWORD PTR [edi+ebx]
  001a2	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  001a5	8d 45 d8	 lea	 eax, DWORD PTR _memberid$[ebp]
$LL23@CGGuildDel:
  001a8	8a 10		 mov	 dl, BYTE PTR [eax]
  001aa	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001ac	75 1a		 jne	 SHORT $LN24@CGGuildDel
  001ae	84 d2		 test	 dl, dl
  001b0	74 12		 je	 SHORT $LN25@CGGuildDel
  001b2	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001b5	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001b8	75 0e		 jne	 SHORT $LN24@CGGuildDel
  001ba	83 c0 02	 add	 eax, 2
  001bd	83 c1 02	 add	 ecx, 2
  001c0	84 d2		 test	 dl, dl
  001c2	75 e4		 jne	 SHORT $LL23@CGGuildDel
$LN25@CGGuildDel:
  001c4	33 c0		 xor	 eax, eax
  001c6	eb 05		 jmp	 SHORT $LN26@CGGuildDel
$LN24@CGGuildDel:
  001c8	1b c0		 sbb	 eax, eax
  001ca	83 d8 ff	 sbb	 eax, -1
$LN26@CGGuildDel:
  001cd	85 c0		 test	 eax, eax
  001cf	75 29		 jne	 SHORT $LN8@CGGuildDel

; 9346 : 			{
; 9347 : 				gObjGuildWarMasterClose(&gObj[aIndex]);

  001d1	56		 push	 esi
  001d2	e8 00 00 00 00	 call	 ?gObjGuildWarMasterClose@@YAHPAUOBJECTSTRUCT@@@Z ; gObjGuildWarMasterClose

; 9348 : 				GDGuildDestroySend(aIndex, gObj[aIndex].lpGuild->Name, gObj[aIndex].Name);

  001d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001dc	8b 94 07 18 06
	00 00		 mov	 edx, DWORD PTR [edi+eax+1560]
  001e3	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  001e7	8b 45 c4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  001ea	51		 push	 ecx
  001eb	83 c2 04	 add	 edx, 4
  001ee	52		 push	 edx
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ?GDGuildDestroySend@@YAXHPAD0@Z ; GDGuildDestroySend
  001f5	83 c4 10	 add	 esp, 16			; 00000010H

; 9349 : 			}
; 9350 : 			else

  001f8	eb 14		 jmp	 SHORT $LN7@CGGuildDel
$LN8@CGGuildDel:

; 9351 : 			{
; 9352 : 				GDGuildMemberDel(aIndex, guildname, memberid);

  001fa	8b 45 c4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  001fd	8d 4d d8	 lea	 ecx, DWORD PTR _memberid$[ebp]
  00200	51		 push	 ecx
  00201	8d 55 cc	 lea	 edx, DWORD PTR _guildname$[ebp]
  00204	52		 push	 edx
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 ?GDGuildMemberDel@@YAXHPAD0@Z ; GDGuildMemberDel
  0020b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CGGuildDel:

; 9353 : 			}
; 9354 : 
; 9355 : 			LogAddTD("[%s][%s] Guild Request - Dismiss All : %s",
; 9356 : 				gObj[aIndex].AccountID,gObj[aIndex].Name, guildname);

  0020e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00213	8d 4d cc	 lea	 ecx, DWORD PTR _guildname$[ebp]
  00216	51		 push	 ecx
  00217	8d 54 07 5d	 lea	 edx, DWORD PTR [edi+eax+93]
  0021b	52		 push	 edx
  0021c	8d 44 07 52	 lea	 eax, DWORD PTR [edi+eax+82]
  00220	50		 push	 eax
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@

; 9363 : 		}
; 9364 : 	}
; 9365 : 	else

  00226	e9 ee 00 00 00	 jmp	 $LN34@CGGuildDel
$LN11@CGGuildDel:

; 9366 : 	{
; 9367 : 		if ( strcmp(memberid, gObj[aIndex].Name) )

  0022b	8b cf		 mov	 ecx, edi
  0022d	8d 45 d8	 lea	 eax, DWORD PTR _memberid$[ebp]
$LL27@CGGuildDel:
  00230	8a 10		 mov	 dl, BYTE PTR [eax]
  00232	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00234	75 1a		 jne	 SHORT $LN28@CGGuildDel
  00236	84 d2		 test	 dl, dl
  00238	74 12		 je	 SHORT $LN29@CGGuildDel
  0023a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0023d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00240	75 0e		 jne	 SHORT $LN28@CGGuildDel
  00242	83 c0 02	 add	 eax, 2
  00245	83 c1 02	 add	 ecx, 2
  00248	84 d2		 test	 dl, dl
  0024a	75 e4		 jne	 SHORT $LL27@CGGuildDel
$LN29@CGGuildDel:
  0024c	33 c0		 xor	 eax, eax
  0024e	eb 05		 jmp	 SHORT $LN30@CGGuildDel
$LN28@CGGuildDel:
  00250	1b c0		 sbb	 eax, eax
  00252	83 d8 ff	 sbb	 eax, -1
$LN30@CGGuildDel:
  00255	85 c0		 test	 eax, eax
  00257	74 2a		 je	 SHORT $LN4@CGGuildDel

; 9368 : 		{
; 9369 : 			pMsg.Result = 0;
; 9370 : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00259	0f b6 4d c9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0025d	8b 45 c4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00260	51		 push	 ecx
  00261	8d 55 c8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00264	52		 push	 edx
  00265	50		 push	 eax
  00266	c6 45 cb 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  0026a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0026f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5b		 pop	 ebx

; 9392 : 	}
; 9393 : }

  00275	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00278	33 cd		 xor	 ecx, ebp
  0027a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027f	8b e5		 mov	 esp, ebp
  00281	5d		 pop	 ebp
  00282	c3		 ret	 0
$LN4@CGGuildDel:

; 9371 : 			return;
; 9372 : 		}
; 9373 : 
; 9374 : 		memset(joomin, 0, sizeof(joomin));
; 9375 : 		memcpy(joomin, lpMsg->JoominNumber, 20);

  00283	8b 4e 0d	 mov	 ecx, DWORD PTR [esi+13]
  00286	8b 56 11	 mov	 edx, DWORD PTR [esi+17]
  00289	33 c0		 xor	 eax, eax

; 9376 : 
; 9377 : #if (__CUSTOM__ == 1)
; 9378 : 		if ( gc_bPersonalID == FALSE || gObjJoominCheck(aIndex, joomin) == TRUE )

  0028b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gc_bPersonalID@@3HA, 0 ; gc_bPersonalID
  00292	89 45 e4	 mov	 DWORD PTR _joomin$[ebp], eax
  00295	89 45 e8	 mov	 DWORD PTR _joomin$[ebp+4], eax
  00298	89 45 ec	 mov	 DWORD PTR _joomin$[ebp+8], eax
  0029b	89 45 f0	 mov	 DWORD PTR _joomin$[ebp+12], eax
  0029e	89 45 f4	 mov	 DWORD PTR _joomin$[ebp+16], eax
  002a1	88 45 f8	 mov	 BYTE PTR _joomin$[ebp+20], al
  002a4	8b 46 15	 mov	 eax, DWORD PTR [esi+21]
  002a7	89 4d e4	 mov	 DWORD PTR _joomin$[ebp], ecx
  002aa	8b 4e 19	 mov	 ecx, DWORD PTR [esi+25]
  002ad	89 55 e8	 mov	 DWORD PTR _joomin$[ebp+4], edx
  002b0	8b 56 1d	 mov	 edx, DWORD PTR [esi+29]
  002b3	8b 75 c4	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  002b6	89 45 ec	 mov	 DWORD PTR _joomin$[ebp+8], eax
  002b9	89 4d f0	 mov	 DWORD PTR _joomin$[ebp+12], ecx
  002bc	89 55 f4	 mov	 DWORD PTR _joomin$[ebp+16], edx
  002bf	74 2c		 je	 SHORT $LN2@CGGuildDel
  002c1	8d 45 e4	 lea	 eax, DWORD PTR _joomin$[ebp]
  002c4	50		 push	 eax
  002c5	56		 push	 esi
  002c6	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  002cb	83 c4 08	 add	 esp, 8
  002ce	83 f8 01	 cmp	 eax, 1
  002d1	74 1a		 je	 SHORT $LN2@CGGuildDel

; 9384 : 		}
; 9385 : 		else
; 9386 : 		{
; 9387 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 108)), aIndex, 1);

  002d3	6a 01		 push	 1
  002d5	56		 push	 esi
  002d6	68 6c 04 00 00	 push	 1132			; 0000046cH
  002db	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  002e0	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  002eb	eb 0e		 jmp	 SHORT $LN35@CGGuildDel
$LN2@CGGuildDel:

; 9379 : #else
; 9380 : 		if ( gObjJoominCheck(aIndex, joomin) == TRUE )
; 9381 : #endif
; 9382 : 		{
; 9383 : 			GDGuildMemberDel(aIndex, guildname, memberid);

  002ed	8d 4d d8	 lea	 ecx, DWORD PTR _memberid$[ebp]
  002f0	51		 push	 ecx
  002f1	8d 55 cc	 lea	 edx, DWORD PTR _guildname$[ebp]
  002f4	52		 push	 edx
  002f5	56		 push	 esi
  002f6	e8 00 00 00 00	 call	 ?GDGuildMemberDel@@YAXHPAD0@Z ; GDGuildMemberDel
$LN35@CGGuildDel:

; 9388 : 		}
; 9389 : 
; 9390 : 		LogAddTD("[%s][%s] Guild Request - Leave : %s",
; 9391 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, guildname);

  002fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00300	83 c4 0c	 add	 esp, 12			; 0000000cH
  00303	8d 4d cc	 lea	 ecx, DWORD PTR _guildname$[ebp]
  00306	51		 push	 ecx
  00307	8b 4d c0	 mov	 ecx, DWORD PTR tv288[ebp]
  0030a	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  0030e	52		 push	 edx
  0030f	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  00313	50		 push	 eax
  00314	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@
$LN34@CGGuildDel:
  00319	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0031f	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@CGGuildDel:

; 9392 : 	}
; 9393 : }

  00322	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00325	5f		 pop	 edi
  00326	5e		 pop	 esi
  00327	33 cd		 xor	 ecx, ebp
  00329	5b		 pop	 ebx
  0032a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032f	8b e5		 mov	 esp, ebp
  00331	5d		 pop	 ebp
  00332	c3		 ret	 0
?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z ENDP	; CGGuildDelUser
_TEXT	ENDS
PUBLIC	?GCGuildDelUserResult@@YAXHE@Z			; GCGuildDelUserResult
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildDelUserResult@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Result$ = 12						; size = 1
?GCGuildDelUserResult@@YAXHE@Z PROC			; GCGuildDelUserResult, COMDAT

; 9399 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 9400 : 	PMSG_GUILDDELUSER_RESULT pMsg;
; 9401 : 
; 9402 : 	PHeadSetB((LPBYTE)&pMsg, 0x53, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 53		 push	 83			; 00000053H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9403 : 	pMsg.Result = Result;
; 9404 : 
; 9405 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 0c	 mov	 cl, BYTE PTR _Result$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 9406 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GCGuildDelUserResult@@YAXHE@Z ENDP			; GCGuildDelUserResult
_TEXT	ENDS
PUBLIC	?GCGuildMasterQuestionSend@@YAXH@Z		; GCGuildMasterQuestionSend
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildMasterQuestionSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 3
_aIndex$ = 8						; size = 4
?GCGuildMasterQuestionSend@@YAXH@Z PROC			; GCGuildMasterQuestionSend, COMDAT

; 9418 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 9419 : 	if ( gObj[aIndex].m_IfState.use > 0 )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000d	8b f7		 mov	 esi, edi
  0000f	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00015	f6 84 06 b8 11
	00 00 03	 test	 BYTE PTR [esi+eax+4536], 3
  0001d	77 64		 ja	 SHORT $LN2@GCGuildMas

; 9420 : 	{
; 9421 : 		return;
; 9422 : 	}
; 9423 : 
; 9424 : 	PMSG_GUILDMASTERQUESTION pMsg;
; 9425 : 
; 9426 : 	PHeadSetB((LPBYTE)&pMsg, 0x54, sizeof(pMsg));

  0001f	6a 03		 push	 3
  00021	8d 4d 08	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00024	6a 54		 push	 84			; 00000054H
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9427 : 	gObj[aIndex].m_IfState.use = 1;

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00031	8b 94 06 b8 11
	00 00		 mov	 edx, DWORD PTR [esi+eax+4536]
  00038	83 e2 fd	 and	 edx, -3			; fffffffdH
  0003b	83 ca 01	 or	 edx, 1
  0003e	89 94 06 b8 11
	00 00		 mov	 DWORD PTR [esi+eax+4536], edx

; 9428 : 	gObj[aIndex].m_IfState.type = 5;

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004a	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  00051	81 e1 7f 01 ff
	ff		 and	 ecx, -65153		; ffff017fH
  00057	81 c9 40 01 00
	00		 or	 ecx, 320		; 00000140H
  0005d	89 8c 06 b8 11
	00 00		 mov	 DWORD PTR [esi+eax+4536], ecx

; 9429 : 	gObj[aIndex].m_IfState.state = 0;

  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00069	83 a4 06 b8 11
	00 00 c3	 and	 DWORD PTR [esi+eax+4536], -61 ; ffffffc3H

; 9430 : 
; 9431 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00071	0f b6 55 09	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00075	52		 push	 edx
  00076	8d 45 08	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00079	50		 push	 eax
  0007a	57		 push	 edi
  0007b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00080	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@GCGuildMas:
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi

; 9432 : }

  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
?GCGuildMasterQuestionSend@@YAXH@Z ENDP			; GCGuildMasterQuestionSend
_TEXT	ENDS
PUBLIC	?GCGuildMasterManagerRun@@YAXH@Z		; GCGuildMasterManagerRun
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildMasterManagerRun@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?GCGuildMasterManagerRun@@YAXH@Z PROC			; GCGuildMasterManagerRun, COMDAT

; 9470 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 9471 : 	PMSG_GUILDMASTERMANAGER_RUN pMsg;
; 9472 : 
; 9473 : 	PHeadSetB((LPBYTE)&pMsg, 0x55, sizeof(pMsg));

  00004	6a 03		 push	 3
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 55		 push	 85			; 00000055H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9474 : 
; 9475 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 4d fd	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00015	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00018	51		 push	 ecx
  00019	8d 55 fc	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0001c	52		 push	 edx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00023	83 c4 18	 add	 esp, 24			; 00000018H

; 9476 : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?GCGuildMasterManagerRun@@YAXH@Z ENDP			; GCGuildMasterManagerRun
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ; CGGuildMasterInfoSave
EXTRN	?GDGuildCreateSend@@YAXHPAD0PAEH@Z:PROC		; GDGuildCreateSend
EXTRN	?g_MultilangGuildName@@3EA:BYTE			; g_MultilangGuildName
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z
_TEXT	SEGMENT
tv258 = -24						; size = 4
_pMsg$220763 = -24					; size = 5
_pMsg$220753 = -24					; size = 5
_GuildName$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z PROC ; CGGuildMasterInfoSave, COMDAT

; 9482 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMsg$[ebp]

; 9483 : 	char GuildName[MAX_GUILD_LEN+1];
; 9484 : 	GuildName[MAX_GUILD_LEN] ='\0';
; 9485 : 	memcpy(GuildName, lpMsg->GuildName, MAX_GUILD_LEN);

  00014	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00017	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0001a	89 45 f0	 mov	 DWORD PTR _GuildName$[ebp], eax

; 9486 : 	int len = strlen(GuildName);

  0001d	8d 45 f0	 lea	 eax, DWORD PTR _GuildName$[ebp]
  00020	56		 push	 esi
  00021	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00024	c6 45 f8 00	 mov	 BYTE PTR _GuildName$[ebp+8], 0
  00028	89 4d f4	 mov	 DWORD PTR _GuildName$[ebp+4], ecx
  0002b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0002e	8b ff		 npad	 2
$LL16@CGGuildMas:
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL16@CGGuildMas
  00037	2b c2		 sub	 eax, edx

; 9487 : 
; 9488 : 	if ( len <= 2 || len > MAX_GUILD_LEN)

  00039	8d 50 fd	 lea	 edx, DWORD PTR [eax-3]
  0003c	89 45 e8	 mov	 DWORD PTR tv258[ebp], eax
  0003f	83 fa 05	 cmp	 edx, 5
  00042	0f 87 ef 00 00
	00		 ja	 $LN9@CGGuildMas

; 9500 : 		}
; 9501 : 
; 9502 : 		return;
; 9503 : 	}
; 9504 : 
; 9505 : 	if( g_MultilangGuildName == 0 )

  00048	57		 push	 edi
  00049	38 0d 00 00 00
	00		 cmp	 BYTE PTR ?g_MultilangGuildName@@3EA, cl ; g_MultilangGuildName
  0004f	75 27		 jne	 SHORT $LN4@CGGuildMas

; 9506 : 	{
; 9507 : 		for(int i = 0; i < len; i++)

  00051	33 ff		 xor	 edi, edi
  00053	85 c0		 test	 eax, eax
  00055	7e 21		 jle	 SHORT $LN4@CGGuildMas
  00057	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL6@CGGuildMas:

; 9508 : 		{
; 9509 : 			if( !isalnum(GuildName[i]) )	

  00060	0f be 44 3d f0	 movsx	 eax, BYTE PTR _GuildName$[ebp+edi]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _isalnum
  0006b	83 c4 04	 add	 esp, 4
  0006e	85 c0		 test	 eax, eax
  00070	74 64		 je	 SHORT $LN14@CGGuildMas

; 9506 : 	{
; 9507 : 		for(int i = 0; i < len; i++)

  00072	47		 inc	 edi
  00073	3b 7d e8	 cmp	 edi, DWORD PTR tv258[ebp]
  00076	7c e8		 jl	 SHORT $LL6@CGGuildMas
$LN4@CGGuildMas:

; 9521 : 				}
; 9522 : 				return;
; 9523 : 			}
; 9524 : 		}
; 9525 : 	}
; 9526 : 
; 9527 : 	GDGuildCreateSend(aIndex, GuildName, gObj[aIndex].Name, lpMsg->Mark, lpMsg->btGuildType);

  00078	0f b6 53 03	 movzx	 edx, BYTE PTR [ebx+3]
  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00081	8b fe		 mov	 edi, esi
  00083	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00089	52		 push	 edx
  0008a	83 c3 0c	 add	 ebx, 12			; 0000000cH
  0008d	53		 push	 ebx
  0008e	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  00092	51		 push	 ecx
  00093	8d 55 f0	 lea	 edx, DWORD PTR _GuildName$[ebp]
  00096	52		 push	 edx
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 ?GDGuildCreateSend@@YAXHPAD0PAEH@Z ; GDGuildCreateSend

; 9528 : 
; 9529 : 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a3	8b 84 0f b8 11
	00 00		 mov	 eax, DWORD PTR [edi+ecx+4536]
  000aa	83 c4 14	 add	 esp, 20			; 00000014H
  000ad	a8 03		 test	 al, 3
  000af	74 14		 je	 SHORT $LN17@CGGuildMas
  000b1	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000b6	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  000bb	75 08		 jne	 SHORT $LN17@CGGuildMas

; 9530 : 	{
; 9531 : 		gObj[aIndex].m_IfState.use = 0;

  000bd	83 a4 0f b8 11
	00 00 fc	 and	 DWORD PTR [edi+ecx+4536], -4 ; fffffffcH
$LN17@CGGuildMas:
  000c5	5f		 pop	 edi
$LN8@CGGuildMas:
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx

; 9532 : 	}
; 9533 : }

  000c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cb	33 cd		 xor	 ecx, ebp
  000cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
$LN14@CGGuildMas:

; 9510 : 			{
; 9511 : 				PMSG_GUILDCREATED_RESULT pMsg;
; 9512 : 
; 9513 : 				PHeadSetB((LPBYTE)&pMsg, 0x56, sizeof(pMsg));

  000d6	6a 05		 push	 5
  000d8	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$220763[ebp]
  000db	6a 56		 push	 86			; 00000056H
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9514 : 				pMsg.Result = 5;
; 9515 : 
; 9516 : 				DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000e3	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$220763[ebp+1]
  000e7	52		 push	 edx
  000e8	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$220763[ebp]
  000eb	50		 push	 eax
  000ec	56		 push	 esi
  000ed	c6 45 eb 05	 mov	 BYTE PTR _pMsg$220763[ebp+3], 5
  000f1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 9517 : 
; 9518 : 				if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )	

  000f6	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00102	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  00109	8d 8c 0e b8 11
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+4536]
  00110	83 c4 18	 add	 esp, 24			; 00000018H
  00113	a8 03		 test	 al, 3
  00115	74 ae		 je	 SHORT $LN17@CGGuildMas
  00117	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0011c	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00121	75 a2		 jne	 SHORT $LN17@CGGuildMas

; 9519 : 				{
; 9520 : 					gObj[aIndex].m_IfState.use = 0;

  00123	83 21 fc	 and	 DWORD PTR [ecx], -4	; fffffffcH
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx

; 9532 : 	}
; 9533 : }

  00129	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012c	33 cd		 xor	 ecx, ebp
  0012e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
$LN9@CGGuildMas:

; 9489 : 	{
; 9490 : 		PMSG_GUILDCREATED_RESULT pMsg;
; 9491 : 
; 9492 : 		PHeadSetB((LPBYTE)&pMsg, 0x56, sizeof(pMsg));

  00137	6a 05		 push	 5
  00139	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$220753[ebp]
  0013c	6a 56		 push	 86			; 00000056H
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9493 : 		pMsg.Result = 2;
; 9494 : 		
; 9495 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00144	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pMsg$220753[ebp+1]
  00148	51		 push	 ecx
  00149	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$220753[ebp]
  0014c	52		 push	 edx
  0014d	56		 push	 esi
  0014e	c6 45 eb 02	 mov	 BYTE PTR _pMsg$220753[ebp+3], 2
  00152	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 9496 : 
; 9497 : 		if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  00157	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0015d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00162	8d b4 06 b8 11
	00 00		 lea	 esi, DWORD PTR [esi+eax+4536]
  00169	8b 06		 mov	 eax, DWORD PTR [esi]
  0016b	83 c4 18	 add	 esp, 24			; 00000018H
  0016e	a8 03		 test	 al, 3
  00170	0f 84 50 ff ff
	ff		 je	 $LN8@CGGuildMas
  00176	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0017b	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00180	0f 85 40 ff ff
	ff		 jne	 $LN8@CGGuildMas

; 9498 : 		{
; 9499 : 			gObj[aIndex].m_IfState.use = 0;

  00186	83 26 fc	 and	 DWORD PTR [esi], -4	; fffffffcH

; 9532 : 	}
; 9533 : }

  00189	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018c	5e		 pop	 esi
  0018d	33 cd		 xor	 ecx, ebp
  0018f	5b		 pop	 ebx
  00190	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ENDP ; CGGuildMasterInfoSave
_TEXT	ENDS
PUBLIC	?CGGuildMasterCreateCancel@@YAXH@Z		; CGGuildMasterCreateCancel
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildMasterCreateCancel@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGGuildMasterCreateCancel@@YAXH@Z PROC			; CGGuildMasterCreateCancel, COMDAT

; 9539 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 9540 : 	if ( gObj[aIndex].GuildNumber > 0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0000c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	83 b8 14 06 00
	00 00		 cmp	 DWORD PTR [eax+1556], 0
  00019	7f 20		 jg	 SHORT $LN1@CGGuildMas@2

; 9541 : 		return;
; 9542 : 
; 9543 : 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  0001b	8b 88 b8 11 00
	00		 mov	 ecx, DWORD PTR [eax+4536]
  00021	f6 c1 03	 test	 cl, 3
  00024	74 15		 je	 SHORT $LN1@CGGuildMas@2
  00026	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0002c	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  00032	75 07		 jne	 SHORT $LN1@CGGuildMas@2

; 9544 : 	{
; 9545 : 		gObj[aIndex].m_IfState.use = 0;

  00034	83 a0 b8 11 00
	00 fc		 and	 DWORD PTR [eax+4536], -4 ; fffffffcH
$LN1@CGGuildMas@2:

; 9546 : 	}
; 9547 : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?CGGuildMasterCreateCancel@@YAXH@Z ENDP			; CGGuildMasterCreateCancel
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildViewportNowPaint@@YAXHPADPAEH@Z		; GCGuildViewportNowPaint
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildViewportNowPaint@@YAXHPADPAEH@Z
_TEXT	SEGMENT
_pMsg$ = -284						; size = 12
_aIndex$GSCopy$ = -272					; size = 4
_pGVCount$ = -268					; size = 5
__GuildInfoBuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_guildname$ = 12					; size = 4
_mark$ = 16						; size = 4
_isGuildMaster$ = 20					; size = 4
?GCGuildViewportNowPaint@@YAXHPADPAEH@Z PROC		; GCGuildViewportNowPaint, COMDAT

; 9552 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _guildname$[ebp]
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 9553 : 	_GUILD_INFO_STRUCT * lpGuild = Guild.SearchGuild(guildname);

  0001a	50		 push	 eax
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild

; 9584 : 	_GuildInfoOfs += sizeof(pMsg);
; 9585 : 
; 9586 : 	PMSG_SIMPLE_GUILDVIEWPORT_COUNT pGVCount;
; 9587 : 
; 9588 : 	pGVCount.h.c = 0xC2;
; 9589 : 	pGVCount.h.headcode = 0x65;
; 9590 : 	pGVCount.h.sizeH = SET_NUMBERH(_GuildInfoOfs);
; 9591 : 	pGVCount.h.sizeL = SET_NUMBERL(_GuildInfoOfs);
; 9592 : 	pGVCount.Count = 1;
; 9593 : 	memcpy(_GuildInfoBuf, &pGVCount, sizeof(pGVCount));
; 9594 : 
; 9595 : 	if ( !CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  00020	89 b5 f0 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  00026	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 1e 01 00
	00		 je	 $LN7@GCGuildVie

; 9554 : 
; 9555 : 	if ( lpGuild == NULL )
; 9556 : 		return;
; 9557 : 
; 9558 : 	LPOBJ lpObj = &gObj[aIndex];

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0003e	53		 push	 ebx
  0003f	57		 push	 edi

; 9559 : 	BYTE _GuildInfoBuf[256] = {0};

  00040	33 db		 xor	 ebx, ebx
  00042	68 ff 00 00 00	 push	 255			; 000000ffH
  00047	8d 8d fd fe ff
	ff		 lea	 ecx, DWORD PTR __GuildInfoBuf$[ebp+1]
  0004d	53		 push	 ebx
  0004e	51		 push	 ecx
  0004f	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]
  00052	88 9d fc fe ff
	ff		 mov	 BYTE PTR __GuildInfoBuf$[ebp], bl
  00058	e8 00 00 00 00	 call	 _memset

; 9560 : 	int _GuildInfoOfs = 5;
; 9561 : 
; 9562 : 	if ( lpObj->lpGuild == NULL )

  0005d	8b 87 18 06 00
	00		 mov	 eax, DWORD PTR [edi+1560]
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	3b c3		 cmp	 eax, ebx
  00068	0f 84 e1 00 00
	00		 je	 $LN15@GCGuildVie

; 9563 : 		return;
; 9564 : 
; 9565 : 
; 9566 : 	PMSG_SIMPLE_GUILDVIEWPORT pMsg;
; 9567 : 	pMsg.GuildNumber = lpObj->lpGuild->Number;
; 9568 : 	pMsg.NumberH = SET_NUMBERH(aIndex)&0x7F;

  0006e	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	c1 ea 08	 shr	 edx, 8
  00079	80 e2 7f	 and	 dl, 127			; 0000007fH
  0007c	88 95 eb fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+7], dl

; 9569 : 	pMsg.NumberL = SET_NUMBERL(aIndex);

  00082	8a 95 f0 fe ff
	ff		 mov	 dl, BYTE PTR _aIndex$GSCopy$[ebp]
  00088	88 95 ec fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+8], dl

; 9570 : 
; 9571 : 	if ( isGuildMaster != FALSE )

  0008e	39 5d 14	 cmp	 DWORD PTR _isGuildMaster$[ebp], ebx
  00091	74 10		 je	 SHORT $LN3@GCGuildVie

; 9572 : 		pMsg.NumberH |= 0x80;

  00093	80 8d eb fe ff
	ff 80		 or	 BYTE PTR _pMsg$[ebp+7], 128 ; 00000080H

; 9573 : 
; 9574 : 
; 9575 : 	if ( isGuildMaster != FALSE )
; 9576 : 		pMsg.btGuildStatus = 0x80;

  0009a	c6 85 e8 fe ff
	ff 80		 mov	 BYTE PTR _pMsg$[ebp+4], 128 ; 00000080H

; 9577 : 	else

  000a1	eb 0c		 jmp	 SHORT $LN2@GCGuildVie
$LN3@GCGuildVie:

; 9578 : 		pMsg.btGuildStatus = lpObj->GuildStatus;

  000a3	8a 97 28 06 00
	00		 mov	 dl, BYTE PTR [edi+1576]
  000a9	88 95 e8 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], dl
$LN2@GCGuildVie:

; 9579 : 
; 9580 : 	pMsg.btGuildType = lpObj->lpGuild->btGuildType;

  000af	0f b6 80 40 07
	00 00		 movzx	 eax, BYTE PTR [eax+1856]

; 9581 : 	pMsg.btGuildRelationShip = 0;
; 9582 : 	lpObj->iGuildUnionTimeStamp = 0;
; 9583 : 	memcpy(&_GuildInfoBuf[_GuildInfoOfs], &pMsg, sizeof(pMsg));

  000b6	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _pMsg$[ebp+8]
  000bc	89 9f 2c 06 00
	00		 mov	 DWORD PTR [edi+1580], ebx
  000c2	88 85 e9 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+5], al
  000c8	89 8d 01 ff ff
	ff		 mov	 DWORD PTR __GuildInfoBuf$[ebp+5], ecx
  000ce	88 9d ea fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+6], bl
  000d4	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _pMsg$[ebp+4]
  000da	89 8d 05 ff ff
	ff		 mov	 DWORD PTR __GuildInfoBuf$[ebp+9], ecx
  000e0	89 95 09 ff ff
	ff		 mov	 DWORD PTR __GuildInfoBuf$[ebp+13], edx

; 9584 : 	_GuildInfoOfs += sizeof(pMsg);
; 9585 : 
; 9586 : 	PMSG_SIMPLE_GUILDVIEWPORT_COUNT pGVCount;
; 9587 : 
; 9588 : 	pGVCount.h.c = 0xC2;
; 9589 : 	pGVCount.h.headcode = 0x65;
; 9590 : 	pGVCount.h.sizeH = SET_NUMBERH(_GuildInfoOfs);
; 9591 : 	pGVCount.h.sizeL = SET_NUMBERL(_GuildInfoOfs);
; 9592 : 	pGVCount.Count = 1;
; 9593 : 	memcpy(_GuildInfoBuf, &pGVCount, sizeof(pGVCount));
; 9594 : 
; 9595 : 	if ( !CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  000e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ec	c7 85 f4 fe ff
	ff c2 00 11 65	 mov	 DWORD PTR _pGVCount$[ebp], 1695613122 ; 651100c2H
  000f6	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _pGVCount$[ebp]
  000fc	b0 01		 mov	 al, 1
  000fe	89 8d fc fe ff
	ff		 mov	 DWORD PTR __GuildInfoBuf$[ebp], ecx
  00104	88 85 00 ff ff
	ff		 mov	 BYTE PTR __GuildInfoBuf$[ebp+4], al
  0010a	0f b6 84 16 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+edx+291]
  00112	3c 35		 cmp	 al, 53			; 00000035H
  00114	74 27		 je	 SHORT $LN14@GCGuildVie
  00116	3c 12		 cmp	 al, 18			; 00000012H
  00118	72 0b		 jb	 SHORT $LN13@GCGuildVie
  0011a	b1 17		 mov	 cl, 23			; 00000017H
  0011c	3a c8		 cmp	 cl, al
  0011e	1b c0		 sbb	 eax, eax
  00120	40		 inc	 eax
  00121	3b c3		 cmp	 eax, ebx
  00123	75 18		 jne	 SHORT $LN14@GCGuildVie
$LN13@GCGuildVie:

; 9596 : 		DataSend(aIndex, _GuildInfoBuf, _GuildInfoOfs);

  00125	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0012b	6a 11		 push	 17			; 00000011H
  0012d	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR __GuildInfoBuf$[ebp]
  00133	52		 push	 edx
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@GCGuildVie:

; 9597 : 
; 9598 : 	MsgSendV2(lpObj, _GuildInfoBuf, _GuildInfoOfs);

  0013d	6a 11		 push	 17			; 00000011H
  0013f	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR __GuildInfoBuf$[ebp]
  00145	51		 push	 ecx
  00146	57		 push	 edi
  00147	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0014c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@GCGuildVie:
  0014f	5f		 pop	 edi
  00150	5b		 pop	 ebx
$LN7@GCGuildVie:

; 9599 : }

  00151	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00154	33 cd		 xor	 ecx, ebp
  00156	5e		 pop	 esi
  00157	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c3		 ret	 0
?GCGuildViewportNowPaint@@YAXHPADPAEH@Z ENDP		; GCGuildViewportNowPaint
_TEXT	ENDS
PUBLIC	?GCGuildViewportDelNow@@YAXHH@Z			; GCGuildViewportDelNow
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildViewportDelNow@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_isGuildMaster$ = 12					; size = 4
?GCGuildViewportDelNow@@YAXHH@Z PROC			; GCGuildViewportDelNow, COMDAT

; 9615 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 9616 : 	PMSG_GUILDDEL_VIEWPORT_NOW pMsg;
; 9617 : 
; 9618 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b f3		 mov	 esi, ebx
  0000d	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00013	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 9619 : 
; 9620 : 	PHeadSetB((LPBYTE)&pMsg, 0x5D, sizeof(pMsg));

  00019	6a 05		 push	 5
  0001b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001e	6a 5d		 push	 93			; 0000005dH
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9621 : 	pMsg.NumberH = SET_NUMBERH(aIndex) & 0x7F;

  00026	8b cb		 mov	 ecx, ebx
  00028	c1 e9 08	 shr	 ecx, 8
  0002b	80 e1 7f	 and	 cl, 127			; 0000007fH
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9622 : 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 9623 : 
; 9624 : 	if ( isGuildMaster != FALSE )

  00031	83 7d 0c 00	 cmp	 DWORD PTR _isGuildMaster$[ebp], 0
  00035	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00038	88 5d fc	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  0003b	74 04		 je	 SHORT $LN1@GCGuildVie@2

; 9625 : 	{
; 9626 : 		pMsg.NumberH |= 0x80;

  0003d	80 4d fb 80	 or	 BYTE PTR _pMsg$[ebp+3], 128 ; 00000080H
$LN1@GCGuildVie@2:

; 9627 : 	}
; 9628 : 
; 9629 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00041	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00045	52		 push	 edx
  00046	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00049	50		 push	 eax
  0004a	53		 push	 ebx
  0004b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 9630 : 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00050	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00054	51		 push	 ecx
  00055	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00058	52		 push	 edx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0005f	83 c4 18	 add	 esp, 24			; 00000018H
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 9631 : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?GCGuildViewportDelNow@@YAXHH@Z ENDP			; GCGuildViewportDelNow
_TEXT	ENDS
PUBLIC	?GCManagerGuildWarEnd@@YAXPAD@Z			; GCManagerGuildWarEnd
EXTRN	?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z:PROC ; gObjGuildWarEnd
EXTRN	?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z:PROC ; gObjGuildWarEndSend
EXTRN	?gBattleGroundEnable@@YAXHH@Z:PROC		; gBattleGroundEnable
; Function compile flags: /Ogtp
;	COMDAT ?GCManagerGuildWarEnd@@YAXPAD@Z
_TEXT	SEGMENT
_Result1$220843 = -8					; size = 1
_Result2$220844 = -4					; size = 1
_GuildName$ = 8						; size = 4
?GCManagerGuildWarEnd@@YAXPAD@Z PROC			; GCManagerGuildWarEnd, COMDAT

; 9637 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 9638 : 	_GUILD_INFO_STRUCT * lpNode = Guild.SearchGuild(GuildName);

  00003	8b 45 08	 mov	 eax, DWORD PTR _GuildName$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00010	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00015	8b f8		 mov	 edi, eax

; 9639 : 
; 9640 : 	if ( lpNode == NULL )

  00017	85 ff		 test	 edi, edi
  00019	0f 84 0b 01 00
	00		 je	 $LN1@GCManagerG

; 9641 : 	{
; 9642 : 		return;
; 9643 : 	}
; 9644 : 
; 9645 : 	int n=0;

  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00027	33 db		 xor	 ebx, ebx
  00029	83 c6 5d	 add	 esi, 93			; 0000005dH
  0002c	8d 64 24 00	 npad	 4
$LL15@GCManagerG:

; 9646 : 	int warmaster = -1;
; 9647 : 
; 9648 : 	while ( true )
; 9649 : 	{
; 9650 : 		if ( gObj[n].Type == OBJ_USER )

  00030	80 7e f3 01	 cmp	 BYTE PTR [esi-13], 1
  00034	75 3b		 jne	 SHORT $LN10@GCManagerG

; 9651 : 		{
; 9652 : 			if ( gObj[n].Connected > PLAYER_LOGGED )

  00036	83 7e a7 02	 cmp	 DWORD PTR [esi-89], 2
  0003a	7e 35		 jle	 SHORT $LN10@GCManagerG

; 9653 : 			{
; 9654 : 				if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  0003c	8a 16		 mov	 dl, BYTE PTR [esi]
  0003e	3a 57 2f	 cmp	 dl, BYTE PTR [edi+47]
  00041	8d 4f 2f	 lea	 ecx, DWORD PTR [edi+47]
  00044	75 2b		 jne	 SHORT $LN10@GCManagerG

; 9655 : 				{
; 9656 : 					if ( strcmp(gObj[n].Name, lpNode->Names[0]) == 0 )

  00046	8b c6		 mov	 eax, esi
$LL21@GCManagerG:
  00048	8a 10		 mov	 dl, BYTE PTR [eax]
  0004a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0004c	75 1a		 jne	 SHORT $LN22@GCManagerG
  0004e	84 d2		 test	 dl, dl
  00050	74 12		 je	 SHORT $LN23@GCManagerG
  00052	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00055	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00058	75 0e		 jne	 SHORT $LN22@GCManagerG
  0005a	83 c0 02	 add	 eax, 2
  0005d	83 c1 02	 add	 ecx, 2
  00060	84 d2		 test	 dl, dl
  00062	75 e4		 jne	 SHORT $LL21@GCManagerG
$LN23@GCManagerG:
  00064	33 c0		 xor	 eax, eax
  00066	eb 05		 jmp	 SHORT $LN24@GCManagerG
$LN22@GCManagerG:
  00068	1b c0		 sbb	 eax, eax
  0006a	83 d8 ff	 sbb	 eax, -1
$LN24@GCManagerG:
  0006d	85 c0		 test	 eax, eax
  0006f	74 15		 je	 SHORT $LN20@GCManagerG
$LN10@GCManagerG:

; 9657 : 					{
; 9658 : 						warmaster = n;
; 9659 : 						break;
; 9660 : 					}
; 9661 : 				}
; 9662 : 			}
; 9663 : 		}
; 9664 : 
; 9665 : 		if ( n < OBJMAX-1 )

  00071	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00077	0f 8d ab 00 00
	00		 jge	 $LN25@GCManagerG

; 9666 : 		{
; 9667 : 			n++;

  0007d	43		 inc	 ebx
  0007e	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H

; 9668 : 		}
; 9669 : 		else
; 9670 : 		{
; 9671 : 			break;
; 9672 : 		}
; 9673 : 	}

  00084	eb aa		 jmp	 SHORT $LL15@GCManagerG
$LN20@GCManagerG:

; 9674 : 
; 9675 : 	if ( warmaster >= 1 )

  00086	83 fb 01	 cmp	 ebx, 1
  00089	0f 8c 99 00 00
	00		 jl	 $LN25@GCManagerG

; 9676 : 	{
; 9677 : 		BYTE Result1 = 0;
; 9678 : 		BYTE Result2 = 0;
; 9679 : 
; 9680 : 		if ( lpNode != NULL )
; 9681 : 		{
; 9682 : 			if ( lpNode->lpTargetGuildNode != NULL )

  0008f	8b 87 8c 05 00
	00		 mov	 eax, DWORD PTR [edi+1420]
  00095	c6 45 f8 00	 mov	 BYTE PTR _Result1$220843[ebp], 0
  00099	c6 45 fc 00	 mov	 BYTE PTR _Result2$220844[ebp], 0
  0009d	85 c0		 test	 eax, eax
  0009f	74 24		 je	 SHORT $LN3@GCManagerG

; 9683 : 			{
; 9684 : 				if ( lpNode->PlayScore == 0 && lpNode->lpTargetGuildNode->PlayScore == 0 )

  000a1	80 bf 95 05 00
	00 00		 cmp	 BYTE PTR [edi+1429], 0
  000a8	75 13		 jne	 SHORT $LN4@GCManagerG
  000aa	80 b8 95 05 00
	00 00		 cmp	 BYTE PTR [eax+1429], 0
  000b1	75 0a		 jne	 SHORT $LN4@GCManagerG

; 9685 : 				{
; 9686 : 					Result1 = 6;

  000b3	b1 06		 mov	 cl, 6
  000b5	88 4d f8	 mov	 BYTE PTR _Result1$220843[ebp], cl

; 9687 : 					Result2 = 6;

  000b8	88 4d fc	 mov	 BYTE PTR _Result2$220844[ebp], cl

; 9688 : 				}
; 9689 : 				else

  000bb	eb 08		 jmp	 SHORT $LN3@GCManagerG
$LN4@GCManagerG:

; 9690 : 				{
; 9691 : 					Result1 = 0;

  000bd	c6 45 f8 00	 mov	 BYTE PTR _Result1$220843[ebp], 0

; 9692 : 					Result2 = 1;

  000c1	c6 45 fc 01	 mov	 BYTE PTR _Result2$220844[ebp], 1
$LN3@GCManagerG:

; 9693 : 				}
; 9694 : 			}
; 9695 : 		}
; 9696 : 
; 9697 : 		if ( lpNode->WarType == 1 )

  000c5	80 bf 92 05 00
	00 01		 cmp	 BYTE PTR [edi+1426], 1
  000cc	75 3b		 jne	 SHORT $LN2@GCManagerG

; 9698 : 		{
; 9699 : 			gBattleGroundEnable(lpNode->BattleGroundIndex, FALSE );

  000ce	0f b6 87 93 05
	00 00		 movzx	 eax, BYTE PTR [edi+1427]
  000d5	6a 00		 push	 0
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable

; 9700 : 			gObjGuildWarEndSend(lpNode, lpNode->lpTargetGuildNode, Result1, Result2);

  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _Result2$220844[ebp]
  000e0	8b 55 f8	 mov	 edx, DWORD PTR _Result1$220843[ebp]
  000e3	8b 87 8c 05 00
	00		 mov	 eax, DWORD PTR [edi+1420]
  000e9	51		 push	 ecx
  000ea	52		 push	 edx
  000eb	50		 push	 eax
  000ec	57		 push	 edi
  000ed	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend

; 9701 : 			gObjGuildWarEnd(lpNode, lpNode->lpTargetGuildNode);

  000f2	8b 8f 8c 05 00
	00		 mov	 ecx, DWORD PTR [edi+1420]
  000f8	51		 push	 ecx
  000f9	57		 push	 edi
  000fa	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  000ff	83 c4 20	 add	 esp, 32			; 00000020H
  00102	5e		 pop	 esi
  00103	5b		 pop	 ebx
  00104	5f		 pop	 edi

; 9709 : 		}
; 9710 : 	}
; 9711 : }

  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
$LN2@GCManagerG:

; 9702 : 
; 9703 : 			//cManager.BattleInfoSend(::GetBattleTeamName(0, 0), -1, ::GetBattleTeamName(0, 1), -1);
; 9704 : 		}
; 9705 : 		else
; 9706 : 		{
; 9707 : 			gObjGuildWarEndSend(lpNode, lpNode->lpTargetGuildNode, Result1, Result2);

  00109	8b 55 fc	 mov	 edx, DWORD PTR _Result2$220844[ebp]
  0010c	8b 4d f8	 mov	 ecx, DWORD PTR _Result1$220843[ebp]
  0010f	52		 push	 edx
  00110	51		 push	 ecx
  00111	50		 push	 eax
  00112	57		 push	 edi
  00113	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend

; 9708 : 			gObjGuildWarEnd(lpNode, lpNode->lpTargetGuildNode);

  00118	8b 97 8c 05 00
	00		 mov	 edx, DWORD PTR [edi+1420]
  0011e	52		 push	 edx
  0011f	57		 push	 edi
  00120	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  00125	83 c4 18	 add	 esp, 24			; 00000018H
$LN25@GCManagerG:
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
$LN1@GCManagerG:
  0012a	5f		 pop	 edi

; 9709 : 		}
; 9710 : 	}
; 9711 : }

  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
?GCManagerGuildWarEnd@@YAXPAD@Z ENDP			; GCManagerGuildWarEnd
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildWarRequestSend@@YAXPADHH@Z		; GCGuildWarRequestSend
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildWarRequestSend@@YAXPADHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_GuildName$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 4
?GCGuildWarRequestSend@@YAXPADHH@Z PROC			; GCGuildWarRequestSend, COMDAT

; 9977 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _GuildName$[ebp]

; 9978 : #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 9979 : 	PMSG_GUILDWARSEND pMsg;
; 9980 : 
; 9981 : 	PHeadSetB((LPBYTE)&pMsg, 0x61, sizeof(pMsg));

  00014	6a 0c		 push	 12			; 0000000cH
  00016	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 61		 push	 97			; 00000061H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9982 : 	pMsg.Type = type;

  00021	8a 4d 10	 mov	 cl, BYTE PTR _type$[ebp]

; 9983 : 	memcpy(pMsg.GuildName, GuildName, MAX_GUILD_LEN);

  00024	8b 16		 mov	 edx, DWORD PTR [esi]
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+11], cl

; 9984 : 
; 9985 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0002c	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00030	89 55 f3	 mov	 DWORD PTR _pMsg$[ebp+3], edx
  00033	51		 push	 ecx
  00034	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00037	89 45 f7	 mov	 DWORD PTR _pMsg$[ebp+7], eax
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003d	52		 push	 edx
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00044	83 c4 18	 add	 esp, 24			; 00000018H

; 9986 : 
; 9987 : 	// (%s) guild declared guild war
; 9988 : 	LogAddTD(lMsg.Get(MSGGET(1, 237)), GuildName);

  00047	56		 push	 esi
  00048	68 ed 01 00 00	 push	 493			; 000001edH
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00052	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9989 : #endif
; 9990 : }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	83 c4 08	 add	 esp, 8
  00064	33 cd		 xor	 ecx, ebp
  00066	5e		 pop	 esi
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?GCGuildWarRequestSend@@YAXPADHH@Z ENDP			; GCGuildWarRequestSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildWarDeclare@@YAXHPAD@Z			; GCGuildWarDeclare
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildWarDeclare@@YAXHPAD@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
__guildname$ = 12					; size = 4
?GCGuildWarDeclare@@YAXHPAD@Z PROC			; GCGuildWarDeclare, COMDAT

; 10272: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR __guildname$[ebp]

; 10273: #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 10274: 	PMSG_GUILDWAR_DECLARE pMsg;
; 10275: 
; 10276: 	PHeadSetB((LPBYTE)&pMsg, 0x62, sizeof(pMsg));

  00014	6a 0d		 push	 13			; 0000000dH
  00016	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 62		 push	 98			; 00000062H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10277: 	memcpy(pMsg.GuildName, _guildname, sizeof(pMsg.GuildName));

  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 10278: 
; 10279: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00023	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00027	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002a	89 4d ef	 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  0002d	50		 push	 eax
  0002e	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00031	89 55 f3	 mov	 DWORD PTR _pMsg$[ebp+7], edx
  00034	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10280: #endif
; 10281: }

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00041	83 c4 18	 add	 esp, 24			; 00000018H
  00044	33 cd		 xor	 ecx, ebp
  00046	5e		 pop	 esi
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?GCGuildWarDeclare@@YAXHPAD@Z ENDP			; GCGuildWarDeclare
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildWarEnd@@YAXHEPAD@Z			; GCGuildWarEnd
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildWarEnd@@YAXHEPAD@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
__guildname$ = 16					; size = 4
?GCGuildWarEnd@@YAXHEPAD@Z PROC				; GCGuildWarEnd, COMDAT

; 10294: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 10	 mov	 esi, DWORD PTR __guildname$[ebp]

; 10295: #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 10296: 	PMSG_GUILDWAR_END pMsg;
; 10297: 
; 10298: 	PHeadSetB((LPBYTE)&pMsg, 0x63, sizeof(pMsg));

  00014	6a 0c		 push	 12			; 0000000cH
  00016	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 63		 push	 99			; 00000063H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10299: 	pMsg.Result = result;

  00021	8a 4d 0c	 mov	 cl, BYTE PTR _result$[ebp]

; 10300: 	memcpy(pMsg.GuildName, _guildname, sizeof(pMsg.GuildName));

  00024	8b 16		 mov	 edx, DWORD PTR [esi]
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 10301: 
; 10302: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0002c	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00030	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+4], edx
  00033	51		 push	 ecx
  00034	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  0003a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003d	52		 push	 edx
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10303: #endif
; 10304: }

  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	83 c4 18	 add	 esp, 24			; 00000018H
  0004a	33 cd		 xor	 ecx, ebp
  0004c	5e		 pop	 esi
  0004d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?GCGuildWarEnd@@YAXHEPAD@Z ENDP				; GCGuildWarEnd
_TEXT	ENDS
PUBLIC	??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	?GCGuildWarScore@@YAXH@Z			; GCGuildWarScore
;	COMDAT ??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@ DB 'Target Score %s %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@ DB 'Score %s %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCGuildWarScore@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
?GCGuildWarScore@@YAXH@Z PROC				; GCGuildWarScore, COMDAT

; 10319: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10320: #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 10321: 	if ( gObj[aIndex].GuildNumber < 1 )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00010	8b f7		 mov	 esi, edi
  00012	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00018	83 bc 06 14 06
	00 00 01	 cmp	 DWORD PTR [esi+eax+1556], 1
  00020	0f 8c b9 00 00
	00		 jl	 $LN4@GCGuildWar

; 10322: 		return;
; 10323: 
; 10324: 	PMSG_GUILDSCORE pMsg;
; 10325: 
; 10326: 	PHeadSetB((LPBYTE)&pMsg, 0x64, sizeof(pMsg));

  00026	6a 06		 push	 6
  00028	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002b	6a 64		 push	 100			; 00000064H
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10327: 	pMsg.Score1 = 0;
; 10328: 	pMsg.Score2 = 0;
; 10329: 	pMsg.Type = 0;
; 10330: 
; 10331: 	if ( gObj[aIndex].lpGuild != NULL )

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	66 c7 45 fb 00
	00		 mov	 WORD PTR _pMsg$[ebp+3], 0
  00041	c6 45 fd 00	 mov	 BYTE PTR _pMsg$[ebp+5], 0
  00045	83 bc 06 18 06
	00 00 00	 cmp	 DWORD PTR [esi+eax+1560], 0
  0004d	74 37		 je	 SHORT $LN2@GCGuildWar

; 10332: 	{
; 10333: 		pMsg.Score1 = gObj[aIndex].lpGuild->PlayScore;

  0004f	8b 94 06 18 06
	00 00		 mov	 edx, DWORD PTR [esi+eax+1560]
  00056	8a 8a 95 05 00
	00		 mov	 cl, BYTE PTR [edx+1429]
  0005c	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 10334: 		LogAdd("Score %s %d", gObj[aIndex].Name, gObj[aIndex].lpGuild->PlayScore);

  0005f	8b 94 06 18 06
	00 00		 mov	 edx, DWORD PTR [esi+eax+1560]
  00066	0f b6 8a 95 05
	00 00		 movzx	 ecx, BYTE PTR [edx+1429]
  0006d	51		 push	 ecx
  0006e	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  00072	52		 push	 edx
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCGuildWar:

; 10335: 	}
; 10336: 
; 10337: 	if ( gObj[aIndex].lpGuild->lpTargetGuildNode != NULL )

  00086	8b 8c 06 18 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1560]
  0008d	83 b9 8c 05 00
	00 00		 cmp	 DWORD PTR [ecx+1420], 0
  00094	74 37		 je	 SHORT $LN1@GCGuildWar

; 10338: 	{
; 10339: 		pMsg.Score2 = gObj[aIndex].lpGuild->lpTargetGuildNode->PlayScore;

  00096	8b 89 8c 05 00
	00		 mov	 ecx, DWORD PTR [ecx+1420]
  0009c	8a 91 95 05 00
	00		 mov	 dl, BYTE PTR [ecx+1429]
  000a2	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl

; 10340: 		LogAdd("Target Score %s %d", gObj[aIndex].Name, gObj[aIndex].lpGuild->lpTargetGuildNode->PlayScore);

  000a5	8b 8c 06 18 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1560]
  000ac	8b 91 8c 05 00
	00		 mov	 edx, DWORD PTR [ecx+1420]
  000b2	0f b6 8a 95 05
	00 00		 movzx	 ecx, BYTE PTR [edx+1429]
  000b9	51		 push	 ecx
  000ba	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  000be	52		 push	 edx
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCGuildWar:

; 10341: 	}
; 10342: 
; 10343: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000cd	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000d1	50		 push	 eax
  000d2	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000d5	51		 push	 ecx
  000d6	57		 push	 edi
  000d7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GCGuildWar:
  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi

; 10344: #endif
; 10345: }	

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
?GCGuildWarScore@@YAXH@Z ENDP				; GCGuildWarScore
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1511 : 		return (this->_Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1512 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCWarehouseInventoryMoneySend@@YAXHEHH@Z	; GCWarehouseInventoryMoneySend
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
;	COMDAT ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_money$ = 16						; size = 4
_wmoney$ = 20						; size = 4
?GCWarehouseInventoryMoneySend@@YAXHEHH@Z PROC		; GCWarehouseInventoryMoneySend, COMDAT

; 10485: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 10486: 	PMSG_MONEY pMsg;
; 10487: 
; 10488: 	PHeadSetB((LPBYTE)&pMsg, 0x81, sizeof(pMsg));

  00010	6a 0c		 push	 12			; 0000000cH
  00012	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	68 81 00 00 00	 push	 129			; 00000081H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10489: 	pMsg.Result = result;

  00020	8a 4d 0c	 mov	 cl, BYTE PTR _result$[ebp]

; 10490: 	pMsg.iMoney = money;

  00023	8b 55 10	 mov	 edx, DWORD PTR _money$[ebp]

; 10491: 	pMsg.wMoney = wmoney;

  00026	8b 45 14	 mov	 eax, DWORD PTR _wmoney$[ebp]
  00029	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 10492: 
; 10493: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0002c	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00030	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00033	51		 push	 ecx
  00034	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00037	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+4], eax
  0003a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003d	52		 push	 edx
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10494: }

  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	33 cd		 xor	 ecx, ebp
  00049	83 c4 18	 add	 esp, 24			; 00000018H
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ENDP		; GCWarehouseInventoryMoneySend
_TEXT	ENDS
PUBLIC	??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	?CGWarehouseUseEnd@@YAXH@Z			; CGWarehouseUseEnd
EXTRN	?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; GDUserItemSave
EXTRN	?GDSetWarehouseList@@YAXH@Z:PROC		; GDSetWarehouseList
EXTRN	?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjItemTextSave
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
;	COMDAT ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ DB 'error-L'
	DB	'3 [%s][%d]', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGWarehouseUseEnd@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?CGWarehouseUseEnd@@YAXH@Z PROC				; CGWarehouseUseEnd, COMDAT

; 10500: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 10501: 	if ( !gObjIsConnectedGP(aIndex))

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	75 1f		 jne	 SHORT $LN2@CGWarehous

; 10502: 	{
; 10503: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00015	68 07 29 00 00	 push	 10503			; 00002907H
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00024	6a 02		 push	 2
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	5f		 pop	 edi

; 10522: 	}
; 10523: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN2@CGWarehous:
  00034	56		 push	 esi

; 10504: 		return;
; 10505: 	}
; 10506: 
; 10507: 	LPOBJ lpObj = &gObj[aIndex];

  00035	8b f7		 mov	 esi, edi
  00037	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0003d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 10508: 
; 10509: 	PMSG_DEFAULT pMsg;
; 10510: 	PHeadSetB((LPBYTE)&pMsg, 0x82, sizeof(pMsg));

  00043	6a 03		 push	 3
  00045	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00048	68 82 00 00 00	 push	 130			; 00000082H
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10511: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00053	0f b6 4d fd	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00057	51		 push	 ecx
  00058	8d 55 fc	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0005b	52		 push	 edx
  0005c	57		 push	 edi
  0005d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10512: 
; 10513: 	gObjItemTextSave(lpObj);

  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjItemTextSave

; 10514: 	GDSetWarehouseList(aIndex);

  00068	57		 push	 edi
  00069	e8 00 00 00 00	 call	 ?GDSetWarehouseList@@YAXH@Z ; GDSetWarehouseList

; 10515: 	GDUserItemSave(lpObj);

  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 ?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z ; GDUserItemSave

; 10516: 
; 10517: 	if ( lpObj->m_IfState.use  && lpObj->m_IfState.type == 6 )

  00074	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  0007a	83 c4 24	 add	 esp, 36			; 00000024H
  0007d	a8 03		 test	 al, 3
  0007f	74 23		 je	 SHORT $LN5@CGWarehous
  00081	8b c8		 mov	 ecx, eax
  00083	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00089	81 f9 80 01 00
	00		 cmp	 ecx, 384		; 00000180H
  0008f	75 13		 jne	 SHORT $LN5@CGWarehous

; 10518: 	{
; 10519: 		lpObj->m_IfState.use = 0;
; 10520: 		lpObj->m_IfState.state = 0;

  00091	83 e0 c0	 and	 eax, -64		; ffffffc0H
  00094	89 86 b8 11 00
	00		 mov	 DWORD PTR [esi+4536], eax

; 10521: 		lpObj->WarehouseSave = FALSE;

  0009a	c7 86 0c 12 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4620], 0
$LN5@CGWarehous:
  000a4	5e		 pop	 esi
  000a5	5f		 pop	 edi

; 10522: 	}
; 10523: }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
?CGWarehouseUseEnd@@YAXH@Z ENDP				; CGWarehouseUseEnd
_TEXT	ENDS
PUBLIC	?GCWarehouseStateSend@@YAXHE@Z			; GCWarehouseStateSend
; Function compile flags: /Ogtp
;	COMDAT ?GCWarehouseStateSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_state$ = 12						; size = 1
?GCWarehouseStateSend@@YAXHE@Z PROC			; GCWarehouseStateSend, COMDAT

; 10537: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 10538: 	PMSG_WAREHOUSESTATE pMsg;
; 10539: 
; 10540: 	PHeadSetB((LPBYTE)&pMsg, 0x83, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	68 83 00 00 00	 push	 131			; 00000083H
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10541: 	pMsg.State = state;
; 10542: 
; 10543: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00014	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00018	8a 4d 0c	 mov	 cl, BYTE PTR _state$[ebp]
  0001b	52		 push	 edx
  0001c	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00025	50		 push	 eax
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002c	83 c4 18	 add	 esp, 24			; 00000018H

; 10544: }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?GCWarehouseStateSend@@YAXHE@Z ENDP			; GCWarehouseStateSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ; GCWarehouseRecivePassword
EXTRN	?bCanWarehouseLock@@3HA:DWORD			; bCanWarehouseLock
; Function compile flags: /Ogtp
;	COMDAT ?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z
_TEXT	SEGMENT
_szJoomin$221199 = -28					; size = 21
_szJoomin$221195 = -28					; size = 21
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z PROC ; GCWarehouseRecivePassword, COMDAT

; 10550: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 10551: 	if ( bCanWarehouseLock == FALSE )

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 0 ; bCanWarehouseLock
  00017	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001e	0f 84 05 01 00
	00		 je	 $LN8@GCWarehous

; 10552: 		return;
; 10553: 
; 10554: 	int pw = lpMsg->Pass;
; 10555: 
; 10556: 	switch ( lpMsg->Type )

  00024	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00028	83 e9 00	 sub	 ecx, 0
  0002b	53		 push	 ebx
  0002c	0f bf 58 04	 movsx	 ebx, WORD PTR [eax+4]
  00030	0f 84 73 01 00
	00		 je	 $LN11@GCWarehous
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	2b ca		 sub	 ecx, edx
  0003d	0f 84 ba 00 00
	00		 je	 $LN7@GCWarehous
  00043	2b ca		 sub	 ecx, edx
  00045	0f 85 dd 00 00
	00		 jne	 $LN18@GCWarehous

; 10599: 		case 0x02:
; 10600: 			{
; 10601: 				char szJoomin[21];
; 10602: 
; 10603: 				memset(szJoomin, 0, sizeof(szJoomin));

  0004b	89 4d e4	 mov	 DWORD PTR _szJoomin$221199[ebp], ecx
  0004e	89 4d e8	 mov	 DWORD PTR _szJoomin$221199[ebp+4], ecx
  00051	89 4d ec	 mov	 DWORD PTR _szJoomin$221199[ebp+8], ecx
  00054	89 4d f0	 mov	 DWORD PTR _szJoomin$221199[ebp+12], ecx
  00057	89 4d f4	 mov	 DWORD PTR _szJoomin$221199[ebp+16], ecx
  0005a	88 4d f8	 mov	 BYTE PTR _szJoomin$221199[ebp+20], cl

; 10604: 				memcpy(szJoomin, lpMsg->LastJoominNumber, 20);

  0005d	8b 48 06	 mov	 ecx, DWORD PTR [eax+6]
  00060	89 4d e4	 mov	 DWORD PTR _szJoomin$221199[ebp], ecx
  00063	8b 48 0a	 mov	 ecx, DWORD PTR [eax+10]
  00066	89 4d e8	 mov	 DWORD PTR _szJoomin$221199[ebp+4], ecx
  00069	8b 48 0e	 mov	 ecx, DWORD PTR [eax+14]
  0006c	89 4d ec	 mov	 DWORD PTR _szJoomin$221199[ebp+8], ecx
  0006f	8b 48 12	 mov	 ecx, DWORD PTR [eax+18]
  00072	8b 40 16	 mov	 eax, DWORD PTR [eax+22]
  00075	89 4d f0	 mov	 DWORD PTR _szJoomin$221199[ebp+12], ecx
  00078	89 45 f4	 mov	 DWORD PTR _szJoomin$221199[ebp+16], eax

; 10605: 
; 10606: #if (__CUSTOM__ == 1)
; 10607: 				if ( gc_bPersonalID == TRUE && gObjJoominCheck(aIndex, szJoomin) == FALSE )

  0007b	39 15 00 00 00
	00		 cmp	 DWORD PTR ?gc_bPersonalID@@3HA, edx ; gc_bPersonalID
  00081	75 2c		 jne	 SHORT $LN1@GCWarehous
  00083	8d 4d e4	 lea	 ecx, DWORD PTR _szJoomin$221199[ebp]
  00086	51		 push	 ecx
  00087	57		 push	 edi
  00088	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  0008d	83 c4 08	 add	 esp, 8
  00090	85 c0		 test	 eax, eax
  00092	75 1b		 jne	 SHORT $LN1@GCWarehous

; 10608: #else
; 10609: 				if ( gObjJoominCheck(aIndex, szJoomin) == FALSE )
; 10610: #endif
; 10611: 				{
; 10612: 					GCWarehouseStateSend(aIndex, 0x0D);

  00094	6a 0d		 push	 13			; 0000000dH
  00096	57		 push	 edi
  00097	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  0009c	83 c4 08	 add	 esp, 8
  0009f	5b		 pop	 ebx
  000a0	5f		 pop	 edi

; 10619: 			}
; 10620: 			break;
; 10621: 	}
; 10622: }	

  000a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a4	33 cd		 xor	 ecx, ebp
  000a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
$LN1@GCWarehous:

; 10613: 					return;
; 10614: 				}
; 10615: 
; 10616: 				gObj[aIndex].WarehouseLock = FALSE;

  000af	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b5	8b c7		 mov	 eax, edi
  000b7	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  000bd	c6 84 10 04 12
	00 00 00	 mov	 BYTE PTR [eax+edx+4612], 0

; 10617: 				gObj[aIndex].WarehousePW = 0;

  000c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cb	33 c9		 xor	 ecx, ecx
  000cd	66 89 8c 10 02
	12 00 00	 mov	 WORD PTR [eax+edx+4610], cx

; 10618: 				GCWarehouseStateSend(aIndex, gObj[aIndex].WarehouseLock);

  000d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000db	0f b6 94 08 04
	12 00 00	 movzx	 edx, BYTE PTR [eax+ecx+4612]
  000e3	52		 push	 edx
  000e4	57		 push	 edi
  000e5	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  000ea	83 c4 08	 add	 esp, 8
  000ed	5b		 pop	 ebx
  000ee	5f		 pop	 edi

; 10619: 			}
; 10620: 			break;
; 10621: 	}
; 10622: }	

  000ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f2	33 cd		 xor	 ecx, ebp
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN7@GCWarehous:

; 10569: 				}
; 10570: 			}
; 10571: 			break;
; 10572: 		case 0x01:
; 10573: 			if ( !gObj[aIndex].WarehouseLock || gObj[aIndex].WarehouseLock == 0xFF )

  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00103	56		 push	 esi
  00104	8b f7		 mov	 esi, edi
  00106	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0010c	8a 8c 0e 04 12
	00 00		 mov	 cl, BYTE PTR [esi+ecx+4612]
  00113	84 c9		 test	 cl, cl
  00115	74 21		 je	 SHORT $LN5@GCWarehous
  00117	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  0011a	74 1c		 je	 SHORT $LN5@GCWarehous

; 10593: 			}
; 10594: 			else
; 10595: 			{
; 10596: 				GCWarehouseStateSend(aIndex, 0x0B);

  0011c	6a 0b		 push	 11			; 0000000bH
$LN20@GCWarehous:

; 10582: #else
; 10583: 				if ( gObjJoominCheck(aIndex, szJoomin) == FALSE )
; 10584: #endif
; 10585: 				{
; 10586: 					GCWarehouseStateSend(aIndex, 0x0D);

  0011e	57		 push	 edi
  0011f	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  00124	83 c4 08	 add	 esp, 8
  00127	5e		 pop	 esi
$LN18@GCWarehous:
  00128	5b		 pop	 ebx
$LN8@GCWarehous:
  00129	5f		 pop	 edi

; 10619: 			}
; 10620: 			break;
; 10621: 	}
; 10622: }	

  0012a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012d	33 cd		 xor	 ecx, ebp
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c3		 ret	 0
$LN5@GCWarehous:

; 10574: 			{
; 10575: 				char szJoomin[21];
; 10576: 
; 10577: 				memset(szJoomin, 0, sizeof(szJoomin));

  00138	33 c9		 xor	 ecx, ecx
  0013a	89 4d e4	 mov	 DWORD PTR _szJoomin$221195[ebp], ecx
  0013d	89 4d e8	 mov	 DWORD PTR _szJoomin$221195[ebp+4], ecx
  00140	89 4d ec	 mov	 DWORD PTR _szJoomin$221195[ebp+8], ecx
  00143	89 4d f0	 mov	 DWORD PTR _szJoomin$221195[ebp+12], ecx
  00146	89 4d f4	 mov	 DWORD PTR _szJoomin$221195[ebp+16], ecx
  00149	88 4d f8	 mov	 BYTE PTR _szJoomin$221195[ebp+20], cl

; 10578: 				memcpy(szJoomin, lpMsg->LastJoominNumber, 20);

  0014c	8b 48 06	 mov	 ecx, DWORD PTR [eax+6]
  0014f	89 4d e4	 mov	 DWORD PTR _szJoomin$221195[ebp], ecx
  00152	8b 48 0a	 mov	 ecx, DWORD PTR [eax+10]
  00155	89 4d e8	 mov	 DWORD PTR _szJoomin$221195[ebp+4], ecx
  00158	8b 48 0e	 mov	 ecx, DWORD PTR [eax+14]
  0015b	89 4d ec	 mov	 DWORD PTR _szJoomin$221195[ebp+8], ecx
  0015e	8b 48 12	 mov	 ecx, DWORD PTR [eax+18]
  00161	8b 40 16	 mov	 eax, DWORD PTR [eax+22]
  00164	89 4d f0	 mov	 DWORD PTR _szJoomin$221195[ebp+12], ecx
  00167	89 45 f4	 mov	 DWORD PTR _szJoomin$221195[ebp+16], eax

; 10579: 
; 10580: #if (__CUSTOM__ == 1)
; 10581: 				if ( gc_bPersonalID == TRUE && gObjJoominCheck(aIndex, szJoomin) == FALSE )

  0016a	39 15 00 00 00
	00		 cmp	 DWORD PTR ?gc_bPersonalID@@3HA, edx ; gc_bPersonalID
  00170	75 15		 jne	 SHORT $LN17@GCWarehous
  00172	8d 4d e4	 lea	 ecx, DWORD PTR _szJoomin$221195[ebp]
  00175	51		 push	 ecx
  00176	57		 push	 edi
  00177	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  0017c	83 c4 08	 add	 esp, 8
  0017f	85 c0		 test	 eax, eax
  00181	75 04		 jne	 SHORT $LN17@GCWarehous

; 10582: #else
; 10583: 				if ( gObjJoominCheck(aIndex, szJoomin) == FALSE )
; 10584: #endif
; 10585: 				{
; 10586: 					GCWarehouseStateSend(aIndex, 0x0D);

  00183	6a 0d		 push	 13			; 0000000dH

; 10587: 					return;

  00185	eb 97		 jmp	 SHORT $LN20@GCWarehous
$LN17@GCWarehous:

; 10588: 				}
; 10589: 
; 10590: 				gObj[aIndex].WarehousePW = pw;

  00187	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018d	66 89 9c 16 02
	12 00 00	 mov	 WORD PTR [esi+edx+4610], bx

; 10591: 				gObj[aIndex].WarehouseLock = FALSE;

  00195	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0019a	c6 84 06 04 12
	00 00 00	 mov	 BYTE PTR [esi+eax+4612], 0

; 10592: 				GCWarehouseStateSend(aIndex, 0x0C);

  001a2	6a 0c		 push	 12			; 0000000cH

; 10597: 			}
; 10598: 			break;

  001a4	e9 75 ff ff ff	 jmp	 $LN20@GCWarehous
$LN11@GCWarehous:

; 10557: 	{
; 10558: 		case 0x00:
; 10559: 			if ( gObj[aIndex].WarehouseLock )

  001a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001af	8b c7		 mov	 eax, edi
  001b1	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  001b7	80 bc 10 04 12
	00 00 00	 cmp	 BYTE PTR [eax+edx+4612], 0
  001bf	0f 84 63 ff ff
	ff		 je	 $LN18@GCWarehous

; 10560: 			{
; 10561: 				if ( gObj[aIndex].WarehousePW == pw )

  001c5	0f bf 8c 10 02
	12 00 00	 movsx	 ecx, WORD PTR [eax+edx+4610]
  001cd	3b cb		 cmp	 ecx, ebx
  001cf	75 23		 jne	 SHORT $LN9@GCWarehous

; 10562: 				{
; 10563: 					gObj[aIndex].WarehouseLock = FALSE;
; 10564: 					GCWarehouseStateSend(aIndex, 0x0C);

  001d1	6a 0c		 push	 12			; 0000000cH
  001d3	57		 push	 edi
  001d4	c6 84 10 04 12
	00 00 00	 mov	 BYTE PTR [eax+edx+4612], 0
  001dc	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  001e1	83 c4 08	 add	 esp, 8
  001e4	5b		 pop	 ebx
  001e5	5f		 pop	 edi

; 10619: 			}
; 10620: 			break;
; 10621: 	}
; 10622: }	

  001e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e9	33 cd		 xor	 ecx, ebp
  001eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c3		 ret	 0
$LN9@GCWarehous:

; 10565: 				}
; 10566: 				else
; 10567: 				{
; 10568: 					GCWarehouseStateSend(aIndex, 0x0A);

  001f4	6a 0a		 push	 10			; 0000000aH
  001f6	57		 push	 edi
  001f7	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend

; 10619: 			}
; 10620: 			break;
; 10621: 	}
; 10622: }	

  001fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ff	83 c4 08	 add	 esp, 8
  00202	5b		 pop	 ebx
  00203	33 cd		 xor	 ecx, ebp
  00205	5f		 pop	 edi
  00206	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020b	8b e5		 mov	 esp, ebp
  0020d	5d		 pop	 ebp
  0020e	c3		 ret	 0
?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ENDP ; GCWarehouseRecivePassword
_TEXT	ENDS
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z	; GCUserChaosBoxSend
; Function compile flags: /Ogtp
;	COMDAT ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$GSCopy$ = -2072					; size = 4
tv246 = -2068						; size = 4
_n$221217 = -2064					; size = 4
_pMsg$ = -2060						; size = 6
_SendByte$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iChaosBoxType$ = 12					; size = 4
?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; GCUserChaosBoxSend, COMDAT

; 10628: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 08 00
	00		 sub	 esp, 2072		; 00000818H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 10629: 	if ( iChaosBoxType == 1  )
; 10630: 	{
; 10631: 		if ( lpObj->m_IfState.type != 13 )

  00018	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  0001e	57		 push	 edi
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _iChaosBoxType$[ebp]

; 10678: 		}
; 10679: 	}
; 10680: 
; 10681: 	pMsg.h.sizeH = SET_NUMBERH(lOfs);

  00022	89 b5 e8 f7 ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], esi
  00028	83 ff 01	 cmp	 edi, 1
  0002b	75 10		 jne	 SHORT $LN12@GCUserChao

; 10629: 	if ( iChaosBoxType == 1  )
; 10630: 	{
; 10631: 		if ( lpObj->m_IfState.type != 13 )

  0002d	8b c8		 mov	 ecx, eax
  0002f	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00035	81 f9 40 03 00
	00		 cmp	 ecx, 832		; 00000340H

; 10632: 		{
; 10633: 			return;
; 10634: 		}
; 10635: 
; 10636: 		if ( lpObj->m_IfState.type == 13 && lpObj->m_IfState.state == 1 )
; 10637: 		{
; 10638: 			return;
; 10639: 		}
; 10640: 	}
; 10641: 	else 

  0003b	eb 0e		 jmp	 SHORT $LN18@GCUserChao
$LN12@GCUserChao:

; 10642: 	{
; 10643: 		if ( lpObj->m_IfState.type != 7 )

  0003d	8b d0		 mov	 edx, eax
  0003f	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00045	81 fa c0 01 00
	00		 cmp	 edx, 448		; 000001c0H
$LN18@GCUserChao:
  0004b	0f 85 05 01 00
	00		 jne	 $LN13@GCUserChao

; 10644: 		{
; 10645: 			return;
; 10646: 		}
; 10647: 
; 10648: 		if ( lpObj->m_IfState.type == 7 && lpObj->m_IfState.state == 1 )

  00051	24 3c		 and	 al, 60			; 0000003cH
  00053	3c 04		 cmp	 al, 4
  00055	0f 84 fb 00 00
	00		 je	 $LN13@GCUserChao

; 10649: 		{
; 10650: 			return;
; 10651: 		}
; 10652: 	}
; 10653: 
; 10654: 	PMSG_SHOPITEMCOUNT pMsg;
; 10655: 	BYTE SendByte[2048];
; 10656: 	int lOfs = sizeof(pMsg);
; 10657: 	PHeadSetW((LPBYTE)&pMsg, 0x31, 0);

  0005b	6a 00		 push	 0
  0005d	8d 85 f4 f7 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00063	6a 31		 push	 49			; 00000031H
  00065	50		 push	 eax
  00066	bb 06 00 00 00	 mov	 ebx, 6
  0006b	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10658: 	pMsg.count = 0;
; 10659: 
; 10660: 	if ( iChaosBoxType == 1 )

  00073	83 ff 01	 cmp	 edi, 1
  00076	0f 94 c1	 sete	 cl

; 10661: 	{
; 10662: 		pMsg.Type = 5;
; 10663: 	}
; 10664: 	else
; 10665: 	{
; 10666: 		pMsg.Type = 3;
; 10667: 	}
; 10668: 
; 10669: 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00079	33 ff		 xor	 edi, edi
  0007b	c6 85 f9 f7 ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+5], 0
  00082	89 bd f0 f7 ff
	ff		 mov	 DWORD PTR _n$221217[ebp], edi
  00088	89 bd ec f7 ff
	ff		 mov	 DWORD PTR tv246[ebp], edi
  0008e	8d 4c 09 03	 lea	 ecx, DWORD PTR [ecx+ecx+3]
  00092	88 8d f8 f7 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00098	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL4@GCUserChao:

; 10670: 	{
; 10671: 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  000a0	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  000a6	03 cf		 add	 ecx, edi
  000a8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	75 4c		 jne	 SHORT $LN3@GCUserChao

; 10672: 		{
; 10673: 			SendByte[lOfs] = n;
; 10674: 			lOfs++;
; 10675: 			ItemByteConvert(&SendByte[lOfs], lpObj->pChaosBox[n] );

  000b2	8b b6 10 12 00
	00		 mov	 esi, DWORD PTR [esi+4624]
  000b8	8a 95 f0 f7 ff
	ff		 mov	 dl, BYTE PTR _n$221217[ebp]
  000be	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  000c4	03 f7		 add	 esi, edi
  000c6	8d 84 1d fd f7
	ff ff		 lea	 eax, DWORD PTR _SendByte$[ebp+ebx+1]
  000cd	8b fc		 mov	 edi, esp
  000cf	88 94 1d fc f7
	ff ff		 mov	 BYTE PTR _SendByte$[ebp+ebx], dl
  000d6	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  000db	50		 push	 eax
  000dc	f3 a5		 rep movsd
  000de	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 10676: 			lOfs += MAX_ITEM_INFO;
; 10677: 			pMsg.count ++;

  000e3	8b bd ec f7 ff
	ff		 mov	 edi, DWORD PTR tv246[ebp]
  000e9	8b b5 e8 f7 ff
	ff		 mov	 esi, DWORD PTR _lpObj$GSCopy$[ebp]
  000ef	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000f5	83 c3 0d	 add	 ebx, 13			; 0000000dH
  000f8	fe 85 f9 f7 ff
	ff		 inc	 BYTE PTR _pMsg$[ebp+5]
$LN3@GCUserChao:

; 10661: 	{
; 10662: 		pMsg.Type = 5;
; 10663: 	}
; 10664: 	else
; 10665: 	{
; 10666: 		pMsg.Type = 3;
; 10667: 	}
; 10668: 
; 10669: 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  000fe	ff 85 f0 f7 ff
	ff		 inc	 DWORD PTR _n$221217[ebp]
  00104	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  0010a	89 bd ec f7 ff
	ff		 mov	 DWORD PTR tv246[ebp], edi
  00110	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  00116	7c 88		 jl	 SHORT $LL4@GCUserChao

; 10682: 	pMsg.h.sizeL = SET_NUMBERL(lOfs);
; 10683: 	memcpy(SendByte, &pMsg, sizeof(pMsg));

  00118	66 8b 85 f8 f7
	ff ff		 mov	 ax, WORD PTR _pMsg$[ebp+4]
  0011f	8b cb		 mov	 ecx, ebx
  00121	c1 e9 08	 shr	 ecx, 8
  00124	88 8d f5 f7 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+1], cl
  0012a	88 9d f6 f7 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+2], bl
  00130	8b 95 f4 f7 ff
	ff		 mov	 edx, DWORD PTR _pMsg$[ebp]

; 10684: 
; 10685: 	DataSend(lpObj->m_Index, SendByte, lOfs);

  00136	53		 push	 ebx
  00137	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp]
  0013d	89 95 fc f7 ff
	ff		 mov	 DWORD PTR _SendByte$[ebp], edx
  00143	8b 16		 mov	 edx, DWORD PTR [esi]
  00145	51		 push	 ecx
  00146	52		 push	 edx
  00147	66 89 85 00 f8
	ff ff		 mov	 WORD PTR _SendByte$[ebp+4], ax
  0014e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@GCUserChao:

; 10686: }

  00156	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	33 cd		 xor	 ecx, ebp
  0015d	5b		 pop	 ebx
  0015e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; GCUserChaosBoxSend
_TEXT	ENDS
PUBLIC	??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@ ; `string'
PUBLIC	??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@ ; `string'
PUBLIC	??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_aRecv$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ; CGChaosBoxItemMixButtonClick
EXTRN	?SocketItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@H@Z:PROC ; CChaosBox::SocketItemMix
EXTRN	?Wing25Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::Wing25Mix
EXTRN	?Mix@SnakeBegins@@QAEXPAUOBJECTSTRUCT@@@Z:PROC	; SnakeBegins::Mix
EXTRN	?LuckySystemJewelCreate@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::LuckySystemJewelCreate
EXTRN	?LuckySystemItemCreate@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::LuckySystemItemCreate
EXTRN	?GoldenNSilverBoxMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::GoldenNSilverBoxMix
EXTRN	?SecromiconMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::SecromiconMix
EXTRN	?RemoveSeedSphereMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@E@Z:PROC ; CChaosBox::RemoveSeedSphereMix
EXTRN	?SetSeedSphereMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@E@Z:PROC ; CChaosBox::SetSeedSphereMix
EXTRN	?SeedSphereCompositeMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::SeedSphereCompositeMix
EXTRN	?SeedExtractMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::SeedExtractMix
EXTRN	?CherryBlossomMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::CherryBlossomMix
EXTRN	?NewWingChaos_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::NewWingChaos_Mix
EXTRN	?CondorFeather_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::CondorFeather_Mix
EXTRN	?IllusionTemple_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::IllusionTemple_Mix
EXTRN	?LotteryItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::LotteryItemMix
EXTRN	?ChaosMix380ItemOption@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CItemSystemFor380::ChaosMix380ItemOption
EXTRN	?g_kItemSystemFor380@@3VCItemSystemFor380@@A:BYTE ; g_kItemSystemFor380
EXTRN	?RestoreStrengthenItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CJewelOfHarmonySystem::RestoreStrengthenItem
EXTRN	?MakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CJewelOfHarmonySystem::MakeSmeltingStoneItem
EXTRN	?PurityJewelOfHarmony@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CJewelOfHarmonySystem::PurityJewelOfHarmony
EXTRN	?ShieldPotionLv3_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ShieldPotionLv3_Mix
EXTRN	?ShieldPotionLv2_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ShieldPotionLv2_Mix
EXTRN	?ShieldPotionLv1_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ShieldPotionLv1_Mix
EXTRN	?Fenrir_04Upgrade_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::Fenrir_04Upgrade_Mix
EXTRN	?Fenrir_03Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::Fenrir_03Level_Mix
EXTRN	?Fenrir_02Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::Fenrir_02Level_Mix
EXTRN	?Fenrir_01Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::Fenrir_01Level_Mix
EXTRN	?HiddenTreasureBoxItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::HiddenTreasureBoxItemMix
EXTRN	?CastleSpecialItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::CastleSpecialItemMix
EXTRN	?LifeStoneChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::LifeStoneChaosMix
EXTRN	?SoulPotionChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::SoulPotionChaosMix
EXTRN	?BlessPotionChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::BlessPotionChaosMix
EXTRN	?DarkSpiritChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::DarkSpiritChaosMix
EXTRN	?DarkHorseChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::DarkHorseChaosMix
EXTRN	?DefaultChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::DefaultChaosMix
EXTRN	?BloodCastleItemChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::BloodCastleItemChaosMix
EXTRN	?WingChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::WingChaosMix
EXTRN	?CircleChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::CircleChaosMix
EXTRN	?PegasiaChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::PegasiaChaosMix
EXTRN	?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CChaosBox::PlusItemLevelChaosMix
EXTRN	?DevilSquareItemChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::DevilSquareItemChaosMix
EXTRN	?g_ChaosBox@@3VCChaosBox@@A:BYTE		; g_ChaosBox
EXTRN	?GetSize@CItem@@QAEHAAH0@Z:PROC			; CItem::GetSize
;	COMDAT ??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@
CONST	SEGMENT
??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@ DB '['
	DB	'%s][%s] Undefine chaosmix type detect %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
CONST	SEGMENT
??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@ DB '['
	DB	'%s][%s] is Already Opening PShop, ChaosBox Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@
CONST	SEGMENT
??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@ DB '['
	DB	'%s][%s] Already Used Chaos', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z
_TEXT	SEGMENT
_iWidth$221263 = -44					; size = 4
_iHeight$221264 = -40					; size = 4
_aRecv$GSCopy$ = -36					; size = 4
_aIndex$GSCopy$ = -32					; size = 4
tv627 = -28						; size = 4
_iItemCount$221242 = -24				; size = 4
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z PROC ; CGChaosBoxItemMixButtonClick, COMDAT

; 10692: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 10693: 	if ( !gObjIsConnectedGP(aIndex))

  00018	56		 push	 esi

; 10776: 		}
; 10777: 
; 10778: 		if( lpObj->pChaosBox[iPos].m_bLuckySet )

  00019	89 7d dc	 mov	 DWORD PTR _aRecv$GSCopy$[ebp], edi
  0001c	89 75 e0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0001f	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 2a		 jne	 SHORT $LN77@CGChaosBox

; 10694: 	{
; 10695: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  0002b	68 c7 29 00 00	 push	 10695			; 000029c7H
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  0003a	6a 02		 push	 2
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00042	83 c4 10	 add	 esp, 16			; 00000010H
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN77@CGChaosBox:

; 10696: 		return;
; 10697: 	}
; 10698: 
; 10699: 	LPOBJ lpObj = &gObj[aIndex];

  00055	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0005b	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 10700: 
; 10701: 	if ( lpObj->ChaosLock == TRUE )

  00061	83 be 20 12 00
	00 01		 cmp	 DWORD PTR [esi+4640], 1
  00068	75 43		 jne	 SHORT $LN76@CGChaosBox

; 10702: 	{
; 10703: 		LogAdd("[%s][%s] Already Used Chaos",
; 10704: 			lpObj->AccountID, lpObj->Name);

  0006a	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0006d	50		 push	 eax
  0006e	8d 4e 52	 lea	 ecx, DWORD PTR [esi+82]
  00071	51		 push	 ecx
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 10705: 
; 10706: 		GCServerMsgStringSend(lMsg.Get(MSGGET(2, 198)), lpObj->m_Index, 1);

  0007d	8b 16		 mov	 edx, DWORD PTR [esi]
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	6a 01		 push	 1
  00084	52		 push	 edx
  00085	68 c6 02 00 00	 push	 710			; 000002c6H
$LN92@CGChaosBox:
  0008a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0008f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN76@CGChaosBox:

; 10707: 		return;
; 10708: 	}
; 10709: 
; 10710: 	if ( lpObj->m_bPShopOpen == true )

  000ad	80 be 5c 12 00
	00 01		 cmp	 BYTE PTR [esi+4700], 1
  000b4	75 22		 jne	 SHORT $LN75@CGChaosBox

; 10711: 	{
; 10712: 		LogAdd("[%s][%s] is Already Opening PShop, ChaosBox Failed",
; 10713: 			lpObj->AccountID, lpObj->Name);

  000b6	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000b9	50		 push	 eax
  000ba	8d 4e 52	 lea	 ecx, DWORD PTR [esi+82]
  000bd	51		 push	 ecx
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 10714: 
; 10715: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 194)), lpObj->m_Index, 1);

  000c9	8b 16		 mov	 edx, DWORD PTR [esi]
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ce	6a 01		 push	 1
  000d0	52		 push	 edx
  000d1	68 c2 04 00 00	 push	 1218			; 000004c2H

; 10716: 		return;

  000d6	eb b2		 jmp	 SHORT $LN92@CGChaosBox
$LN75@CGChaosBox:
  000d8	53		 push	 ebx

; 10717: 	}
; 10718: 
; 10719: 
; 10720: 	PMSG_CHAOSMIXRESULT pMsg;
; 10721: 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  000d9	6a 10		 push	 16			; 00000010H
  000db	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000de	68 86 00 00 00	 push	 134			; 00000086H
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10722: 	pMsg.Result = FALSE;
; 10723: 
; 10724: 	if ( aRecv->Type == CHAOS_TYPE_UPGRADE_10 ||
; 10725: 		 aRecv->Type == CHAOS_TYPE_UPGRADE_11 || 
; 10726: 		 aRecv->Type == CHAOS_TYPE_UPGRADE_12 ||
; 10727: 		 aRecv->Type == CHAOS_TYPE_UPGRADE_13 ||
; 10728: 		 aRecv->Type == CHAOS_TYPE_UPGRADE_14 ||
; 10729: 		 aRecv->Type == CHAOS_TYPE_UPGRADE_15 )

  000e9	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ef	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  000f3	3c 03		 cmp	 al, 3
  000f5	74 18		 je	 SHORT $LN73@CGChaosBox
  000f7	3c 04		 cmp	 al, 4
  000f9	74 14		 je	 SHORT $LN73@CGChaosBox
  000fb	3c 16		 cmp	 al, 22			; 00000016H
  000fd	74 10		 je	 SHORT $LN73@CGChaosBox
  000ff	3c 17		 cmp	 al, 23			; 00000017H
  00101	74 0c		 je	 SHORT $LN73@CGChaosBox
  00103	3c 31		 cmp	 al, 49			; 00000031H
  00105	74 08		 je	 SHORT $LN73@CGChaosBox
  00107	3c 32		 cmp	 al, 50			; 00000032H
  00109	0f 85 e4 00 00
	00		 jne	 $LN54@CGChaosBox
$LN73@CGChaosBox:

; 10730: 	{
; 10731: 		int iPos = 0;

  0010f	33 ff		 xor	 edi, edi
  00111	33 db		 xor	 ebx, ebx

; 10732: 		int iItemCount = 0;

  00113	89 7d e8	 mov	 DWORD PTR _iItemCount$221242[ebp], edi
  00116	89 7d e4	 mov	 DWORD PTR tv627[ebp], edi
  00119	8d a4 24 00 00
	00 00		 npad	 7
$LL85@CGChaosBox:

; 10735: 		{
; 10736: 			if( lpObj->pChaosBox[n].IsItem() == TRUE )

  00120	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  00126	03 4d e4	 add	 ecx, DWORD PTR tv627[ebp]
  00129	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0012e	b9 01 00 00 00	 mov	 ecx, 1
  00133	3b c1		 cmp	 eax, ecx
  00135	75 37		 jne	 SHORT $LN71@CGChaosBox

; 10737: 			{
; 10738: 				if( lpObj->pChaosBox[n].m_Level == 9 )

  00137	8b 96 10 12 00
	00		 mov	 edx, DWORD PTR [esi+4624]
  0013d	8b 45 e4	 mov	 eax, DWORD PTR tv627[ebp]
  00140	0f b7 44 10 08	 movzx	 eax, WORD PTR [eax+edx+8]
  00145	66 83 f8 09	 cmp	 ax, 9

; 10739: 				{
; 10740: 					iPos = n;
; 10741: 					iItemCount++;

  00149	74 1e		 je	 SHORT $LN90@CGChaosBox

; 10742: 				}
; 10743: 				else if( lpObj->pChaosBox[n].m_Level == 10 )

  0014b	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH

; 10744: 				{
; 10745: 					iPos = n;
; 10746: 					iItemCount++;

  0014f	74 18		 je	 SHORT $LN90@CGChaosBox

; 10747: 				}
; 10748: 				else if( lpObj->pChaosBox[n].m_Level == 11 )

  00151	66 83 f8 0b	 cmp	 ax, 11			; 0000000bH

; 10749: 				{
; 10750: 					iPos = n;
; 10751: 					iItemCount++;

  00155	74 12		 je	 SHORT $LN90@CGChaosBox

; 10752: 				}
; 10753: 				else if( lpObj->pChaosBox[n].m_Level == 12 )

  00157	66 83 f8 0c	 cmp	 ax, 12			; 0000000cH

; 10754: 				{
; 10755: 					iPos = n;
; 10756: 					iItemCount++;

  0015b	74 0c		 je	 SHORT $LN90@CGChaosBox

; 10757: 				}
; 10758: 				else if( lpObj->pChaosBox[n].m_Level == 13 )

  0015d	66 83 f8 0d	 cmp	 ax, 13			; 0000000dH

; 10759: 				{
; 10760: 					iPos = n;
; 10761: 					iItemCount++;

  00161	74 06		 je	 SHORT $LN90@CGChaosBox

; 10762: 				}
; 10763: 				else if( lpObj->pChaosBox[n].m_Level == 14 )

  00163	66 83 f8 0e	 cmp	 ax, 14			; 0000000eH
  00167	75 05		 jne	 SHORT $LN71@CGChaosBox
$LN90@CGChaosBox:

; 10764: 				{
; 10765: 					iPos = n;
; 10766: 					iItemCount++;

  00169	01 4d e8	 add	 DWORD PTR _iItemCount$221242[ebp], ecx
  0016c	8b df		 mov	 ebx, edi
$LN71@CGChaosBox:

; 10733: 
; 10734: 		for(int n = 0; n < CHAOS_BOX_SIZE; n++)

  0016e	8b 45 e4	 mov	 eax, DWORD PTR tv627[ebp]
  00171	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  00176	03 f9		 add	 edi, ecx
  00178	89 45 e4	 mov	 DWORD PTR tv627[ebp], eax
  0017b	3d 80 1a 00 00	 cmp	 eax, 6784		; 00001a80H
  00180	7c 9e		 jl	 SHORT $LL85@CGChaosBox

; 10767: 				}
; 10768: 			}
; 10769: 		}
; 10770: 
; 10771: 		if( iItemCount != 1 )

  00182	39 4d e8	 cmp	 DWORD PTR _iItemCount$221242[ebp], ecx
  00185	74 12		 je	 SHORT $LN57@CGChaosBox
$LN82@CGChaosBox:

; 10772: 		{
; 10773: 			pMsg.Result = FALSE;
; 10774: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00187	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0018b	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0018e	51		 push	 ecx
  0018f	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00192	52		 push	 edx
  00193	50		 push	 eax

; 10775: 			return;

  00194	e9 08 06 00 00	 jmp	 $LN91@CGChaosBox
$LN57@CGChaosBox:

; 10776: 		}
; 10777: 
; 10778: 		if( lpObj->pChaosBox[iPos].m_bLuckySet )

  00199	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  0019f	69 db d4 00 00
	00		 imul	 ebx, 212		; 000000d4H
  001a5	03 cb		 add	 ecx, ebx
  001a7	80 b9 ce 00 00
	00 00		 cmp	 BYTE PTR [ecx+206], 0
  001ae	74 12		 je	 SHORT $LN56@CGChaosBox

; 10779: 		{
; 10780: 			pMsg.Result = FALSE;
; 10781: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  001b0	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  001b4	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  001b7	52		 push	 edx
  001b8	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001bb	50		 push	 eax
  001bc	51		 push	 ecx

; 10782: 			return;

  001bd	e9 df 05 00 00	 jmp	 $LN91@CGChaosBox
$LN56@CGChaosBox:

; 10783: 		}
; 10784: 
; 10785: 		int iWidth = 0;

  001c2	33 c0		 xor	 eax, eax

; 10786: 		int iHeight = 0;
; 10787: 
; 10788: 		lpObj->pChaosBox[iPos].GetSize(iHeight,iWidth);

  001c4	8d 55 d4	 lea	 edx, DWORD PTR _iWidth$221263[ebp]
  001c7	89 45 d4	 mov	 DWORD PTR _iWidth$221263[ebp], eax
  001ca	89 45 d8	 mov	 DWORD PTR _iHeight$221264[ebp], eax
  001cd	52		 push	 edx
  001ce	8d 45 d8	 lea	 eax, DWORD PTR _iHeight$221264[ebp]
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 10789: 
; 10790: 		if( CheckInventoryEmptySpace(lpObj,iHeight,iWidth) != false )

  001d7	8b 4d d4	 mov	 ecx, DWORD PTR _iWidth$221263[ebp]
  001da	8b 55 d8	 mov	 edx, DWORD PTR _iHeight$221264[ebp]
  001dd	51		 push	 ecx
  001de	52		 push	 edx
  001df	56		 push	 esi
  001e0	e8 00 00 00 00	 call	 ?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z ; CheckInventoryEmptySpace
  001e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e8	85 c0		 test	 eax, eax
  001ea	0f 84 a4 05 00
	00		 je	 $LN55@CGChaosBox
  001f0	8b 7d dc	 mov	 edi, DWORD PTR _aRecv$GSCopy$[ebp]
$LN54@CGChaosBox:

; 10798: 			return;
; 10799: 		}
; 10800: 	}
; 10801: 
; 10802: 
; 10803: 	lpObj->bIsChaosMixCompleted = true;

  001f3	c6 86 09 16 00
	00 01		 mov	 BYTE PTR [esi+5641], 1

; 10804: 	int iMixType = aRecv->Type;

  001fa	0f b6 5f 03	 movzx	 ebx, BYTE PTR [edi+3]
  001fe	33 ff		 xor	 edi, edi
$LL53@CGChaosBox:

; 10807: 	{
; 10808: 		if ( lpObj->pChaosBox[n].IsItem() == TRUE
; 10809: 			&& lpObj->pChaosBox[n].m_bPeriodItem )

  00200	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  00206	03 cf		 add	 ecx, edi
  00208	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0020d	83 f8 01	 cmp	 eax, 1
  00210	75 14		 jne	 SHORT $LN52@CGChaosBox
  00212	8b 86 10 12 00
	00		 mov	 eax, DWORD PTR [esi+4624]
  00218	80 bc 07 cf 00
	00 00 00	 cmp	 BYTE PTR [edi+eax+207], 0
  00220	0f 85 61 ff ff
	ff		 jne	 $LN82@CGChaosBox
$LN52@CGChaosBox:

; 10805: 
; 10806: 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00226	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  0022c	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  00232	7c cc		 jl	 SHORT $LL53@CGChaosBox

; 10810: 		{
; 10811: 			pMsg.Result = FALSE;
; 10812: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 10813: 			return;
; 10814: 		}
; 10815: 	}
; 10816: #if(ENABLETEST_CHAOSMACHINEMNGR == 1)
; 10817: 	if (g_ChaosMachineManager.StartMix(lpObj, iMixType))
; 10818: 	{
; 10819: 		return;
; 10820: 	}
; 10821: #endif
; 10822: 	switch ( iMixType )	// TEST - Good

  00234	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00237	83 f8 38	 cmp	 eax, 56			; 00000038H
  0023a	0f 87 2c 05 00
	00		 ja	 $LN1@CGChaosBox
  00240	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN93@CGChaosBox[eax*4]
$LN47@CGChaosBox:

; 10823: 	{
; 10824: 		case CHAOS_TYPE_DEVILSQUARE:
; 10825: 			g_ChaosBox.DevilSquareItemChaosMix(lpObj);

  00247	56		 push	 esi
  00248	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0024d	e8 00 00 00 00	 call	 ?DevilSquareItemChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::DevilSquareItemChaosMix
  00252	5b		 pop	 ebx
  00253	5f		 pop	 edi
  00254	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00255	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00258	33 cd		 xor	 ecx, ebp
  0025a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025f	8b e5		 mov	 esp, ebp
  00261	5d		 pop	 ebp
  00262	c3		 ret	 0
$LN46@CGChaosBox:

; 10826: 			break;
; 10827: 		case CHAOS_TYPE_UPGRADE_10:
; 10828: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_10);

  00263	6a 03		 push	 3
  00265	56		 push	 esi
  00266	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0026b	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  00270	5b		 pop	 ebx
  00271	5f		 pop	 edi
  00272	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00273	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00276	33 cd		 xor	 ecx, ebp
  00278	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027d	8b e5		 mov	 esp, ebp
  0027f	5d		 pop	 ebp
  00280	c3		 ret	 0
$LN45@CGChaosBox:

; 10829: 			break;
; 10830: 		case CHAOS_TYPE_UPGRADE_11:
; 10831: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_11);

  00281	6a 04		 push	 4
  00283	56		 push	 esi
  00284	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00289	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  0028e	5b		 pop	 ebx
  0028f	5f		 pop	 edi
  00290	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00291	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00294	33 cd		 xor	 ecx, ebp
  00296	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029b	8b e5		 mov	 esp, ebp
  0029d	5d		 pop	 ebp
  0029e	c3		 ret	 0
$LN44@CGChaosBox:

; 10832: 			break;
; 10833: 		case CHAOS_TYPE_UPGRADE_12:
; 10834: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_12);

  0029f	6a 16		 push	 22			; 00000016H
  002a1	56		 push	 esi
  002a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  002a7	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  002ac	5b		 pop	 ebx
  002ad	5f		 pop	 edi
  002ae	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  002af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b2	33 cd		 xor	 ecx, ebp
  002b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b9	8b e5		 mov	 esp, ebp
  002bb	5d		 pop	 ebp
  002bc	c3		 ret	 0
$LN43@CGChaosBox:

; 10835: 			break;
; 10836: 		case CHAOS_TYPE_UPGRADE_13:
; 10837: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_13);

  002bd	6a 17		 push	 23			; 00000017H
  002bf	56		 push	 esi
  002c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  002c5	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  002ca	5b		 pop	 ebx
  002cb	5f		 pop	 edi
  002cc	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  002cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d0	33 cd		 xor	 ecx, ebp
  002d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d7	8b e5		 mov	 esp, ebp
  002d9	5d		 pop	 ebp
  002da	c3		 ret	 0
$LN42@CGChaosBox:

; 10838: 			break;
; 10839: 		case CHAOS_TYPE_UPGRADE_14:
; 10840: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_14);

  002db	6a 31		 push	 49			; 00000031H
  002dd	56		 push	 esi
  002de	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  002e3	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  002e8	5b		 pop	 ebx
  002e9	5f		 pop	 edi
  002ea	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  002eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ee	33 cd		 xor	 ecx, ebp
  002f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f5	8b e5		 mov	 esp, ebp
  002f7	5d		 pop	 ebp
  002f8	c3		 ret	 0
$LN41@CGChaosBox:

; 10841: 			break;
; 10842: 		case CHAOS_TYPE_UPGRADE_15:
; 10843: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_15);

  002f9	6a 32		 push	 50			; 00000032H
  002fb	56		 push	 esi
  002fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00301	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  00306	5b		 pop	 ebx
  00307	5f		 pop	 edi
  00308	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00309	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0030c	33 cd		 xor	 ecx, ebp
  0030e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00313	8b e5		 mov	 esp, ebp
  00315	5d		 pop	 ebp
  00316	c3		 ret	 0
$LN40@CGChaosBox:

; 10844: 			break;
; 10845: 		case CHAOS_TYPE_DINORANT:
; 10846: 			g_ChaosBox.PegasiaChaosMix(lpObj);

  00317	56		 push	 esi
  00318	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0031d	e8 00 00 00 00	 call	 ?PegasiaChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::PegasiaChaosMix
  00322	5b		 pop	 ebx
  00323	5f		 pop	 edi
  00324	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00325	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00328	33 cd		 xor	 ecx, ebp
  0032a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032f	8b e5		 mov	 esp, ebp
  00331	5d		 pop	 ebp
  00332	c3		 ret	 0
$LN39@CGChaosBox:

; 10847: 			break;
; 10848: 		case CHAOS_TYPE_FRUIT:
; 10849: 			g_ChaosBox.CircleChaosMix(lpObj);

  00333	56		 push	 esi
  00334	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00339	e8 00 00 00 00	 call	 ?CircleChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::CircleChaosMix
  0033e	5b		 pop	 ebx
  0033f	5f		 pop	 edi
  00340	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00341	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00344	33 cd		 xor	 ecx, ebp
  00346	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034b	8b e5		 mov	 esp, ebp
  0034d	5d		 pop	 ebp
  0034e	c3		 ret	 0
$LN38@CGChaosBox:

; 10850: 			break;
; 10851: 		case CHAOS_TYPE_SECOND_WING:
; 10852: 		case CHAOS_TYPE_CLOAK:
; 10853: 			g_ChaosBox.WingChaosMix(lpObj);

  0034f	56		 push	 esi
  00350	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00355	e8 00 00 00 00	 call	 ?WingChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::WingChaosMix
  0035a	5b		 pop	 ebx
  0035b	5f		 pop	 edi
  0035c	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  0035d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00360	33 cd		 xor	 ecx, ebp
  00362	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00367	8b e5		 mov	 esp, ebp
  00369	5d		 pop	 ebp
  0036a	c3		 ret	 0
$LN37@CGChaosBox:

; 10854: 			break;
; 10855: 		case CHAOS_TYPE_BLOODCATLE:
; 10856: 			g_ChaosBox.BloodCastleItemChaosMix(lpObj);

  0036b	56		 push	 esi
  0036c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00371	e8 00 00 00 00	 call	 ?BloodCastleItemChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::BloodCastleItemChaosMix
  00376	5b		 pop	 ebx
  00377	5f		 pop	 edi
  00378	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00379	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0037c	33 cd		 xor	 ecx, ebp
  0037e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00383	8b e5		 mov	 esp, ebp
  00385	5d		 pop	 ebp
  00386	c3		 ret	 0
$LN36@CGChaosBox:

; 10857: 			break;
; 10858: 		case CHAOS_TYPE_DEFAULT:
; 10859: 		case CHAOS_TYPE_FIRST_WING:
; 10860: 			g_ChaosBox.DefaultChaosMix(lpObj);

  00387	56		 push	 esi
  00388	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0038d	e8 00 00 00 00	 call	 ?DefaultChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::DefaultChaosMix
  00392	5b		 pop	 ebx
  00393	5f		 pop	 edi
  00394	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00395	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00398	33 cd		 xor	 ecx, ebp
  0039a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0039f	8b e5		 mov	 esp, ebp
  003a1	5d		 pop	 ebp
  003a2	c3		 ret	 0
$LN35@CGChaosBox:

; 10861: 			break;
; 10862: 		//case CHAOS_TYPE_SETITEM:	// #warning Activate this to SetItemChaosMix
; 10863: 			//SetItemChaosMix(lpObj);
; 10864: 			//break;
; 10865: 		case CHAOS_TYPE_DARKHORSE:
; 10866: 			g_ChaosBox.DarkHorseChaosMix(lpObj);

  003a3	56		 push	 esi
  003a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  003a9	e8 00 00 00 00	 call	 ?DarkHorseChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::DarkHorseChaosMix
  003ae	5b		 pop	 ebx
  003af	5f		 pop	 edi
  003b0	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  003b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b4	33 cd		 xor	 ecx, ebp
  003b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003bb	8b e5		 mov	 esp, ebp
  003bd	5d		 pop	 ebp
  003be	c3		 ret	 0
$LN34@CGChaosBox:

; 10867: 			break;
; 10868: 		case CHAOS_TYPE_DARKSPIRIT:
; 10869: 			g_ChaosBox.DarkSpiritChaosMix(lpObj);

  003bf	56		 push	 esi
  003c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  003c5	e8 00 00 00 00	 call	 ?DarkSpiritChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::DarkSpiritChaosMix
  003ca	5b		 pop	 ebx
  003cb	5f		 pop	 edi
  003cc	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  003cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d0	33 cd		 xor	 ecx, ebp
  003d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d7	8b e5		 mov	 esp, ebp
  003d9	5d		 pop	 ebp
  003da	c3		 ret	 0
$LN33@CGChaosBox:

; 10870: 			break;
; 10871: 		case CHAOS_TYPE_BLESS_POTION:
; 10872: 			g_ChaosBox.BlessPotionChaosMix(lpObj);

  003db	56		 push	 esi
  003dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  003e1	e8 00 00 00 00	 call	 ?BlessPotionChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::BlessPotionChaosMix
  003e6	5b		 pop	 ebx
  003e7	5f		 pop	 edi
  003e8	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  003e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ec	33 cd		 xor	 ecx, ebp
  003ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f3	8b e5		 mov	 esp, ebp
  003f5	5d		 pop	 ebp
  003f6	c3		 ret	 0
$LN32@CGChaosBox:

; 10873: 			break;
; 10874: 		case CHAOS_TYPE_SOUL_POTION:
; 10875: 			g_ChaosBox.SoulPotionChaosMix(lpObj);

  003f7	56		 push	 esi
  003f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  003fd	e8 00 00 00 00	 call	 ?SoulPotionChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::SoulPotionChaosMix
  00402	5b		 pop	 ebx
  00403	5f		 pop	 edi
  00404	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00405	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00408	33 cd		 xor	 ecx, ebp
  0040a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040f	8b e5		 mov	 esp, ebp
  00411	5d		 pop	 ebp
  00412	c3		 ret	 0
$LN31@CGChaosBox:

; 10876: 			break;
; 10877: 		case CHAOS_TYPE_LIFE_STONE:
; 10878: 			g_ChaosBox.LifeStoneChaosMix(lpObj);

  00413	56		 push	 esi
  00414	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00419	e8 00 00 00 00	 call	 ?LifeStoneChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::LifeStoneChaosMix
  0041e	5b		 pop	 ebx
  0041f	5f		 pop	 edi
  00420	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00421	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00424	33 cd		 xor	 ecx, ebp
  00426	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0042b	8b e5		 mov	 esp, ebp
  0042d	5d		 pop	 ebp
  0042e	c3		 ret	 0
$LN30@CGChaosBox:

; 10879: 			break;
; 10880: #if (GS_CASTLE == 1)
; 10881: 		case CHAOS_TYPE_CASTLE_SPECIALMIX:
; 10882: 			g_ChaosBox.CastleSpecialItemMix(lpObj);

  0042f	56		 push	 esi
  00430	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00435	e8 00 00 00 00	 call	 ?CastleSpecialItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::CastleSpecialItemMix
  0043a	5b		 pop	 ebx
  0043b	5f		 pop	 edi
  0043c	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  0043d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00440	33 cd		 xor	 ecx, ebp
  00442	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00447	8b e5		 mov	 esp, ebp
  00449	5d		 pop	 ebp
  0044a	c3		 ret	 0
$LN29@CGChaosBox:

; 10883: 			break;
; 10884: #endif
; 10885: 		case CHAOS_TYPE_HT_BOX:
; 10886: 			g_ChaosBox.HiddenTreasureBoxItemMix(lpObj);

  0044b	56		 push	 esi
  0044c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00451	e8 00 00 00 00	 call	 ?HiddenTreasureBoxItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::HiddenTreasureBoxItemMix
  00456	5b		 pop	 ebx
  00457	5f		 pop	 edi
  00458	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00459	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0045c	33 cd		 xor	 ecx, ebp
  0045e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00463	8b e5		 mov	 esp, ebp
  00465	5d		 pop	 ebp
  00466	c3		 ret	 0
$LN28@CGChaosBox:

; 10887: 			break;
; 10888: 		case CHAOS_TYPE_FENRIR_01:
; 10889: 			g_ChaosBox.Fenrir_01Level_Mix(lpObj);

  00467	56		 push	 esi
  00468	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0046d	e8 00 00 00 00	 call	 ?Fenrir_01Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::Fenrir_01Level_Mix
  00472	5b		 pop	 ebx
  00473	5f		 pop	 edi
  00474	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00475	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00478	33 cd		 xor	 ecx, ebp
  0047a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0047f	8b e5		 mov	 esp, ebp
  00481	5d		 pop	 ebp
  00482	c3		 ret	 0
$LN27@CGChaosBox:

; 10890: 			break;
; 10891: 		case CHAOS_TYPE_FENRIR_02:
; 10892: 			g_ChaosBox.Fenrir_02Level_Mix(lpObj);

  00483	56		 push	 esi
  00484	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00489	e8 00 00 00 00	 call	 ?Fenrir_02Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::Fenrir_02Level_Mix
  0048e	5b		 pop	 ebx
  0048f	5f		 pop	 edi
  00490	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00491	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00494	33 cd		 xor	 ecx, ebp
  00496	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0049b	8b e5		 mov	 esp, ebp
  0049d	5d		 pop	 ebp
  0049e	c3		 ret	 0
$LN26@CGChaosBox:

; 10893: 			break;
; 10894: 		case CHAOS_TYPE_FENRIR_03:
; 10895: 			g_ChaosBox.Fenrir_03Level_Mix(lpObj);

  0049f	56		 push	 esi
  004a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  004a5	e8 00 00 00 00	 call	 ?Fenrir_03Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::Fenrir_03Level_Mix
  004aa	5b		 pop	 ebx
  004ab	5f		 pop	 edi
  004ac	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  004ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b0	33 cd		 xor	 ecx, ebp
  004b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004b7	8b e5		 mov	 esp, ebp
  004b9	5d		 pop	 ebp
  004ba	c3		 ret	 0
$LN25@CGChaosBox:

; 10896: 			break;
; 10897: 		case CHAOS_TYPE_FENRIR_04:
; 10898: 			g_ChaosBox.Fenrir_04Upgrade_Mix(lpObj);

  004bb	56		 push	 esi
  004bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  004c1	e8 00 00 00 00	 call	 ?Fenrir_04Upgrade_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::Fenrir_04Upgrade_Mix
  004c6	5b		 pop	 ebx
  004c7	5f		 pop	 edi
  004c8	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  004c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004cc	33 cd		 xor	 ecx, ebp
  004ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004d3	8b e5		 mov	 esp, ebp
  004d5	5d		 pop	 ebp
  004d6	c3		 ret	 0
$LN24@CGChaosBox:

; 10899: 			break;
; 10900: 		case CHAOS_TYPE_COMPOUNDPOTION_LV1:
; 10901: 			g_ChaosBox.ShieldPotionLv1_Mix(lpObj);

  004d7	56		 push	 esi
  004d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  004dd	e8 00 00 00 00	 call	 ?ShieldPotionLv1_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::ShieldPotionLv1_Mix
  004e2	5b		 pop	 ebx
  004e3	5f		 pop	 edi
  004e4	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  004e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004e8	33 cd		 xor	 ecx, ebp
  004ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ef	8b e5		 mov	 esp, ebp
  004f1	5d		 pop	 ebp
  004f2	c3		 ret	 0
$LN23@CGChaosBox:

; 10902: 			break;
; 10903: 		case CHAOS_TYPE_COMPOUNTPOTION_LV2:
; 10904: 			g_ChaosBox.ShieldPotionLv2_Mix(lpObj);

  004f3	56		 push	 esi
  004f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  004f9	e8 00 00 00 00	 call	 ?ShieldPotionLv2_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::ShieldPotionLv2_Mix
  004fe	5b		 pop	 ebx
  004ff	5f		 pop	 edi
  00500	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00501	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00504	33 cd		 xor	 ecx, ebp
  00506	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0050b	8b e5		 mov	 esp, ebp
  0050d	5d		 pop	 ebp
  0050e	c3		 ret	 0
$LN22@CGChaosBox:

; 10905: 			break;
; 10906: 		case CHAOS_TYPE_COMPOUNTPOTION_LV3:
; 10907: 			g_ChaosBox.ShieldPotionLv3_Mix(lpObj);

  0050f	56		 push	 esi
  00510	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00515	e8 00 00 00 00	 call	 ?ShieldPotionLv3_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::ShieldPotionLv3_Mix
  0051a	5b		 pop	 ebx
  0051b	5f		 pop	 edi
  0051c	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  0051d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00520	33 cd		 xor	 ecx, ebp
  00522	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00527	8b e5		 mov	 esp, ebp
  00529	5d		 pop	 ebp
  0052a	c3		 ret	 0
$LN21@CGChaosBox:

; 10908: 			break;
; 10909: 		case CHAOS_TYPE_JEWELOFHARMONY_PURITY:
; 10910: 			g_kJewelOfHarmonySystem.PurityJewelOfHarmony(lpObj);

  0052b	56		 push	 esi
  0052c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00531	e8 00 00 00 00	 call	 ?PurityJewelOfHarmony@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::PurityJewelOfHarmony
  00536	5b		 pop	 ebx
  00537	5f		 pop	 edi
  00538	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00539	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0053c	33 cd		 xor	 ecx, ebp
  0053e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00543	8b e5		 mov	 esp, ebp
  00545	5d		 pop	 ebp
  00546	c3		 ret	 0
$LN20@CGChaosBox:

; 10911: 			break;
; 10912: 		case CHAOS_TYPE_JEWELOFHARMONY_MIX_SMELTINGITEM:
; 10913: 			g_kJewelOfHarmonySystem.MakeSmeltingStoneItem(lpObj);

  00547	56		 push	 esi
  00548	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0054d	e8 00 00 00 00	 call	 ?MakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::MakeSmeltingStoneItem
  00552	5b		 pop	 ebx
  00553	5f		 pop	 edi
  00554	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00555	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00558	33 cd		 xor	 ecx, ebp
  0055a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0055f	8b e5		 mov	 esp, ebp
  00561	5d		 pop	 ebp
  00562	c3		 ret	 0
$LN19@CGChaosBox:

; 10914: 			break;
; 10915: 		case CHAOS_TYPE_JEWELOFHARMONY_RESTORE_ITEM:
; 10916: 			g_kJewelOfHarmonySystem.RestoreStrengthenItem(lpObj);

  00563	56		 push	 esi
  00564	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00569	e8 00 00 00 00	 call	 ?RestoreStrengthenItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::RestoreStrengthenItem
  0056e	5b		 pop	 ebx
  0056f	5f		 pop	 edi
  00570	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00571	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00574	33 cd		 xor	 ecx, ebp
  00576	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0057b	8b e5		 mov	 esp, ebp
  0057d	5d		 pop	 ebp
  0057e	c3		 ret	 0
$LN18@CGChaosBox:

; 10917: 			break;
; 10918: 		case CHAOS_TYPE_380_OPTIONITEM:
; 10919: 			g_kItemSystemFor380.ChaosMix380ItemOption(lpObj);

  0057f	56		 push	 esi
  00580	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kItemSystemFor380@@3VCItemSystemFor380@@A ; g_kItemSystemFor380
  00585	e8 00 00 00 00	 call	 ?ChaosMix380ItemOption@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z ; CItemSystemFor380::ChaosMix380ItemOption
  0058a	5b		 pop	 ebx
  0058b	5f		 pop	 edi
  0058c	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  0058d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00590	33 cd		 xor	 ecx, ebp
  00592	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00597	8b e5		 mov	 esp, ebp
  00599	5d		 pop	 ebp
  0059a	c3		 ret	 0
$LN17@CGChaosBox:

; 10920: 			break;
; 10921: 		case CHAOS_TYPE_LOTTERY_MIX:
; 10922: 			g_ChaosBox.LotteryItemMix(lpObj);

  0059b	56		 push	 esi
  0059c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  005a1	e8 00 00 00 00	 call	 ?LotteryItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::LotteryItemMix
  005a6	5b		 pop	 ebx
  005a7	5f		 pop	 edi
  005a8	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  005a9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005ac	33 cd		 xor	 ecx, ebp
  005ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005b3	8b e5		 mov	 esp, ebp
  005b5	5d		 pop	 ebp
  005b6	c3		 ret	 0
$LN16@CGChaosBox:

; 10923: 			break;
; 10924: 		case CHAOS_TYPE_ILLUSIONMIX:
; 10925: 			g_ChaosBox.IllusionTemple_Mix(lpObj);

  005b7	56		 push	 esi
  005b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  005bd	e8 00 00 00 00	 call	 ?IllusionTemple_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::IllusionTemple_Mix
  005c2	5b		 pop	 ebx
  005c3	5f		 pop	 edi
  005c4	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  005c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005c8	33 cd		 xor	 ecx, ebp
  005ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005cf	8b e5		 mov	 esp, ebp
  005d1	5d		 pop	 ebp
  005d2	c3		 ret	 0
$LN15@CGChaosBox:

; 10926: 			break;
; 10927: 		case CHAOS_TYPE_CONDOR_FEATHER:
; 10928: 			g_ChaosBox.CondorFeather_Mix(lpObj);

  005d3	56		 push	 esi
  005d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  005d9	e8 00 00 00 00	 call	 ?CondorFeather_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::CondorFeather_Mix
  005de	5b		 pop	 ebx
  005df	5f		 pop	 edi
  005e0	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  005e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005e4	33 cd		 xor	 ecx, ebp
  005e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005eb	8b e5		 mov	 esp, ebp
  005ed	5d		 pop	 ebp
  005ee	c3		 ret	 0
$LN14@CGChaosBox:

; 10929: 			break;
; 10930: 		case CHAOS_TYPE_3RDWING_MIX:
; 10931: 			g_ChaosBox.NewWingChaos_Mix(lpObj);

  005ef	56		 push	 esi
  005f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  005f5	e8 00 00 00 00	 call	 ?NewWingChaos_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::NewWingChaos_Mix
  005fa	5b		 pop	 ebx
  005fb	5f		 pop	 edi
  005fc	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  005fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00600	33 cd		 xor	 ecx, ebp
  00602	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00607	8b e5		 mov	 esp, ebp
  00609	5d		 pop	 ebp
  0060a	c3		 ret	 0
$LN13@CGChaosBox:

; 10932: 			break;
; 10933: 		case CHAOS_TYPE_CHERRY_BLOSSOM:
; 10934: 			g_ChaosBox.CherryBlossomMix(lpObj);

  0060b	56		 push	 esi
  0060c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00611	e8 00 00 00 00	 call	 ?CherryBlossomMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::CherryBlossomMix
  00616	5b		 pop	 ebx
  00617	5f		 pop	 edi
  00618	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00619	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0061c	33 cd		 xor	 ecx, ebp
  0061e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00623	8b e5		 mov	 esp, ebp
  00625	5d		 pop	 ebp
  00626	c3		 ret	 0
$LN12@CGChaosBox:

; 10935: 			break;
; 10936: 		case CHAOS_TYPE_SEEDEXTRACT:
; 10937: 			g_ChaosBox.SeedExtractMix(lpObj);

  00627	56		 push	 esi
  00628	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0062d	e8 00 00 00 00	 call	 ?SeedExtractMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::SeedExtractMix
  00632	5b		 pop	 ebx
  00633	5f		 pop	 edi
  00634	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00635	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00638	33 cd		 xor	 ecx, ebp
  0063a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0063f	8b e5		 mov	 esp, ebp
  00641	5d		 pop	 ebp
  00642	c3		 ret	 0
$LN11@CGChaosBox:

; 10938: 			break;
; 10939: 		case CHAOS_TYPE_SPHEREMIX:
; 10940: 			g_ChaosBox.SeedSphereCompositeMix(lpObj);

  00643	56		 push	 esi
  00644	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00649	e8 00 00 00 00	 call	 ?SeedSphereCompositeMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::SeedSphereCompositeMix
  0064e	5b		 pop	 ebx
  0064f	5f		 pop	 edi
  00650	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00651	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00654	33 cd		 xor	 ecx, ebp
  00656	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0065b	8b e5		 mov	 esp, ebp
  0065d	5d		 pop	 ebp
  0065e	c3		 ret	 0
$LN10@CGChaosBox:

; 10941: 			break;
; 10942: 		case CHAOS_TYPE_SPHEREMOUNT:
; 10943: 			g_ChaosBox.SetSeedSphereMix(lpObj,aRecv->Pos);

  0065f	8b 4d dc	 mov	 ecx, DWORD PTR _aRecv$GSCopy$[ebp]
  00662	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00666	52		 push	 edx
  00667	56		 push	 esi
  00668	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0066d	e8 00 00 00 00	 call	 ?SetSeedSphereMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@E@Z ; CChaosBox::SetSeedSphereMix
  00672	5b		 pop	 ebx
  00673	5f		 pop	 edi
  00674	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00675	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00678	33 cd		 xor	 ecx, ebp
  0067a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0067f	8b e5		 mov	 esp, ebp
  00681	5d		 pop	 ebp
  00682	c3		 ret	 0
$LN9@CGChaosBox:

; 10944: 			break;
; 10945: 		case CHAOS_TYPE_SPHEREUNMOUNT:
; 10946: 			g_ChaosBox.RemoveSeedSphereMix(lpObj,aRecv->Pos);

  00683	8b 45 dc	 mov	 eax, DWORD PTR _aRecv$GSCopy$[ebp]
  00686	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0068a	51		 push	 ecx
  0068b	56		 push	 esi
  0068c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00691	e8 00 00 00 00	 call	 ?RemoveSeedSphereMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@E@Z ; CChaosBox::RemoveSeedSphereMix
  00696	5b		 pop	 ebx
  00697	5f		 pop	 edi
  00698	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00699	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0069c	33 cd		 xor	 ecx, ebp
  0069e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006a3	8b e5		 mov	 esp, ebp
  006a5	5d		 pop	 ebp
  006a6	c3		 ret	 0
$LN8@CGChaosBox:

; 10947: 			break;
; 10948: 		case CHAOS_TYPE_DUNGEON_KEYITEM:
; 10949: 			g_ChaosBox.SecromiconMix(lpObj);

  006a7	56		 push	 esi
  006a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  006ad	e8 00 00 00 00	 call	 ?SecromiconMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::SecromiconMix
  006b2	5b		 pop	 ebx
  006b3	5f		 pop	 edi
  006b4	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  006b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006b8	33 cd		 xor	 ecx, ebp
  006ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006bf	8b e5		 mov	 esp, ebp
  006c1	5d		 pop	 ebp
  006c2	c3		 ret	 0
$LN7@CGChaosBox:

; 10950: 			break;
; 10951: 		case CHAOS_TYPE_GOLD_AND_SILBER_BOX:
; 10952: 			g_ChaosBox.GoldenNSilverBoxMix(lpObj);

  006c3	56		 push	 esi
  006c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  006c9	e8 00 00 00 00	 call	 ?GoldenNSilverBoxMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::GoldenNSilverBoxMix
  006ce	5b		 pop	 ebx
  006cf	5f		 pop	 edi
  006d0	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  006d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006d4	33 cd		 xor	 ecx, ebp
  006d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006db	8b e5		 mov	 esp, ebp
  006dd	5d		 pop	 ebp
  006de	c3		 ret	 0
$LN6@CGChaosBox:

; 10953: 			break;
; 10954: 		case CHAOS_TYPE_LUCKYSYSTEM1:
; 10955: 			g_ChaosBox.LuckySystemItemCreate(lpObj);

  006df	56		 push	 esi
  006e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  006e5	e8 00 00 00 00	 call	 ?LuckySystemItemCreate@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::LuckySystemItemCreate
  006ea	5b		 pop	 ebx
  006eb	5f		 pop	 edi
  006ec	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  006ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006f0	33 cd		 xor	 ecx, ebp
  006f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006f7	8b e5		 mov	 esp, ebp
  006f9	5d		 pop	 ebp
  006fa	c3		 ret	 0
$LN5@CGChaosBox:

; 10956: 			break;
; 10957: 		case CHAOS_TYPE_LUCKYSYSTEM2:
; 10958: 			g_ChaosBox.LuckySystemJewelCreate(lpObj);

  006fb	56		 push	 esi
  006fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00701	e8 00 00 00 00	 call	 ?LuckySystemJewelCreate@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::LuckySystemJewelCreate
  00706	5b		 pop	 ebx
  00707	5f		 pop	 edi
  00708	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00709	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0070c	33 cd		 xor	 ecx, ebp
  0070e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00713	8b e5		 mov	 esp, ebp
  00715	5d		 pop	 ebp
  00716	c3		 ret	 0
$LN4@CGChaosBox:

; 10959: 			break;
; 10960: 		case CHAOS_TYPE_SNAKEBEGINS:
; 10961: 			g_SnakeBegins.Mix(lpObj);

  00717	56		 push	 esi
  00718	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SnakeBegins@@3VSnakeBegins@@A ; g_SnakeBegins
  0071d	e8 00 00 00 00	 call	 ?Mix@SnakeBegins@@QAEXPAUOBJECTSTRUCT@@@Z ; SnakeBegins::Mix
  00722	5b		 pop	 ebx
  00723	5f		 pop	 edi
  00724	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00725	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00728	33 cd		 xor	 ecx, ebp
  0072a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0072f	8b e5		 mov	 esp, ebp
  00731	5d		 pop	 ebp
  00732	c3		 ret	 0
$LN3@CGChaosBox:

; 10962: 			break;
; 10963: #if (ENABLETEST_ARCA == 1)
; 10964: 		case CHAOS_TYPE_ARCA_BOOTY:
; 10965: 			g_ArcaBattle.BootyExchange(lpObj);
; 10966: 			break;
; 10967: 		case CHAOS_TYPE_ARCA_REGMARK:
; 10968: 			//CGReqMarkRegButtonClick(lpObj);
; 10969: 			break;
; 10970: #endif
; 10971: 		case CHAOS_TYPE_25WINGMIX:
; 10972: 			g_ChaosBox.Wing25Mix(lpObj);

  00733	56		 push	 esi
  00734	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00739	e8 00 00 00 00	 call	 ?Wing25Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::Wing25Mix
  0073e	5b		 pop	 ebx
  0073f	5f		 pop	 edi
  00740	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00741	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00744	33 cd		 xor	 ecx, ebp
  00746	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0074b	8b e5		 mov	 esp, ebp
  0074d	5d		 pop	 ebp
  0074e	c3		 ret	 0
$LN2@CGChaosBox:

; 10973: 			break;
; 10974: 		case CHAOS_TYPE_SOCKETMIX1:
; 10975: 			g_ChaosBox.SocketItemMix(lpObj,iMixType);

  0074f	53		 push	 ebx
  00750	56		 push	 esi
  00751	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00756	e8 00 00 00 00	 call	 ?SocketItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@H@Z ; CChaosBox::SocketItemMix
  0075b	5b		 pop	 ebx
  0075c	5f		 pop	 edi
  0075d	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  0075e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00761	33 cd		 xor	 ecx, ebp
  00763	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00768	8b e5		 mov	 esp, ebp
  0076a	5d		 pop	 ebp
  0076b	c3		 ret	 0
$LN1@CGChaosBox:

; 10976: 			break;
; 10977: 
; 10978: #if (CUSTOM_WINGS == 1)
; 10979: 		case CHAOS_TYPE_4THWINGS:
; 10980: 			g_ChaosBox.Create4thWings(lpObj);
; 10981: 			break;
; 10982: #endif
; 10983: #ifdef __NOVUS__
; 10984: 		case CHAOS_TYPE_RAREITEM:
; 10985: 			g_ChaosBox.RareItem(lpObj);
; 10986: 			break;
; 10987: #endif
; 10988: 		default:
; 10989: 			LogAddTD("[%s][%s] Undefine chaosmix type detect %d",
; 10990: 				lpObj->AccountID, lpObj->Name, iMixType);

  0076c	53		 push	 ebx
  0076d	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  00770	52		 push	 edx
  00771	83 c6 52	 add	 esi, 82			; 00000052H
  00774	56		 push	 esi
  00775	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@
  0077a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00780	83 c4 10	 add	 esp, 16			; 00000010H
  00783	5b		 pop	 ebx
  00784	5f		 pop	 edi
  00785	5e		 pop	 esi

; 10991: 			break;
; 10992: 	}
; 10993: }

  00786	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00789	33 cd		 xor	 ecx, ebp
  0078b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00790	8b e5		 mov	 esp, ebp
  00792	5d		 pop	 ebp
  00793	c3		 ret	 0
$LN55@CGChaosBox:

; 10791: 		{
; 10792: 
; 10793: 		}
; 10794: 		else
; 10795: 		{
; 10796: 			pMsg.Result = FALSE;
; 10797: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00794	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00798	8b 55 e0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0079b	50		 push	 eax
  0079c	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0079f	51		 push	 ecx
  007a0	52		 push	 edx
$LN91@CGChaosBox:
  007a1	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  007a5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10991: 			break;
; 10992: 	}
; 10993: }

  007aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  007b0	5b		 pop	 ebx
  007b1	5f		 pop	 edi
  007b2	33 cd		 xor	 ecx, ebp
  007b4	5e		 pop	 esi
  007b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007ba	8b e5		 mov	 esp, ebp
  007bc	5d		 pop	 ebp
  007bd	c3		 ret	 0
  007be	8b ff		 npad	 2
$LN93@CGChaosBox:
  007c0	00 00 00 00	 DD	 $LN36@CGChaosBox
  007c4	00 00 00 00	 DD	 $LN47@CGChaosBox
  007c8	00 00 00 00	 DD	 $LN46@CGChaosBox
  007cc	00 00 00 00	 DD	 $LN45@CGChaosBox
  007d0	00 00 00 00	 DD	 $LN40@CGChaosBox
  007d4	00 00 00 00	 DD	 $LN39@CGChaosBox
  007d8	00 00 00 00	 DD	 $LN38@CGChaosBox
  007dc	00 00 00 00	 DD	 $LN37@CGChaosBox
  007e0	00 00 00 00	 DD	 $LN1@CGChaosBox
  007e4	00 00 00 00	 DD	 $LN1@CGChaosBox
  007e8	00 00 00 00	 DD	 $LN36@CGChaosBox
  007ec	00 00 00 00	 DD	 $LN1@CGChaosBox
  007f0	00 00 00 00	 DD	 $LN35@CGChaosBox
  007f4	00 00 00 00	 DD	 $LN34@CGChaosBox
  007f8	00 00 00 00	 DD	 $LN33@CGChaosBox
  007fc	00 00 00 00	 DD	 $LN32@CGChaosBox
  00800	00 00 00 00	 DD	 $LN31@CGChaosBox
  00804	00 00 00 00	 DD	 $LN30@CGChaosBox
  00808	00 00 00 00	 DD	 $LN1@CGChaosBox
  0080c	00 00 00 00	 DD	 $LN29@CGChaosBox
  00810	00 00 00 00	 DD	 $LN1@CGChaosBox
  00814	00 00 00 00	 DD	 $LN44@CGChaosBox
  00818	00 00 00 00	 DD	 $LN43@CGChaosBox
  0081c	00 00 00 00	 DD	 $LN38@CGChaosBox
  00820	00 00 00 00	 DD	 $LN28@CGChaosBox
  00824	00 00 00 00	 DD	 $LN27@CGChaosBox
  00828	00 00 00 00	 DD	 $LN26@CGChaosBox
  0082c	00 00 00 00	 DD	 $LN25@CGChaosBox
  00830	00 00 00 00	 DD	 $LN1@CGChaosBox
  00834	00 00 00 00	 DD	 $LN24@CGChaosBox
  00838	00 00 00 00	 DD	 $LN23@CGChaosBox
  0083c	00 00 00 00	 DD	 $LN22@CGChaosBox
  00840	00 00 00 00	 DD	 $LN21@CGChaosBox
  00844	00 00 00 00	 DD	 $LN20@CGChaosBox
  00848	00 00 00 00	 DD	 $LN19@CGChaosBox
  0084c	00 00 00 00	 DD	 $LN18@CGChaosBox
  00850	00 00 00 00	 DD	 $LN16@CGChaosBox
  00854	00 00 00 00	 DD	 $LN15@CGChaosBox
  00858	00 00 00 00	 DD	 $LN14@CGChaosBox
  0085c	00 00 00 00	 DD	 $LN17@CGChaosBox
  00860	00 00 00 00	 DD	 $LN13@CGChaosBox
  00864	00 00 00 00	 DD	 $LN12@CGChaosBox
  00868	00 00 00 00	 DD	 $LN11@CGChaosBox
  0086c	00 00 00 00	 DD	 $LN10@CGChaosBox
  00870	00 00 00 00	 DD	 $LN9@CGChaosBox
  00874	00 00 00 00	 DD	 $LN8@CGChaosBox
  00878	00 00 00 00	 DD	 $LN7@CGChaosBox
  0087c	00 00 00 00	 DD	 $LN4@CGChaosBox
  00880	00 00 00 00	 DD	 $LN42@CGChaosBox
  00884	00 00 00 00	 DD	 $LN41@CGChaosBox
  00888	00 00 00 00	 DD	 $LN6@CGChaosBox
  0088c	00 00 00 00	 DD	 $LN5@CGChaosBox
  00890	00 00 00 00	 DD	 $LN1@CGChaosBox
  00894	00 00 00 00	 DD	 $LN1@CGChaosBox
  00898	00 00 00 00	 DD	 $LN1@CGChaosBox
  0089c	00 00 00 00	 DD	 $LN3@CGChaosBox
  008a0	00 00 00 00	 DD	 $LN2@CGChaosBox
?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ENDP ; CGChaosBoxItemMixButtonClick
_TEXT	ENDS
PUBLIC	?CGChaosBoxUseEnd@@YAXH@Z			; CGChaosBoxUseEnd
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ChaosBoxInit
; Function compile flags: /Ogtp
;	COMDAT ?CGChaosBoxUseEnd@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?CGChaosBoxUseEnd@@YAXH@Z PROC				; CGChaosBoxUseEnd, COMDAT

; 10999: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 11000: 	if ( !gObjIsConnectedGP(aIndex))

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	75 1f		 jne	 SHORT $LN3@CGChaosBox@2

; 11001: 	{
; 11002: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00015	68 fa 2a 00 00	 push	 11002			; 00002afaH
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00024	6a 02		 push	 2
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	5f		 pop	 edi

; 11026: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN3@CGChaosBox@2:
  00034	56		 push	 esi

; 11003: 		return;
; 11004: 	}
; 11005: 
; 11006: 	LPOBJ lpObj = &gObj[aIndex];

  00035	8b f7		 mov	 esi, edi
  00037	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0003d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11007: 
; 11008: 	PMSG_DEFAULT pMsg;
; 11009: 	PHeadSetB((LPBYTE)&pMsg, 0x87, sizeof(pMsg));

  00043	6a 03		 push	 3
  00045	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00048	68 87 00 00 00	 push	 135			; 00000087H
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11010: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00053	0f b6 4d fd	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00057	51		 push	 ecx
  00058	8d 55 fc	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0005b	52		 push	 edx
  0005c	57		 push	 edi
  0005d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11011: 
; 11012: 	if ( lpObj->m_IfState.use && lpObj->m_IfState.type == 7 )

  00062	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  00068	83 c4 18	 add	 esp, 24			; 00000018H
  0006b	a8 03		 test	 al, 3
  0006d	74 19		 je	 SHORT $LN2@CGChaosBox@2
  0006f	8b c8		 mov	 ecx, eax
  00071	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00077	81 f9 c0 01 00
	00		 cmp	 ecx, 448		; 000001c0H
  0007d	75 09		 jne	 SHORT $LN2@CGChaosBox@2

; 11013: 	{
; 11014: 		lpObj->m_IfState.use = 0;
; 11015: 		lpObj->m_IfState.state = 0;

  0007f	83 e0 c0	 and	 eax, -64		; ffffffc0H
  00082	89 86 b8 11 00
	00		 mov	 DWORD PTR [esi+4536], eax
$LN2@CGChaosBox@2:

; 11016: 	}
; 11017: 
; 11018: 	g_ChaosBox.ChaosBoxInit(lpObj);

  00088	56		 push	 esi
  00089	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0008e	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 11019: 
; 11020: 	if(lpObj->pTransaction == 1)

  00093	80 be cc 11 00
	00 01		 cmp	 BYTE PTR [esi+4556], 1
  0009a	75 0b		 jne	 SHORT $LN1@CGChaosBox@2

; 11021: 	{
; 11022: 		gObjInventoryCommit(lpObj->m_Index);

  0009c	8b 16		 mov	 edx, DWORD PTR [esi]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  000a4	83 c4 04	 add	 esp, 4
$LN1@CGChaosBox@2:

; 11023: 	}
; 11024: 
; 11025: 	lpObj->m_bIsCastleNPCUpgradeCompleted = false;

  000a7	c6 86 5c 20 00
	00 00		 mov	 BYTE PTR [esi+8284], 0
  000ae	5e		 pop	 esi
  000af	5f		 pop	 edi

; 11026: }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?CGChaosBoxUseEnd@@YAXH@Z ENDP				; CGChaosBoxUseEnd
_TEXT	ENDS
PUBLIC	??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@ ; `string'
PUBLIC	??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_lpMove$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z		; PMoveProc
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjPositionCheck
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?CheckPlayStart@CBloodCastle@@QAE_NH@Z:PROC	; CBloodCastle::CheckPlayStart
EXTRN	?GetCurrentState@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetCurrentState
EXTRN	?GetBridgeLevel@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetBridgeLevel
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?gObjSetPosition@@YAXHHH@Z:PROC			; gObjSetPosition
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?RoadPathTable@@3PAFA:BYTE			; RoadPathTable
EXTRN	?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckXYMapTile
EXTRN	?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckUsedBuffEffect
;	COMDAT ??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@
CONST	SEGMENT
??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@ DB 'error'
	DB	'-L3 : Path Count error %d id:%s %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@
CONST	SEGMENT
??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@ DB 'error-L3 '
	DB	': move protocol index error %s %d', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z
_TEXT	SEGMENT
_sy$ = -300						; size = 4
_sx$ = -296						; size = 4
_aIndex$GSCopy$ = -292					; size = 4
_pMove$ = -288						; size = 8
_n$ = -280						; size = 2
_lpMove$GSCopy$ = -280					; size = 4
_ay$ = -274						; size = 1
_ax$ = -273						; size = 1
_pActionResult$221431 = -272				; size = 9
_msg$221367 = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_lpMove$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z PROC			; PMoveProc, COMDAT

; 11044: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpMove$[ebp]
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 11140: 		}
; 11141: 
; 11142: 		ax += RoadPathTable[pathtable*2];

  0001b	89 9d e8 fe ff
	ff		 mov	 DWORD PTR _lpMove$GSCopy$[ebp], ebx
  00021	89 b5 dc fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  00027	85 f6		 test	 esi, esi
  00029	78 0f		 js	 SHORT $LN66@PMoveProc

; 11045: 	if ( !OBJMAX_RANGE(aIndex))

  0002b	33 c0		 xor	 eax, eax
  0002d	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00033	0f 9e c0	 setle	 al
  00036	85 c0		 test	 eax, eax
  00038	75 28		 jne	 SHORT $LN49@PMoveProc
$LN66@PMoveProc:

; 11046: 	{
; 11047: 		LogAdd("error-L3 : move protocol index error %s %d", __FILE__, __LINE__);

  0003a	68 27 2b 00 00	 push	 11047			; 00002b27H
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx

; 11415: }

  00054	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00057	33 cd		 xor	 ecx, ebp
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN49@PMoveProc:

; 11048: 		return;
; 11049: 	}
; 11050: 
; 11051: 	PMSG_RECVMOVE pMove;
; 11052: 	short n;
; 11053: 	short pathtable;
; 11054: 	BYTE ax;
; 11055: 	BYTE ay;
; 11056: 	int sx;
; 11057: 	int sy;
; 11058: 	LPOBJ lpObj = &gObj[aIndex];

  00062	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00068	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11059: 
; 11060: 	if ( lpObj->RegenOk > 0 )

  0006e	80 be 8b 05 00
	00 00		 cmp	 BYTE PTR [esi+1419], 0
  00075	0f 8f 98 06 00
	00		 jg	 $LN43@PMoveProc

; 11061: 		return;
; 11062: 
; 11063: 	if ( lpObj->SkillRecallParty_Time )

  0007b	66 83 be 04 16
	00 00 00	 cmp	 WORD PTR [esi+5636], 0
  00083	74 3a		 je	 SHORT $LN69@PMoveProc

; 11064: 	{
; 11065: 		lpObj->SkillRecallParty_Time = 0;

  00085	33 c0		 xor	 eax, eax

; 11066: 		char msg[255];
; 11067: 		wsprintf(msg, lMsg.Get(MSGGET(4, 230)));

  00087	68 e6 04 00 00	 push	 1254			; 000004e6H
  0008c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00091	66 89 86 04 16
	00 00		 mov	 WORD PTR [esi+5636], ax
  00098	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0009d	50		 push	 eax
  0009e	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$221367[ebp]
  000a4	51		 push	 ecx
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 11068: 		GCServerMsgStringSend(msg, lpObj->m_Index, 1);

  000ab	8b 16		 mov	 edx, DWORD PTR [esi]
  000ad	6a 01		 push	 1
  000af	52		 push	 edx
  000b0	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$221367[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000bc	83 c4 14	 add	 esp, 20			; 00000014H
$LN69@PMoveProc:

; 11069: 	}
; 11070: 
; 11071: 	if ( (GetTickCount()-lpObj->m_LastMoveTime) < 100 )

  000bf	57		 push	 edi
  000c0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  000c6	ff d7		 call	 edi
  000c8	2b 86 58 05 00
	00		 sub	 eax, DWORD PTR [esi+1368]
  000ce	83 f8 64	 cmp	 eax, 100		; 00000064H
  000d1	0f 82 3b 06 00
	00		 jb	 $LN78@PMoveProc

; 11072: 		return;
; 11073: 
; 11074: 	if ( lpObj->Teleport )

  000d7	80 be 88 05 00
	00 00		 cmp	 BYTE PTR [esi+1416], 0
  000de	0f 85 2e 06 00
	00		 jne	 $LN78@PMoveProc

; 11075: 		return;
; 11076: 
; 11077: 	if ( gObjCheckUsedBuffEffect(lpObj,BUFF_ICEARROW) == TRUE ||
; 11078: 		 gObjCheckUsedBuffEffect(lpObj,BUFF_STUN) == TRUE ||
; 11079: 		 gObjCheckUsedBuffEffect(lpObj,BUFF_SLEEP) == TRUE ||
; 11080: 		 gObjCheckUsedBuffEffect(lpObj,BUFF_FREEZE) == TRUE ||
; 11081: 		 gObjCheckUsedBuffEffect(lpObj,BUFF_EARTHBINDS) == TRUE )

  000e4	6a 39		 push	 57			; 00000039H
  000e6	56		 push	 esi
  000e7	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000ec	83 c4 08	 add	 esp, 8
  000ef	3c 01		 cmp	 al, 1
  000f1	0f 84 1b 06 00
	00		 je	 $LN78@PMoveProc
  000f7	6a 3d		 push	 61			; 0000003dH
  000f9	56		 push	 esi
  000fa	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000ff	83 c4 08	 add	 esp, 8
  00102	3c 01		 cmp	 al, 1
  00104	0f 84 08 06 00
	00		 je	 $LN78@PMoveProc
  0010a	6a 48		 push	 72			; 00000048H
  0010c	56		 push	 esi
  0010d	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00112	83 c4 08	 add	 esp, 8
  00115	3c 01		 cmp	 al, 1
  00117	0f 84 f5 05 00
	00		 je	 $LN78@PMoveProc
  0011d	68 92 00 00 00	 push	 146			; 00000092H
  00122	56		 push	 esi
  00123	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00128	83 c4 08	 add	 esp, 8
  0012b	3c 01		 cmp	 al, 1
  0012d	0f 84 df 05 00
	00		 je	 $LN78@PMoveProc
  00133	68 93 00 00 00	 push	 147			; 00000093H
  00138	56		 push	 esi
  00139	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0013e	83 c4 08	 add	 esp, 8
  00141	3c 01		 cmp	 al, 1
  00143	0f 84 c9 05 00
	00		 je	 $LN78@PMoveProc

; 11082: 	{
; 11083: 		return;
; 11084: 	}
; 11085: 
; 11086: 	lpObj->m_LastMoveTime = GetTickCount();

  00149	ff d7		 call	 edi
  0014b	89 86 58 05 00
	00		 mov	 DWORD PTR [esi+1368], eax

; 11087: 	lpObj->m_Rest = 0;

  00151	c6 86 d4 01 00
	00 00		 mov	 BYTE PTR [esi+468], 0

; 11088: 	lpObj->PathCur = 0;

  00158	c7 86 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+348], 0

; 11089: 	lpObj->Dir = lpMove->Path[0] >> 4;

  00162	8a 4b 05	 mov	 cl, BYTE PTR [ebx+5]
  00165	c0 e9 04	 shr	 cl, 4
  00168	88 8e 22 01 00
	00		 mov	 BYTE PTR [esi+290], cl

; 11090: 	lpObj->PathCount = lpMove->Path[0] & 0x0F;

  0016e	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  00172	83 e0 0f	 and	 eax, 15			; 0000000fH
  00175	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax

; 11091: 
; 11092: 	if ( lpObj->PathCount > 15 )

  0017b	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0017e	7e 2e		 jle	 SHORT $LN42@PMoveProc

; 11093: 	{
; 11094: 		LogAdd("error-L3 : Path Count error %d id:%s %s %d",
; 11095: 			lpObj->PathCount, lpObj->AccountID, __FILE__, __LINE__);

  00180	68 57 2b 00 00	 push	 11095			; 00002b57H
  00185	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0018a	83 c6 52	 add	 esi, 82			; 00000052H
  0018d	56		 push	 esi
  0018e	50		 push	 eax
  0018f	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0019a	83 c4 14	 add	 esp, 20			; 00000014H
  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	5b		 pop	 ebx

; 11415: }

  001a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a3	33 cd		 xor	 ecx, ebp
  001a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
$LN42@PMoveProc:

; 11096: 		return;
; 11097: 	}
; 11098: 
; 11099: 	for ( n=0;n<15;n++)

  001ae	8d 86 8f 01 00
	00		 lea	 eax, DWORD PTR [esi+399]
  001b4	8d 8e 62 01 00
	00		 lea	 ecx, DWORD PTR [esi+354]
  001ba	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  001bf	90		 npad	 1
$LL41@PMoveProc:

; 11100: 	{
; 11101: 		lpObj->PathX[n]=0;
; 11102: 		lpObj->PathY[n]=0;
; 11103: 		lpObj->PathOri[n]=0;

  001c0	33 ff		 xor	 edi, edi
  001c2	c6 40 f1 00	 mov	 BYTE PTR [eax-15], 0
  001c6	c6 00 00	 mov	 BYTE PTR [eax], 0
  001c9	66 89 39	 mov	 WORD PTR [ecx], di
  001cc	bf 01 00 00 00	 mov	 edi, 1
  001d1	83 c1 02	 add	 ecx, 2
  001d4	03 c7		 add	 eax, edi
  001d6	2b d7		 sub	 edx, edi
  001d8	75 e6		 jne	 SHORT $LL41@PMoveProc

; 11104: 	}
; 11105: 
; 11106: 	sx = lpMove->X;

  001da	0f b6 53 03	 movzx	 edx, BYTE PTR [ebx+3]

; 11107: 	sy = lpMove->Y;

  001de	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]

; 11108: 
; 11109: 	if ( gObjCheckXYMapTile(lpObj, 1) == TRUE )

  001e2	57		 push	 edi
  001e3	56		 push	 esi
  001e4	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _sx$[ebp], edx
  001ea	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _sy$[ebp], eax
  001f0	e8 00 00 00 00	 call	 ?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCheckXYMapTile
  001f5	83 c4 08	 add	 esp, 8
  001f8	3b c7		 cmp	 eax, edi

; 11110: 	{
; 11111: 		lpObj->PathCount = 0;
; 11112: 		lpObj->PathCur = 0;
; 11113: 		lpObj->PathStartEnd = 0;
; 11114: 		gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);
; 11115: 		return;

  001fa	0f 84 4a 01 00
	00		 je	 $LN83@PMoveProc

; 11116: 	}
; 11117: 
; 11118: 	lpObj->PathX[0] = lpMove->X;
; 11119: 	ax = lpObj->PathX[0];
; 11120: 	lpObj->PathY[0] = lpMove->Y;
; 11121: 	ay = lpObj->PathY[0];
; 11122: 	lpObj->PathDir[0] = lpObj->Dir;
; 11123: 	lpObj->PathStartEnd = 1;
; 11124: 
; 11125: 	if ( lpObj->PathCount > 0 )

  00200	83 be 58 01 00
	00 00		 cmp	 DWORD PTR [esi+344], 0
  00207	8a 43 03	 mov	 al, BYTE PTR [ebx+3]
  0020a	8a 8e 22 01 00
	00		 mov	 cl, BYTE PTR [esi+290]
  00210	88 86 80 01 00
	00		 mov	 BYTE PTR [esi+384], al
  00216	8a 5b 04	 mov	 bl, BYTE PTR [ebx+4]
  00219	88 85 ef fe ff
	ff		 mov	 BYTE PTR _ax$[ebp], al
  0021f	88 9e 8f 01 00
	00		 mov	 BYTE PTR [esi+399], bl
  00225	88 9d ee fe ff
	ff		 mov	 BYTE PTR _ay$[ebp], bl
  0022b	88 8e 9e 01 00
	00		 mov	 BYTE PTR [esi+414], cl
  00231	c6 86 60 01 00
	00 01		 mov	 BYTE PTR [esi+352], 1
  00238	7e 0c		 jle	 SHORT $LN37@PMoveProc

; 11126: 	{
; 11127: 		lpObj->PathCur = 1;
; 11128: 		lpObj->PathCount++;

  0023a	01 be 58 01 00
	00		 add	 DWORD PTR [esi+344], edi
  00240	89 be 5c 01 00
	00		 mov	 DWORD PTR [esi+348], edi
$LN37@PMoveProc:

; 11129: 	}
; 11130: 
; 11131: 	for (n=1;n<lpObj->PathCount;n++)

  00246	8b cf		 mov	 ecx, edi
  00248	39 8e 58 01 00
	00		 cmp	 DWORD PTR [esi+344], ecx
  0024e	0f 8e 99 00 00
	00		 jle	 $LN34@PMoveProc
$LL68@PMoveProc:

; 11132: 	{
; 11133: 		if ( (n%2) == 1 )

  00254	8b d1		 mov	 edx, ecx
  00256	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  0025c	79 05		 jns	 SHORT $LN79@PMoveProc
  0025e	4a		 dec	 edx
  0025f	83 ca fe	 or	 edx, -2			; fffffffeH
  00262	42		 inc	 edx
$LN79@PMoveProc:

; 11134: 		{
; 11135: 			pathtable = lpMove->Path[(n+1) / 2] >> 4;

  00263	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00266	83 fa 01	 cmp	 edx, 1
  00269	99		 cdq
  0026a	75 13		 jne	 SHORT $LN33@PMoveProc
  0026c	2b c2		 sub	 eax, edx
  0026e	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _lpMove$GSCopy$[ebp]
  00274	d1 f8		 sar	 eax, 1
  00276	8a 44 10 05	 mov	 al, BYTE PTR [eax+edx+5]
  0027a	c0 e8 04	 shr	 al, 4

; 11136: 		}
; 11137: 		else

  0027d	eb 10		 jmp	 SHORT $LN80@PMoveProc
$LN33@PMoveProc:

; 11138: 		{
; 11139: 			pathtable = lpMove->Path[(n+1) / 2] & 0x0F;

  0027f	2b c2		 sub	 eax, edx
  00281	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _lpMove$GSCopy$[ebp]
  00287	d1 f8		 sar	 eax, 1
  00289	8a 44 10 05	 mov	 al, BYTE PTR [eax+edx+5]
  0028d	24 0f		 and	 al, 15			; 0000000fH
$LN80@PMoveProc:
  0028f	0f b6 d0	 movzx	 edx, al

; 11140: 		}
; 11141: 
; 11142: 		ax += RoadPathTable[pathtable*2];

  00292	0f bf c2	 movsx	 eax, dx
  00295	03 c0		 add	 eax, eax
  00297	0f b6 9c 00 00
	00 00 00	 movzx	 ebx, BYTE PTR ?RoadPathTable@@3PAFA[eax+eax]
  0029f	00 9d ef fe ff
	ff		 add	 BYTE PTR _ax$[ebp], bl

; 11143: 		ay += RoadPathTable[pathtable*2+1];

  002a5	8a 9d ee fe ff
	ff		 mov	 bl, BYTE PTR _ay$[ebp]
  002ab	02 9c 00 02 00
	00 00		 add	 bl, BYTE PTR ?RoadPathTable@@3PAFA[eax+eax+2]
  002b2	03 c0		 add	 eax, eax

; 11144: 		
; 11145: 		lpObj->PathOri[n-1] = pathtable;
; 11146: 		lpObj->PathDir[n]= (char)pathtable;
; 11147: 		lpObj->PathX[n] = ax;

  002b4	8a 85 ef fe ff
	ff		 mov	 al, BYTE PTR _ax$[ebp]
  002ba	66 89 94 4e 60
	01 00 00	 mov	 WORD PTR [esi+ecx*2+352], dx
  002c2	47		 inc	 edi
  002c3	88 94 31 9e 01
	00 00		 mov	 BYTE PTR [ecx+esi+414], dl
  002ca	88 84 31 80 01
	00 00		 mov	 BYTE PTR [ecx+esi+384], al

; 11148: 		lpObj->PathY[n] = ay;

  002d1	88 9c 31 8f 01
	00 00		 mov	 BYTE PTR [ecx+esi+399], bl
  002d8	0f bf cf	 movsx	 ecx, di
  002db	88 9d ee fe ff
	ff		 mov	 BYTE PTR _ay$[ebp], bl
  002e1	3b 8e 58 01 00
	00		 cmp	 ecx, DWORD PTR [esi+344]
  002e7	0f 8c 67 ff ff
	ff		 jl	 $LL68@PMoveProc
$LN34@PMoveProc:

; 11149: 	}
; 11150: 
; 11151: 	if ( lpObj->PathCount > 0 )

  002ed	83 be 58 01 00
	00 00		 cmp	 DWORD PTR [esi+344], 0
  002f4	0f 8e 90 00 00
	00		 jle	 $LN70@PMoveProc

; 11152: 	{
; 11153: 		int nextX;
; 11154: 		int nextY;
; 11155: 		BYTE mapnumber;
; 11156: 		BYTE attr;
; 11157: 		nextX = lpObj->PathX[1];
; 11158: 		nextY = lpObj->PathY[1];
; 11159: 		mapnumber = lpObj->MapNumber;
; 11160: 		attr = MapC[mapnumber].GetAttr(nextX, nextY);

  002fa	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  00301	0f b6 be 90 01
	00 00		 movzx	 edi, BYTE PTR [esi+400]
  00308	69 c9 28 38 05
	00		 imul	 ecx, 342056		; 00053828H
  0030e	0f b6 86 81 01
	00 00		 movzx	 eax, BYTE PTR [esi+385]
  00315	57		 push	 edi
  00316	50		 push	 eax
  00317	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0031d	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 11161: 
; 11162: 		if ( (((BYTE)attr & (BYTE)4) == (BYTE)4) || (((BYTE)attr & (BYTE)8) == (BYTE)8) )

  00322	a8 0c		 test	 al, 12			; 0000000cH
  00324	74 64		 je	 SHORT $LN70@PMoveProc

; 11163: 		{
; 11164: 			for ( n=0 ; n<15 ; n++)

  00326	8d 86 8f 01 00
	00		 lea	 eax, DWORD PTR [esi+399]
  0032c	8d 8e 62 01 00
	00		 lea	 ecx, DWORD PTR [esi+354]
  00332	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
$LL28@PMoveProc:

; 11165: 			{
; 11166: 				lpObj->PathX[n] = 0;
; 11167: 				lpObj->PathY[n] = 0;
; 11168: 				lpObj->PathOri[n] = 0;

  00337	33 ff		 xor	 edi, edi
  00339	c6 40 f1 00	 mov	 BYTE PTR [eax-15], 0
  0033d	c6 00 00	 mov	 BYTE PTR [eax], 0
  00340	66 89 39	 mov	 WORD PTR [ecx], di
  00343	83 c1 02	 add	 ecx, 2
  00346	40		 inc	 eax
  00347	4a		 dec	 edx
  00348	75 ed		 jne	 SHORT $LL28@PMoveProc
$LN83@PMoveProc:

; 11169: 			}
; 11170: 
; 11171: 			lpObj->PathCount = 0;
; 11172: 			lpObj->PathCur = 0;
; 11173: 			lpObj->PathStartEnd = 0;
; 11174: 			gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  0034a	0f b6 8e 21 01
	00 00		 movzx	 ecx, BYTE PTR [esi+289]
  00351	0f b6 96 20 01
	00 00		 movzx	 edx, BYTE PTR [esi+288]
  00358	33 c0		 xor	 eax, eax
  0035a	51		 push	 ecx
  0035b	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax
  00361	89 86 5c 01 00
	00		 mov	 DWORD PTR [esi+348], eax
  00367	88 86 60 01 00
	00		 mov	 BYTE PTR [esi+352], al
  0036d	8b 06		 mov	 eax, DWORD PTR [esi]
  0036f	52		 push	 edx
  00370	50		 push	 eax
  00371	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  00376	83 c4 0c	 add	 esp, 12			; 0000000cH
  00379	5f		 pop	 edi
  0037a	5e		 pop	 esi
  0037b	5b		 pop	 ebx

; 11415: }

  0037c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0037f	33 cd		 xor	 ecx, ebp
  00381	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00386	8b e5		 mov	 esp, ebp
  00388	5d		 pop	 ebp
  00389	c3		 ret	 0
$LN70@PMoveProc:

; 11175: 			return;
; 11176: 		}
; 11177: 	}
; 11178: 
; 11179: 	lpObj->TX = (BYTE)ax;
; 11180: 	lpObj->TY = (BYTE)ay;
; 11181: 
; 11182: 	/*if ( lpObj->Type == OBJ_USER )
; 11183: 	{
; 11184: 		int x = lpObj->X;
; 11185: 		int y = lpObj->Y;
; 11186: 		int bOk = FALSE;
; 11187: 		WORD Attr = 0;
; 11188: 
; 11189: 		for(int i = 0; i< 256;i++)
; 11190: 		{
; 11191: 			if( x > lpObj->TX )
; 11192: 			{
; 11193: 				x--;
; 11194: 			}
; 11195: 
; 11196: 			if( x < lpObj->TX )
; 11197: 			{
; 11198: 				x++;
; 11199: 			}
; 11200: 
; 11201: 			if( y > lpObj->TY )
; 11202: 			{
; 11203: 				y--;
; 11204: 			}
; 11205: 
; 11206: 			if( y < lpObj->TY )
; 11207: 			{
; 11208: 				y++;
; 11209: 			}
; 11210: 
; 11211: 			Attr = MapC[lpObj->MapNumber].GetAttr(x,y);
; 11212: 
; 11213: 			if( (Attr & 16) == 16 )
; 11214: 			{
; 11215: 				bOk = TRUE;
; 11216: 				break;
; 11217: 			}
; 11218: 
; 11219: 			if( x == lpObj->TX &&
; 11220: 				y == lpObj->TY )
; 11221: 			{
; 11222: 				break;
; 11223: 			}
; 11224: 		}
; 11225: 
; 11226: 		if( bOk == TRUE )
; 11227: 		{
; 11228: 			lpObj->m_Rest = 1;
; 11229: 			lpObj->PathCur = 0;
; 11230: 			lpObj->PathCount = 0;
; 11231: 			lpObj->PathStartEnd = 0;
; 11232: 			gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);
; 11233: 
; 11234: 			PMSG_ACTIONRESULT pActionResult;
; 11235: 
; 11236: 			PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));
; 11237: 			pActionResult.NumberH = SET_NUMBERH(aIndex);
; 11238: 			pActionResult.NumberL = SET_NUMBERL(aIndex);
; 11239: 			pActionResult.ActionNumber = 0x7A;
; 11240: 			pActionResult.Dir = lpObj->Dir;
; 11241: 			pActionResult.TargetNumberH = 0;
; 11242: 			pActionResult.TargetNumberL = 0;
; 11243: 			DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));
; 11244: 			return;
; 11245: 		}
; 11246: 	}*/
; 11247: 
; 11248: 	if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Type == OBJ_USER )

  0038a	8a 86 23 01 00
	00		 mov	 al, BYTE PTR [esi+291]
  00390	8a 8d ef fe ff
	ff		 mov	 cl, BYTE PTR _ax$[ebp]
  00396	88 8e 52 01 00
	00		 mov	 BYTE PTR [esi+338], cl
  0039c	88 9e 53 01 00
	00		 mov	 BYTE PTR [esi+339], bl
  003a2	3c 34		 cmp	 al, 52			; 00000034H
  003a4	74 15		 je	 SHORT $LN67@PMoveProc
  003a6	3c 0b		 cmp	 al, 11			; 0000000bH
  003a8	0f 82 58 01 00
	00		 jb	 $LN74@PMoveProc
  003ae	b2 11		 mov	 dl, 17			; 00000011H
  003b0	3a d0		 cmp	 dl, al
  003b2	1b c9		 sbb	 ecx, ecx
  003b4	41		 inc	 ecx
  003b5	0f 84 4b 01 00
	00		 je	 $LN74@PMoveProc
$LN67@PMoveProc:
  003bb	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  003bf	0f 85 41 01 00
	00		 jne	 $LN74@PMoveProc

; 11249: 	{
; 11250: 		int Bridge = g_BloodCastle.GetBridgeLevel(lpObj->MapNumber);

  003c5	0f b6 c0	 movzx	 eax, al
  003c8	50		 push	 eax
  003c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  003ce	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  003d3	8b f8		 mov	 edi, eax

; 11251: 		switch ( g_BloodCastle.GetCurrentState(Bridge) )

  003d5	57		 push	 edi
  003d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  003db	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  003e0	48		 dec	 eax
  003e1	0f 84 12 01 00
	00		 je	 $LN22@PMoveProc
  003e7	48		 dec	 eax
  003e8	0f 85 18 01 00
	00		 jne	 $LN74@PMoveProc

; 11274: 				}
; 11275: 				break;
; 11276: 			case 0x02:
; 11277: 				if ( lpObj->Y > 17 && g_BloodCastle.CheckPlayStart(Bridge) == false)

  003ee	80 be 21 01 00
	00 11		 cmp	 BYTE PTR [esi+289], 17	; 00000011H
  003f5	76 2f		 jbe	 SHORT $LN19@PMoveProc
  003f7	57		 push	 edi
  003f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  003fd	e8 00 00 00 00	 call	 ?CheckPlayStart@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckPlayStart
  00402	84 c0		 test	 al, al
  00404	75 20		 jne	 SHORT $LN19@PMoveProc

; 11278: 				{
; 11279: 					gObjMoveGate(lpObj->m_Index, Bridge+0x42);

  00406	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00408	83 c7 42	 add	 edi, 66			; 00000042H
  0040b	57		 push	 edi
  0040c	51		 push	 ecx
  0040d	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00412	83 c4 08	 add	 esp, 8
  00415	5f		 pop	 edi
  00416	5e		 pop	 esi
  00417	5b		 pop	 ebx

; 11415: }

  00418	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041b	33 cd		 xor	 ecx, ebp
  0041d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00422	8b e5		 mov	 esp, ebp
  00424	5d		 pop	 ebp
  00425	c3		 ret	 0
$LN19@PMoveProc:

; 11280: 					return;
; 11281: 				}
; 11282: 
; 11283: 				if ( lpObj->TY > 15 && g_BloodCastle.CheckPlayStart(Bridge) == false )

  00426	80 be 53 01 00
	00 0f		 cmp	 BYTE PTR [esi+339], 15	; 0000000fH
  0042d	76 0f		 jbe	 SHORT $LN18@PMoveProc
  0042f	57		 push	 edi
  00430	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00435	e8 00 00 00 00	 call	 ?CheckPlayStart@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckPlayStart
  0043a	84 c0		 test	 al, al

; 11284: 				{
; 11285: 					lpObj->m_Rest = 1;
; 11286: 					lpObj->PathCur = 0;
; 11287: 					lpObj->PathCount = 0;
; 11288: 					lpObj->PathStartEnd = 0;
; 11289: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);
; 11290: 
; 11291: 					PMSG_ACTIONRESULT pActionResult;
; 11292: 
; 11293: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));
; 11294: 					pActionResult.NumberH = SET_NUMBERH(aIndex);
; 11295: 					pActionResult.NumberL = SET_NUMBERL(aIndex);
; 11296: 					pActionResult.ActionNumber = 0x7A;
; 11297: 					pActionResult.Dir = lpObj->Dir;
; 11298: 					pActionResult.TargetNumberH = 0;
; 11299: 					pActionResult.TargetNumberL = 0;
; 11300: 
; 11301: 					DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));
; 11302: 					return;

  0043c	74 20		 je	 SHORT $LN82@PMoveProc
$LN18@PMoveProc:

; 11303: 				}
; 11304: 
; 11305: 				if ( lpObj->TY > 76 &&  g_BloodCastle.m_BridgeData[Bridge].m_bCASTLE_DOOR_LIVE )

  0043e	80 be 53 01 00
	00 4c		 cmp	 BYTE PTR [esi+339], 76	; 0000004cH
  00445	0f 86 bb 00 00
	00		 jbe	 $LN74@PMoveProc
  0044b	69 ff 0c 02 00
	00		 imul	 edi, 524		; 0000020cH
  00451	83 bf 4c 01 00
	00 00		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edi+332], 0
  00458	0f 84 a8 00 00
	00		 je	 $LN74@PMoveProc
$LN82@PMoveProc:

; 11306: 				{
; 11307: 					lpObj->m_Rest = 1;
; 11308: 					lpObj->PathCur = 0;
; 11309: 					lpObj->PathCount = 0;
; 11310: 					lpObj->PathStartEnd = 0;
; 11311: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  0045e	0f b6 96 21 01
	00 00		 movzx	 edx, BYTE PTR [esi+289]
  00465	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00467	33 c0		 xor	 eax, eax
  00469	89 86 5c 01 00
	00		 mov	 DWORD PTR [esi+348], eax
  0046f	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax
  00475	88 86 60 01 00
	00		 mov	 BYTE PTR [esi+352], al
  0047b	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00482	52		 push	 edx
  00483	50		 push	 eax
  00484	51		 push	 ecx
  00485	c6 86 d4 01 00
	00 01		 mov	 BYTE PTR [esi+468], 1
  0048c	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition

; 11312: 
; 11313: 					PMSG_ACTIONRESULT pActionResult;
; 11314: 
; 11315: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));

  00491	6a 09		 push	 9
  00493	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _pActionResult$221431[ebp]
  00499	6a 18		 push	 24			; 00000018H
  0049b	52		 push	 edx
  0049c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11316: 					pActionResult.NumberH = SET_NUMBERH(aIndex);

  004a1	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]

; 11317: 					pActionResult.NumberL = SET_NUMBERL(aIndex);
; 11318: 					pActionResult.ActionNumber = 0x7A;
; 11319: 					pActionResult.Dir = lpObj->Dir;

  004a7	8a 96 22 01 00
	00		 mov	 dl, BYTE PTR [esi+290]
  004ad	8b c8		 mov	 ecx, eax
  004af	c1 e9 08	 shr	 ecx, 8
  004b2	88 85 f4 fe ff
	ff		 mov	 BYTE PTR _pActionResult$221431[ebp+4], al

; 11320: 					pActionResult.TargetNumberH = 0;
; 11321: 					pActionResult.TargetNumberL = 0;
; 11322: 
; 11323: 					DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));

  004b8	6a 09		 push	 9
  004ba	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$221431[ebp]
  004c0	88 8d f3 fe ff
	ff		 mov	 BYTE PTR _pActionResult$221431[ebp+3], cl
  004c6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  004c8	50		 push	 eax
  004c9	51		 push	 ecx
  004ca	88 95 f5 fe ff
	ff		 mov	 BYTE PTR _pActionResult$221431[ebp+5], dl
  004d0	66 c7 85 f6 fe
	ff ff 7a 00	 mov	 WORD PTR _pActionResult$221431[ebp+6], 122 ; 0000007aH
  004d9	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _pActionResult$221431[ebp+8], 0
  004e0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004e5	83 c4 24	 add	 esp, 36			; 00000024H
  004e8	5f		 pop	 edi
  004e9	5e		 pop	 esi
  004ea	5b		 pop	 ebx

; 11415: }

  004eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004ee	33 cd		 xor	 ecx, ebp
  004f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004f5	8b e5		 mov	 esp, ebp
  004f7	5d		 pop	 ebp
  004f8	c3		 ret	 0
$LN22@PMoveProc:

; 11252: 		{
; 11253: 			case 0x01:
; 11254: 				if ( lpObj->TY > 15 )

  004f9	80 be 53 01 00
	00 0f		 cmp	 BYTE PTR [esi+339], 15	; 0000000fH

; 11255: 				{
; 11256: 					lpObj->m_Rest = 1;
; 11257: 					lpObj->PathCur = 0;
; 11258: 					lpObj->PathCount = 0;
; 11259: 					lpObj->PathStartEnd = 0;
; 11260: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);
; 11261: 
; 11262: 					PMSG_ACTIONRESULT pActionResult;
; 11263: 
; 11264: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));
; 11265: 					pActionResult.NumberH = SET_NUMBERH(aIndex);
; 11266: 					pActionResult.NumberL = SET_NUMBERL(aIndex);
; 11267: 					pActionResult.ActionNumber = 0x7A;
; 11268: 					pActionResult.Dir = lpObj->Dir;
; 11269: 					pActionResult.TargetNumberH = 0;
; 11270: 					pActionResult.TargetNumberL = 0;
; 11271: 
; 11272: 					DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));
; 11273: 					return;

  00500	0f 87 58 ff ff
	ff		 ja	 $LN82@PMoveProc
$LN74@PMoveProc:

; 11324: 					return;
; 11325: 				}
; 11326: 				break;
; 11327: 		}
; 11328: 	}
; 11329: 
; 11330: 	
; 11331: #if (__ENG__ == 1)
; 11332: 	PHeadSetB((LPBYTE)&pMove, 0xD4, sizeof(pMove));

  00506	6a 08		 push	 8
  00508	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _pMove$[ebp]
  0050e	68 d4 00 00 00	 push	 212			; 000000d4H
  00513	52		 push	 edx
  00514	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11333: #else
; 11334: 	// KOR PROTOCOL !!
; 11335: 	PHeadSetB((LPBYTE)&pMove, 0xD7, sizeof(pMove));
; 11336: #endif
; 11337: 	pMove.NumberH = SET_NUMBERH(aIndex);

  00519	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]

; 11338: 	pMove.NumberL = SET_NUMBERL(aIndex);
; 11339: 	pMove.X = ax;

  0051f	8a 95 ef fe ff
	ff		 mov	 dl, BYTE PTR _ax$[ebp]
  00525	8b c8		 mov	 ecx, eax
  00527	c1 e9 08	 shr	 ecx, 8
  0052a	88 85 e4 fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+4], al
  00530	88 8d e3 fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+3], cl
  00536	88 95 e5 fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+5], dl

; 11340: 	pMove.Y = ay;

  0053c	88 9d e6 fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+6], bl

; 11341: 	pMove.Path = lpObj->Dir << 4;

  00542	8a 86 22 01 00
	00		 mov	 al, BYTE PTR [esi+290]
  00548	c0 e0 04	 shl	 al, 4
  0054b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0054e	88 85 e7 fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+7], al

; 11342: 
; 11343: 	if ( lpObj->Type == OBJ_USER )

  00554	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00558	0f 85 91 00 00
	00		 jne	 $LN76@PMoveProc

; 11344: 	{
; 11345: 		if ( lpObj->m_IfState.use )

  0055e	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  00564	a8 03		 test	 al, 3
  00566	74 2c		 je	 SHORT $LN12@PMoveProc

; 11346: 		{
; 11347: 			if ( lpObj->m_IfState.type == 3 )

  00568	8b c8		 mov	 ecx, eax
  0056a	c1 e9 06	 shr	 ecx, 6
  0056d	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00573	83 f9 03	 cmp	 ecx, 3
  00576	75 0c		 jne	 SHORT $LN14@PMoveProc

; 11348: 			{
; 11349: 				lpObj->TargetShopNumber = -1;

  00578	83 c9 ff	 or	 ecx, -1
  0057b	66 89 8e 3a 06
	00 00		 mov	 WORD PTR [esi+1594], cx

; 11350: 				lpObj->m_IfState.type = 0;
; 11351: 				lpObj->m_IfState.use = 0;

  00582	eb 05		 jmp	 SHORT $LN81@PMoveProc
$LN14@PMoveProc:

; 11352: 			}
; 11353: 			else if( lpObj->m_IfState.type == 21 )

  00584	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00587	75 0b		 jne	 SHORT $LN12@PMoveProc
$LN81@PMoveProc:

; 11354: 			{
; 11355: 				lpObj->m_IfState.type = 0;
; 11356: 				lpObj->m_IfState.use = 0;

  00589	25 3c 00 ff ff	 and	 eax, -65476		; ffff003cH
  0058e	89 86 b8 11 00
	00		 mov	 DWORD PTR [esi+4536], eax
$LN12@PMoveProc:

; 11357: 			}
; 11358: 		}
; 11359: 
; 11360: 		if ( !gObjPositionCheck(lpObj))

  00594	56		 push	 esi
  00595	e8 00 00 00 00	 call	 ?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjPositionCheck
  0059a	83 c4 04	 add	 esp, 4
  0059d	85 c0		 test	 eax, eax
  0059f	75 30		 jne	 SHORT $LN75@PMoveProc

; 11361: 		{
; 11362: 			lpObj->PathCur = 0;
; 11363: 			lpObj->PathCount = 0;
; 11364: 			ax = lpObj->X;
; 11365: 			ay = lpObj->Y;

  005a1	8a 8e 21 01 00
	00		 mov	 cl, BYTE PTR [esi+289]
  005a7	89 86 5c 01 00
	00		 mov	 DWORD PTR [esi+348], eax
  005ad	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax
  005b3	8a 86 20 01 00
	00		 mov	 al, BYTE PTR [esi+288]

; 11366: 			lpObj->TX = (BYTE)ax;

  005b9	88 86 52 01 00
	00		 mov	 BYTE PTR [esi+338], al

; 11367: 			lpObj->TY = (BYTE)ay;

  005bf	88 8e 53 01 00
	00		 mov	 BYTE PTR [esi+339], cl

; 11368: 			pMove.X = ax;

  005c5	88 85 e5 fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+5], al

; 11369: 			pMove.Y = ay;

  005cb	88 8d e6 fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+6], cl
$LN75@PMoveProc:

; 11370: 		}
; 11371: 
; 11372: 		DataSend(aIndex, (LPBYTE)&pMove, pMove.h.size);

  005d1	0f b6 95 e1 fe
	ff ff		 movzx	 edx, BYTE PTR _pMove$[ebp+1]
  005d8	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  005de	52		 push	 edx
  005df	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _pMove$[ebp]
  005e5	50		 push	 eax
  005e6	51		 push	 ecx
  005e7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005ec	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN76@PMoveProc:

; 11373: 	}
; 11374: 
; 11375: 	int MVL = MAX_VIEWPORT;
; 11376: 
; 11377: 	if ( lpObj->Type == OBJ_MONSTER )
; 11378: 		MVL = MAX_VIEWPORT_MONSTER;
; 11379: 		
; 11380: 	for (n=0;n<MVL;n++)

  005ef	33 c0		 xor	 eax, eax
  005f1	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
  005f7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL77@PMoveProc:

; 11381: 	{
; 11382: 		if ( lpObj->VpPlayer2[n].state == TRUE )

  00600	8d 94 40 12 03
	00 00		 lea	 edx, DWORD PTR [eax+eax*2+786]
  00607	80 3c 96 01	 cmp	 BYTE PTR [esi+edx*4], 1
  0060b	8d 1c 96	 lea	 ebx, DWORD PTR [esi+edx*4]
  0060e	75 62		 jne	 SHORT $LN8@PMoveProc

; 11383: 		{
; 11384: 			int number = lpObj->VpPlayer2[n].number;

  00610	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00613	0f bf 8c 86 4a
	0c 00 00	 movsx	 ecx, WORD PTR [esi+eax*4+3146]
  0061b	8d 84 86 4a 0c
	00 00		 lea	 eax, DWORD PTR [esi+eax*4+3146]

; 11385: 			
; 11386: 			if ( number >= 0 )

  00622	85 c9		 test	 ecx, ecx
  00624	78 4c		 js	 SHORT $LN8@PMoveProc

; 11387: 			{
; 11388: 				if ( gObj[number].Connected > PLAYER_CONNECTED )

  00626	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0062c	8b d1		 mov	 edx, ecx
  0062e	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  00634	83 7c 3a 04 01	 cmp	 DWORD PTR [edx+edi+4], 1
  00639	7e 28		 jle	 SHORT $LN4@PMoveProc

; 11389: 				{
; 11390: 					if ( gObj[number].Live )

  0063b	80 7c 3a 51 00	 cmp	 BYTE PTR [edx+edi+81], 0
  00640	74 30		 je	 SHORT $LN8@PMoveProc

; 11391: 					{
; 11392: 						if ( gObj[number].Type == OBJ_USER )

  00642	80 7c 3a 50 01	 cmp	 BYTE PTR [edx+edi+80], 1
  00647	75 29		 jne	 SHORT $LN8@PMoveProc

; 11393: 						{
; 11394: 							DataSend(lpObj->VpPlayer2[n].number, (LPBYTE)&pMove, pMove.h.size);

  00649	0f b6 85 e1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  00650	50		 push	 eax
  00651	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _pMove$[ebp]
  00657	52		 push	 edx
  00658	51		 push	 ecx
  00659	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0065e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11395: 						}
; 11396: 					}
; 11397: 				}
; 11398: 				else

  00661	eb 0f		 jmp	 SHORT $LN8@PMoveProc
$LN4@PMoveProc:

; 11399: 				{
; 11400: 					lpObj->VpPlayer2[n].number= -1;

  00663	83 c9 ff	 or	 ecx, -1
  00666	66 89 08	 mov	 WORD PTR [eax], cx

; 11401: 					lpObj->VpPlayer2[n].state = 0;

  00669	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 11402: 					lpObj->VPCount2--;

  0066c	ff 8e d0 0f 00
	00		 dec	 DWORD PTR [esi+4048]
$LN8@PMoveProc:

; 11373: 	}
; 11374: 
; 11375: 	int MVL = MAX_VIEWPORT;
; 11376: 
; 11377: 	if ( lpObj->Type == OBJ_MONSTER )
; 11378: 		MVL = MAX_VIEWPORT_MONSTER;
; 11379: 		
; 11380: 	for (n=0;n<MVL;n++)

  00672	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00678	40		 inc	 eax
  00679	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
  0067f	98		 cwde
  00680	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00683	0f 8c 77 ff ff
	ff		 jl	 $LL77@PMoveProc

; 11403: 				}
; 11404: 			}
; 11405: 		}
; 11406: 	}
; 11407: 
; 11408: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  00689	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  00690	0f b6 96 51 01
	00 00		 movzx	 edx, BYTE PTR [esi+337]
  00697	69 c9 28 38 05
	00		 imul	 ecx, 342056		; 00053828H
  0069d	0f b6 86 50 01
	00 00		 movzx	 eax, BYTE PTR [esi+336]
  006a4	52		 push	 edx
  006a5	50		 push	 eax
  006a6	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  006ac	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 11409: 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  006b1	0f b6 8e 53 01
	00 00		 movzx	 ecx, BYTE PTR [esi+339]
  006b8	0f b6 96 52 01
	00 00		 movzx	 edx, BYTE PTR [esi+338]
  006bf	51		 push	 ecx
  006c0	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  006c7	69 c9 28 38 05
	00		 imul	 ecx, 342056		; 00053828H
  006cd	52		 push	 edx
  006ce	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  006d4	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 11410: 	lpObj->m_OldX = lpObj->TX;

  006d9	0f b6 86 52 01
	00 00		 movzx	 eax, BYTE PTR [esi+338]

; 11411: 	lpObj->m_OldY = lpObj->TY;

  006e0	8a 8e 53 01 00
	00		 mov	 cl, BYTE PTR [esi+339]

; 11412: 	lpObj->X = sx;

  006e6	8a 95 d8 fe ff
	ff		 mov	 dl, BYTE PTR _sx$[ebp]
  006ec	88 86 50 01 00
	00		 mov	 BYTE PTR [esi+336], al

; 11413: 	lpObj->Y = sy;

  006f2	0f b6 85 d4 fe
	ff ff		 movzx	 eax, BYTE PTR _sy$[ebp]
  006f9	88 8e 51 01 00
	00		 mov	 BYTE PTR [esi+337], cl
  006ff	88 96 20 01 00
	00		 mov	 BYTE PTR [esi+288], dl
  00705	88 86 21 01 00
	00		 mov	 BYTE PTR [esi+289], al

; 11414: 	lpObj->m_ViewState = 0;

  0070b	c6 86 d5 01 00
	00 00		 mov	 BYTE PTR [esi+469], 0
$LN78@PMoveProc:
  00712	5f		 pop	 edi
$LN43@PMoveProc:

; 11415: }

  00713	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00716	5e		 pop	 esi
  00717	33 cd		 xor	 ecx, ebp
  00719	5b		 pop	 ebx
  0071a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0071f	8b e5		 mov	 esp, ebp
  00721	5d		 pop	 ebp
  00722	c3		 ret	 0
?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ENDP			; PMoveProc
_TEXT	ENDS
PUBLIC	??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@ ; `string'
PUBLIC	?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
;	COMDAT ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@
CONST	SEGMENT
??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@ DB 'error : mo'
	DB	've protocol index error %s %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z
_TEXT	SEGMENT
_pMove$ = -8						; size = 7
_lpMove$ = 8						; size = 4
_n$ = 12						; size = 2
_aIndex$ = 12						; size = 4
?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z PROC ; RecvPositionSetProc, COMDAT

; 11422: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 11423: 	short n;
; 11424: 
; 11425: 	if (  OBJMAX_RANGE(aIndex) == FALSE)

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	85 db		 test	 ebx, ebx
  0000c	78 0f		 js	 SHORT $LN27@RecvPositi
  0000e	33 c0		 xor	 eax, eax
  00010	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 1d		 jne	 SHORT $LN16@RecvPositi
$LN27@RecvPositi:

; 11426: 	{
; 11427: 		LogAdd("error : move protocol index error %s %d", __FILE__, __LINE__);

  0001d	68 a3 2c 00 00	 push	 11427			; 00002ca3H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	5b		 pop	 ebx

; 11523: 
; 11524: }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN16@RecvPositi:
  0003a	56		 push	 esi

; 11428: 		return;
; 11429: 	}
; 11430: 
; 11431: 	LPOBJ lpObj = &gObj[aIndex];

  0003b	8b f3		 mov	 esi, ebx
  0003d	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00043	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11432: 
; 11433: 	if ( ::PacketCheckTime(lpObj) == FALSE )

  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0004f	83 c4 04	 add	 esp, 4
  00052	85 c0		 test	 eax, eax
  00054	0f 84 c6 01 00
	00		 je	 $LN31@RecvPositi

; 11434: 	{
; 11435: 		return;
; 11436: 	}
; 11437: 
; 11438: 	if ( lpObj->Teleport != 0 )

  0005a	80 be 88 05 00
	00 00		 cmp	 BYTE PTR [esi+1416], 0
  00061	0f 85 b9 01 00
	00		 jne	 $LN31@RecvPositi

; 11439: 	{
; 11440: 		return;
; 11441: 	}
; 11442: 
; 11443: 	lpObj->X = lpMove->X;

  00067	57		 push	 edi
  00068	8b 7d 08	 mov	 edi, DWORD PTR _lpMove$[ebp]
  0006b	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0006f	88 86 20 01 00
	00		 mov	 BYTE PTR [esi+288], al

; 11444: 	lpObj->Y = lpMove->Y;
; 11445: 
; 11446: 	if ( CC_MAP_RANGE(lpObj->MapNumber) != FALSE )

  00075	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  0007c	8a 4f 04	 mov	 cl, BYTE PTR [edi+4]
  0007f	88 8e 21 01 00
	00		 mov	 BYTE PTR [esi+289], cl
  00085	3c 35		 cmp	 al, 53			; 00000035H
  00087	74 0d		 je	 SHORT $LN28@RecvPositi
  00089	3c 12		 cmp	 al, 18			; 00000012H
  0008b	72 20		 jb	 SHORT $LN12@RecvPositi
  0008d	b2 17		 mov	 dl, 23			; 00000017H
  0008f	3a d0		 cmp	 dl, al
  00091	1b c0		 sbb	 eax, eax
  00093	40		 inc	 eax
  00094	74 17		 je	 SHORT $LN12@RecvPositi
$LN28@RecvPositi:

; 11447: 	{
; 11448: 		if ( (GetTickCount() - lpObj->m_iChaosCastleBlowTime ) < 1000 )

  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0009c	2b 86 40 12 00
	00		 sub	 eax, DWORD PTR [esi+4672]
  000a2	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  000a7	0f 82 72 01 00
	00		 jb	 $LN32@RecvPositi
$LN12@RecvPositi:

; 11449: 		{
; 11450: 			return;
; 11451: 		}
; 11452: 	}
; 11453: 
; 11454: 	if ( gObjCheckXYMapTile(lpObj, 2) == TRUE)

  000ad	6a 02		 push	 2
  000af	56		 push	 esi
  000b0	e8 00 00 00 00	 call	 ?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCheckXYMapTile
  000b5	83 c4 08	 add	 esp, 8
  000b8	83 f8 01	 cmp	 eax, 1
  000bb	0f 84 5e 01 00
	00		 je	 $LN32@RecvPositi

; 11455: 	{
; 11456: 		return;
; 11457: 	}
; 11458: 
; 11459: 	PMSG_RECV_POSISTION_SET pMove;
; 11460: #if (__ENG__ == 1)
; 11461: 	PHeadSetB((LPBYTE)&pMove, 0x15, sizeof(pMove));

  000c1	6a 07		 push	 7
  000c3	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  000c6	6a 15		 push	 21			; 00000015H
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11462: #else
; 11463: 	// KOR PROTOCOL
; 11464: 	PHeadSetB((LPBYTE)&pMove, 0x10, sizeof(pMove));
; 11465: #endif
; 11466: 	pMove.NumberH = SET_NUMBERH(aIndex);
; 11467: 	pMove.NumberL = SET_NUMBERL(aIndex);
; 11468: 	pMove.X = lpMove->X;

  000ce	8a 47 03	 mov	 al, BYTE PTR [edi+3]

; 11469: 	pMove.Y = lpMove->Y;

  000d1	8a 57 04	 mov	 dl, BYTE PTR [edi+4]
  000d4	8b cb		 mov	 ecx, ebx
  000d6	c1 e9 08	 shr	 ecx, 8
  000d9	88 45 fd	 mov	 BYTE PTR _pMove$[ebp+5], al
  000dc	88 4d fb	 mov	 BYTE PTR _pMove$[ebp+3], cl
  000df	88 5d fc	 mov	 BYTE PTR _pMove$[ebp+4], bl
  000e2	88 55 fe	 mov	 BYTE PTR _pMove$[ebp+6], dl

; 11470: 	lpObj->TX = lpMove->X;

  000e5	88 86 52 01 00
	00		 mov	 BYTE PTR [esi+338], al

; 11471: 	lpObj->TY = lpMove->Y;

  000eb	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]

; 11472: 
; 11473: 	if ( ::gObjPositionCheck(lpObj) == FALSE )

  000ef	56		 push	 esi
  000f0	88 86 53 01 00
	00		 mov	 BYTE PTR [esi+339], al
  000f6	e8 00 00 00 00	 call	 ?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjPositionCheck
  000fb	83 c4 10	 add	 esp, 16			; 00000010H
  000fe	85 c0		 test	 eax, eax
  00100	0f 84 19 01 00
	00		 je	 $LN32@RecvPositi

; 11474: 	{
; 11475: 		return;
; 11476: 	}
; 11477: 
; 11478: 	CreateFrustrum(lpObj->X, lpObj->Y, aIndex);

  00106	0f b6 8e 21 01
	00 00		 movzx	 ecx, BYTE PTR [esi+289]
  0010d	0f b6 96 20 01
	00 00		 movzx	 edx, BYTE PTR [esi+288]
  00114	53		 push	 ebx
  00115	51		 push	 ecx
  00116	52		 push	 edx
  00117	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11479: 
; 11480: 	if ( lpObj->Type == OBJ_USER )

  0011f	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00123	75 12		 jne	 SHORT $LN9@RecvPositi

; 11481: 	{
; 11482: 		DataSend(aIndex, (UCHAR *)&pMove, pMove.h.size);

  00125	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  00129	50		 push	 eax
  0012a	8d 4d f8	 lea	 ecx, DWORD PTR _pMove$[ebp]
  0012d	51		 push	 ecx
  0012e	53		 push	 ebx
  0012f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00134	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@RecvPositi:

; 11483: 	}
; 11484: 
; 11485: 	int MVL = MAX_VIEWPORT;
; 11486: 
; 11487: 	if ( lpObj->Type == OBJ_MONSTER )
; 11488: 	{
; 11489: #if (GS_CASTLE == 1)
; 11490: 		MVL = MAX_VIEWPORT;
; 11491: #else
; 11492: 		MVL = MAX_VIEWPORT_MONSTER;
; 11493: #endif
; 11494: 	}
; 11495: 
; 11496: 	for ( n=0;n<MVL;n++)

  00137	33 c0		 xor	 eax, eax
  00139	89 45 0c	 mov	 DWORD PTR _n$[ebp], eax
  0013c	8d 64 24 00	 npad	 4
$LL7@RecvPositi:

; 11497: 	{
; 11498: 		if ( lpObj->VpPlayer2[n].type == OBJ_USER )

  00140	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00143	80 bc 96 4c 0c
	00 00 01	 cmp	 BYTE PTR [esi+edx*4+3148], 1
  0014b	8d 0c 96	 lea	 ecx, DWORD PTR [esi+edx*4]
  0014e	75 5a		 jne	 SHORT $LN6@RecvPositi

; 11499: 		{
; 11500: 			if ( lpObj->VpPlayer2[n].state == 1 )

  00150	8d 84 40 12 03
	00 00		 lea	 eax, DWORD PTR [eax+eax*2+786]
  00157	80 3c 86 01	 cmp	 BYTE PTR [esi+eax*4], 1
  0015b	8d 3c 86	 lea	 edi, DWORD PTR [esi+eax*4]
  0015e	75 4a		 jne	 SHORT $LN6@RecvPositi

; 11501: 			{
; 11502: 				int Index = lpObj->VpPlayer2[n].number;

  00160	0f bf 91 4a 0c
	00 00		 movsx	 edx, WORD PTR [ecx+3146]

; 11503: 
; 11504: 				if ( gObj[Index].Connected > PLAYER_CONNECTED && gObj[Index].Live != FALSE)

  00167	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016d	8b c2		 mov	 eax, edx
  0016f	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00175	83 7c 18 04 01	 cmp	 DWORD PTR [eax+ebx+4], 1
  0017a	7e 1b		 jle	 SHORT $LN29@RecvPositi
  0017c	80 7c 18 51 00	 cmp	 BYTE PTR [eax+ebx+81], 0
  00181	74 14		 je	 SHORT $LN29@RecvPositi

; 11505: 				{
; 11506: 					DataSend(lpObj->VpPlayer2[n].number, (UCHAR *)&pMove, pMove.h.size);

  00183	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMove$[ebp+1]
  00187	51		 push	 ecx
  00188	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  0018b	50		 push	 eax
  0018c	52		 push	 edx
  0018d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00192	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11507: 				}
; 11508: 				else

  00195	eb 13		 jmp	 SHORT $LN6@RecvPositi
$LN29@RecvPositi:

; 11509: 				{
; 11510: 					lpObj->VpPlayer2[n].number = -1;

  00197	83 ca ff	 or	 edx, -1
  0019a	66 89 91 4a 0c
	00 00		 mov	 WORD PTR [ecx+3146], dx

; 11511: 					lpObj->VpPlayer2[n].state = FALSE;

  001a1	c6 07 00	 mov	 BYTE PTR [edi], 0

; 11512: 					lpObj->VPCount2--;

  001a4	ff 8e d0 0f 00
	00		 dec	 DWORD PTR [esi+4048]
$LN6@RecvPositi:

; 11483: 	}
; 11484: 
; 11485: 	int MVL = MAX_VIEWPORT;
; 11486: 
; 11487: 	if ( lpObj->Type == OBJ_MONSTER )
; 11488: 	{
; 11489: #if (GS_CASTLE == 1)
; 11490: 		MVL = MAX_VIEWPORT;
; 11491: #else
; 11492: 		MVL = MAX_VIEWPORT_MONSTER;
; 11493: #endif
; 11494: 	}
; 11495: 
; 11496: 	for ( n=0;n<MVL;n++)

  001aa	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  001ad	40		 inc	 eax
  001ae	89 45 0c	 mov	 DWORD PTR _n$[ebp], eax
  001b1	98		 cwde
  001b2	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  001b5	7c 89		 jl	 SHORT $LL7@RecvPositi

; 11513: 				}
; 11514: 			}
; 11515: 		}
; 11516: 	}
; 11517: 
; 11518: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  001b7	0f b6 86 51 01
	00 00		 movzx	 eax, BYTE PTR [esi+337]
  001be	0f b6 8e 50 01
	00 00		 movzx	 ecx, BYTE PTR [esi+336]
  001c5	50		 push	 eax
  001c6	51		 push	 ecx
  001c7	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  001ce	69 c9 28 38 05
	00		 imul	 ecx, 342056		; 00053828H
  001d4	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001da	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 11519: 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  001df	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  001e6	0f b6 96 53 01
	00 00		 movzx	 edx, BYTE PTR [esi+339]
  001ed	69 c9 28 38 05
	00		 imul	 ecx, 342056		; 00053828H
  001f3	0f b6 86 52 01
	00 00		 movzx	 eax, BYTE PTR [esi+338]
  001fa	52		 push	 edx
  001fb	50		 push	 eax
  001fc	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00202	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 11520: 
; 11521: 	lpObj->m_OldX = lpObj->TX;

  00207	8a 8e 52 01 00
	00		 mov	 cl, BYTE PTR [esi+338]

; 11522: 	lpObj->m_OldY = lpObj->TY;

  0020d	8a 96 53 01 00
	00		 mov	 dl, BYTE PTR [esi+339]
  00213	88 8e 50 01 00
	00		 mov	 BYTE PTR [esi+336], cl
  00219	88 96 51 01 00
	00		 mov	 BYTE PTR [esi+337], dl
$LN32@RecvPositi:
  0021f	5f		 pop	 edi
$LN31@RecvPositi:
  00220	5e		 pop	 esi
  00221	5b		 pop	 ebx

; 11523: 
; 11524: }

  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	c3		 ret	 0
?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ENDP ; RecvPositionSetProc
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCDamageSend@@YAXHHHHHH@Z			; GCDamageSend
; Function compile flags: /Ogtp
;	COMDAT ?GCDamageSend@@YAXHHHHHH@Z
_TEXT	SEGMENT
_pResult$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
_MSBDamage$ = 24					; size = 4
_iShieldDamage$ = 28					; size = 4
?GCDamageSend@@YAXHHHHHH@Z PROC				; GCDamageSend, COMDAT

; 11610: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _TargetIndex$[ebp]
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 11611: 	PMSG_ATTACKRESULT pResult;
; 11612: 
; 11613: #if (__ENG__ == 1)
; 11614: 	PHeadSetB((LPBYTE)&pResult, 0x11, sizeof(pResult));

  00018	6a 14		 push	 20			; 00000014H
  0001a	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0001d	6a 11		 push	 17			; 00000011H
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11615: #else
; 11616: 	// KOR PROTOCOL
; 11617: 	PHeadSetB((LPBYTE)&pResult, 0xDF, sizeof(pResult));
; 11618: #endif
; 11619: 	pResult.NumberH = SET_NUMBERH(TargetIndex);
; 11620: 	pResult.NumberL = SET_NUMBERL(TargetIndex);
; 11621: 
; 11622: #if (FIX_HP == 1)
; 11623: 	pResult.Damage = AttackDamage;

  00025	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00028	8b cb		 mov	 ecx, ebx
  0002a	c1 e9 08	 shr	 ecx, 8
  0002d	88 4d eb	 mov	 BYTE PTR _pResult$[ebp+3], cl

; 11624: 	pResult.ShieldDamage = iShieldDamage;

  00030	8b 4d 1c	 mov	 ecx, DWORD PTR _iShieldDamage$[ebp]

; 11625: #endif
; 11626: 
; 11627: 	pResult.DamageH = SET_NUMBERH(AttackDamage);

  00033	8b d0		 mov	 edx, eax
  00035	89 45 f4	 mov	 DWORD PTR _pResult$[ebp+12], eax

; 11628: 	pResult.DamageL = SET_NUMBERL(AttackDamage);

  00038	88 45 ee	 mov	 BYTE PTR _pResult$[ebp+6], al

; 11629: 	pResult.btShieldDamageH = SET_NUMBERH(iShieldDamage);

  0003b	8b c1		 mov	 eax, ecx
  0003d	c1 ea 08	 shr	 edx, 8
  00040	c1 e8 08	 shr	 eax, 8
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11630: 	pResult.btShieldDamageL = SET_NUMBERL(iShieldDamage);
; 11631: 
; 11632: 	if ( MSBFlag != FALSE )

  00046	83 7d 14 00	 cmp	 DWORD PTR _MSBFlag$[ebp], 0
  0004a	88 5d ec	 mov	 BYTE PTR _pResult$[ebp+4], bl
  0004d	89 4d f8	 mov	 DWORD PTR _pResult$[ebp+16], ecx
  00050	88 55 ed	 mov	 BYTE PTR _pResult$[ebp+5], dl
  00053	88 45 f1	 mov	 BYTE PTR _pResult$[ebp+9], al
  00056	88 4d f2	 mov	 BYTE PTR _pResult$[ebp+10], cl
  00059	74 04		 je	 SHORT $LN3@GCDamageSe

; 11633: 	{
; 11634: 		pResult.NumberH &= 0x7F;
; 11635: 		pResult.NumberH |= 0x80;

  0005b	80 4d eb 80	 or	 BYTE PTR _pResult$[ebp+3], 128 ; 00000080H
$LN3@GCDamageSe:

; 11636: 	}
; 11637: 
; 11638: 	pResult.DamageType = (MSBDamage/0x100)&1;

  0005f	8b 4d 18	 mov	 ecx, DWORD PTR _MSBDamage$[ebp]
  00062	8b c1		 mov	 eax, ecx

; 11639: 	pResult.DamageType2 = MSBDamage;

  00064	88 4d f0	 mov	 BYTE PTR _pResult$[ebp+8], cl
  00067	99		 cdq

; 11640: 
; 11641: 
; 11642: 
; 11643: 	if ( gObj[TargetIndex].Type == OBJ_USER )

  00068	8b cb		 mov	 ecx, ebx
  0006a	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00070	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00076	03 c2		 add	 eax, edx
  00078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007e	c1 f8 08	 sar	 eax, 8
  00081	24 01		 and	 al, 1
  00083	88 45 ef	 mov	 BYTE PTR _pResult$[ebp+7], al
  00086	80 7c 11 50 01	 cmp	 BYTE PTR [ecx+edx+80], 1
  0008b	75 12		 jne	 SHORT $LN2@GCDamageSe

; 11644: 	{
; 11645: 		DataSend(TargetIndex, (LPBYTE)&pResult, pResult.h.size);

  0008d	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00091	50		 push	 eax
  00092	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00095	51		 push	 ecx
  00096	53		 push	 ebx
  00097	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCDamageSe:

; 11646: 	}
; 11647: 
; 11648: //	if ( cManager.WatchTargetIndex == TargetIndex || cManager.WatchTargetIndex == aIndex )
; 11649: //	{
; 11650: //		cManager.DataSend((LPBYTE)&pResult, pResult.h.size);
; 11651: //	}
; 11652: 
; 11653: 	if ( gObj[aIndex].Type == OBJ_USER )

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a4	8b d6		 mov	 edx, esi
  000a6	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  000ac	80 7c 02 50 01	 cmp	 BYTE PTR [edx+eax+80], 1
  000b1	75 12		 jne	 SHORT $LN1@GCDamageSe

; 11654: 	{
; 11655: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000b3	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  000b7	51		 push	 ecx
  000b8	8d 55 e8	 lea	 edx, DWORD PTR _pResult$[ebp]
  000bb	52		 push	 edx
  000bc	56		 push	 esi
  000bd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCDamageSe:

; 11656: 	}
; 11657: }

  000c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c8	5e		 pop	 esi
  000c9	33 cd		 xor	 ecx, ebp
  000cb	5b		 pop	 ebx
  000cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
?GCDamageSend@@YAXHHHHHH@Z ENDP				; GCDamageSend
_TEXT	ENDS
PUBLIC	?GCDamageSend@@YAXHHH@Z				; GCDamageSend
; Function compile flags: /Ogtp
;	COMDAT ?GCDamageSend@@YAXHHH@Z
_TEXT	SEGMENT
_pDamage$ = -8						; size = 8
_aIndex$ = 8						; size = 4
_damage$ = 12						; size = 4
_iShieldDamage$ = 16					; size = 4
?GCDamageSend@@YAXHHH@Z PROC				; GCDamageSend, COMDAT

; 11673: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11674: 	if ( gObj[aIndex].Type != OBJ_USER )

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	83 ec 08	 sub	 esp, 8
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00010	8b c6		 mov	 eax, esi
  00012	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00018	80 7c 08 50 01	 cmp	 BYTE PTR [eax+ecx+80], 1
  0001d	75 40		 jne	 SHORT $LN2@GCDamageSe@2

; 11675: 	{
; 11676: 		return;
; 11677: 	}
; 11678: 
; 11679: 
; 11680: 	PMSG_DAMAGE pDamage;
; 11681: 
; 11682: 	PHeadSubSetB((LPBYTE)&pDamage, 0xF3, 0x07, sizeof(pDamage));

  0001f	6a 08		 push	 8
  00021	6a 07		 push	 7
  00023	8d 55 f8	 lea	 edx, DWORD PTR _pDamage$[ebp]
  00026	68 f3 00 00 00	 push	 243			; 000000f3H
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 11683: 	pDamage.DamageH = SET_NUMBERH(damage);

  00031	8b 45 0c	 mov	 eax, DWORD PTR _damage$[ebp]
  00034	8b c8		 mov	 ecx, eax

; 11684: 	pDamage.DamageL = SET_NUMBERL(damage);

  00036	88 45 fd	 mov	 BYTE PTR _pDamage$[ebp+5], al

; 11685: 	pDamage.btShieldDamageH = SET_NUMBERH(iShieldDamage);

  00039	8b 45 10	 mov	 eax, DWORD PTR _iShieldDamage$[ebp]
  0003c	8b d0		 mov	 edx, eax

; 11686: 	pDamage.btShieldDamageL = SET_NUMBERL(iShieldDamage);

  0003e	88 45 ff	 mov	 BYTE PTR _pDamage$[ebp+7], al

; 11687: 
; 11688: 	DataSend(aIndex, (LPBYTE)&pDamage, pDamage.h.size);

  00041	0f b6 45 f9	 movzx	 eax, BYTE PTR _pDamage$[ebp+1]
  00045	c1 e9 08	 shr	 ecx, 8
  00048	88 4d fc	 mov	 BYTE PTR _pDamage$[ebp+4], cl
  0004b	50		 push	 eax
  0004c	8d 4d f8	 lea	 ecx, DWORD PTR _pDamage$[ebp]
  0004f	51		 push	 ecx
  00050	c1 ea 08	 shr	 edx, 8
  00053	56		 push	 esi
  00054	88 55 fe	 mov	 BYTE PTR _pDamage$[ebp+6], dl
  00057	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005c	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@GCDamageSe@2:
  0005f	5e		 pop	 esi

; 11689: }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?GCDamageSend@@YAXHHH@Z ENDP				; GCDamageSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z		; GCLifeSendAll
; Function compile flags: /Ogtp
;	COMDAT ?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z PROC		; GCLifeSendAll, COMDAT

; 11735: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 11736: 	PMSG_LIFEINFO_SEND pMsg;
; 11737: 	PHeadSubSetB((LPBYTE)&pMsg,0xEC,0x10,sizeof(pMsg));

  00015	6a 0e		 push	 14			; 0000000eH
  00017	6a 10		 push	 16			; 00000010H
  00019	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	68 ec 00 00 00	 push	 236			; 000000ecH
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 11738: 
; 11739: 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);
; 11740: 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 11741: 
; 11742: 	int MaxLife = (int)(lpObj->MaxLife + lpObj->AddLife);

  00027	db 86 24 01 00
	00		 fild	 DWORD PTR [esi+292]
  0002d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002f	8a 16		 mov	 dl, BYTE PTR [esi]
  00031	d8 86 dc 00 00
	00		 fadd	 DWORD PTR [esi+220]
  00037	c1 e9 08	 shr	 ecx, 8
  0003a	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0003d	88 55 f1	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  00040	e8 00 00 00 00	 call	 __ftol2_sse

; 11743: 	int Life = (int)lpObj->Life;

  00045	d9 86 d8 00 00
	00		 fld	 DWORD PTR [esi+216]
  0004b	8b d8		 mov	 ebx, eax
  0004d	e8 00 00 00 00	 call	 __ftol2_sse

; 11744: 
; 11745: 	pMsg.MAXHP_HIGHH = (MaxLife>>16)>>8;

  00052	8b cb		 mov	 ecx, ebx
  00054	c1 f9 18	 sar	 ecx, 24			; 00000018H
  00057	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+6], cl

; 11746: 	pMsg.MAXHP_HIGHL = (MaxLife>>16)&0xFF;

  0005a	8b d3		 mov	 edx, ebx
  0005c	c1 fa 10	 sar	 edx, 16			; 00000010H
  0005f	88 55 f4	 mov	 BYTE PTR _pMsg$[ebp+8], dl

; 11747: 	pMsg.MAXHP_LOWH = (MaxLife&0xFFFF)>>8;
; 11748: 	pMsg.MAXHP_LOWL = (MaxLife&0xFFFF)&0xFF;
; 11749: 
; 11750: 	pMsg.HP_HIGHH = (Life>>16)>>8;

  00062	8b d0		 mov	 edx, eax
  00064	c1 fa 18	 sar	 edx, 24			; 00000018H
  00067	8b cb		 mov	 ecx, ebx
  00069	c1 f9 08	 sar	 ecx, 8
  0006c	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+7], cl
  0006f	88 55 f6	 mov	 BYTE PTR _pMsg$[ebp+10], dl

; 11751: 	pMsg.HP_HIGHL = (Life>>16)&0xFF;

  00072	8b c8		 mov	 ecx, eax

; 11752: 	pMsg.HP_LOWH = (Life&0xFFFF)>>8;

  00074	8b d0		 mov	 edx, eax

; 11753: 	pMsg.HP_LOWL = (Life&0xFFFF)&0xFF;

  00076	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+13], al

; 11754: 
; 11755: 	MsgSendV2(lpObj,(LPBYTE)&pMsg,pMsg.h.size);

  00079	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0007d	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00080	88 4d f8	 mov	 BYTE PTR _pMsg$[ebp+12], cl
  00083	50		 push	 eax
  00084	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00087	51		 push	 ecx
  00088	c1 fa 08	 sar	 edx, 8
  0008b	56		 push	 esi
  0008c	88 5d f5	 mov	 BYTE PTR _pMsg$[ebp+9], bl
  0008f	88 55 f7	 mov	 BYTE PTR _pMsg$[ebp+11], dl
  00092	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 11756: }

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0009d	5e		 pop	 esi
  0009e	33 cd		 xor	 ecx, ebp
  000a0	5b		 pop	 ebx
  000a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; GCLifeSendAll
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCKillPlayerExpSend@@YAXHHHHH@Z		; GCKillPlayerExpSend
EXTRN	?AddExperience@CBloodCastle@@QAE_NHH@Z:PROC	; CBloodCastle::AddExperience
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
; Function compile flags: /Ogtp
;	COMDAT ?GCKillPlayerExpSend@@YAXHHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_exp$ = 16						; size = 4
_AttackDamage$ = 20					; size = 4
_MSBFlag$ = 24						; size = 4
?GCKillPlayerExpSend@@YAXHHHHH@Z PROC			; GCKillPlayerExpSend, COMDAT

; 11774: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 11775: 	/*PMSG_KILLPLAYER pkillMsg;
; 11776: 
; 11777: 	PHeadSetBE((LPBYTE)&pkillMsg, 0x16, sizeof(pkillMsg));
; 11778: 	pkillMsg.NumberH = SET_NUMBERH(TargetIndex);
; 11779: 	pkillMsg.NumberL = SET_NUMBERL(TargetIndex);
; 11780: 	pkillMsg.ExpH = SET_NUMBERH(exp);
; 11781: 	pkillMsg.ExpL = SET_NUMBERL(exp);
; 11782: 	pkillMsg.DamageH = SET_NUMBERH(AttackDamage);
; 11783: 	pkillMsg.DamageL = SET_NUMBERL(AttackDamage);
; 11784: 
; 11785: 	if ( MSBFlag != FALSE )
; 11786: 	{
; 11787: 		pkillMsg.NumberH &= 0x7F;
; 11788: 		pkillMsg.NumberH |= 0x80;
; 11789: 	}
; 11790: 
; 11791: 	if (  BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )
; 11792: 	{
; 11793: 		g_BloodCastle.AddExperience(aIndex, exp);
; 11794: 	}
; 11795: 
; 11796: 	DataSend(aIndex, (UCHAR*)&pkillMsg, pkillMsg.h.size);*/
; 11797: 
; 11798: 	PMSG_KILLPLAYER_EXT pMsg;
; 11799: 	PHeadSetBE((LPBYTE)&pMsg,0x9C,sizeof(pMsg));

  00014	6a 0c		 push	 12			; 0000000cH
  00016	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	68 9c 00 00 00	 push	 156			; 0000009cH
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 11800: 
; 11801: 	pMsg.NumberH = SET_NUMBERH(TargetIndex);

  00024	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00027	8b c8		 mov	 ecx, eax
  00029	c1 e9 08	 shr	 ecx, 8
  0002c	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 11802: 	pMsg.NumberL = SET_NUMBERL(TargetIndex);
; 11803: 	pMsg.ExpH = (DWORD)exp >> 16;

  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _exp$[ebp]
  00032	8b d1		 mov	 edx, ecx
  00034	c1 ea 10	 shr	 edx, 16			; 00000010H
  00037	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 11804: 	pMsg.ExpL = (DWORD)exp & 0xFFFF;
; 11805: 
; 11806: #if (CUSTOM_DAMAGE==1)
; 11807: 	pMsg.DamageHW = SET_NUMBERHW(AttackDamage);
; 11808: 	pMsg.DamageLW = SET_NUMBERLW(AttackDamage);
; 11809: #else
; 11810: 	pMsg.DamageH = SET_NUMBERH(AttackDamage);

  0003a	8b 45 14	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  0003d	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+6], dx
  00041	8b d0		 mov	 edx, eax
  00043	c1 ea 08	 shr	 edx, 8
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11811: 	pMsg.DamageL = SET_NUMBERL(AttackDamage);
; 11812: #endif
; 11813: 
; 11814: 	if ( MSBFlag != FALSE )

  00049	83 7d 18 00	 cmp	 DWORD PTR _MSBFlag$[ebp], 0
  0004d	66 89 4d f8	 mov	 WORD PTR _pMsg$[ebp+8], cx
  00051	88 55 fa	 mov	 BYTE PTR _pMsg$[ebp+10], dl
  00054	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+11], al
  00057	74 04		 je	 SHORT $LN2@GCKillPlay

; 11815: 	{
; 11816: 		pMsg.NumberH &= 0x7F;
; 11817: 		pMsg.NumberH |= 0x80;

  00059	80 4d f3 80	 or	 BYTE PTR _pMsg$[ebp+3], 128 ; 00000080H
$LN2@GCKillPlay:

; 11818: 	}
; 11819: 
; 11820: 	if (  BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00063	8b c6		 mov	 eax, esi
  00065	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0006b	0f b6 84 10 23
	01 00 00	 movzx	 eax, BYTE PTR [eax+edx+291]
  00073	3c 34		 cmp	 al, 52			; 00000034H
  00075	74 0d		 je	 SHORT $LN9@GCKillPlay
  00077	3c 0b		 cmp	 al, 11			; 0000000bH
  00079	72 15		 jb	 SHORT $LN1@GCKillPlay
  0007b	b2 11		 mov	 dl, 17			; 00000011H
  0007d	3a d0		 cmp	 dl, al
  0007f	1b c0		 sbb	 eax, eax
  00081	40		 inc	 eax
  00082	74 0c		 je	 SHORT $LN1@GCKillPlay
$LN9@GCKillPlay:

; 11821: 	{
; 11822: 		g_BloodCastle.AddExperience(aIndex, exp);

  00084	51		 push	 ecx
  00085	56		 push	 esi
  00086	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0008b	e8 00 00 00 00	 call	 ?AddExperience@CBloodCastle@@QAE_NHH@Z ; CBloodCastle::AddExperience
$LN1@GCKillPlay:

; 11823: 	}
; 11824: 
; 11825: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00090	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00094	50		 push	 eax
  00095	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00098	51		 push	 ecx
  00099	56		 push	 esi
  0009a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11826: 
; 11827: }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a5	33 cd		 xor	 ecx, ebp
  000a7	5e		 pop	 esi
  000a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
?GCKillPlayerExpSend@@YAXHHHHH@Z ENDP			; GCKillPlayerExpSend
_TEXT	ENDS
PUBLIC	?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HGH@Z	; GCDiePlayerSend
; Function compile flags: /Ogtp
;	COMDAT ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HGH@Z
_TEXT	SEGMENT
_pDieMsg$ = -8						; size = 8
_lpObj$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_skill$ = 16						; size = 2
_KillerIndex$ = 20					; size = 4
?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HGH@Z PROC	; GCDiePlayerSend, COMDAT

; 11845: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 11846: 	PMSG_DIEPLAYER pDieMsg;
; 11847: 
; 11848: 	PHeadSetB((LPBYTE)&pDieMsg, 0x17, sizeof(pDieMsg));

  00008	6a 08		 push	 8
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pDieMsg$[ebp]
  0000d	6a 17		 push	 23			; 00000017H
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11849: 	pDieMsg.NumberH = SET_NUMBERH(TargetIndex);

  00015	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]

; 11850: 	pDieMsg.NumberL = SET_NUMBERL(TargetIndex);
; 11851: 	pDieMsg.Skill = (BYTE)skill;
; 11852: 	pDieMsg.KillerNumberH = SET_NUMBERH(KillerIndex);
; 11853: 	pDieMsg.KillerNumberL = SET_NUMBERL(KillerIndex);
; 11854: 	int iSize = pDieMsg.h.size;

  00018	0f b6 75 f9	 movzx	 esi, BYTE PTR _pDieMsg$[ebp+1]
  0001c	8a 55 10	 mov	 dl, BYTE PTR _skill$[ebp]

; 11855: 
; 11856: 	MsgSendV2(lpObj, (LPBYTE)&pDieMsg, iSize);

  0001f	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00022	8b c8		 mov	 ecx, eax
  00024	c1 e9 08	 shr	 ecx, 8
  00027	88 45 fc	 mov	 BYTE PTR _pDieMsg$[ebp+4], al
  0002a	8b 45 14	 mov	 eax, DWORD PTR _KillerIndex$[ebp]
  0002d	88 4d fb	 mov	 BYTE PTR _pDieMsg$[ebp+3], cl
  00030	88 55 fd	 mov	 BYTE PTR _pDieMsg$[ebp+5], dl
  00033	56		 push	 esi
  00034	8d 55 f8	 lea	 edx, DWORD PTR _pDieMsg$[ebp]
  00037	8b c8		 mov	 ecx, eax
  00039	52		 push	 edx
  0003a	c1 e9 08	 shr	 ecx, 8
  0003d	57		 push	 edi
  0003e	88 4d fe	 mov	 BYTE PTR _pDieMsg$[ebp+6], cl
  00041	88 45 ff	 mov	 BYTE PTR _pDieMsg$[ebp+7], al
  00044	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00049	83 c4 18	 add	 esp, 24			; 00000018H

; 11857: 
; 11858: 	if ( lpObj->Type == OBJ_USER )

  0004c	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  00050	75 10		 jne	 SHORT $LN1@GCDiePlaye

; 11859: 	{
; 11860: 		DataSend(lpObj->m_Index, (LPBYTE)&pDieMsg, iSize);

  00052	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00054	56		 push	 esi
  00055	8d 45 f8	 lea	 eax, DWORD PTR _pDieMsg$[ebp]
  00058	50		 push	 eax
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCDiePlaye:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 11861: 	}
; 11862: }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HGH@Z ENDP	; GCDiePlayerSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z	; GCActionSend
; Function compile flags: /Ogtp
;	COMDAT ?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z
_TEXT	SEGMENT
_pActionResult$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_ActionNumber$ = 12					; size = 1
_aIndex$ = 16						; size = 4
_aTargetIndex$ = 20					; size = 4
?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z PROC		; GCActionSend, COMDAT

; 11868: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 11869: 	PMSG_ACTIONRESULT pActionResult;
; 11870: 
; 11871: 	PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));

  00014	6a 09		 push	 9
  00016	8d 45 f0	 lea	 eax, DWORD PTR _pActionResult$[ebp]
  00019	6a 18		 push	 24			; 00000018H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11872: 	pActionResult.NumberH = SET_NUMBERH(aIndex);

  00021	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 11873: 	pActionResult.NumberL = SET_NUMBERL(aIndex);
; 11874: 	pActionResult.ActionNumber = ActionNumber;

  00024	8a 55 0c	 mov	 dl, BYTE PTR _ActionNumber$[ebp]
  00027	8b c8		 mov	 ecx, eax
  00029	88 45 f4	 mov	 BYTE PTR _pActionResult$[ebp+4], al

; 11875: 	pActionResult.Dir = lpObj->Dir;

  0002c	8a 86 22 01 00
	00		 mov	 al, BYTE PTR [esi+290]
  00032	c1 e9 08	 shr	 ecx, 8
  00035	88 55 f6	 mov	 BYTE PTR _pActionResult$[ebp+6], dl

; 11876: 	pActionResult.TargetNumberH = SET_NUMBERH(aTargetIndex);
; 11877: 	pActionResult.TargetNumberL = SET_NUMBERL(aTargetIndex);
; 11878: 
; 11879: 	MsgSendV2(lpObj, (LPBYTE)&pActionResult, pActionResult.h.size);

  00038	0f b6 55 f1	 movzx	 edx, BYTE PTR _pActionResult$[ebp+1]
  0003c	88 45 f5	 mov	 BYTE PTR _pActionResult$[ebp+5], al
  0003f	8b 45 14	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00042	88 4d f3	 mov	 BYTE PTR _pActionResult$[ebp+3], cl
  00045	8b c8		 mov	 ecx, eax
  00047	88 45 f8	 mov	 BYTE PTR _pActionResult$[ebp+8], al
  0004a	52		 push	 edx
  0004b	8d 45 f0	 lea	 eax, DWORD PTR _pActionResult$[ebp]
  0004e	50		 push	 eax
  0004f	c1 e9 08	 shr	 ecx, 8
  00052	56		 push	 esi
  00053	88 4d f7	 mov	 BYTE PTR _pActionResult$[ebp+7], cl
  00056	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 11880: }

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005e	83 c4 18	 add	 esp, 24			; 00000018H
  00061	33 cd		 xor	 ecx, ebp
  00063	5e		 pop	 esi
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z ENDP		; GCActionSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z		; CGActionRecv
; Function compile flags: /Ogtp
;	COMDAT ?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z
_TEXT	SEGMENT
_pResult$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z PROC		; CGActionRecv, COMDAT

; 11886: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 11887: 	if ( !OBJMAX_RANGE(aIndex))

  00018	85 db		 test	 ebx, ebx
  0001a	78 0f		 js	 SHORT $LN19@CGActionRe
  0001c	33 c0		 xor	 eax, eax
  0001e	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN12@CGActionRe
$LN19@CGActionRe:

; 11888: 	{
; 11889: 		LogAdd("error : move protocol index error %s %d", __FILE__, __LINE__);

  0002b	68 71 2e 00 00	 push	 11889			; 00002e71H
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	5f		 pop	 edi
  00044	5b		 pop	 ebx

; 11934: 			}
; 11935: 		}
; 11936: 	}
; 11937: }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	33 cd		 xor	 ecx, ebp
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN12@CGActionRe:
  00053	56		 push	 esi

; 11890: 		return;
; 11891: 	}
; 11892: 
; 11893: 	PMSG_ACTIONRESULT pResult;
; 11894: 	LPOBJ lpObj = &gObj[aIndex];

  00054	8b f3		 mov	 esi, ebx
  00056	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0005c	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11895: 
; 11896: 	PHeadSetB((LPBYTE)&pResult, 0x18, sizeof(pResult));

  00062	6a 09		 push	 9
  00064	8d 45 f0	 lea	 eax, DWORD PTR _pResult$[ebp]
  00067	6a 18		 push	 24			; 00000018H
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11897: 	pResult.ActionNumber = lpMsg->ActionNumber;

  0006f	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  00072	88 45 f6	 mov	 BYTE PTR _pResult$[ebp+6], al

; 11898: 	pResult.NumberH = SET_NUMBERH(aIndex);

  00075	8b cb		 mov	 ecx, ebx
  00077	c1 e9 08	 shr	 ecx, 8
  0007a	88 4d f3	 mov	 BYTE PTR _pResult$[ebp+3], cl

; 11899: 	pResult.NumberL = SET_NUMBERL(aIndex);

  0007d	88 5d f4	 mov	 BYTE PTR _pResult$[ebp+4], bl

; 11900: 	lpObj->m_ActionNumber = lpMsg->ActionNumber;

  00080	88 86 cc 01 00
	00		 mov	 BYTE PTR [esi+460], al

; 11901: 	lpObj->Dir = lpMsg->Dir;

  00086	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00089	88 86 22 01 00
	00		 mov	 BYTE PTR [esi+290], al

; 11902: 	pResult.Dir = lpObj->Dir;
; 11903: 	pResult.TargetNumberH = lpMsg->iTargetIndexH;

  0008f	8a 57 05	 mov	 dl, BYTE PTR [edi+5]
  00092	88 45 f5	 mov	 BYTE PTR _pResult$[ebp+5], al

; 11904: 	pResult.TargetNumberL = lpMsg->iTargetIndexL;

  00095	0f b6 47 06	 movzx	 eax, BYTE PTR [edi+6]
  00099	88 55 f7	 mov	 BYTE PTR _pResult$[ebp+7], dl
  0009c	88 45 f8	 mov	 BYTE PTR _pResult$[ebp+8], al

; 11905: 
; 11906: 	if ( lpObj->m_ActionNumber == 0x80)

  0009f	8a 86 cc 01 00
	00		 mov	 al, BYTE PTR [esi+460]
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	3c 80		 cmp	 al, 128			; 00000080H
  000aa	75 0b		 jne	 SHORT $LN11@CGActionRe

; 11907: 	{
; 11908: 		lpObj->m_ViewState = 2;

  000ac	66 c7 86 d4 01
	00 00 80 02	 mov	 WORD PTR [esi+468], 640	; 00000280H

; 11909: 		lpObj->m_Rest = lpObj->m_ActionNumber;

  000b5	eb 1c		 jmp	 SHORT $LN7@CGActionRe
$LN11@CGActionRe:

; 11910: 	}
; 11911: 	else if ( lpObj->m_ActionNumber == 0x81 )

  000b7	3c 81		 cmp	 al, 129			; 00000081H
  000b9	75 0b		 jne	 SHORT $LN9@CGActionRe

; 11912: 	{
; 11913: 		lpObj->m_ViewState = 3;

  000bb	66 c7 86 d4 01
	00 00 81 03	 mov	 WORD PTR [esi+468], 897	; 00000381H

; 11914: 		lpObj->m_Rest = lpObj->m_ActionNumber;

  000c4	eb 0d		 jmp	 SHORT $LN7@CGActionRe
$LN9@CGActionRe:

; 11915: 	}
; 11916: 	else if ( lpObj->m_ActionNumber == 0x82 )

  000c6	3c 82		 cmp	 al, 130			; 00000082H
  000c8	75 09		 jne	 SHORT $LN7@CGActionRe

; 11917: 	{
; 11918: 		lpObj->m_ViewState = 4;

  000ca	66 c7 86 d4 01
	00 00 82 04	 mov	 WORD PTR [esi+468], 1154 ; 00000482H
$LN7@CGActionRe:

; 11919: 		lpObj->m_Rest = lpObj->m_ActionNumber;
; 11920: 	}
; 11921: 	
; 11922: 	int MVL = MAX_VIEWPORT;
; 11923: 
; 11924: 	if ( lpObj->Type == OBJ_MONSTER )
; 11925: 		MVL = MAX_VIEWPORT_MONSTER;
; 11926: 
; 11927: 	for (int n=0;n<MVL;n++)

  000d3	81 c6 48 0c 00
	00		 add	 esi, 3144		; 00000c48H
  000d9	bf 4b 00 00 00	 mov	 edi, 75			; 0000004bH
  000de	bb 01 00 00 00	 mov	 ebx, 1
$LL5@CGActionRe:

; 11928: 	{
; 11929: 		if ( lpObj->VpPlayer2[n].type == OBJ_USER )

  000e3	38 5e 04	 cmp	 BYTE PTR [esi+4], bl
  000e6	75 24		 jne	 SHORT $LN4@CGActionRe

; 11930: 		{
; 11931: 			if ( lpObj->VpPlayer2[n].state != 0 && lpObj->VpPlayer2[n].state != 0x10 && lpObj->VpPlayer2[n].state != 0x08)

  000e8	8a 06		 mov	 al, BYTE PTR [esi]
  000ea	84 c0		 test	 al, al
  000ec	74 1e		 je	 SHORT $LN4@CGActionRe
  000ee	3c 10		 cmp	 al, 16			; 00000010H
  000f0	74 1a		 je	 SHORT $LN4@CGActionRe
  000f2	3c 08		 cmp	 al, 8
  000f4	74 16		 je	 SHORT $LN4@CGActionRe

; 11932: 			{
; 11933: 				DataSend(lpObj->VpPlayer2[n].number, (LPBYTE)&pResult, pResult.h.size);

  000f6	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  000fa	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]
  000fe	51		 push	 ecx
  000ff	8d 55 f0	 lea	 edx, DWORD PTR _pResult$[ebp]
  00102	52		 push	 edx
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@CGActionRe:

; 11919: 		lpObj->m_Rest = lpObj->m_ActionNumber;
; 11920: 	}
; 11921: 	
; 11922: 	int MVL = MAX_VIEWPORT;
; 11923: 
; 11924: 	if ( lpObj->Type == OBJ_MONSTER )
; 11925: 		MVL = MAX_VIEWPORT_MONSTER;
; 11926: 
; 11927: 	for (int n=0;n<MVL;n++)

  0010c	83 c6 0c	 add	 esi, 12			; 0000000cH
  0010f	2b fb		 sub	 edi, ebx
  00111	75 d0		 jne	 SHORT $LL5@CGActionRe

; 11934: 			}
; 11935: 		}
; 11936: 	}
; 11937: }

  00113	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00116	5e		 pop	 esi
  00117	5f		 pop	 edi
  00118	33 cd		 xor	 ecx, ebp
  0011a	5b		 pop	 ebx
  0011b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z ENDP		; CGActionRecv
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2008 : 		{	// determine current pointer to buffer for nonmutable string

  00000	8b c1		 mov	 eax, ecx

; 2009 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2010 : 			: this->_Bx._Buf);

  00002	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00006	72 02		 jb	 SHORT $LN4@Myptr
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Myptr:

; 2011 : 		}

  0000a	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 459  : 		}

  00000	c3		 ret	 0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
;	COMDAT ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z
_TEXT	SEGMENT
_pAttack$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_MagicNumber$ = 12					; size = 2
_usernumber$ = 16					; size = 4
_skillsuccess$ = 20					; size = 1
?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z PROC ; GCMagicAttackNumberSend, COMDAT

; 12091: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 12092: 	PMSG_MAGICATTACK_RESULT pAttack;
; 12093: 	
; 12094: 	PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof(pAttack));

  00015	6a 09		 push	 9
  00017	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  0001a	6a 19		 push	 25			; 00000019H
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 12095: 
; 12096: 	pAttack.MagicNumberH = SET_NUMBERH(MagicNumber);

  00022	8b 5d 0c	 mov	 ebx, DWORD PTR _MagicNumber$[ebp]
  00025	8b cb		 mov	 ecx, ebx
  00027	c1 e9 08	 shr	 ecx, 8
  0002a	88 4d f5	 mov	 BYTE PTR _pAttack$[ebp+5], cl

; 12097: 	pAttack.MagicNumberL = SET_NUMBERL(MagicNumber);
; 12098: 
; 12099: 	pAttack.SourceNumberH = SET_NUMBERH(lpObj->m_Index);

  0002d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002f	8b d1		 mov	 edx, ecx
  00031	c1 ea 08	 shr	 edx, 8

; 12100: 	pAttack.SourceNumberL = SET_NUMBERL(lpObj->m_Index);

  00034	8a c1		 mov	 al, cl
  00036	88 55 f3	 mov	 BYTE PTR _pAttack$[ebp+3], dl

; 12101: 	pAttack.TargetNumberH = SET_NUMBERH(usernumber);

  00039	8b 55 10	 mov	 edx, DWORD PTR _usernumber$[ebp]
  0003c	88 45 f4	 mov	 BYTE PTR _pAttack$[ebp+4], al
  0003f	8b c2		 mov	 eax, edx
  00041	c1 e8 08	 shr	 eax, 8

; 12102: 	pAttack.TargetNumberL = SET_NUMBERL(usernumber);
; 12103: 	pAttack.TargetNumberH &= 0x7F;

  00044	24 7f		 and	 al, 127			; 0000007fH
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12104: 
; 12105: 	if ( skillsuccess )

  00049	80 7d 14 00	 cmp	 BYTE PTR _skillsuccess$[ebp], 0
  0004d	88 5d f6	 mov	 BYTE PTR _pAttack$[ebp+6], bl
  00050	88 55 f8	 mov	 BYTE PTR _pAttack$[ebp+8], dl
  00053	88 45 f7	 mov	 BYTE PTR _pAttack$[ebp+7], al
  00056	74 05		 je	 SHORT $LN6@GCMagicAtt

; 12106: 		pAttack.TargetNumberH |= 0x80;

  00058	0c 80		 or	 al, 128			; 00000080H
  0005a	88 45 f7	 mov	 BYTE PTR _pAttack$[ebp+7], al
$LN6@GCMagicAtt:

; 12107: 
; 12108: 	if ( lpObj->Type == OBJ_USER )

  0005d	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00061	75 12		 jne	 SHORT $LN5@GCMagicAtt

; 12109: 		DataSend(lpObj->m_Index, (LPBYTE)&pAttack, pAttack.h.size);

  00063	0f b6 55 f1	 movzx	 edx, BYTE PTR _pAttack$[ebp+1]
  00067	52		 push	 edx
  00068	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  0006b	50		 push	 eax
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@GCMagicAtt:

; 12110: 
; 12111: 	if ( CC_MAP_RANGE(lpObj->MapNumber) )

  00075	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  0007c	3c 35		 cmp	 al, 53			; 00000035H
  0007e	74 0d		 je	 SHORT $LN14@GCMagicAtt
  00080	3c 12		 cmp	 al, 18			; 00000012H
  00082	72 43		 jb	 SHORT $LN2@GCMagicAtt
  00084	b1 17		 mov	 cl, 23			; 00000017H
  00086	3a c8		 cmp	 cl, al
  00088	1b c0		 sbb	 eax, eax
  0008a	40		 inc	 eax
  0008b	74 3a		 je	 SHORT $LN2@GCMagicAtt
$LN14@GCMagicAtt:

; 12112: 	{
; 12113: 		switch ( MagicNumber )

  0008d	0f b7 c3	 movzx	 eax, bx
  00090	3d 64 01 00 00	 cmp	 eax, 356		; 00000164H
  00095	7f 18		 jg	 SHORT $LN13@GCMagicAtt
  00097	74 40		 je	 SHORT $LN7@GCMagicAtt
  00099	83 e8 10	 sub	 eax, 16			; 00000010H
  0009c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0009f	77 26		 ja	 SHORT $LN2@GCMagicAtt
  000a1	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN15@GCMagicAtt[eax]
  000a8	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN17@GCMagicAtt[edx*4]
$LN13@GCMagicAtt:
  000af	2d 68 01 00 00	 sub	 eax, 360		; 00000168H
  000b4	83 f8 49	 cmp	 eax, 73			; 00000049H
  000b7	77 0e		 ja	 SHORT $LN2@GCMagicAtt
  000b9	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN16@GCMagicAtt[eax]
  000c0	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@GCMagicAtt[eax*4]
$LN2@GCMagicAtt:

; 12114: 		{
; 12115: 			case 16:
; 12116: 			case 26:
; 12117: 			case 27:
; 12118: 			case 28:
; 12119: 			case 48:
; 12120: 				// MSKILL
; 12121: 			case AT_MSKILL_DW_MANASHIELD1:
; 12122: 			case AT_MSKILL_DW_MANASHIELD2:
; 12123: 			case AT_MSKILL_FE_HEAL1:
; 12124: 			case AT_MSKILL_FE_DEFENSEBUFF1:
; 12125: 			case AT_MSKILL_FE_DEFENSEBUFF2:
; 12126: 			case AT_MSKILL_FE_CURE:
; 12127: 			case AT_MSKILL_FE_BLESS:
; 12128: 			case AT_MSKILL_FE_BLESS1:
; 12129: 			case AT_MSKILL_FE_ATTACKBUFF1:
; 12130: 			case AT_MSKILL_FE_ATTACKBUFF2:
; 12131: 			case AT_MSKILL_DK_SWELLLIFE1:
; 12132: 			case AT_MSKILL_DK_SWELLLIFE2:
; 12133: 			case AT_MSKILL_DK_SWELLLIFE3:
; 12134: 				return;
; 12135: 		}
; 12136: 	}
; 12137: 	
; 12138: 	MsgSendV2(lpObj, (LPBYTE)&pAttack, pAttack.h.size);

  000c7	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pAttack$[ebp+1]
  000cb	51		 push	 ecx
  000cc	8d 55 f0	 lea	 edx, DWORD PTR _pAttack$[ebp]
  000cf	52		 push	 edx
  000d0	56		 push	 esi
  000d1	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@GCMagicAtt:

; 12139: }

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dc	5e		 pop	 esi
  000dd	33 cd		 xor	 ecx, ebp
  000df	5b		 pop	 ebx
  000e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
  000e9	8d 49 00	 npad	 3
$LN17@GCMagicAtt:
  000ec	00 00 00 00	 DD	 $LN7@GCMagicAtt
  000f0	00 00 00 00	 DD	 $LN2@GCMagicAtt
$LN15@GCMagicAtt:
  000f4	00		 DB	 0
  000f5	01		 DB	 1
  000f6	01		 DB	 1
  000f7	01		 DB	 1
  000f8	01		 DB	 1
  000f9	01		 DB	 1
  000fa	01		 DB	 1
  000fb	01		 DB	 1
  000fc	01		 DB	 1
  000fd	01		 DB	 1
  000fe	00		 DB	 0
  000ff	00		 DB	 0
  00100	00		 DB	 0
  00101	01		 DB	 1
  00102	01		 DB	 1
  00103	01		 DB	 1
  00104	01		 DB	 1
  00105	01		 DB	 1
  00106	01		 DB	 1
  00107	01		 DB	 1
  00108	01		 DB	 1
  00109	01		 DB	 1
  0010a	01		 DB	 1
  0010b	01		 DB	 1
  0010c	01		 DB	 1
  0010d	01		 DB	 1
  0010e	01		 DB	 1
  0010f	01		 DB	 1
  00110	01		 DB	 1
  00111	01		 DB	 1
  00112	01		 DB	 1
  00113	01		 DB	 1
  00114	00		 DB	 0
  00115	8d 49 00	 npad	 3
$LN18@GCMagicAtt:
  00118	00 00 00 00	 DD	 $LN7@GCMagicAtt
  0011c	00 00 00 00	 DD	 $LN2@GCMagicAtt
$LN16@GCMagicAtt:
  00120	00		 DB	 0
  00121	01		 DB	 1
  00122	01		 DB	 1
  00123	00		 DB	 0
  00124	01		 DB	 1
  00125	01		 DB	 1
  00126	01		 DB	 1
  00127	01		 DB	 1
  00128	01		 DB	 1
  00129	01		 DB	 1
  0012a	01		 DB	 1
  0012b	01		 DB	 1
  0012c	01		 DB	 1
  0012d	01		 DB	 1
  0012e	01		 DB	 1
  0012f	01		 DB	 1
  00130	01		 DB	 1
  00131	01		 DB	 1
  00132	01		 DB	 1
  00133	01		 DB	 1
  00134	01		 DB	 1
  00135	01		 DB	 1
  00136	01		 DB	 1
  00137	01		 DB	 1
  00138	01		 DB	 1
  00139	01		 DB	 1
  0013a	01		 DB	 1
  0013b	01		 DB	 1
  0013c	01		 DB	 1
  0013d	01		 DB	 1
  0013e	01		 DB	 1
  0013f	01		 DB	 1
  00140	01		 DB	 1
  00141	01		 DB	 1
  00142	01		 DB	 1
  00143	01		 DB	 1
  00144	01		 DB	 1
  00145	01		 DB	 1
  00146	01		 DB	 1
  00147	01		 DB	 1
  00148	01		 DB	 1
  00149	01		 DB	 1
  0014a	01		 DB	 1
  0014b	00		 DB	 0
  0014c	00		 DB	 0
  0014d	01		 DB	 1
  0014e	01		 DB	 1
  0014f	01		 DB	 1
  00150	01		 DB	 1
  00151	01		 DB	 1
  00152	01		 DB	 1
  00153	01		 DB	 1
  00154	01		 DB	 1
  00155	00		 DB	 0
  00156	01		 DB	 1
  00157	01		 DB	 1
  00158	01		 DB	 1
  00159	00		 DB	 0
  0015a	01		 DB	 1
  0015b	01		 DB	 1
  0015c	00		 DB	 0
  0015d	01		 DB	 1
  0015e	00		 DB	 0
  0015f	00		 DB	 0
  00160	01		 DB	 1
  00161	00		 DB	 0
  00162	01		 DB	 1
  00163	01		 DB	 1
  00164	01		 DB	 1
  00165	01		 DB	 1
  00166	00		 DB	 0
  00167	01		 DB	 1
  00168	01		 DB	 1
  00169	00		 DB	 0
?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ENDP ; GCMagicAttackNumberSend
_TEXT	ENDS
PUBLIC	?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z	; GCMagicCancelSend
; Function compile flags: /Ogtp
;	COMDAT ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_lpObj$ = 8						; size = 4
_MagicNumber$ = 12					; size = 4
?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; GCMagicCancelSend, COMDAT

; 12146: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 12147: 	PMSG_MAGICCANCEL pMsg;
; 12148: 
; 12149: 	PHeadSetB((LPBYTE)&pMsg, 0x1B, sizeof(pMsg));

  00007	6a 07		 push	 7
  00009	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000c	6a 1b		 push	 27			; 0000001bH
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12150: 
; 12151: 	pMsg.MagicNumberH = SET_NUMBERH(MagicNumber);

  00014	8b 45 0c	 mov	 eax, DWORD PTR _MagicNumber$[ebp]

; 12152: 	pMsg.MagicNumberL = SET_NUMBERL(MagicNumber);
; 12153: 
; 12154: 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  00017	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0001a	8b c8		 mov	 ecx, eax
  0001c	c1 e9 08	 shr	 ecx, 8
  0001f	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	8b d0		 mov	 edx, eax
  00026	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00029	c1 ea 08	 shr	 edx, 8
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12155: 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 12156: 
; 12157: 	if ( lpObj->Type == OBJ_USER )

  0002f	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00033	8a c8		 mov	 cl, al
  00035	88 55 fd	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  00038	88 4d fe	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  0003b	75 12		 jne	 SHORT $LN1@GCMagicCan

; 12158: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0003d	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00041	52		 push	 edx
  00042	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00045	51		 push	 ecx
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCMagicCan:

; 12159: 	
; 12160: 	MsgSendV2(lpObj, (UCHAR*)&pMsg, pMsg.h.size);

  0004f	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00053	52		 push	 edx
  00054	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00057	50		 push	 eax
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	5e		 pop	 esi

; 12161: }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; GCMagicCancelSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendEffect@@YAXPAUOBJECTSTRUCT@@HHHH@Z	; GCSendEffect
; Function compile flags: /Ogtp
;	COMDAT ?GCSendEffect@@YAXPAUOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iEffectUseOption$ = 12					; size = 4
_iOptionType$ = 16					; size = 4
_iEffectType$ = 20					; size = 4
_iLeftTime$ = 24					; size = 4
?GCSendEffect@@YAXPAUOBJECTSTRUCT@@HHHH@Z PROC		; GCSendEffect, COMDAT

; 12164: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 12165: 	PMSG_SENDEFFECT pMsg;
; 12166: 
; 12167: 	PHeadSetB((LPBYTE)&pMsg, 0x2D, sizeof(pMsg));

  00014	6a 18		 push	 24			; 00000018H
  00016	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 2d		 push	 45			; 0000002dH
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12168: 	pMsg.byEffectOption = iEffectUseOption;

  00021	8a 4d 0c	 mov	 cl, BYTE PTR _iEffectUseOption$[ebp]

; 12169: 	pMsg.wOptionType = iOptionType;
; 12170: 	pMsg.wEffectType = iEffectType;

  00024	8b 45 14	 mov	 eax, DWORD PTR _iEffectType$[ebp]
  00027	66 8b 55 10	 mov	 dx, WORD PTR _iOptionType$[ebp]
  0002b	88 4d ec	 mov	 BYTE PTR _pMsg$[ebp+8], cl

; 12171: 	pMsg.iLeftTime = iLeftTime;

  0002e	8b 4d 18	 mov	 ecx, DWORD PTR _iLeftTime$[ebp]
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12172: 	pMsg.iEffect = iEffectType;
; 12173: 
; 12174: 	if ( lpObj->Type == OBJ_USER )

  00034	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00038	66 89 55 e8	 mov	 WORD PTR _pMsg$[ebp+4], dx
  0003c	66 89 45 ea	 mov	 WORD PTR _pMsg$[ebp+6], ax
  00040	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+12], ecx
  00043	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+16], al
  00046	75 14		 jne	 SHORT $LN1@GCSendEffe

; 12175: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00048	0f b6 55 e5	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0004c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004e	52		 push	 edx
  0004f	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00052	50		 push	 eax
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCSendEffe:

; 12176: }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	5e		 pop	 esi
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?GCSendEffect@@YAXPAUOBJECTSTRUCT@@HHHH@Z ENDP		; GCSendEffect
_TEXT	ENDS
PUBLIC	?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z	; CGMagicCancel
EXTRN	?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRemoveBuffEffect
; Function compile flags: /Ogtp
;	COMDAT ?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z PROC	; CGMagicCancel, COMDAT

; 12180: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 12181: 	if ( !OBJMAX_RANGE(aIndex))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 88 0c 01 00
	00		 js	 $LN1@CGMagicCan@2
  0000e	33 c9		 xor	 ecx, ecx
  00010	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00015	0f 9e c1	 setle	 cl
  00018	85 c9		 test	 ecx, ecx
  0001a	0f 84 fa 00 00
	00		 je	 $LN1@CGMagicCan@2

; 12182: 		return;
; 12183: 
; 12184: 	LPOBJ lpObj = &gObj[aIndex];

  00020	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00026	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	56		 push	 esi
  0002d	8b f0		 mov	 esi, eax

; 12185: 
; 12186: 	WORD MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH,lpMsg->MagicNumberL);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00032	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00036	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  0003a	66 c1 e1 08	 shl	 cx, 8
  0003e	66 0b ca	 or	 cx, dx
  00041	0f b7 c1	 movzx	 eax, cx

; 12187: 
; 12188: 	if ( MagicNumber == AT_SKILL_INFINITY_ARROW )

  00044	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00047	75 21		 jne	 SHORT $LN14@CGMagicCan@2

; 12189: 	{
; 12190: 		if ( gObjCheckUsedBuffEffect(lpObj,BUFF_INFINITY_ARROW) == TRUE )

  00049	6a 06		 push	 6
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00051	83 c4 08	 add	 esp, 8
  00054	3c 01		 cmp	 al, 1
  00056	0f 85 bd 00 00
	00		 jne	 $LN20@CGMagicCan@2

; 12191: 		{
; 12192: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW);

  0005c	6a 06		 push	 6

; 12219: 		{
; 12220: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  00064	83 c4 08	 add	 esp, 8
  00067	5e		 pop	 esi

; 12221: 		}
; 12222: 	}
; 12223: }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN14@CGMagicCan@2:

; 12193: 		}
; 12194: 	}
; 12195: 	else if( MagicNumber == AT_SKILL_EXPWIZARDRY )

  0006a	b9 e9 00 00 00	 mov	 ecx, 233		; 000000e9H
  0006f	66 3b c1	 cmp	 ax, cx
  00072	75 21		 jne	 SHORT $LN11@CGMagicCan@2

; 12196: 	{
; 12197: 		if ( gObjCheckUsedBuffEffect(lpObj,BUFF_EXP_WIZARDRY) == TRUE )

  00074	6a 52		 push	 82			; 00000052H
  00076	56		 push	 esi
  00077	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0007c	83 c4 08	 add	 esp, 8
  0007f	3c 01		 cmp	 al, 1
  00081	0f 85 92 00 00
	00		 jne	 $LN20@CGMagicCan@2

; 12198: 		{
; 12199: 			gObjRemoveBuffEffect(lpObj,BUFF_EXP_WIZARDRY);

  00087	6a 52		 push	 82			; 00000052H

; 12219: 		{
; 12220: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  00089	56		 push	 esi
  0008a	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  0008f	83 c4 08	 add	 esp, 8
  00092	5e		 pop	 esi

; 12221: 		}
; 12222: 	}
; 12223: }

  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
$LN11@CGMagicCan@2:

; 12200: 		}
; 12201: 	}
; 12202: 	else if( MagicNumber == AT_MSKILL_DW_EXPWIZARDRY1 )

  00095	ba 7c 01 00 00	 mov	 edx, 380		; 0000017cH
  0009a	66 3b c2	 cmp	 ax, dx
  0009d	75 23		 jne	 SHORT $LN8@CGMagicCan@2

; 12203: 	{
; 12204: 		if ( gObjCheckUsedBuffEffect(lpObj,BUFF_EXP_WIZARDRY2) == TRUE )

  0009f	68 8a 00 00 00	 push	 138			; 0000008aH
  000a4	56		 push	 esi
  000a5	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000aa	83 c4 08	 add	 esp, 8
  000ad	3c 01		 cmp	 al, 1
  000af	75 68		 jne	 SHORT $LN20@CGMagicCan@2

; 12205: 		{
; 12206: 			gObjRemoveBuffEffect(lpObj,BUFF_EXP_WIZARDRY2);

  000b1	68 8a 00 00 00	 push	 138			; 0000008aH

; 12219: 		{
; 12220: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  000b6	56		 push	 esi
  000b7	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  000bc	83 c4 08	 add	 esp, 8
  000bf	5e		 pop	 esi

; 12221: 		}
; 12222: 	}
; 12223: }

  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
$LN8@CGMagicCan@2:

; 12207: 		}
; 12208: 	}
; 12209: 	else if( MagicNumber == AT_MSKILL_DW_EXPWIZARDRY2 )

  000c2	b9 7f 01 00 00	 mov	 ecx, 383		; 0000017fH
  000c7	66 3b c1	 cmp	 ax, cx
  000ca	75 23		 jne	 SHORT $LN5@CGMagicCan@2

; 12210: 	{
; 12211: 		if ( gObjCheckUsedBuffEffect(lpObj,BUFF_EXP_WIZARDRY3) == TRUE )

  000cc	68 8b 00 00 00	 push	 139			; 0000008bH
  000d1	56		 push	 esi
  000d2	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000d7	83 c4 08	 add	 esp, 8
  000da	3c 01		 cmp	 al, 1
  000dc	75 3b		 jne	 SHORT $LN20@CGMagicCan@2

; 12212: 		{
; 12213: 			gObjRemoveBuffEffect(lpObj,BUFF_EXP_WIZARDRY3);

  000de	68 8b 00 00 00	 push	 139			; 0000008bH

; 12219: 		{
; 12220: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  000e3	56		 push	 esi
  000e4	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  000e9	83 c4 08	 add	 esp, 8
  000ec	5e		 pop	 esi

; 12221: 		}
; 12222: 	}
; 12223: }

  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
$LN5@CGMagicCan@2:

; 12214: 		}
; 12215: 	}
; 12216: 	else if( MagicNumber == AT_MSKILL_FE_INFINITY1 )

  000ef	ba b9 01 00 00	 mov	 edx, 441		; 000001b9H
  000f4	66 3b c2	 cmp	 ax, dx
  000f7	75 20		 jne	 SHORT $LN20@CGMagicCan@2

; 12217: 	{
; 12218: 		if( gObjCheckUsedBuffEffect(lpObj,BUFF_INFINITY_ARROW2) == TRUE )

  000f9	68 8f 00 00 00	 push	 143			; 0000008fH
  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00104	83 c4 08	 add	 esp, 8
  00107	3c 01		 cmp	 al, 1
  00109	75 0e		 jne	 SHORT $LN20@CGMagicCan@2

; 12219: 		{
; 12220: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  0010b	68 8f 00 00 00	 push	 143			; 0000008fH
  00110	56		 push	 esi
  00111	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  00116	83 c4 08	 add	 esp, 8
$LN20@CGMagicCan@2:
  00119	5e		 pop	 esi
$LN1@CGMagicCan@2:

; 12221: 		}
; 12222: 	}
; 12223: }

  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z ENDP	; CGMagicCancel
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z ; GCUseMonsterSkillSend
; Function compile flags: /Ogtp
;	COMDAT ?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_iSkillNumber$ = 16					; size = 4
?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z PROC	; GCUseMonsterSkillSend, COMDAT

; 12237: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]

; 12238: 	PMSG_USE_MONSTERSKILL pMsg;
; 12239: 
; 12240: 	PHeadSetB((LPBYTE)&pMsg, 0x69, sizeof(pMsg));

  00018	6a 0a		 push	 10			; 0000000aH
  0001a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001d	6a 69		 push	 105			; 00000069H
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12241: 
; 12242: 	pMsg.btMonsterSkillNumberH = SET_NUMBERH(iSkillNumber);

  00025	8b 45 10	 mov	 eax, DWORD PTR _iSkillNumber$[ebp]

; 12243: 	pMsg.btMonsterSkillNumberL = SET_NUMBERL(iSkillNumber);
; 12244: 
; 12245: 
; 12246: 	pMsg.wObjIndex = lpObj->m_Index;

  00028	66 8b 16	 mov	 dx, WORD PTR [esi]
  0002b	8b c8		 mov	 ecx, eax
  0002d	c1 e9 08	 shr	 ecx, 8
  00030	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 12247: 	pMsg.wTargetObjIndex = lpTargetObj->m_Index;

  00033	66 8b 07	 mov	 ax, WORD PTR [edi]
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12248: 
; 12249: 	if ( lpObj->Type == OBJ_USER )

  00039	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  0003d	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00040	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+6], dx
  00044	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+8], ax
  00048	75 14		 jne	 SHORT $LN1@GCUseMonst

; 12250: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0004a	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0004e	8b 06		 mov	 eax, DWORD PTR [esi]
  00050	51		 push	 ecx
  00051	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00054	52		 push	 edx
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCUseMonst:

; 12251: 
; 12252: 	MsgSendV2(lpObj, (UCHAR*)&pMsg, pMsg.h.size);

  0005e	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00062	51		 push	 ecx
  00063	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00066	52		 push	 edx
  00067	56		 push	 esi
  00068	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 12253: }

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	5f		 pop	 edi
  00074	33 cd		 xor	 ecx, ebp
  00076	5e		 pop	 esi
  00077	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z ENDP	; GCUseMonsterSkillSend
_TEXT	ENDS
PUBLIC	?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z	; GCStateInfoSend
; Function compile flags: /Ogtp
;	COMDAT ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_lpObj$ = 8						; size = 4
_state$ = 12						; size = 1
_Effect$ = 16						; size = 1
?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z PROC		; GCStateInfoSend, COMDAT

; 12267: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 12268: 	PMSG_VIEWSKILLSTATE pMsg;
; 12269: 
; 12270: 	PHeadSetB((LPBYTE)&pMsg, 0x07, sizeof(pMsg));

  00007	6a 07		 push	 7
  00009	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000c	6a 07		 push	 7
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12271: 	pMsg.State = state;
; 12272: 	pMsg.Effect = Effect;
; 12273: 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00017	8a 4d 0c	 mov	 cl, BYTE PTR _state$[ebp]
  0001a	8a 55 10	 mov	 dl, BYTE PTR _Effect$[ebp]
  0001d	8b 06		 mov	 eax, DWORD PTR [esi]
  0001f	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00022	88 55 fe	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  00025	8b c8		 mov	 ecx, eax

; 12274: 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);

  00027	0f b6 d0	 movzx	 edx, al
  0002a	c1 e9 08	 shr	 ecx, 8
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12275: 
; 12276: 	if ( lpObj->Type == OBJ_USER )

  00030	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00034	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00037	88 55 fd	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  0003a	75 12		 jne	 SHORT $LN2@GCStateInf

; 12277: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0003c	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00040	51		 push	 ecx
  00041	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00044	52		 push	 edx
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCStateInf:

; 12278: 
; 12279: 	if ( CC_MAP_RANGE(lpObj->MapNumber) != FALSE )

  0004e	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  00055	3c 35		 cmp	 al, 53			; 00000035H
  00057	74 0d		 je	 SHORT $LN9@GCStateInf
  00059	3c 12		 cmp	 al, 18			; 00000012H
  0005b	72 0d		 jb	 SHORT $LN1@GCStateInf
  0005d	b1 17		 mov	 cl, 23			; 00000017H
  0005f	3a c8		 cmp	 cl, al
  00061	1b c0		 sbb	 eax, eax
  00063	40		 inc	 eax
  00064	74 04		 je	 SHORT $LN1@GCStateInf
$LN9@GCStateInf:

; 12280: 		pMsg.Effect = 0;

  00066	c6 45 fe 00	 mov	 BYTE PTR _pMsg$[ebp+6], 0
$LN1@GCStateInf:

; 12281: 
; 12282: 	MsgSendV2(lpObj, (UCHAR*)&pMsg, pMsg.h.size);

  0006a	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0006e	52		 push	 edx
  0006f	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00072	50		 push	 eax
  00073	56		 push	 esi
  00074	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007c	5e		 pop	 esi

; 12283: }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z ENDP		; GCStateInfoSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z	; GCTeleportSend
; Function compile flags: /Ogtp
;	COMDAT ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_MoveNumber$ = 12					; size = 4
_MapNumber$ = 16					; size = 1
_MapX$ = 20						; size = 1
_MapY$ = 24						; size = 1
_Dir$ = 28						; size = 1
?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z PROC	; GCTeleportSend, COMDAT

; 12574: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]

; 12575: 	PMSG_TELEPORT_RESULT pMsg;
; 12576: 
; 12577: 	if ( lpObj->Type != OBJ_USER )

  00013	80 78 50 01	 cmp	 BYTE PTR [eax+80], 1
  00017	75 3c		 jne	 SHORT $LN1@GCTeleport

; 12578: 		return;
; 12579: 
; 12580: 	pMsg.h.c = 0xC3;
; 12581: 	pMsg.h.size = sizeof(pMsg);
; 12582: 	pMsg.h.headcode = 0x1C;
; 12583: 	pMsg.MoveNumber = MoveNumber;
; 12584: 	pMsg.MapNumber = MapNumber;

  00019	8a 55 10	 mov	 dl, BYTE PTR _MapNumber$[ebp]
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _MoveNumber$[ebp]
  0001f	88 55 f6	 mov	 BYTE PTR _pMsg$[ebp+6], dl

; 12585: 	pMsg.MapX = MapX;

  00022	8a 55 14	 mov	 dl, BYTE PTR _MapX$[ebp]
  00025	88 55 f7	 mov	 BYTE PTR _pMsg$[ebp+7], dl

; 12586: 	pMsg.MapY = MapY;

  00028	8a 55 18	 mov	 dl, BYTE PTR _MapY$[ebp]
  0002b	88 55 f8	 mov	 BYTE PTR _pMsg$[ebp+8], dl

; 12587: 	pMsg.Dir = Dir;

  0002e	8a 55 1c	 mov	 dl, BYTE PTR _Dir$[ebp]
  00031	66 89 4d f4	 mov	 WORD PTR _pMsg$[ebp+4], cx

; 12588: 
; 12589: 	if ( MoveNumber == 0 )

  00035	85 c9		 test	 ecx, ecx

; 12590: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00037	6a 0a		 push	 10			; 0000000aH
  00039	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0003c	88 55 f9	 mov	 BYTE PTR _pMsg$[ebp+9], dl
  0003f	8b 10		 mov	 edx, DWORD PTR [eax]
  00041	51		 push	 ecx
  00042	52		 push	 edx
  00043	66 c7 45 f0 c3
	0a		 mov	 WORD PTR _pMsg$[ebp], 2755 ; 00000ac3H
  00049	c6 45 f2 1c	 mov	 BYTE PTR _pMsg$[ebp+2], 28 ; 0000001cH

; 12591: 	else
; 12592: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0004d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCTeleport:

; 12593: }

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	33 cd		 xor	 ecx, ebp
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ENDP	; GCTeleportSend
_TEXT	ENDS
PUBLIC	??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@ ; `string'
PUBLIC	??_C@_0DJ@COJBHLGO@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@ ; `string'
PUBLIC	??_C@_0DN@PFIDPOLC@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@ ; `string'
PUBLIC	??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@ ; `string'
PUBLIC	??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ ; `string'
PUBLIC	??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@ ; `string'
PUBLIC	??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@ ; `string'
PUBLIC	??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_lpRecv$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGBeattackRecv@@YAXPAEHH@Z			; CGBeattackRecv
EXTRN	?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z:PROC ; gObjAttack
EXTRN	?MLS_FireScream@CMasterLevelSkillTreeSystem@@QAEHHHPAVCMagicInf@@@Z:PROC ; CMasterLevelSkillTreeSystem::MLS_FireScream
EXTRN	?MLS_MaGumSkillDefenseDownMastery@CMasterLevelSkillTreeSystem@@QAEXHHPAVCMagicInf@@@Z:PROC ; CMasterLevelSkillTreeSystem::MLS_MaGumSkillDefenseDownMastery
EXTRN	?MLS_MaGumSkillDefenseDown@CMasterLevelSkillTreeSystem@@QAEXHH@Z:PROC ; CMasterLevelSkillTreeSystem::MLS_MaGumSkillDefenseDown
EXTRN	?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z:PROC ; CObjUseSkill::SkillFireScream
EXTRN	?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z:PROC ; CObjUseSkill::MaGumSkillDefenseDown
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?bIsIgnorePacketSpeedHackDetect@@3HA:DWORD	; bIsIgnorePacketSpeedHackDetect
EXTRN	?gDetectedHackKickCount@@3HA:DWORD		; gDetectedHackKickCount
EXTRN	?gIsKickDetecHackCountLimit@@3HA:DWORD		; gIsKickDetecHackCountLimit
EXTRN	?gHackCheckCount@@3KA:DWORD			; gHackCheckCount
EXTRN	?gObjUserKill@@YAXH@Z:PROC			; gObjUserKill
EXTRN	?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z:PROC ; CMagicDamage::SkillGetRequireClass
EXTRN	?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z:PROC ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
EXTRN	?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagic
EXTRN	?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagicSearch
;	COMDAT ??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\tdurmagickeychecker.h
CONST	SEGMENT
??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@ DB '['
	DB	'%s][%s] %s Detect Hack : Multi Attack', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@COJBHLGO@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@
CONST	SEGMENT
??_C@_0DJ@COJBHLGO@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@ DB 0a1H
	DB	0daH, 0a1H, 0daH, 0a1H, 0daH, 0a1H, 0daH, ' InValid VailidCoun'
	DB	't = %d ( Count : %d) [%s][%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@PFIDPOLC@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@
CONST	SEGMENT
??_C@_0DN@PFIDPOLC@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@ DB 0a1H
	DB	0daH, 0a1H, 0daH, 0a1H, 0daH, 0a1H, 0daH, ' InValid DurationTi'
	DB	'me Key = %d ( Time : %d) [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@
CONST	SEGMENT
??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@ DB '['
	DB	'%s][%s] %s Apply Attack Speed Penalty (%d left)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
CONST	SEGMENT
??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ DB '['
	DB	'%s][%s] %s Attack Speed Is Wrong Magic3 (%d)(%d) Penalty %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@
CONST	SEGMENT
??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@ DB '['
	DB	'%s][%s] %s Kick DetecHackCountLimit Over User (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@
CONST	SEGMENT
??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@ DB 'Too long ti'
	DB	'me passed after casting magic. [%s][%s] (%d)(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@ DB 'error-L3 %s %d', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?CGBeattackRecv@@YAXPAEHH@Z
_TEXT	SEGMENT
tv1231 = -540						; size = 4
_n$ = -536						; size = 4
_lpRecv$GSCopy$ = -532					; size = 4
_aIndex$GSCopy$ = -528					; size = 4
tv1044 = -524						; size = 4
tv1574 = -520						; size = 4
_pTargetNumber$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_magic_send$ = 16					; size = 4
?CGBeattackRecv@@YAXPAEHH@Z PROC			; CGBeattackRecv, COMDAT

; 12600: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 55 08	 mov	 edx, DWORD PTR _lpRecv$[ebp]

; 12601: 	// Set the lpRecv to a Predeterminated Packet
; 12602: 	PMSG_BEATTACK_COUNT * lpCount = (PMSG_BEATTACK_COUNT *)lpRecv;
; 12603: 
; 12604: #if (__ENG__ ==1)
; 12605: 	if ( lpCount->h.headcode != 0xDB )

  00016	80 7a 02 db	 cmp	 BYTE PTR [edx+2], 219	; 000000dbH
  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 12904: 			{
; 12905: 				continue;
; 12906: 			}
; 12907: 
; 12908: 			int Dis = gObjCalDistance(lpObj,&gObj[tNumber]);

  0001e	89 95 ec fd ff
	ff		 mov	 DWORD PTR _lpRecv$GSCopy$[ebp], edx
  00024	89 b5 f0 fd ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0002a	74 27		 je	 SHORT $LN64@CGBeattack

; 12606: #else
; 12607: 	// KOR PROTOCOL
; 12608: 	// Check the Protocol
; 12609: 	if ( lpCount->h.headcode != 0xD3 )
; 12610: #endif
; 12611: 	{
; 12612: 		LogAdd("error-L3 %s %d", __FILE__, __LINE__);

  0002c	68 44 31 00 00	 push	 12612			; 00003144H
$LN101@CGBeattack:
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	5e		 pop	 esi

; 12997: 	}
; 12998: }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	33 cd		 xor	 ecx, ebp
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN64@CGBeattack:

; 12613: 		return;
; 12614: 	}
; 12615: 
; 12616: 	// Check if the count is leess than 1
; 12617: 	if ( lpCount->Count < 1 )

  00053	8a 42 04	 mov	 al, BYTE PTR [edx+4]
  00056	3c 01		 cmp	 al, 1
  00058	73 07		 jae	 SHORT $LN63@CGBeattack

; 12618: 	{
; 12619: 		LogAdd("error-L3 %s %d", __FILE__, __LINE__);

  0005a	68 4b 31 00 00	 push	 12619			; 0000314bH

; 12620: 		return;

  0005f	eb d0		 jmp	 SHORT $LN101@CGBeattack
$LN63@CGBeattack:

; 12621: 	}
; 12622: 
; 12623: 	// Set the Max limitation to 5
; 12624: 	if ( lpCount->Count > 5 )

  00061	3c 05		 cmp	 al, 5
  00063	76 04		 jbe	 SHORT $LN62@CGBeattack

; 12625: 	{
; 12626: 		lpCount->Count = 5;

  00065	c6 42 04 05	 mov	 BYTE PTR [edx+4], 5
$LN62@CGBeattack:

; 12627: 	}
; 12628: 
; 12629: 	int lOfs = sizeof(PMSG_BEATTACK_COUNT);
; 12630: 	CMagicInf * lpMagic;
; 12631: 
; 12632: 	// Set the Start of the Offset
; 12633: 	int tNumber;
; 12634: 	PMSG_BEATTACK * lpMsg;
; 12635: 
; 12636: 	if ( MAKE_NUMBERW(lpCount->MagicNumberH,lpCount->MagicNumberL) == NULL )

  00069	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  0006d	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00071	66 c1 e1 08	 shl	 cx, 8
  00075	66 0b c8	 or	 cx, ax
  00078	0f 84 94 09 00
	00		 je	 $LN55@CGBeattack

; 12637: 		return;
; 12638: 
; 12639: 	// Set lpMagic according
; 12640: 	// if aIndex is OBJ_USER
; 12641: 	// or if it is OBJ_MONSTER
; 12642: 	if ( gObj[aIndex].Type == OBJ_USER )

  0007e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00084	53		 push	 ebx
  00085	8b de		 mov	 ebx, esi
  00087	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  0008d	80 7c 13 50 01	 cmp	 BYTE PTR [ebx+edx+80], 1
  00092	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00095	57		 push	 edi
  00096	89 9d f4 fd ff
	ff		 mov	 DWORD PTR tv1044[ebp], ebx
  0009c	0f 85 87 00 00
	00		 jne	 $LN60@CGBeattack

; 12643: 	{
; 12644: 		BYTE MapAttr = MapC[gObj[aIndex].MapNumber].GetAttr(gObj[aIndex].X,gObj[aIndex].Y);
; 12645: 
; 12646: 		if( (MapAttr&1) == TRUE )

  000a2	0f b6 88 21 01
	00 00		 movzx	 ecx, BYTE PTR [eax+289]
  000a9	0f b6 90 20 01
	00 00		 movzx	 edx, BYTE PTR [eax+288]
  000b0	51		 push	 ecx
  000b1	0f b6 88 23 01
	00 00		 movzx	 ecx, BYTE PTR [eax+291]
  000b8	69 c9 28 38 05
	00		 imul	 ecx, 342056		; 00053828H
  000be	52		 push	 edx
  000bf	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000c5	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000ca	a8 01		 test	 al, 1
  000cc	74 31		 je	 SHORT $LN59@CGBeattack

; 12647: 		{
; 12648: 			gObjSetPosition(aIndex,gObj[aIndex].X,gObj[aIndex].Y);

  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d3	0f b6 8c 03 21
	01 00 00	 movzx	 ecx, BYTE PTR [ebx+eax+289]
  000db	0f b6 94 03 20
	01 00 00	 movzx	 edx, BYTE PTR [ebx+eax+288]
  000e3	51		 push	 ecx
  000e4	52		 push	 edx
  000e5	56		 push	 esi
  000e6	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ee	5f		 pop	 edi
  000ef	5b		 pop	 ebx
  000f0	5e		 pop	 esi

; 12997: 	}
; 12998: }

  000f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f4	33 cd		 xor	 ecx, ebp
  000f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
$LN59@CGBeattack:

; 12649: 			return;
; 12650: 		}
; 12651: 		WORD MagicNumber = MAKE_NUMBERW(lpCount->MagicNumberH,lpCount->MagicNumberL);

  000ff	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$[ebp]
  00105	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00109	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  0010d	66 c1 e1 08	 shl	 cx, 8
  00111	66 0b ca	 or	 cx, dx
  00114	0f b7 c1	 movzx	 eax, cx

; 12652: 
; 12653: 		lpMagic = gObjGetMagicSearch(&gObj[aIndex], MagicNumber);

  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011d	50		 push	 eax
  0011e	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  00121	52		 push	 edx
  00122	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch

; 12654: 	}
; 12655: 	else

  00127	eb 0a		 jmp	 SHORT $LN92@CGBeattack
$LN60@CGBeattack:

; 12656: 	{
; 12657: 		WORD MagicNumber = MAKE_NUMBERW(lpCount->MagicNumberH,lpCount->MagicNumberL);

  00129	0f b7 c9	 movzx	 ecx, cx

; 12658: 		lpMagic = gObjGetMagic(&gObj[aIndex], MagicNumber);

  0012c	51		 push	 ecx
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
$LN92@CGBeattack:
  00133	8b f8		 mov	 edi, eax
  00135	83 c4 08	 add	 esp, 8

; 12659: 	}
; 12660: 
; 12661: 	// Check if there is Magic
; 12662: 	if ( lpMagic == NULL )

  00138	85 ff		 test	 edi, edi
  0013a	75 29		 jne	 SHORT $LN57@CGBeattack

; 12663: 	{
; 12664: 		LogAdd("error-L3 %s %d", __FILE__, __LINE__);

  0013c	68 78 31 00 00	 push	 12664			; 00003178H
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00146	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH
  00154	5f		 pop	 edi
  00155	5b		 pop	 ebx
  00156	5e		 pop	 esi

; 12997: 	}
; 12998: }

  00157	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015a	33 cd		 xor	 ecx, ebp
  0015c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
$LN57@CGBeattack:

; 12665: 		return;
; 12666: 	}
; 12667: 
; 12668: 	// Avoid use Skill of the following types
; 12669: 	if ( lpMagic->m_Skill == AT_SKILL_BLOWOFFURY ||
; 12670: 		 lpMagic->m_Skill == AT_SKILL_STRIKE ||
; 12671: 		 g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == AT_MSKILL_DK_DEATHSTAB1 ||
; 12672: 		 g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == AT_MSKILL_DK_RAGEFULBLOW1 ||
; 12673: 		 lpMagic->m_Skill == AT_MSKILL_DK_RAGEFULBLOW2 ||
; 12674: 		 lpMagic->m_Skill == AT_MSKILL_DK_TWISTINGSLASH2 ||
; 12675: 		 lpMagic->m_Skill == AT_SKILL_WHEEL ||
; 12676: 		 lpMagic->m_Skill == AT_MSKILL_DK_TWISTINGSLASH1 )	

  00165	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00168	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0016b	0f 84 9f 08 00
	00		 je	 $LN90@CGBeattack
  00171	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00174	0f 84 96 08 00
	00		 je	 $LN90@CGBeattack
  0017a	50		 push	 eax
  0017b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00180	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00185	3d 50 01 00 00	 cmp	 eax, 336		; 00000150H
  0018a	0f 84 80 08 00
	00		 je	 $LN90@CGBeattack
  00190	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00193	52		 push	 edx
  00194	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00199	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  0019e	3d 4b 01 00 00	 cmp	 eax, 331		; 0000014bH
  001a3	0f 84 67 08 00
	00		 je	 $LN90@CGBeattack
  001a9	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  001ac	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  001b1	0f 84 59 08 00
	00		 je	 $LN90@CGBeattack
  001b7	3d 4c 01 00 00	 cmp	 eax, 332		; 0000014cH
  001bc	0f 84 4e 08 00
	00		 je	 $LN90@CGBeattack
  001c2	83 f8 29	 cmp	 eax, 41			; 00000029H
  001c5	0f 84 45 08 00
	00		 je	 $LN90@CGBeattack
  001cb	3d 4a 01 00 00	 cmp	 eax, 330		; 0000014aH
  001d0	0f 84 3a 08 00
	00		 je	 $LN90@CGBeattack

; 12677: 	{
; 12678: 		return;
; 12679: 	}
; 12680: 
; 12681: 	if ( gObj[aIndex].Type == OBJ_USER )

  001d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001dc	80 7c 13 50 01	 cmp	 BYTE PTR [ebx+edx+80], 1
  001e1	0f 85 e8 00 00
	00		 jne	 $LN54@CGBeattack

; 12682: 	{
; 12683: 		// Check if Player can use Magic
; 12684: 		// Acording to its Class
; 12685: 		if ( MagicDamageC.SkillGetRequireClass(gObj[aIndex].Class,
; 12686: 												gObj[aIndex].ChangeUP,
; 12687: 												gObj[aIndex].ChangeUP2,
; 12688: 												lpMagic->m_Skill) < 1 )

  001e7	0f b6 8c 13 93
	00 00 00	 movzx	 ecx, BYTE PTR [ebx+edx+147]
  001ef	50		 push	 eax
  001f0	0f b6 84 13 94
	00 00 00	 movzx	 eax, BYTE PTR [ebx+edx+148]
  001f8	0f b7 94 13 90
	00 00 00	 movzx	 edx, WORD PTR [ebx+edx+144]
  00200	50		 push	 eax
  00201	51		 push	 ecx
  00202	52		 push	 edx
  00203	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00208	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z ; CMagicDamage::SkillGetRequireClass
  0020d	83 f8 01	 cmp	 eax, 1
  00210	7d 45		 jge	 SHORT $LN53@CGBeattack

; 12689: 		{
; 12690: 			// It's not his magic [%s][%s] .
; 12691: 			LogAddC(2, lMsg.Get(MSGGET(1, 239)),
; 12692: 				gObj[aIndex].AccountID,
; 12693: 				gObj[aIndex].Name,
; 12694: 				lpMagic->m_Skill);	// #error Deathway change on WTFFile

  00212	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00217	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0021a	51		 push	 ecx
  0021b	8d 54 03 5d	 lea	 edx, DWORD PTR [ebx+eax+93]
  0021f	52		 push	 edx
  00220	8d 44 03 52	 lea	 eax, DWORD PTR [ebx+eax+82]
  00224	50		 push	 eax
  00225	68 ef 01 00 00	 push	 495			; 000001efH
  0022a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0022f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00234	50		 push	 eax
  00235	6a 02		 push	 2
  00237	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 12695: 
; 12696: 			gObjUserKill(aIndex);

  0023d	56		 push	 esi
  0023e	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  00243	83 c4 18	 add	 esp, 24			; 00000018H
  00246	5f		 pop	 edi
  00247	5b		 pop	 ebx
  00248	5e		 pop	 esi

; 12997: 	}
; 12998: }

  00249	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024c	33 cd		 xor	 ecx, ebp
  0024e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00253	8b e5		 mov	 esp, ebp
  00255	5d		 pop	 ebp
  00256	c3		 ret	 0
$LN53@CGBeattack:

; 12697: 			return;
; 12698: 		}
; 12699: 
; 12700: 		// Check the time cast Spell
; 12701: 		// No longer that 8 seconds
; 12702: 		if ( (GetTickCount()- gObj[aIndex].UseMagicTime) > 8000 )

  00257	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0025d	8d 34 0b	 lea	 esi, DWORD PTR [ebx+ecx]
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00266	2b 86 b0 06 00
	00		 sub	 eax, DWORD PTR [esi+1712]
  0026c	3d 40 1f 00 00	 cmp	 eax, 8000		; 00001f40H
  00271	76 43		 jbe	 SHORT $LN52@CGBeattack

; 12703: 		{
; 12704: 			LogAddC(2, "Too long time passed after casting magic. [%s][%s] (%d)(%d)",
; 12705: 				gObj[aIndex].AccountID,
; 12706: 				gObj[aIndex].Name,
; 12707: 				lpMagic->m_Skill,
; 12708: 				GetTickCount() - gObj[aIndex].UseMagicTime);

  00273	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00279	8d 34 13	 lea	 esi, DWORD PTR [ebx+edx]
  0027c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00282	2b 86 b0 06 00
	00		 sub	 eax, DWORD PTR [esi+1712]
  00288	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  0028b	50		 push	 eax
  0028c	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0028f	50		 push	 eax
  00290	51		 push	 ecx
  00291	83 c6 52	 add	 esi, 82			; 00000052H
  00294	56		 push	 esi
  00295	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@
  0029a	6a 02		 push	 2
  0029c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002a2	83 c4 18	 add	 esp, 24			; 00000018H
  002a5	5f		 pop	 edi
  002a6	5b		 pop	 ebx
  002a7	5e		 pop	 esi

; 12997: 	}
; 12998: }

  002a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ab	33 cd		 xor	 ecx, ebp
  002ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b2	8b e5		 mov	 esp, ebp
  002b4	5d		 pop	 ebp
  002b5	c3		 ret	 0
$LN52@CGBeattack:

; 12709: 
; 12710: 			return;
; 12711: 		}
; 12712: 
; 12713: 		// Check if user cast to much Spells
; 12714: 		// Npo longer thant 4
; 12715: 		if ( gObj[aIndex].UseMagicCount > 4 )

  002b6	80 be b4 06 00
	00 04		 cmp	 BYTE PTR [esi+1716], 4
  002bd	0f 8f 4d 07 00
	00		 jg	 $LN90@CGBeattack

; 12716: 		{
; 12717: 			return;
; 12718: 		}
; 12719: 
; 12720: 		gObj[aIndex].UseMagicCount++;

  002c3	fe 86 b4 06 00
	00		 inc	 BYTE PTR [esi+1716]
  002c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN54@CGBeattack:

; 12721: 	}
; 12722: 
; 12723: 	if (	lpMagic->m_Skill != AT_SKILL_STORM
; 12724: 		  && lpMagic->m_Skill != AT_SKILL_EVIL
; 12725: 		  && lpMagic->m_Skill != AT_SKILL_HELL
; 12726: 		  && lpMagic->m_Skill != AT_SKILL_BLAST
; 12727: 		  && lpMagic->m_Skill != AT_SKILL_INFERNO
; 12728: 		  && lpMagic->m_Skill != AT_SKILL_FLAME
; 12729: 		  && lpMagic->m_Skill != AT_SKILL_CROSSBOW
; 12730: 		  && lpMagic->m_Skill != AT_SKILL_DEVILFIRE
; 12731: 		  && lpMagic->m_Skill != AT_SKILL_FLASH
; 12732: 		  && lpMagic->m_Skill != AT_SKILL_WHEEL
; 12733: 		  && lpMagic->m_Skill != AT_SKILL_KNIGHTSPEAR
; 12734: 		  && lpMagic->m_Skill != AT_SKILL_STRIKE
; 12735: 		  && lpMagic->m_Skill != AT_SKILL_BLOWOFFURY
; 12736: 		  && lpMagic->m_Skill != AT_SKILL_PENETRATION
; 12737: 		  && lpMagic->m_Skill != AT_SKILL_DEFENSEDOWN
; 12738: 		  && lpMagic->m_Skill != AT_SKILL_FIRESCREAM 
; 12739: 		  // MSKILL
; 12740: 		  && lpMagic->m_Skill != AT_MSKILL_DW_FLAME1
; 12741: 		  && lpMagic->m_Skill != AT_MSKILL_DW_BLAST1
; 12742: 		  && lpMagic->m_Skill != AT_MSKILL_DW_INFERNO1
; 12743: 		  && lpMagic->m_Skill != AT_MSKILL_DW_HELLFIRE1
; 12744: 		  && lpMagic->m_Skill != AT_MSKILL_DW_EVILSPIRIT1
; 12745: 		  && lpMagic->m_Skill != AT_MSKILL_FE_TRIPLESHOT1
; 12746: 		  && lpMagic->m_Skill != AT_MSKILL_FE_TRIPLESHOT2
; 12747: 		  && lpMagic->m_Skill != AT_MSKILL_FE_PENETRATION1
; 12748: 		  && lpMagic->m_Skill != AT_MSKILL_DK_TWISTINGSLASH1
; 12749: 		  && lpMagic->m_Skill != AT_MSKILL_DK_TWISTINGSLASH2
; 12750: 		  && lpMagic->m_Skill != AT_MSKILL_MG_TWISTINGSLASH1
; 12751: 		  && lpMagic->m_Skill != AT_MSKILL_DK_RAGEFULBLOW1
; 12752: 		  && lpMagic->m_Skill != AT_MSKILL_DK_RAGEFULBLOW2
; 12753: 		  && lpMagic->m_Skill != AT_MSKILL_MG_FLAME1
; 12754: 		  && lpMagic->m_Skill != AT_MSKILL_MG_BLAST1
; 12755: 		  && lpMagic->m_Skill != AT_MSKILL_MG_INFERNO1
; 12756: 		  && lpMagic->m_Skill != AT_MSKILL_MG_EVILSPIRIT1
; 12757: 		  && lpMagic->m_Skill != AT_MSKILL_MG_FIRESLASH1
; 12758: 		  && lpMagic->m_Skill != AT_MSKILL_MG_FIRESLASH2
; 12759: 		  && lpMagic->m_Skill != AT_MSKILL_DL_FIRESCREAM1 
; 12760: 		  && lpMagic->m_Skill != AT_MSKILL_DL_FIRESCREAM2 )

  002cf	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  002d2	83 f8 08	 cmp	 eax, 8
  002d5	0f 84 2a 01 00
	00		 je	 $LN50@CGBeattack
  002db	83 f8 09	 cmp	 eax, 9
  002de	0f 84 21 01 00
	00		 je	 $LN50@CGBeattack
  002e4	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  002e7	0f 84 18 01 00
	00		 je	 $LN50@CGBeattack
  002ed	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  002f0	0f 84 0f 01 00
	00		 je	 $LN50@CGBeattack
  002f6	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  002f9	0f 84 06 01 00
	00		 je	 $LN50@CGBeattack
  002ff	83 f8 05	 cmp	 eax, 5
  00302	0f 84 fd 00 00
	00		 je	 $LN50@CGBeattack
  00308	83 f8 18	 cmp	 eax, 24			; 00000018H
  0030b	0f 84 1e 01 00
	00		 je	 $LN48@CGBeattack
  00311	83 f8 32	 cmp	 eax, 50			; 00000032H
  00314	0f 84 eb 00 00
	00		 je	 $LN50@CGBeattack
  0031a	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0031d	0f 84 e2 00 00
	00		 je	 $LN50@CGBeattack
  00323	83 f8 29	 cmp	 eax, 41			; 00000029H
  00326	0f 84 d9 00 00
	00		 je	 $LN50@CGBeattack
  0032c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0032f	0f 84 d0 00 00
	00		 je	 $LN50@CGBeattack
  00335	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00338	0f 84 c7 00 00
	00		 je	 $LN50@CGBeattack
  0033e	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00341	0f 84 be 00 00
	00		 je	 $LN50@CGBeattack
  00347	83 f8 34	 cmp	 eax, 52			; 00000034H
  0034a	0f 84 b5 00 00
	00		 je	 $LN50@CGBeattack
  00350	83 f8 37	 cmp	 eax, 55			; 00000037H
  00353	0f 84 ac 00 00
	00		 je	 $LN50@CGBeattack
  00359	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  0035c	0f 84 a3 00 00
	00		 je	 $LN50@CGBeattack
  00362	3d 7a 01 00 00	 cmp	 eax, 378		; 0000017aH
  00367	0f 84 98 00 00
	00		 je	 $LN50@CGBeattack
  0036d	3d 7e 01 00 00	 cmp	 eax, 382		; 0000017eH
  00372	0f 84 8d 00 00
	00		 je	 $LN50@CGBeattack
  00378	3d 7d 01 00 00	 cmp	 eax, 381		; 0000017dH
  0037d	0f 84 82 00 00
	00		 je	 $LN50@CGBeattack
  00383	3d 84 01 00 00	 cmp	 eax, 388		; 00000184H
  00388	74 7b		 je	 SHORT $LN50@CGBeattack
  0038a	3d 81 01 00 00	 cmp	 eax, 385		; 00000181H
  0038f	74 74		 je	 SHORT $LN50@CGBeattack
  00391	3d 9e 01 00 00	 cmp	 eax, 414		; 0000019eH
  00396	74 6d		 je	 SHORT $LN50@CGBeattack
  00398	3d a2 01 00 00	 cmp	 eax, 418		; 000001a2H
  0039d	74 66		 je	 SHORT $LN50@CGBeattack
  0039f	3d a0 01 00 00	 cmp	 eax, 416		; 000001a0H
  003a4	74 5f		 je	 SHORT $LN50@CGBeattack
  003a6	3d 4a 01 00 00	 cmp	 eax, 330		; 0000014aH
  003ab	74 58		 je	 SHORT $LN50@CGBeattack
  003ad	3d 4c 01 00 00	 cmp	 eax, 332		; 0000014cH
  003b2	74 51		 je	 SHORT $LN50@CGBeattack
  003b4	3d e1 01 00 00	 cmp	 eax, 481		; 000001e1H
  003b9	74 4a		 je	 SHORT $LN50@CGBeattack
  003bb	3d 4b 01 00 00	 cmp	 eax, 331		; 0000014bH
  003c0	74 43		 je	 SHORT $LN50@CGBeattack
  003c2	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  003c7	74 3c		 je	 SHORT $LN50@CGBeattack
  003c9	3d e3 01 00 00	 cmp	 eax, 483		; 000001e3H
  003ce	74 35		 je	 SHORT $LN50@CGBeattack
  003d0	3d e4 01 00 00	 cmp	 eax, 484		; 000001e4H
  003d5	74 2e		 je	 SHORT $LN50@CGBeattack
  003d7	3d e6 01 00 00	 cmp	 eax, 486		; 000001e6H
  003dc	74 27		 je	 SHORT $LN50@CGBeattack
  003de	3d e7 01 00 00	 cmp	 eax, 487		; 000001e7H
  003e3	74 20		 je	 SHORT $LN50@CGBeattack
  003e5	3d ea 01 00 00	 cmp	 eax, 490		; 000001eaH
  003ea	74 19		 je	 SHORT $LN50@CGBeattack
  003ec	3d ed 01 00 00	 cmp	 eax, 493		; 000001edH
  003f1	74 12		 je	 SHORT $LN50@CGBeattack
  003f3	3d 06 02 00 00	 cmp	 eax, 518		; 00000206H
  003f8	74 0b		 je	 SHORT $LN50@CGBeattack
  003fa	3d 08 02 00 00	 cmp	 eax, 520		; 00000208H
  003ff	0f 85 0b 06 00
	00		 jne	 $LN90@CGBeattack
$LN50@CGBeattack:

; 12761: 	{
; 12762: 		//LogAdd("error-L3 Skill:[%d] %s %d ", lpMagic->m_Skill, __FILE__, __LINE__);
; 12763: 		return;
; 12764: 	}
; 12765: 
; 12766: 	if ( lpMagic->m_Skill == AT_SKILL_CROSSBOW || lpMagic->m_Skill == AT_SKILL_FIRESCREAM ||
; 12767: 		 lpMagic->m_Skill == AT_MSKILL_FE_TRIPLESHOT1 || lpMagic->m_Skill == AT_MSKILL_FE_TRIPLESHOT2 ||
; 12768: 		 lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM1 || lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM2 )

  00405	83 f8 18	 cmp	 eax, 24			; 00000018H
  00408	74 25		 je	 SHORT $LN48@CGBeattack
  0040a	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  0040d	74 20		 je	 SHORT $LN48@CGBeattack
  0040f	3d 9e 01 00 00	 cmp	 eax, 414		; 0000019eH
  00414	74 19		 je	 SHORT $LN48@CGBeattack
  00416	3d a2 01 00 00	 cmp	 eax, 418		; 000001a2H
  0041b	74 12		 je	 SHORT $LN48@CGBeattack
  0041d	3d 06 02 00 00	 cmp	 eax, 518		; 00000206H
  00422	74 0b		 je	 SHORT $LN48@CGBeattack
  00424	3d 08 02 00 00	 cmp	 eax, 520		; 00000208H
  00429	0f 85 74 01 00
	00		 jne	 $LN87@CGBeattack
$LN48@CGBeattack:

; 12769: 	{
; 12770: 		int NSAttackSerial = lpCount->Serial;
; 12771: 
; 12772: 		if ( gObj[aIndex].OSAttackSerial >= 255 && (gObj[aIndex].OSAttackSerial - lpCount->Serial) > 50 )

  0042f	0f b7 8c 13 b6
	06 00 00	 movzx	 ecx, WORD PTR [ebx+edx+1718]
  00437	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$[ebp]
  0043d	0f b6 40 07	 movzx	 eax, BYTE PTR [eax+7]
  00441	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
  00446	66 3b ce	 cmp	 cx, si
  00449	7c 1b		 jl	 SHORT $LN47@CGBeattack
  0044b	0f bf c9	 movsx	 ecx, cx
  0044e	2b c8		 sub	 ecx, eax
  00450	83 f9 32	 cmp	 ecx, 50			; 00000032H
  00453	7e 11		 jle	 SHORT $LN47@CGBeattack

; 12773: 		{
; 12774: 			gObj[aIndex].OSAttackSerial = -1;

  00455	83 c9 ff	 or	 ecx, -1
  00458	66 89 8c 13 b6
	06 00 00	 mov	 WORD PTR [ebx+edx+1718], cx
  00460	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN47@CGBeattack:

; 12775: 		}
; 12776: 	
; 12777: 		if ( NSAttackSerial > gObj[aIndex].OSAttackSerial )

  00466	0f bf 8c 13 b6
	06 00 00	 movsx	 ecx, WORD PTR [ebx+edx+1718]
  0046e	3b c1		 cmp	 eax, ecx
  00470	0f 8e 2d 01 00
	00		 jle	 $LN87@CGBeattack

; 12778: 		{
; 12779: 			gObj[aIndex].OSAttackSerial = NSAttackSerial;

  00476	66 89 84 13 b6
	06 00 00	 mov	 WORD PTR [ebx+edx+1718], ax

; 12780: 			LPOBJ lpObj = &gObj[aIndex];

  0047e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00484	8d 34 13	 lea	 esi, DWORD PTR [ebx+edx]

; 12781: 			int iTimeCalc = GetTickCount() - lpObj->m_LastAttackTime;

  00487	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0048d	2b 86 5c 05 00
	00		 sub	 eax, DWORD PTR [esi+1372]

; 12782: 
; 12783: 			if ( iTimeCalc < lpObj->m_DetectSpeedHackTime && iTimeCalc != 0)

  00493	8b 8e 64 05 00
	00		 mov	 ecx, DWORD PTR [esi+1380]
  00499	3b c1		 cmp	 eax, ecx
  0049b	0f 8d e2 00 00
	00		 jge	 $LN84@CGBeattack
  004a1	85 c0		 test	 eax, eax
  004a3	0f 84 da 00 00
	00		 je	 $LN84@CGBeattack

; 12784: 			{
; 12785: 				lpObj->m_DetectCount++;

  004a9	ff 86 6c 05 00
	00		 inc	 DWORD PTR [esi+1388]
  004af	8b 96 6c 05 00
	00		 mov	 edx, DWORD PTR [esi+1388]

; 12786: 				lpObj->m_SumLastAttackTime += iTimeCalc;

  004b5	01 86 68 05 00
	00		 add	 DWORD PTR [esi+1384], eax
  004bb	8b 86 68 05 00
	00		 mov	 eax, DWORD PTR [esi+1384]

; 12787: 
; 12788: 				if ( lpObj->m_DetectCount > gHackCheckCount )

  004c1	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gHackCheckCount@@3KA ; gHackCheckCount
  004c7	0f 86 a8 00 00
	00		 jbe	 $LN44@CGBeattack

; 12789: 				{
; 12790: 					lpObj->m_DetectedHackKickCount++;

  004cd	ff 86 70 05 00
	00		 inc	 DWORD PTR [esi+1392]

; 12791: 
; 12792: 					if ( gIsKickDetecHackCountLimit )

  004d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsKickDetecHackCountLimit@@3HA, 0 ; gIsKickDetecHackCountLimit
  004da	8b 96 70 05 00
	00		 mov	 edx, DWORD PTR [esi+1392]
  004e0	74 54		 je	 SHORT $LN42@CGBeattack

; 12793: 					{
; 12794: 						if ( lpObj->m_DetectedHackKickCount > gDetectedHackKickCount )

  004e2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gDetectedHackKickCount@@3HA ; gDetectedHackKickCount
  004e8	7e 4c		 jle	 SHORT $LN42@CGBeattack

; 12795: 						{
; 12796: 							LogAddTD("[%s][%s] %s Kick DetecHackCountLimit Over User (%d)",
; 12797: 								lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 12798: 								lpObj->m_DetectedHackKickCount);

  004ea	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  004f1	52		 push	 edx
  004f2	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  004f7	50		 push	 eax
  004f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  004fd	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00502	50		 push	 eax
  00503	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  00506	51		 push	 ecx
  00507	83 c6 52	 add	 esi, 82			; 00000052H
  0050a	56		 push	 esi
  0050b	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@
  00510	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12799: 
; 12800: 							CloseClient(aIndex);

  00516	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0051c	52		 push	 edx
  0051d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00522	83 c4 18	 add	 esp, 24			; 00000018H
  00525	5f		 pop	 edi
  00526	5b		 pop	 ebx
  00527	5e		 pop	 esi

; 12997: 	}
; 12998: }

  00528	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0052b	33 cd		 xor	 ecx, ebp
  0052d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00532	8b e5		 mov	 esp, ebp
  00534	5d		 pop	 ebp
  00535	c3		 ret	 0
$LN42@CGBeattack:

; 12801: 							return;
; 12802: 						}
; 12803: 					}
; 12804: 
; 12805: 					LogAddTD("[%s][%s] %s Attack Speed Is Wrong Magic3 (%d)(%d) Penalty %d",
; 12806: 						lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 12807: 						lpObj->m_DetectSpeedHackTime,lpObj->m_SumLastAttackTime/lpObj->m_DetectCount,
; 12808: 						lpObj->m_SpeedHackPenalty);

  00536	8b 96 74 05 00
	00		 mov	 edx, DWORD PTR [esi+1396]
  0053c	52		 push	 edx
  0053d	33 d2		 xor	 edx, edx
  0053f	f7 b6 6c 05 00
	00		 div	 DWORD PTR [esi+1388]
  00545	50		 push	 eax
  00546	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  0054d	51		 push	 ecx
  0054e	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  00553	50		 push	 eax
  00554	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00559	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0055e	50		 push	 eax
  0055f	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  00562	51		 push	 ecx
  00563	8d 56 52	 lea	 edx, DWORD PTR [esi+82]
  00566	52		 push	 edx
  00567	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
  0056c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00572	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN44@CGBeattack:

; 12809: 				}
; 12810: 
; 12811: 				lpObj->m_LastAttackTime = GetTickCount();

  00575	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0057b	89 86 5c 05 00
	00		 mov	 DWORD PTR [esi+1372], eax

; 12812: 			}
; 12813: 			else

  00581	eb 0e		 jmp	 SHORT $LN41@CGBeattack
$LN84@CGBeattack:

; 12814: 			{
; 12815: 				lpObj->m_SumLastAttackTime = 0;

  00583	33 c0		 xor	 eax, eax
  00585	89 86 68 05 00
	00		 mov	 DWORD PTR [esi+1384], eax

; 12816: 				lpObj->m_DetectCount = 0;

  0058b	89 86 6c 05 00
	00		 mov	 DWORD PTR [esi+1388], eax
$LN41@CGBeattack:

; 12817: 			}
; 12818: 
; 12819: 			lpObj->m_LastAttackTime = GetTickCount();

  00591	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00597	89 86 5c 05 00
	00		 mov	 DWORD PTR [esi+1372], eax
  0059d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN87@CGBeattack:

; 12820: 		}
; 12821: 	}
; 12822: 
; 12823: 	if ( lpMagic->m_Skill == AT_SKILL_EVIL ||
; 12824: 		 lpMagic->m_Skill == AT_MSKILL_DW_EVILSPIRIT1 ||
; 12825: 		 lpMagic->m_Skill == AT_MSKILL_MG_EVILSPIRIT1 )

  005a3	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  005a6	83 f8 09	 cmp	 eax, 9
  005a9	74 0e		 je	 SHORT $LN39@CGBeattack
  005ab	3d 81 01 00 00	 cmp	 eax, 385		; 00000181H
  005b0	74 07		 je	 SHORT $LN39@CGBeattack
  005b2	3d e7 01 00 00	 cmp	 eax, 487		; 000001e7H
  005b7	75 16		 jne	 SHORT $LN89@CGBeattack
$LN39@CGBeattack:

; 12826: 	{
; 12827: 		if( gObj[aIndex].Class != CLASS_WIZARD &&
; 12828: 			gObj[aIndex].Class != CLASS_MAGUMSA )

  005b9	0f b7 84 13 90
	00 00 00	 movzx	 eax, WORD PTR [ebx+edx+144]
  005c1	66 85 c0	 test	 ax, ax
  005c4	74 09		 je	 SHORT $LN89@CGBeattack
  005c6	83 f8 03	 cmp	 eax, 3
  005c9	0f 85 41 04 00
	00		 jne	 $LN90@CGBeattack
$LN89@CGBeattack:

; 12829: 		{
; 12830: 			return;
; 12831: 		}
; 12832: 	}
; 12833: 
; 12834: 
; 12835: 	if ( bIsIgnorePacketSpeedHackDetect )

  005cf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  005d6	74 55		 je	 SHORT $LN85@CGBeattack

; 12836: 	{
; 12837: 		LPOBJ lpObj = &gObj[aIndex];
; 12838: 
; 12839: 		if ( lpObj->m_SpeedHackPenalty > 0 )

  005d8	8b 84 13 74 05
	00 00		 mov	 eax, DWORD PTR [ebx+edx+1396]
  005df	8d 34 13	 lea	 esi, DWORD PTR [ebx+edx]
  005e2	85 c0		 test	 eax, eax
  005e4	7e 47		 jle	 SHORT $LN85@CGBeattack

; 12840: 		{
; 12841: 			lpObj->m_SpeedHackPenalty--;

  005e6	48		 dec	 eax

; 12842: 			
; 12843: 			LogAddTD("[%s][%s] %s Apply Attack Speed Penalty (%d left)",
; 12844: 				lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 12845: 				lpObj->m_SpeedHackPenalty);

  005e7	50		 push	 eax
  005e8	89 86 74 05 00
	00		 mov	 DWORD PTR [esi+1396], eax
  005ee	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  005f5	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  005fa	50		 push	 eax
  005fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00600	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00605	50		 push	 eax
  00606	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  00609	51		 push	 ecx
  0060a	83 c6 52	 add	 esi, 82			; 00000052H
  0060d	56		 push	 esi
  0060e	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@
  00613	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12943: 
; 12944: 					CloseClient(gObj[aIndex].m_Index);

  00619	83 c4 14	 add	 esp, 20			; 00000014H
  0061c	5f		 pop	 edi
  0061d	5b		 pop	 ebx
  0061e	5e		 pop	 esi

; 12997: 	}
; 12998: }

  0061f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00622	33 cd		 xor	 ecx, ebp
  00624	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00629	8b e5		 mov	 esp, ebp
  0062b	5d		 pop	 ebp
  0062c	c3		 ret	 0
$LN85@CGBeattack:

; 12846: 
; 12847: 			return;
; 12848: 		}
; 12849: 	}
; 12850: 	
; 12851: 	int lOfs2 = lOfs;
; 12852: 	int pTargetNumber[128];
; 12853: 
; 12854: 	int i;
; 12855: 	int n;
; 12856: 	
; 12857: 	for (i=0;i<lpCount->Count;i++)

  0062d	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$[ebp]
  00633	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00637	33 c9		 xor	 ecx, ecx
  00639	85 d2		 test	 edx, edx
  0063b	7e 2c		 jle	 SHORT $LN33@CGBeattack
  0063d	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00641	83 c0 09	 add	 eax, 9
$LL35@CGBeattack:

; 12858: 	{
; 12859: 		lpMsg = (PMSG_BEATTACK *)&lpRecv[lOfs2];
; 12860: 		pTargetNumber[i] = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00644	0f b6 30	 movzx	 esi, BYTE PTR [eax]
  00647	0f b6 58 02	 movzx	 ebx, BYTE PTR [eax+2]
  0064b	66 c1 e6 08	 shl	 si, 8
  0064f	0f b7 f6	 movzx	 esi, si
  00652	0b f3		 or	 esi, ebx
  00654	89 b4 8d fc fd
	ff ff		 mov	 DWORD PTR _pTargetNumber$[ebp+ecx*4], esi
  0065b	41		 inc	 ecx

; 12861: 		lOfs2 += sizeof(PMSG_BEATTACK);

  0065c	83 c0 03	 add	 eax, 3
  0065f	3b ca		 cmp	 ecx, edx
  00661	7c e1		 jl	 SHORT $LL35@CGBeattack

; 12846: 
; 12847: 			return;
; 12848: 		}
; 12849: 	}
; 12850: 	
; 12851: 	int lOfs2 = lOfs;
; 12852: 	int pTargetNumber[128];
; 12853: 
; 12854: 	int i;
; 12855: 	int n;
; 12856: 	
; 12857: 	for (i=0;i<lpCount->Count;i++)

  00663	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$[ebp]
$LN33@CGBeattack:

; 12862: 	}
; 12863: 
; 12864: 	for (n=0;n<lpCount->Count;n++)

  00669	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0066d	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  00677	85 c9		 test	 ecx, ecx
  00679	0f 8e 91 03 00
	00		 jle	 $LN90@CGBeattack
  0067f	83 c0 09	 add	 eax, 9
  00682	89 85 f8 fd ff
	ff		 mov	 DWORD PTR tv1574[ebp], eax
  00688	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL32@CGBeattack:

; 12865: 	{
; 12866: 		lpMsg = (PMSG_BEATTACK *)&lpRecv[lOfs];
; 12867: 		tNumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00690	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR tv1574[ebp]
  00696	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00699	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]

; 12868: 		LPOBJ lpObj = &gObj[aIndex];

  0069d	8b 9d f4 fd ff
	ff		 mov	 ebx, DWORD PTR tv1044[ebp]

; 12869: 
; 12870: 		if ( lpMsg->MagicKey == FALSE && 
; 12871: 			(lpMagic->m_Skill == AT_SKILL_EVIL ||
; 12872: 			 lpMagic->m_Skill == AT_MSKILL_MG_EVILSPIRIT1 ||
; 12873: 			 lpMagic->m_Skill == AT_MSKILL_DW_EVILSPIRIT1 ) )

  006a3	8a 40 01	 mov	 al, BYTE PTR [eax+1]
  006a6	66 c1 e2 08	 shl	 dx, 8
  006aa	0f b7 f2	 movzx	 esi, dx
  006ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006b3	0b f1		 or	 esi, ecx
  006b5	03 da		 add	 ebx, edx
  006b7	84 c0		 test	 al, al
  006b9	75 2c		 jne	 SHORT $LN96@CGBeattack
  006bb	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  006be	83 f9 09	 cmp	 ecx, 9
  006c1	0f 84 49 03 00
	00		 je	 $LN90@CGBeattack
  006c7	81 f9 e7 01 00
	00		 cmp	 ecx, 487		; 000001e7H
  006cd	0f 84 3d 03 00
	00		 je	 $LN90@CGBeattack
  006d3	81 f9 81 01 00
	00		 cmp	 ecx, 385		; 00000181H
  006d9	0f 84 31 03 00
	00		 je	 $LN90@CGBeattack

; 12874: 		{
; 12875: 			return;
; 12876: 		}
; 12877: 
; 12878: 		if ( lpMsg->MagicKey  && 
; 12879: 			(lpMagic->m_Skill == AT_SKILL_EVIL ||
; 12880: 			 lpMagic->m_Skill == AT_MSKILL_DW_EVILSPIRIT1 ||
; 12881: 			 lpMagic->m_Skill == AT_MSKILL_MG_EVILSPIRIT1 ) )

  006df	84 c0		 test	 al, al
  006e1	0f 84 ee 00 00
	00		 je	 $LN22@CGBeattack
$LN96@CGBeattack:
  006e7	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  006ea	83 f9 09	 cmp	 ecx, 9
  006ed	74 14		 je	 SHORT $LN26@CGBeattack
  006ef	81 f9 81 01 00
	00		 cmp	 ecx, 385		; 00000181H
  006f5	74 0c		 je	 SHORT $LN26@CGBeattack
  006f7	81 f9 e7 01 00
	00		 cmp	 ecx, 487		; 000001e7H
  006fd	0f 85 d2 00 00
	00		 jne	 $LN22@CGBeattack
$LN26@CGBeattack:

; 12882: 		{
; 12883: 			if ( lpObj->DurMagicKeyChecker.IsValidDurationTime(lpMsg->MagicKey) == FALSE )

  00703	8d 8b d8 14 00
	00		 lea	 ecx, DWORD PTR [ebx+5336]
  00709	50		 push	 eax
  0070a	89 8d e4 fd ff
	ff		 mov	 DWORD PTR tv1231[ebp], ecx
  00710	e8 00 00 00 00	 call	 ?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::IsValidDurationTime
  00715	85 c0		 test	 eax, eax
  00717	75 42		 jne	 SHORT $LN25@CGBeattack

; 12884: 			{
; 12885: 				LogAddC(0, " InValid DurationTime Key = %d ( Time : %d) [%s][%s]",
; 12886: 					lpMsg->MagicKey, lpObj->DurMagicKeyChecker.GetValidDurationTime(lpMsg->MagicKey),
; 12887: 					lpObj->AccountID, lpObj->Name); 

  00719	8b b5 f8 fd ff
	ff		 mov	 esi, DWORD PTR tv1574[ebp]
  0071f	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00723	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1231[ebp]
  00729	8d 53 5d	 lea	 edx, DWORD PTR [ebx+93]
  0072c	52		 push	 edx
  0072d	83 c3 52	 add	 ebx, 82			; 00000052H
  00730	53		 push	 ebx
  00731	50		 push	 eax
  00732	e8 00 00 00 00	 call	 ?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidDurationTime
  00737	50		 push	 eax
  00738	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  0073c	50		 push	 eax
  0073d	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@PFIDPOLC@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@
$LN100@CGBeattack:
  00742	6a 00		 push	 0
  00744	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0074a	83 c4 18	 add	 esp, 24			; 00000018H

; 12888: 				lOfs += sizeof(PMSG_BEATTACK);

  0074d	83 c6 03	 add	 esi, 3
  00750	89 b5 f8 fd ff
	ff		 mov	 DWORD PTR tv1574[ebp], esi

; 12889: 
; 12890: 				continue;

  00756	e9 3e 02 00 00	 jmp	 $LN31@CGBeattack
$LN25@CGBeattack:

; 12891: 			}
; 12892: 			
; 12893: 			if ( lpObj->DurMagicKeyChecker.IsValidCount(lpMsg->MagicKey) == FALSE )

  0075b	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR tv1574[ebp]
  00761	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00764	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00767	80 fa 3b	 cmp	 dl, 59			; 0000003bH
  0076a	76 27		 jbe	 SHORT $LN24@CGBeattack

; 12894: 			{
; 12895: 				LogAddC(0, " InValid VailidCount = %d ( Count : %d) [%s][%s]",
; 12896: 					lpMsg->MagicKey, lpObj->DurMagicKeyChecker.GetValidCount(lpMsg->MagicKey),
; 12897: 					lpObj->AccountID, lpObj->Name); 

  0076c	8d 4b 5d	 lea	 ecx, DWORD PTR [ebx+93]
  0076f	51		 push	 ecx
  00770	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1231[ebp]
  00776	83 c3 52	 add	 ebx, 82			; 00000052H
  00779	53		 push	 ebx
  0077a	50		 push	 eax
  0077b	e8 00 00 00 00	 call	 ?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidCount
  00780	8b b5 f8 fd ff
	ff		 mov	 esi, DWORD PTR tv1574[ebp]
  00786	0f b6 56 01	 movzx	 edx, BYTE PTR [esi+1]
  0078a	50		 push	 eax
  0078b	52		 push	 edx
  0078c	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@COJBHLGO@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@

; 12898: 				lOfs += sizeof(PMSG_BEATTACK);
; 12899: 
; 12900: 				continue;

  00791	eb af		 jmp	 SHORT $LN100@CGBeattack
$LN24@CGBeattack:

; 12901: 			}
; 12902: 
; 12903: 			if ( OBJMAX_RANGE( tNumber ) == FALSE)

  00793	85 f6		 test	 esi, esi
  00795	0f 88 fe 01 00
	00		 js	 $LN31@CGBeattack
  0079b	33 c0		 xor	 eax, eax
  0079d	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  007a3	0f 9e c0	 setle	 al
  007a6	85 c0		 test	 eax, eax
  007a8	0f 84 eb 01 00
	00		 je	 $LN31@CGBeattack

; 12904: 			{
; 12905: 				continue;
; 12906: 			}
; 12907: 
; 12908: 			int Dis = gObjCalDistance(lpObj,&gObj[tNumber]);

  007ae	8b c6		 mov	 eax, esi
  007b0	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  007b6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007bc	50		 push	 eax
  007bd	53		 push	 ebx
  007be	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  007c3	83 c4 08	 add	 esp, 8

; 12909: 
; 12910: 			if( Dis > 13 )

  007c6	83 f8 0d	 cmp	 eax, 13			; 0000000dH

; 12911: 			{
; 12912: 				lOfs+= sizeof(PMSG_BEATTACK);
; 12913: 				continue;

  007c9	0f 8f c3 01 00
	00		 jg	 $LN1@CGBeattack
  007cf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN22@CGBeattack:

; 12914: 			}
; 12915: 		}
; 12916: 		
; 12917: 		/*if ( gEnableCheckPenetrationSkill )
; 12918: 		{
; 12919: 			if ( lpMagic->m_Skill == AT_SKILL_FIRESCREAM ||
; 12920: 				 lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM1 ||
; 12921: 				 lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM2 )
; 12922: 			{
; 12923: 				if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckFireScreamSkill(tNumber, lpMagic->m_Skill, lpCount->Serial) == FALSE )
; 12924: 				{
; 12925: 					return;
; 12926: 				}
; 12927: 			}
; 12928: 			else if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckPenetrationSkill(tNumber, lpMagic->m_Skill, lpCount->Serial)== FALSE )
; 12929: 			{
; 12930: 				return;
; 12931: 			}
; 12932: 		}*/
; 12933: 
; 12934: 		for (i=0;i<lpCount->Count;i++)

  007d5	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _lpRecv$GSCopy$[ebp]
  007db	33 c0		 xor	 eax, eax
  007dd	38 41 04	 cmp	 BYTE PTR [ecx+4], al
  007e0	76 1e		 jbe	 SHORT $LN83@CGBeattack
$LL86@CGBeattack:

; 12935: 		{
; 12936: 			if ( n != i)

  007e2	39 85 e8 fd ff
	ff		 cmp	 DWORD PTR _n$[ebp], eax
  007e8	74 0d		 je	 SHORT $LN20@CGBeattack

; 12937: 			{
; 12938: 				if ( pTargetNumber[i] == tNumber )

  007ea	39 b4 85 fc fd
	ff ff		 cmp	 DWORD PTR _pTargetNumber$[ebp+eax*4], esi
  007f1	0f 84 d2 01 00
	00		 je	 $LN76@CGBeattack
$LN20@CGBeattack:

; 12914: 			}
; 12915: 		}
; 12916: 		
; 12917: 		/*if ( gEnableCheckPenetrationSkill )
; 12918: 		{
; 12919: 			if ( lpMagic->m_Skill == AT_SKILL_FIRESCREAM ||
; 12920: 				 lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM1 ||
; 12921: 				 lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM2 )
; 12922: 			{
; 12923: 				if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckFireScreamSkill(tNumber, lpMagic->m_Skill, lpCount->Serial) == FALSE )
; 12924: 				{
; 12925: 					return;
; 12926: 				}
; 12927: 			}
; 12928: 			else if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckPenetrationSkill(tNumber, lpMagic->m_Skill, lpCount->Serial)== FALSE )
; 12929: 			{
; 12930: 				return;
; 12931: 			}
; 12932: 		}*/
; 12933: 
; 12934: 		for (i=0;i<lpCount->Count;i++)

  007f7	0f b6 59 04	 movzx	 ebx, BYTE PTR [ecx+4]
  007fb	40		 inc	 eax
  007fc	3b c3		 cmp	 eax, ebx
  007fe	7c e2		 jl	 SHORT $LL86@CGBeattack
$LN83@CGBeattack:

; 12945: 					return;
; 12946: 				}
; 12947: 			}
; 12948: 		}
; 12949: 
; 12950: 		if ( tNumber >= 0 && tNumber < OBJMAX-1 )

  00800	81 fe ea 2c 00
	00		 cmp	 esi, 11498		; 00002ceaH
  00806	0f 87 86 01 00
	00		 ja	 $LN1@CGBeattack

; 12951: 		{
; 12952: 			if ( lpMagic->m_Skill == AT_SKILL_DEFENSEDOWN )

  0080c	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0080f	83 f8 37	 cmp	 eax, 55			; 00000037H
  00812	0f 85 97 00 00
	00		 jne	 $LN15@CGBeattack

; 12953: 			{
; 12954: 				if( gObj[aIndex].Type == OBJ_USER )

  00818	8b 9d f4 fd ff
	ff		 mov	 ebx, DWORD PTR tv1044[ebp]
  0081e	80 7c 13 50 01	 cmp	 BYTE PTR [ebx+edx+80], 1
  00823	75 54		 jne	 SHORT $LN14@CGBeattack

; 12955: 				{
; 12956: 					if( (gObj[aIndex].Strength + gObj[aIndex].AddStrength) >= 596 )

  00825	0f b7 8c 13 fc
	00 00 00	 movzx	 ecx, WORD PTR [ebx+edx+252]
  0082d	0f b7 94 13 d0
	00 00 00	 movzx	 edx, WORD PTR [ebx+edx+208]
  00835	03 ca		 add	 ecx, edx
  00837	81 f9 54 02 00
	00		 cmp	 ecx, 596		; 00000254H
  0083d	0f 8c 4f 01 00
	00		 jl	 $LN1@CGBeattack

; 12957: 					{
; 12958: 						gObjUseSkill.MaGumSkillDefenseDown(aIndex, tNumber, lpMagic);

  00843	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00849	57		 push	 edi
  0084a	56		 push	 esi
  0084b	50		 push	 eax
  0084c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00851	e8 00 00 00 00	 call	 ?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::MaGumSkillDefenseDown

; 12959: 						gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  00856	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0085c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00861	6a 00		 push	 0
  00863	6a 00		 push	 0
  00865	6a 00		 push	 0
  00867	6a 00		 push	 0
  00869	6a 01		 push	 1
  0086b	6a 01		 push	 1
  0086d	57		 push	 edi
  0086e	03 f0		 add	 esi, eax
  00870	56		 push	 esi
  00871	03 d8		 add	 ebx, eax
  00873	53		 push	 ebx

; 12960: 					}
; 12961: 				}
; 12962: 				else

  00874	e9 11 01 00 00	 jmp	 $LN97@CGBeattack
$LN14@CGBeattack:

; 12963: 				{
; 12964: 					gObjUseSkill.MaGumSkillDefenseDown(aIndex, tNumber, lpMagic);

  00879	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0087f	57		 push	 edi
  00880	56		 push	 esi
  00881	51		 push	 ecx
  00882	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00887	e8 00 00 00 00	 call	 ?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::MaGumSkillDefenseDown

; 12965: 					gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  0088c	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00892	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00897	6a 00		 push	 0
  00899	6a 00		 push	 0
  0089b	6a 00		 push	 0
  0089d	6a 00		 push	 0
  0089f	6a 01		 push	 1
  008a1	6a 01		 push	 1
  008a3	57		 push	 edi
  008a4	03 f0		 add	 esi, eax
  008a6	56		 push	 esi
  008a7	03 d8		 add	 ebx, eax
  008a9	53		 push	 ebx

; 12966: 				}

  008aa	e9 db 00 00 00	 jmp	 $LN97@CGBeattack
$LN15@CGBeattack:

; 12967: 			}
; 12968: 			else if ( lpMagic->m_Skill == AT_SKILL_FIRESCREAM )

  008af	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  008b2	75 18		 jne	 SHORT $LN10@CGBeattack

; 12969: 			{
; 12970: 				gObjUseSkill.SkillFireScream(aIndex, tNumber, lpMagic);

  008b4	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  008ba	57		 push	 edi
  008bb	56		 push	 esi
  008bc	52		 push	 edx
  008bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  008c2	e8 00 00 00 00	 call	 ?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFireScream
  008c7	e9 c6 00 00 00	 jmp	 $LN1@CGBeattack
$LN10@CGBeattack:

; 12971: 			}
; 12972: 			else if ( g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == AT_MSKILL_MG_FIRESLASH1 )

  008cc	50		 push	 eax
  008cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  008d2	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill

; 12973: 			{
; 12974: 				g_MasterSkillSystem.MLS_MaGumSkillDefenseDown(aIndex,tNumber);

  008d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  008dc	3d ea 01 00 00	 cmp	 eax, 490		; 000001eaH
  008e1	75 33		 jne	 SHORT $LN8@CGBeattack
  008e3	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  008e9	56		 push	 esi
  008ea	50		 push	 eax
  008eb	e8 00 00 00 00	 call	 ?MLS_MaGumSkillDefenseDown@CMasterLevelSkillTreeSystem@@QAEXHH@Z ; CMasterLevelSkillTreeSystem::MLS_MaGumSkillDefenseDown
$LN98@CGBeattack:

; 12975: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  008f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008f5	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  008fb	6a 00		 push	 0
  008fd	6a 00		 push	 0
  008ff	6a 00		 push	 0
  00901	6a 00		 push	 0
  00903	6a 01		 push	 1
  00905	03 f0		 add	 esi, eax
$LN102@CGBeattack:
  00907	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1044[ebp]
  0090d	6a 01		 push	 1
  0090f	57		 push	 edi
  00910	56		 push	 esi
  00911	03 c8		 add	 ecx, eax
  00913	51		 push	 ecx
  00914	eb 74		 jmp	 SHORT $LN97@CGBeattack
$LN8@CGBeattack:

; 12976: 			}
; 12977: 			else if ( g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == AT_MSKILL_MG_FIRESLASH2 )

  00916	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00919	52		 push	 edx
  0091a	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill

; 12978: 			{
; 12979: 				g_MasterSkillSystem.MLS_MaGumSkillDefenseDownMastery(aIndex,tNumber,lpMagic);

  0091f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00924	3d ed 01 00 00	 cmp	 eax, 493		; 000001edH
  00929	75 10		 jne	 SHORT $LN6@CGBeattack
  0092b	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00931	57		 push	 edi
  00932	56		 push	 esi
  00933	50		 push	 eax
  00934	e8 00 00 00 00	 call	 ?MLS_MaGumSkillDefenseDownMastery@CMasterLevelSkillTreeSystem@@QAEXHHPAVCMagicInf@@@Z ; CMasterLevelSkillTreeSystem::MLS_MaGumSkillDefenseDownMastery

; 12980: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  00939	eb b5		 jmp	 SHORT $LN98@CGBeattack
$LN6@CGBeattack:

; 12981: 			}
; 12982: 			else if ( g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == AT_MSKILL_DL_FIRESCREAM1 )

  0093b	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  0093e	52		 push	 edx
  0093f	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00944	3d 06 02 00 00	 cmp	 eax, 518		; 00000206H
  00949	75 15		 jne	 SHORT $LN4@CGBeattack

; 12983: 			{
; 12984: 				g_MasterSkillSystem.MLS_FireScream(aIndex, tNumber, lpMagic);

  0094b	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00951	57		 push	 edi
  00952	56		 push	 esi
  00953	50		 push	 eax
  00954	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00959	e8 00 00 00 00	 call	 ?MLS_FireScream@CMasterLevelSkillTreeSystem@@QAEHHHPAVCMagicInf@@@Z ; CMasterLevelSkillTreeSystem::MLS_FireScream
  0095e	eb 32		 jmp	 SHORT $LN1@CGBeattack
$LN4@CGBeattack:

; 12985: 			}
; 12986: 			else if ( magic_send )
; 12987: 			{
; 12988: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  00960	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00965	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0096b	6a 00		 push	 0
  0096d	6a 00		 push	 0
  0096f	6a 00		 push	 0
  00971	03 f0		 add	 esi, eax
  00973	83 7d 10 00	 cmp	 DWORD PTR _magic_send$[ebp], 0
  00977	6a 00		 push	 0
  00979	6a 01		 push	 1

; 12989: 			}
; 12990: 			else

  0097b	75 8a		 jne	 SHORT $LN102@CGBeattack

; 12991: 			{
; 12992: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, FALSE, 1, 0, FALSE,0,0);

  0097d	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR tv1044[ebp]
  00983	6a 00		 push	 0
  00985	57		 push	 edi
  00986	56		 push	 esi
  00987	03 d0		 add	 edx, eax
  00989	52		 push	 edx
$LN97@CGBeattack:
  0098a	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0098f	83 c4 24	 add	 esp, 36			; 00000024H
$LN1@CGBeattack:

; 12993: 			}
; 12994: 		}
; 12995: 
; 12996: 		lOfs += sizeof(PMSG_BEATTACK);

  00992	83 85 f8 fd ff
	ff 03		 add	 DWORD PTR tv1574[ebp], 3
$LN31@CGBeattack:

; 12862: 	}
; 12863: 
; 12864: 	for (n=0;n<lpCount->Count;n++)

  00999	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _lpRecv$GSCopy$[ebp]
  0099f	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  009a5	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  009a9	40		 inc	 eax
  009aa	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
  009b0	3b c2		 cmp	 eax, edx
  009b2	0f 8c d8 fc ff
	ff		 jl	 $LL32@CGBeattack
  009b8	5f		 pop	 edi
  009b9	5b		 pop	 ebx
  009ba	5e		 pop	 esi

; 12997: 	}
; 12998: }

  009bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009be	33 cd		 xor	 ecx, ebp
  009c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009c5	8b e5		 mov	 esp, ebp
  009c7	5d		 pop	 ebp
  009c8	c3		 ret	 0
$LN76@CGBeattack:

; 12939: 				{
; 12940: 					LogAddTD("[%s][%s] %s Detect Hack : Multi Attack",
; 12941: 						gObj[aIndex].AccountID, gObj[aIndex].Name,
; 12942: 						lMsg.Get(MSGGET(7, 108)+gObj[aIndex].Class));

  009c9	8b bd f4 fd ff
	ff		 mov	 edi, DWORD PTR tv1044[ebp]
  009cf	0f b7 84 17 90
	00 00 00	 movzx	 eax, WORD PTR [edi+edx+144]
  009d7	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  009dc	50		 push	 eax
  009dd	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  009e2	8d 34 17	 lea	 esi, DWORD PTR [edi+edx]
  009e5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  009ea	50		 push	 eax
  009eb	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  009ee	51		 push	 ecx
  009ef	83 c6 52	 add	 esi, 82			; 00000052H
  009f2	56		 push	 esi
  009f3	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@
  009f8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12943: 
; 12944: 					CloseClient(gObj[aIndex].m_Index);

  009fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a04	8b 04 17	 mov	 eax, DWORD PTR [edi+edx]
  00a07	50		 push	 eax
  00a08	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00a0d	83 c4 14	 add	 esp, 20			; 00000014H
$LN90@CGBeattack:
  00a10	5f		 pop	 edi
  00a11	5b		 pop	 ebx
$LN55@CGBeattack:

; 12997: 	}
; 12998: }

  00a12	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a15	33 cd		 xor	 ecx, ebp
  00a17	5e		 pop	 esi
  00a18	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a1d	8b e5		 mov	 esp, ebp
  00a1f	5d		 pop	 ebp
  00a20	c3		 ret	 0
?CGBeattackRecv@@YAXPAEHH@Z ENDP			; CGBeattackRecv
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2002 : 		{	// determine current pointer to buffer for mutable string

  00000	8b c1		 mov	 eax, ecx

; 2003 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2004 : 			: this->_Bx._Buf);

  00002	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00006	72 02		 jb	 SHORT $LN4@Myptr@2
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Myptr@2:

; 2005 : 		}

  0000a	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2020 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ ; `string'
PUBLIC	??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ ; `string'
PUBLIC	?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ; CGDurationMagicRecv
EXTRN	?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z:PROC ; CObjUseSkill::UseSkill
EXTRN	?CheckWeapon@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CObjUseSkill::CheckWeapon
EXTRN	?EnableSkill@CObjUseSkill@@QAEHH@Z:PROC		; CObjUseSkill::EnableSkill
EXTRN	?SpeedHackCheck@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SpeedHackCheck
EXTRN	?CheckKillCount@CMagicDamage@@QAEHHH@Z:PROC	; CMagicDamage::CheckKillCount
EXTRN	?CheckStatus@CMagicDamage@@QAEHHH@Z:PROC	; CMagicDamage::CheckStatus
;	COMDAT ??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	SEGMENT
??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ DB '['
	DB	'0x1E] CGDurationMagicRecv() - Invalid KillCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
CONST	SEGMENT
??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ DB '['
	DB	'0x1E] CGDurationMagicRecv() - Invalid Status', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z PROC ; CGDurationMagicRecv, COMDAT

; 13006: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 13007: 	CMagicInf * lpMagic;
; 13008: 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  0000d	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13009: 
; 13010: 	if ( lpObj->Teleport )

  00013	80 bf 88 05 00
	00 00		 cmp	 BYTE PTR [edi+1416], 0
  0001a	0f 85 2e 01 00
	00		 jne	 $LN1@CGDuration

; 13011: 	{
; 13012: 		return;
; 13013: 	}
; 13014: 
; 13015: 	int MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH,lpMsg->MagicNumberL);

  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00025	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  00029	0f b6 4e 06	 movzx	 ecx, BYTE PTR [esi+6]
  0002d	66 c1 e2 08	 shl	 dx, 8
  00031	0f b7 c2	 movzx	 eax, dx
  00034	0b c1		 or	 eax, ecx

; 13016: 
; 13017: 	if ( gObj[aIndex].Type == OBJ_USER )

  00036	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1

; 13018: 	{
; 13019: 		lpMagic = gObjGetMagicSearch(lpObj, MagicNumber);

  0003a	50		 push	 eax
  0003b	57		 push	 edi
  0003c	75 07		 jne	 SHORT $LN12@CGDuration
  0003e	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch

; 13020: 	}
; 13021: 	else

  00043	eb 05		 jmp	 SHORT $LN18@CGDuration
$LN12@CGDuration:

; 13022: 	{
; 13023: 		lpMagic = gObjGetMagic( lpObj, MagicNumber);

  00045	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
$LN18@CGDuration:
  0004a	8b d8		 mov	 ebx, eax
  0004c	83 c4 08	 add	 esp, 8

; 13024: 	}
; 13025: 
; 13026: 	if ( lpMagic == NULL )

  0004f	85 db		 test	 ebx, ebx
  00051	0f 84 f5 00 00
	00		 je	 $LN16@CGDuration

; 13027: 	{
; 13028: 		return;
; 13029: 	}
; 13030: 
; 13031: 	if ( lpObj->Type == OBJ_USER )

  00057	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0005b	75 5d		 jne	 SHORT $LN7@CGDuration

; 13032: 	{
; 13033: 		if ( MagicDamageC.CheckStatus(lpMagic->m_Skill, lpObj->GuildStatus) == FALSE )

  0005d	8b 97 28 06 00
	00		 mov	 edx, DWORD PTR [edi+1576]
  00063	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00066	52		 push	 edx
  00067	50		 push	 eax
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0006d	e8 00 00 00 00	 call	 ?CheckStatus@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckStatus
  00072	85 c0		 test	 eax, eax
  00074	75 15		 jne	 SHORT $LN8@CGDuration

; 13034: 		{
; 13035: 			LogAddC(2, "[0x1E] CGDurationMagicRecv() - Invalid Status");	// #warning maybe protocol here change

  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
  0007b	6a 02		 push	 2
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00083	83 c4 08	 add	 esp, 8
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	5f		 pop	 edi

; 13072: }

  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
$LN8@CGDuration:

; 13036: 			return;
; 13037: 		}
; 13038: 
; 13039: 		if ( MagicDamageC.CheckKillCount(lpMagic->m_Skill, lpObj->m_btKillCount) < 0 )

  0008b	0f b6 8f 64 20
	00 00		 movzx	 ecx, BYTE PTR [edi+8292]
  00092	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00095	51		 push	 ecx
  00096	52		 push	 edx
  00097	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0009c	e8 00 00 00 00	 call	 ?CheckKillCount@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckKillCount
  000a1	85 c0		 test	 eax, eax
  000a3	79 15		 jns	 SHORT $LN7@CGDuration

; 13040: 		{
; 13041: 			LogAddC(2, "[0x1E] CGDurationMagicRecv() - Invalid KillCount");

  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
  000aa	6a 02		 push	 2
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000b2	83 c4 08	 add	 esp, 8
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	5f		 pop	 edi

; 13072: }

  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
$LN7@CGDuration:

; 13042: 			return;
; 13043: 		}
; 13044: 	}
; 13045: 
; 13046: 	lpObj->UseMagicNumber = 0;
; 13047: 
; 13048: 	if ( lpMagic->m_Skill != 24 || lpMagic->m_Skill != 0xEB)
; 13049: 	{
; 13050: 		if ( !gObjUseSkill.SpeedHackCheck(aIndex))

  000ba	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000bd	33 c0		 xor	 eax, eax
  000bf	51		 push	 ecx
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000c5	66 89 87 ae 06
	00 00		 mov	 WORD PTR [edi+1710], ax
  000cc	e8 00 00 00 00	 call	 ?SpeedHackCheck@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SpeedHackCheck
  000d1	85 c0		 test	 eax, eax
  000d3	74 77		 je	 SHORT $LN16@CGDuration

; 13051: 		{
; 13052: 			return;
; 13053: 		}
; 13054: 	}
; 13055: 
; 13056: 	if ( !gObjUseSkill.EnableSkill(lpMagic->m_Skill) )

  000d5	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000d8	52		 push	 edx
  000d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000de	e8 00 00 00 00	 call	 ?EnableSkill@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::EnableSkill
  000e3	85 c0		 test	 eax, eax
  000e5	74 65		 je	 SHORT $LN16@CGDuration

; 13057: 	{
; 13058: 		return;
; 13059: 	}
; 13060: 
; 13061: 	if ( !gObjUseSkill.CheckWeapon(lpObj,lpMagic->m_Skill) )

  000e7	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000ea	50		 push	 eax
  000eb	57		 push	 edi
  000ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000f1	e8 00 00 00 00	 call	 ?CheckWeapon@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z ; CObjUseSkill::CheckWeapon
  000f6	85 c0		 test	 eax, eax
  000f8	74 52		 je	 SHORT $LN16@CGDuration

; 13062: 	{
; 13063: 		return;
; 13064: 	}
; 13065: 
; 13066: 	int aTargetIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);
; 13067: 
; 13068: 	gObjUseSkill.UseSkill(aIndex, lpMagic,lpMsg->X, lpMsg->Y, lpMsg->Dir, lpMsg->TargetPos, aTargetIndex);

  000fa	0f b6 4e 08	 movzx	 ecx, BYTE PTR [esi+8]
  000fe	0f b6 46 0a	 movzx	 eax, BYTE PTR [esi+10]
  00102	66 c1 e1 08	 shl	 cx, 8
  00106	0f b7 d1	 movzx	 edx, cx
  00109	0f b6 4e 0b	 movzx	 ecx, BYTE PTR [esi+11]
  0010d	0b d0		 or	 edx, eax
  0010f	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00113	52		 push	 edx
  00114	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  00118	51		 push	 ecx
  00119	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  0011d	52		 push	 edx
  0011e	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00121	50		 push	 eax
  00122	51		 push	 ecx
  00123	53		 push	 ebx
  00124	52		 push	 edx
  00125	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0012a	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 13069: 
; 13070: 	if ( lpMsg->MagicKey )

  0012f	80 7e 0c 00	 cmp	 BYTE PTR [esi+12], 0
  00133	74 17		 je	 SHORT $LN16@CGDuration

; 13071: 		lpObj->DurMagicKeyChecker.SetDurationTime(lpMsg->MagicKey, GetTickCount());

  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0013b	50		 push	 eax
  0013c	0f b6 46 0c	 movzx	 eax, BYTE PTR [esi+12]
  00140	50		 push	 eax
  00141	8d 8f d8 14 00
	00		 lea	 ecx, DWORD PTR [edi+5336]
  00147	e8 00 00 00 00	 call	 ?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z ; TDurMagicKeyChecker::SetDurationTime
$LN16@CGDuration:
  0014c	5e		 pop	 esi
  0014d	5b		 pop	 ebx
$LN1@CGDuration:
  0014e	5f		 pop	 edi

; 13072: }

  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ENDP ; CGDurationMagicRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ObjectMapJoinPositionSend@@YAXF@Z		; ObjectMapJoinPositionSend
; Function compile flags: /Ogtp
;	COMDAT ?ObjectMapJoinPositionSend@@YAXF@Z
_TEXT	SEGMENT
_pObject$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 2
?ObjectMapJoinPositionSend@@YAXF@Z PROC			; ObjectMapJoinPositionSend, COMDAT

; 13090: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	0f b7 5d 08	 movzx	 ebx, WORD PTR _aIndex$[ebp]

; 13091: 	PMSG_USERMAPJOIN pObject;
; 13092: 	
; 13093: 	PHeadSubSetB((LPBYTE)&pObject, 0xF3, 0x03, sizeof(pObject));

  00015	6a 0a		 push	 10			; 0000000aH
  00017	6a 03		 push	 3
  00019	8d 45 f0	 lea	 eax, DWORD PTR _pObject$[ebp]
  0001c	68 f3 00 00 00	 push	 243			; 000000f3H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 13094: 	pObject.NumberH = SET_NUMBERH(aIndex);

  00027	0f bf cb	 movsx	 ecx, bx

; 13095: 	pObject.NumberL = SET_NUMBERL(aIndex);
; 13096: 	pObject.X = gObj[aIndex].X;

  0002a	8b c1		 mov	 eax, ecx
  0002c	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00032	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	8b d1		 mov	 edx, ecx
  0003a	c1 ea 08	 shr	 edx, 8
  0003d	88 55 f4	 mov	 BYTE PTR _pObject$[ebp+4], dl
  00040	88 5d f5	 mov	 BYTE PTR _pObject$[ebp+5], bl
  00043	0f b6 90 20 01
	00 00		 movzx	 edx, BYTE PTR [eax+288]
  0004a	88 55 f6	 mov	 BYTE PTR _pObject$[ebp+6], dl

; 13097: 	pObject.Y = gObj[aIndex].Y;

  0004d	0f b6 90 21 01
	00 00		 movzx	 edx, BYTE PTR [eax+289]
  00054	88 55 f7	 mov	 BYTE PTR _pObject$[ebp+7], dl

; 13098: 	pObject.MapNumber = gObj[aIndex].MapNumber;

  00057	0f b6 90 23 01
	00 00		 movzx	 edx, BYTE PTR [eax+291]
  0005e	88 55 f8	 mov	 BYTE PTR _pObject$[ebp+8], dl

; 13099: 	pObject.Dir = gObj[aIndex].Dir;

  00061	8a 80 22 01 00
	00		 mov	 al, BYTE PTR [eax+290]

; 13100: 
; 13101: 	DataSend(aIndex, (LPBYTE)&pObject, pObject.h.size);

  00067	0f b6 55 f1	 movzx	 edx, BYTE PTR _pObject$[ebp+1]
  0006b	88 45 f9	 mov	 BYTE PTR _pObject$[ebp+9], al
  0006e	52		 push	 edx
  0006f	8d 45 f0	 lea	 eax, DWORD PTR _pObject$[ebp]
  00072	50		 push	 eax
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 13102: }

  00079	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0007f	33 cd		 xor	 ecx, ebp
  00081	5b		 pop	 ebx
  00082	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?ObjectMapJoinPositionSend@@YAXF@Z ENDP			; ObjectMapJoinPositionSend
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1972 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1973 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 2d		 je	 SHORT $LN2@Inside
  0000b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0000e	83 fa 10	 cmp	 edx, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN8@Inside
  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN9@Inside
$LN8@Inside:
  00017	8b c1		 mov	 eax, ecx
$LN9@Inside:
  00019	3b f0		 cmp	 esi, eax
  0001b	72 1b		 jb	 SHORT $LN2@Inside
  0001d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN12@Inside
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN13@Inside
$LN12@Inside:
  00026	8b c1		 mov	 eax, ecx
$LN13@Inside:
  00028	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0002b	03 c8		 add	 ecx, eax
  0002d	3b ce		 cmp	 ecx, esi
  0002f	76 07		 jbe	 SHORT $LN2@Inside

; 1975 : 		else
; 1976 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 1977 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN2@Inside:

; 1974 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 1977 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2015 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 220  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T234278 = -12						; size = 12
$T234283 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3a		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	83 f9 ff	 cmp	 ecx, -1
  00012	77 0d		 ja	 SHORT $LN1@Allocate
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0001f	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00021	8d 45 08	 lea	 eax, DWORD PTR $T234283[ebp]
  00024	50		 push	 eax
  00025	8d 4d f4	 lea	 ecx, DWORD PTR $T234278[ebp]
  00028	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T234283[ebp], 0
  0002f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00034	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00039	8d 4d f4	 lea	 ecx, DWORD PTR $T234278[ebp]
  0003c	51		 push	 ecx
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T234278[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00044	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCReFillSend@@YAXHGEEG@Z			; GCReFillSend
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
;	COMDAT ?GCReFillSend@@YAXHGEEG@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Life$ = 12						; size = 2
_Ipos$ = 16						; size = 1
_flag$ = 20						; size = 1
_wShield$ = 24						; size = 2
?GCReFillSend@@YAXHGEEG@Z PROC				; GCReFillSend, COMDAT

; 14491: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 14492: 	PMSG_REFILL pMsg;
; 14493: 
; 14494: 	PHeadSetB((LPBYTE)&pMsg, 0x26, sizeof(pMsg));

  00015	6a 14		 push	 20			; 00000014H
  00017	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	6a 26		 push	 38			; 00000026H
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14495: 	pMsg.IPos = Ipos;
; 14496: 	pMsg.LifeH = SET_NUMBERH(Life);

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _Life$[ebp]
  00025	8a 45 10	 mov	 al, BYTE PTR _Ipos$[ebp]

; 14497: 	pMsg.LifeL = SET_NUMBERL(Life);
; 14498: 	pMsg.btShieldH = SET_NUMBERH(wShield);
; 14499: 	pMsg.btShieldL = SET_NUMBERL(wShield);
; 14500: 	pMsg.Flag = 0;
; 14501: 
; 14502: #if (FIX_HP==1)
; 14503: 	if( Ipos == 0xFF )
; 14504: 	{
; 14505: 		pMsg.HP = (int)gObj[aIndex].Life;

  00028	8b f7		 mov	 esi, edi
  0002a	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00030	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	8b d1		 mov	 edx, ecx
  00038	c1 ea 08	 shr	 edx, 8
  0003b	88 4d ed	 mov	 BYTE PTR _pMsg$[ebp+5], cl
  0003e	8b 4d 18	 mov	 ecx, DWORD PTR _wShield$[ebp]
  00041	88 55 ec	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  00044	8b d1		 mov	 edx, ecx
  00046	c1 ea 08	 shr	 edx, 8
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  0004f	88 55 ef	 mov	 BYTE PTR _pMsg$[ebp+7], dl
  00052	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+8], cl
  00055	c6 45 ee 00	 mov	 BYTE PTR _pMsg$[ebp+6], 0
  00059	3c ff		 cmp	 al, 255			; 000000ffH
  0005b	75 16		 jne	 SHORT $LN2@GCReFillSe
  0005d	d9 86 d8 00 00
	00		 fld	 DWORD PTR [esi+216]
  00063	e8 00 00 00 00	 call	 __ftol2_sse
  00068	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 14506: 		pMsg.SD = gObj[aIndex].iShield;

  0006b	8b 96 2c 01 00
	00		 mov	 edx, DWORD PTR [esi+300]

; 14507: 	}
; 14508: 	else

  00071	eb 20		 jmp	 SHORT $LN5@GCReFillSe
$LN2@GCReFillSe:

; 14509: 	{
; 14510: 		pMsg.HP = (int)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife);

  00073	db 86 24 01 00
	00		 fild	 DWORD PTR [esi+292]
  00079	d8 86 dc 00 00
	00		 fadd	 DWORD PTR [esi+220]
  0007f	e8 00 00 00 00	 call	 __ftol2_sse
  00084	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 14511: 		pMsg.SD = gObj[aIndex].iAddShield + gObj[aIndex].iMaxShield;

  00087	8b 96 34 01 00
	00		 mov	 edx, DWORD PTR [esi+308]
  0008d	03 96 30 01 00
	00		 add	 edx, DWORD PTR [esi+304]
$LN5@GCReFillSe:

; 14512: 	}
; 14513: #endif
; 14514: 
; 14515: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00093	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00097	50		 push	 eax
  00098	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0009b	51		 push	 ecx
  0009c	57		 push	 edi
  0009d	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+16], edx
  000a0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14516: }

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	5f		 pop	 edi
  000ac	33 cd		 xor	 ecx, ebp
  000ae	5e		 pop	 esi
  000af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
?GCReFillSend@@YAXHGEEG@Z ENDP				; GCReFillSend
_TEXT	ENDS
PUBLIC	??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCManaSend@@YAXHFEEG@Z				; GCManaSend
;	COMDAT ??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@ DB 'GCMa'
	DB	'naSend() return %s %d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCManaSend@@YAXHFEEG@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Mana$ = 12						; size = 2
_Ipos$ = 16						; size = 1
_flag$ = 20						; size = 1
_BP$ = 24						; size = 2
?GCManaSend@@YAXHFEEG@Z PROC				; GCManaSend, COMDAT

; 14535: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 14536: 	if ( aIndex < 0 || aIndex > OBJMAX-1)

  00014	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0001a	0f 87 96 00 00
	00		 ja	 $LN4@GCManaSend

; 14539: 		return;
; 14540: 	}
; 14541: 
; 14542: 	if ( gObj[aIndex].Type != OBJ_USER )

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00025	56		 push	 esi
  00026	8b f7		 mov	 esi, edi
  00028	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0002e	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00033	75 71		 jne	 SHORT $LN8@GCManaSend

; 14543: 	{
; 14544: 		return;
; 14545: 	}
; 14546: 
; 14547: 	PMSG_MANASEND pMsg;
; 14548: 
; 14549: 	PHeadSetB((LPBYTE)&pMsg, 0x27, sizeof(pMsg));

  00035	6a 0c		 push	 12			; 0000000cH
  00037	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0003a	6a 27		 push	 39			; 00000027H
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14550: 	pMsg.IPos = Ipos;
; 14551: 	pMsg.ManaH = SET_NUMBERH(Mana);

  00042	8b 4d 0c	 mov	 ecx, DWORD PTR _Mana$[ebp]
  00045	8a 45 10	 mov	 al, BYTE PTR _Ipos$[ebp]
  00048	8b d1		 mov	 edx, ecx
  0004a	c1 ea 08	 shr	 edx, 8

; 14552: 	pMsg.ManaL = SET_NUMBERL(Mana);

  0004d	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 14553: 	pMsg.BPH = SET_NUMBERH(BP);

  00050	8b 4d 18	 mov	 ecx, DWORD PTR _BP$[ebp]
  00053	88 55 f4	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  00056	8b d1		 mov	 edx, ecx
  00058	c1 ea 08	 shr	 edx, 8
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 14554: 	pMsg.BPL = SET_NUMBERL(BP);
; 14555: 
; 14556: #if (FIX_HP==1)
; 14557: 	if( Ipos == 0xFF )

  00061	3c ff		 cmp	 al, 255			; 000000ffH

; 14558: 		pMsg.MP = (int)gObj[aIndex].Mana;

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00068	88 55 f6	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  0006b	88 4d f7	 mov	 BYTE PTR _pMsg$[ebp+7], cl
  0006e	75 0e		 jne	 SHORT $LN2@GCManaSend
  00070	d9 84 06 ec 00
	00 00		 fld	 DWORD PTR [esi+eax+236]
  00077	e8 00 00 00 00	 call	 __ftol2_sse

; 14559: 	else

  0007c	eb 13		 jmp	 SHORT $LN9@GCManaSend
$LN2@GCManaSend:

; 14560: 		pMsg.MP = (int)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana);

  0007e	db 84 06 28 01
	00 00		 fild	 DWORD PTR [esi+eax+296]
  00085	d8 84 06 f0 00
	00 00		 fadd	 DWORD PTR [esi+eax+240]
  0008c	e8 00 00 00 00	 call	 __ftol2_sse
$LN9@GCManaSend:

; 14561: #endif
; 14562: 
; 14563: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00091	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00095	51		 push	 ecx
  00096	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00099	52		 push	 edx
  0009a	57		 push	 edi
  0009b	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  0009e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@GCManaSend:
  000a6	5e		 pop	 esi
  000a7	5f		 pop	 edi

; 14564: }

  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ab	33 cd		 xor	 ecx, ebp
  000ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
$LN4@GCManaSend:

; 14537: 	{
; 14538: 		LogAdd("GCManaSend() return %s %d", __FILE__, __LINE__);

  000b6	68 ca 38 00 00	 push	 14538			; 000038caH
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 14564: }

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d1	33 cd		 xor	 ecx, ebp
  000d3	5f		 pop	 edi
  000d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?GCManaSend@@YAXHFEEG@Z ENDP				; GCManaSend
_TEXT	ENDS
PUBLIC	?GCInventoryItemDeleteSend@@YAXHEE@Z		; GCInventoryItemDeleteSend
; Function compile flags: /Ogtp
;	COMDAT ?GCInventoryItemDeleteSend@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_flag$ = 16						; size = 1
?GCInventoryItemDeleteSend@@YAXHEE@Z PROC		; GCInventoryItemDeleteSend, COMDAT

; 14577: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 14578: 	PMSG_INVENTORYDELETE pMsg;
; 14579: 	
; 14580: 	PHeadSetB((LPBYTE)&pMsg, 0x28, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 28		 push	 40			; 00000028H
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14581: 	pMsg.IPos = pos;
; 14582: 	pMsg.Flag = flag;
; 14583: 
; 14584: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00013	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00017	8a 4d 0c	 mov	 cl, BYTE PTR _pos$[ebp]
  0001a	8a 55 10	 mov	 dl, BYTE PTR _flag$[ebp]
  0001d	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00020	50		 push	 eax
  00021	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00024	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  00027	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 18	 add	 esp, 24			; 00000018H

; 14585: }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?GCInventoryItemDeleteSend@@YAXHEE@Z ENDP		; GCInventoryItemDeleteSend
_TEXT	ENDS
PUBLIC	?GCItemUseSpecialTimeSend@@YAXHEH@Z		; GCItemUseSpecialTimeSend
; Function compile flags: /Ogtp
;	COMDAT ?GCItemUseSpecialTimeSend@@YAXHEH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_number$ = 12						; size = 1
_time$ = 16						; size = 4
?GCItemUseSpecialTimeSend@@YAXHEH@Z PROC		; GCItemUseSpecialTimeSend, COMDAT

; 14597: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 14598: 	if ( time > 65535 )

  00007	8b 75 10	 mov	 esi, DWORD PTR _time$[ebp]
  0000a	81 fe ff ff 00
	00		 cmp	 esi, 65535		; 0000ffffH
  00010	7e 05		 jle	 SHORT $LN1@GCItemUseS

; 14599: 	{
; 14600: 		time = 65535;

  00012	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
$LN1@GCItemUseS:

; 14601: 	}
; 14602: 
; 14603: 	PMSG_ITEMUSESPECIALTIME pMsg;
; 14604: 
; 14605: 	PHeadSetBE((LPBYTE)&pMsg, 0x29, sizeof(pMsg));

  00017	6a 06		 push	 6
  00019	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	6a 29		 push	 41			; 00000029H
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 14606: 	pMsg.Number = number;
; 14607: 	pMsg.Time = time;
; 14608: 
; 14609: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00024	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00028	8a 4d 0c	 mov	 cl, BYTE PTR _number$[ebp]
  0002b	52		 push	 edx
  0002c	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002f	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00035	50		 push	 eax
  00036	51		 push	 ecx
  00037	66 89 75 fc	 mov	 WORD PTR _pMsg$[ebp+4], si
  0003b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00040	83 c4 18	 add	 esp, 24			; 00000018H
  00043	5e		 pop	 esi

; 14610: }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?GCItemUseSpecialTimeSend@@YAXHEH@Z ENDP		; GCItemUseSpecialTimeSend
_TEXT	ENDS
PUBLIC	?GCItemDurSend@@YAXHEEE@Z			; GCItemDurSend
; Function compile flags: /Ogtp
;	COMDAT ?GCItemDurSend@@YAXHEEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_dur$ = 16						; size = 1
_flag$ = 20						; size = 1
?GCItemDurSend@@YAXHEEE@Z PROC				; GCItemDurSend, COMDAT

; 14624: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 14625: 	PMSG_ITEMDUR pMsg;
; 14626: 
; 14627: 	PHeadSetB((LPBYTE)&pMsg, 0x2A, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 2a		 push	 42			; 0000002aH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14628: 	pMsg.IPos = pos;

  00013	8a 4d 0c	 mov	 cl, BYTE PTR _pos$[ebp]

; 14629: 	pMsg.Dur = dur;

  00016	8a 55 10	 mov	 dl, BYTE PTR _dur$[ebp]

; 14630: 	pMsg.Flag = flag;

  00019	8a 45 14	 mov	 al, BYTE PTR _flag$[ebp]
  0001c	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 14631: 
; 14632: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0001f	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00023	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  00026	51		 push	 ecx
  00027	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0002a	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0002d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00030	52		 push	 edx
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00037	83 c4 18	 add	 esp, 24			; 00000018H

; 14633: }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?GCItemDurSend@@YAXHEEE@Z ENDP				; GCItemDurSend
_TEXT	ENDS
PUBLIC	?GCItemDurSend2@@YAXHEEE@Z			; GCItemDurSend2
; Function compile flags: /Ogtp
;	COMDAT ?GCItemDurSend2@@YAXHEEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_dur$ = 16						; size = 1
_flag$ = 20						; size = 1
?GCItemDurSend2@@YAXHEEE@Z PROC				; GCItemDurSend2, COMDAT

; 14639: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 14640: 	PMSG_ITEMDUR pMsg;
; 14641: 
; 14642: 	PHeadSetB((LPBYTE)&pMsg, 0x2A, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 2a		 push	 42			; 0000002aH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14643: 	pMsg.IPos = pos;

  00013	8a 4d 0c	 mov	 cl, BYTE PTR _pos$[ebp]

; 14644: 	pMsg.Dur = dur;

  00016	8a 55 10	 mov	 dl, BYTE PTR _dur$[ebp]

; 14645: 	pMsg.Flag = flag;

  00019	8a 45 14	 mov	 al, BYTE PTR _flag$[ebp]
  0001c	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 14646: 
; 14647: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0001f	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00023	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  00026	51		 push	 ecx
  00027	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0002a	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0002d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00030	52		 push	 edx
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00037	83 c4 18	 add	 esp, 24			; 00000018H

; 14648: }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?GCItemDurSend2@@YAXHEEE@Z ENDP				; GCItemDurSend2
_TEXT	ENDS
PUBLIC	?CGWeatherSend@@YAXHE@Z				; CGWeatherSend
; Function compile flags: /Ogtp
;	COMDAT ?CGWeatherSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_weather$ = 12						; size = 1
?CGWeatherSend@@YAXHE@Z PROC				; CGWeatherSend, COMDAT

; 14660: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 14661: 	PMSG_WEATHER pMsg;
; 14662: 
; 14663: 	PHeadSetB((LPBYTE)&pMsg, 0x0F, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14664: 	pMsg.Weather = weather;
; 14665: 
; 14666: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 0c	 mov	 cl, BYTE PTR _weather$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 14667: }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?CGWeatherSend@@YAXHE@Z ENDP				; CGWeatherSend
_TEXT	ENDS
PUBLIC	?GCServerCmd@@YAXHEEE@Z				; GCServerCmd
; Function compile flags: /Ogtp
;	COMDAT ?GCServerCmd@@YAXHEEE@Z
_TEXT	SEGMENT
_ServerCmd$ = -8					; size = 7
_aIndex$ = 8						; size = 4
_type$ = 12						; size = 1
_Cmd1$ = 16						; size = 1
_Cmd2$ = 20						; size = 1
?GCServerCmd@@YAXHEEE@Z PROC				; GCServerCmd, COMDAT

; 14674: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 14675: 	PMSG_SERVERCMD ServerCmd;
; 14676: 
; 14677: 	PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  00006	6a 07		 push	 7
  00008	6a 40		 push	 64			; 00000040H
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _ServerCmd$[ebp]
  0000d	68 f3 00 00 00	 push	 243			; 000000f3H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 14678: 	ServerCmd.CmdType = type;

  00018	8a 4d 0c	 mov	 cl, BYTE PTR _type$[ebp]

; 14679: 	ServerCmd.X = Cmd1;

  0001b	8a 55 10	 mov	 dl, BYTE PTR _Cmd1$[ebp]

; 14680: 	ServerCmd.Y = Cmd2;

  0001e	8a 45 14	 mov	 al, BYTE PTR _Cmd2$[ebp]
  00021	88 4d fc	 mov	 BYTE PTR _ServerCmd$[ebp+4], cl

; 14681: 
; 14682: 	DataSend(aIndex, (UCHAR*)&ServerCmd, ServerCmd.h.size);

  00024	0f b6 4d f9	 movzx	 ecx, BYTE PTR _ServerCmd$[ebp+1]
  00028	88 55 fd	 mov	 BYTE PTR _ServerCmd$[ebp+5], dl
  0002b	51		 push	 ecx
  0002c	8d 55 f8	 lea	 edx, DWORD PTR _ServerCmd$[ebp]
  0002f	88 45 fe	 mov	 BYTE PTR _ServerCmd$[ebp+6], al
  00032	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00035	52		 push	 edx
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 14683: }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?GCServerCmd@@YAXHEEE@Z ENDP				; GCServerCmd
_TEXT	ENDS
PUBLIC	??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	__real@3f800000
PUBLIC	??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@ ; `string'
PUBLIC	??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@ ; `string'
PUBLIC	?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ; GCReqmoveDevilSquare
EXTRN	?IncObjCount@CDevilSquareGround@@QAEXXZ:PROC	; CDevilSquareGround::IncObjCount
EXTRN	?GetDevilSquareIndex@CDevilSquare@@QAEHH@Z:PROC	; CDevilSquare::GetDevilSquareIndex
EXTRN	?GetUserLevelToEnter@CDevilSquare@@QAEHHAAH@Z:PROC ; CDevilSquare::GetUserLevelToEnter
EXTRN	?GetObjCount@CDevilSquareGround@@QAEJXZ:PROC	; CDevilSquareGround::GetObjCount
EXTRN	?g_DevilSquare@@3VCDevilSquare@@A:BYTE		; g_DevilSquare
;	COMDAT ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\devilsquare.h
CONST	SEGMENT
??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@ DB 'return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare success [%d][%d] Remov'
	DB	'eItem[%s][%d][%d][%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Invitation LevelError '
	DB	'[%d][%d][%d][%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@
CONST	SEGMENT
??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@ DB '['
	DB	'DevilSquare] [%s][%s] GetUserLevelToEnter() failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@
CONST	SEGMENT
??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@ DB '['
	DB	'DevilSquare] [%s][%s] Request Move DevilSquare [%d][%d][%d]', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z
_TEXT	SEGMENT
tv621 = -40						; size = 4
tv619 = -40						; size = 4
_sitem$ = -40						; size = 4
tv592 = -36						; size = 4
tv591 = -32						; size = 4
_movegateindex$ = -28					; size = 4
_cInvitationItemPos$ = -24				; size = 1
_ItemLevel$ = -20					; size = 4
tv563 = -16						; size = 4
tv564 = -12						; size = 4
_pResult$ = -8						; size = 4
_cSquareNumber$ = -1					; size = 1
_lpMsg$ = 8						; size = 4
tv627 = 12						; size = 4
_aIndex$ = 12						; size = 4
tv624 = 14						; size = 2
?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z PROC ; GCReqmoveDevilSquare, COMDAT

; 14695: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi

; 14696: 	if ( aIndex < 0 || aIndex > OBJMAX-1 )

  00007	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00010	0f 87 21 04 00
	00		 ja	 $LN27@GCReqmoveD

; 14699: 		return;
; 14700: 	}
; 14701: 
; 14702: 	BYTE cSquareNumber = lpMsg->SquareNumber;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]

; 14703: 	BYTE cInvitationItemPos = lpMsg->InvitationItemPos - INVENTORY_BAG_START;
; 14704: 
; 14705: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type != 12 )

  00019	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0001f	53		 push	 ebx
  00020	8a 58 03	 mov	 bl, BYTE PTR [eax+3]
  00023	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00026	2c 0c		 sub	 al, 12			; 0000000cH
  00028	88 45 e8	 mov	 BYTE PTR _cInvitationItemPos$[ebp], al
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	8b 84 06 b8 11
	00 00		 mov	 eax, DWORD PTR [esi+eax+4536]
  00037	88 5d ff	 mov	 BYTE PTR _cSquareNumber$[ebp], bl
  0003a	a8 03		 test	 al, 3
  0003c	74 0c		 je	 SHORT $LN26@GCReqmoveD
  0003e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00043	3d 00 03 00 00	 cmp	 eax, 768		; 00000300H
  00048	75 6f		 jne	 SHORT $LN48@GCReqmoveD
$LN26@GCReqmoveD:
  0004a	57		 push	 edi

; 14706: 		return;
; 14707: 
; 14708: 	PMSG_RESULT_MOVEDEVILSQUARE pResult;
; 14709: 
; 14710: 	PHeadSetB((LPBYTE)&pResult, 0x90, sizeof(pResult));

  0004b	6a 04		 push	 4
  0004d	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00050	68 90 00 00 00	 push	 144			; 00000090H
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14711: 	pResult.Result = 0;
; 14712: 
; 14713: 	LPOBJ lpObj = &gObj[aIndex];

  0005b	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 14714: 
; 14715: 	LogAddTD("[DevilSquare] [%s][%s] Request Move DevilSquare [%d][%d][%d]",
; 14716: 		lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);

  00061	0f b6 c3	 movzx	 eax, bl
  00064	89 45 f0	 mov	 DWORD PTR tv563[ebp], eax
  00067	40		 inc	 eax
  00068	50		 push	 eax
  00069	c6 45 fb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  0006d	0f b7 8e 90 00
	00 00		 movzx	 ecx, WORD PTR [esi+144]
  00074	89 45 f4	 mov	 DWORD PTR tv564[ebp], eax
  00077	0f bf 86 96 00
	00 00		 movsx	 eax, WORD PTR [esi+150]
  0007e	50		 push	 eax
  0007f	51		 push	 ecx
  00080	8d 7e 5d	 lea	 edi, DWORD PTR [esi+93]
  00083	57		 push	 edi
  00084	8d 5e 52	 lea	 ebx, DWORD PTR [esi+82]
  00087	53		 push	 ebx
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00093	83 c4 24	 add	 esp, 36			; 00000024H

; 14717: 
; 14718: 	int bIsPk = FALSE;
; 14719: 
; 14720: #if( ENABLE_FIX_PARTYPK == 1 )
; 14721: 	if ( lpObj->m_PK_Level >= 4 )

  00096	80 be 19 01 00
	00 04		 cmp	 BYTE PTR [esi+281], 4
  0009d	7c 20		 jl	 SHORT $LN24@GCReqmoveD

; 14722: 	{
; 14723: 		bIsPk = TRUE;
; 14724: 	}
; 14725: #else
; 14726: 	if ( lpObj->PartyNumber >= 0 )
; 14727: 	{
; 14728: 		if( gParty.GetPartyPkLevel(lpObj->PartyNumber) >= 5 )
; 14729: 		{
; 14730: 			bIsPk = TRUE;
; 14731: 		}
; 14732: 	}
; 14733: 	else if ( lpObj->m_PK_Level >= 4 )
; 14734: 	{
; 14735: 		bIsPk = TRUE;
; 14736: 	}
; 14737: #endif
; 14738: 
; 14739: #if( ENABLE_FIX_EVENTPK == 1 )
; 14740: 	if ( bIsPk == TRUE )
; 14741: 	{
; 14742: 		pResult.Result = 6;
; 14743: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0009f	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  000a3	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000a6	52		 push	 edx
  000a7	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  000aa	50		 push	 eax
  000ab	51		 push	 ecx
  000ac	c6 45 fb 06	 mov	 BYTE PTR _pResult$[ebp+3], 6
  000b0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b8	5f		 pop	 edi
$LN48@GCReqmoveD:
  000b9	5b		 pop	 ebx
  000ba	5e		 pop	 esi

; 14910: }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
$LN24@GCReqmoveD:

; 14744: 		return;
; 14745: 	}
; 14746: #endif
; 14747: 
; 14748: 	if ( MAIN_INVENTORY_RANGE(cInvitationItemPos) == FALSE )

  000bf	b2 cb		 mov	 dl, 203			; 000000cbH
  000c1	3a 55 e8	 cmp	 dl, BYTE PTR _cInvitationItemPos$[ebp]
  000c4	1b c0		 sbb	 eax, eax
  000c6	40		 inc	 eax
  000c7	75 2f		 jne	 SHORT $LN23@GCReqmoveD

; 14749: 	{
; 14750: 		pResult.Result = 1;
; 14751: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000c9	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000cd	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000d0	50		 push	 eax
  000d1	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000d4	51		 push	 ecx
  000d5	52		 push	 edx
  000d6	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  000da	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14752: 
; 14753: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]",
; 14754: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);

  000df	8b 45 f4	 mov	 eax, DWORD PTR tv564[ebp]
  000e2	0f bf 8e 96 00
	00 00		 movsx	 ecx, WORD PTR [esi+150]
  000e9	0f b7 96 90 00
	00 00		 movzx	 edx, WORD PTR [esi+144]
  000f0	50		 push	 eax
  000f1	51		 push	 ecx
  000f2	52		 push	 edx

; 14755: 
; 14756: 		return;

  000f3	e9 a5 00 00 00	 jmp	 $LN60@GCReqmoveD
$LN23@GCReqmoveD:

; 14757: 	}
; 14758: 
; 14759: 	if ( DS_LEVEL_RANGE(cSquareNumber) == FALSE )

  000f8	b8 06 00 00 00	 mov	 eax, 6
  000fd	3a 45 ff	 cmp	 al, BYTE PTR _cSquareNumber$[ebp]
  00100	1b c0		 sbb	 eax, eax
  00102	40		 inc	 eax

; 14760: 	{
; 14761: 		pResult.Result = 1;
; 14762: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 14763: 
; 14764: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]",
; 14765: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 14766: 
; 14767: 		return;

  00103	74 6e		 je	 SHORT $LN18@GCReqmoveD

; 14768: 	}
; 14769: 
; 14770: 	if ( g_DevilSquare.GetState() != DevilSquare_OPEN )

  00105	83 3d 04 00 00
	00 01		 cmp	 DWORD PTR ?g_DevilSquare@@3VCDevilSquare@@A+4, 1
  0010c	74 06		 je	 SHORT $LN21@GCReqmoveD

; 14771: 	{
; 14772: 		pResult.Result = 2;

  0010e	c6 45 fb 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 14773: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 14774: 
; 14775: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]",
; 14776: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 14777: 
; 14778: 		return;

  00112	eb 63		 jmp	 SHORT $LN59@GCReqmoveD
$LN21@GCReqmoveD:

; 14779: 	}
; 14780: 
; 14781: 	if ( g_DevilSquare.m_DevilSquareGround[cSquareNumber].GetObjCount() >= MAX_DEVILSQUARE_USER )

  00114	8b 4d f0	 mov	 ecx, DWORD PTR tv563[ebp]
  00117	69 c9 20 05 00
	00		 imul	 ecx, 1312		; 00000520H
  0011d	81 c1 3c 00 00
	00		 add	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A+60
  00123	e8 00 00 00 00	 call	 ?GetObjCount@CDevilSquareGround@@QAEJXZ ; CDevilSquareGround::GetObjCount
  00128	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0012b	7c 06		 jl	 SHORT $LN20@GCReqmoveD

; 14782: 	{
; 14783: 		pResult.Result = 5;

  0012d	c6 45 fb 05	 mov	 BYTE PTR _pResult$[ebp+3], 5

; 14784: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 14785: 
; 14786: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]",
; 14787: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 14788: 
; 14789: 		return;

  00131	eb 44		 jmp	 SHORT $LN59@GCReqmoveD
$LN20@GCReqmoveD:

; 14790: 	}
; 14791: 
; 14792: 	CItem * sitem = &lpObj->pInventory[cInvitationItemPos];

  00133	0f b6 45 e8	 movzx	 eax, BYTE PTR _cInvitationItemPos$[ebp]
  00137	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  0013d	89 45 e0	 mov	 DWORD PTR tv591[ebp], eax
  00140	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H

; 14793: 
; 14794: 	if ( sitem->m_Type != ITEMGET(14,19) && ( sitem->m_Type != ITEMGET(13,46) || sitem->m_Durability <= 0.0f ) )	// Devil's Invitation

  00146	0f b7 54 01 06	 movzx	 edx, WORD PTR [ecx+eax+6]
  0014b	03 c8		 add	 ecx, eax
  0014d	89 45 dc	 mov	 DWORD PTR tv592[ebp], eax
  00150	b8 13 1c 00 00	 mov	 eax, 7187		; 00001c13H
  00155	89 4d d8	 mov	 DWORD PTR _sitem$[ebp], ecx
  00158	66 3b d0	 cmp	 dx, ax
  0015b	74 57		 je	 SHORT $LN44@GCReqmoveD
  0015d	b8 2e 1a 00 00	 mov	 eax, 6702		; 00001a2eH
  00162	66 3b d0	 cmp	 dx, ax
  00165	75 0c		 jne	 SHORT $LN18@GCReqmoveD
  00167	d9 ee		 fldz
  00169	d8 59 24	 fcomp	 DWORD PTR [ecx+36]
  0016c	df e0		 fnstsw	 ax
  0016e	f6 c4 01	 test	 ah, 1
  00171	75 41		 jne	 SHORT $LN44@GCReqmoveD
$LN18@GCReqmoveD:

; 14795: 	{
; 14796: 		pResult.Result = 1;

  00173	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
$LN59@GCReqmoveD:

; 14797: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00177	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  0017b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0017e	51		 push	 ecx
  0017f	8d 55 f8	 lea	 edx, DWORD PTR _pResult$[ebp]
  00182	52		 push	 edx
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14798: 
; 14799: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]",
; 14800: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);

  00189	8b 4d f4	 mov	 ecx, DWORD PTR tv564[ebp]
  0018c	0f bf 96 96 00
	00 00		 movsx	 edx, WORD PTR [esi+150]
  00193	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  0019a	51		 push	 ecx
  0019b	52		 push	 edx
  0019c	50		 push	 eax
$LN60@GCReqmoveD:
  0019d	57		 push	 edi
  0019e	53		 push	 ebx
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001aa	83 c4 24	 add	 esp, 36			; 00000024H
  001ad	5f		 pop	 edi
  001ae	5b		 pop	 ebx
  001af	5e		 pop	 esi

; 14910: }

  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c3		 ret	 0
$LN44@GCReqmoveD:

; 14801: 
; 14802: 		return;
; 14803: 	}
; 14804: 
; 14805: 	int ItemLevel = sitem->m_Level;

  001b4	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]

; 14806: 
; 14807: 	if ( sitem->m_Type == ITEMGET(13,46) )

  001b8	b9 2e 1a 00 00	 mov	 ecx, 6702		; 00001a2eH
  001bd	89 45 ec	 mov	 DWORD PTR _ItemLevel$[ebp], eax
  001c0	66 3b d1	 cmp	 dx, cx
  001c3	75 47		 jne	 SHORT $LN17@GCReqmoveD

; 14808: 		ItemLevel = 10;

  001c5	c7 45 ec 0a 00
	00 00		 mov	 DWORD PTR _ItemLevel$[ebp], 10 ; 0000000aH
$LN12@GCReqmoveD:

; 14828: 
; 14829: 				return;
; 14830: 			}
; 14831: 		}
; 14832: 	}
; 14833: 
; 14834: 	BOOL bEnterCheck = FALSE;
; 14835: 	int movegateindex = 61;	// #gate
; 14836: 	int iENTER_LEVEL = g_DevilSquare.GetUserLevelToEnter(aIndex, movegateindex);

  001cc	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  001cf	8d 45 e4	 lea	 eax, DWORD PTR _movegateindex$[ebp]
  001d2	50		 push	 eax
  001d3	51		 push	 ecx
  001d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  001d9	c7 45 e4 3d 00
	00 00		 mov	 DWORD PTR _movegateindex$[ebp], 61 ; 0000003dH
  001e0	e8 00 00 00 00	 call	 ?GetUserLevelToEnter@CDevilSquare@@QAEHHAAH@Z ; CDevilSquare::GetUserLevelToEnter

; 14837: 
; 14838: 	if ( DS_LEVEL_RANGE(iENTER_LEVEL) == FALSE )

  001e5	85 c0		 test	 eax, eax
  001e7	78 0c		 js	 SHORT $LN41@GCReqmoveD
  001e9	33 c9		 xor	 ecx, ecx
  001eb	83 f8 06	 cmp	 eax, 6
  001ee	0f 9e c1	 setle	 cl
  001f1	85 c9		 test	 ecx, ecx
  001f3	75 6a		 jne	 SHORT $LN11@GCReqmoveD
$LN41@GCReqmoveD:

; 14839: 	{
; 14840: 		LogAddTD("[DevilSquare] [%s][%s] GetUserLevelToEnter() failed",
; 14841: 			lpObj->AccountID, lpObj->Name);

  001f5	57		 push	 edi
  001f6	53		 push	 ebx
  001f7	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@
  001fc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00202	83 c4 0c	 add	 esp, 12			; 0000000cH
  00205	5f		 pop	 edi
  00206	5b		 pop	 ebx
  00207	5e		 pop	 esi

; 14910: }

  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c3		 ret	 0
$LN17@GCReqmoveD:

; 14809: 
; 14810: 	int level = lpObj->Level;
; 14811: 
; 14812: 	if ( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA )
; 14813: 	{
; 14814: 		level = (level+1)/2*3;
; 14815: 	}
; 14816: 
; 14817: 	if ( ItemLevel != 0 )

  0020c	85 c0		 test	 eax, eax
  0020e	74 bc		 je	 SHORT $LN12@GCReqmoveD

; 14818: 	{
; 14819: 		if ( ItemLevel != 10 )

  00210	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00213	74 b7		 je	 SHORT $LN12@GCReqmoveD

; 14820: 		{
; 14821: 			if ( ItemLevel != (cSquareNumber+1) )

  00215	3b 45 f4	 cmp	 eax, DWORD PTR tv564[ebp]
  00218	74 b2		 je	 SHORT $LN12@GCReqmoveD

; 14822: 			{
; 14823: 				pResult.Result = 1;
; 14824: 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0021a	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0021e	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00221	52		 push	 edx
  00222	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00225	50		 push	 eax
  00226	51		 push	 ecx
  00227	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  0022b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14825: 
; 14826: 				LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Invitation LevelError [%d][%d][%d][%d]",
; 14827: 					lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1, ItemLevel);

  00230	8b 55 ec	 mov	 edx, DWORD PTR _ItemLevel$[ebp]
  00233	8b 45 f4	 mov	 eax, DWORD PTR tv564[ebp]
  00236	0f bf 8e 96 00
	00 00		 movsx	 ecx, WORD PTR [esi+150]
  0023d	52		 push	 edx
  0023e	0f b7 96 90 00
	00 00		 movzx	 edx, WORD PTR [esi+144]
  00245	50		 push	 eax
  00246	51		 push	 ecx
  00247	52		 push	 edx
  00248	57		 push	 edi
  00249	53		 push	 ebx
  0024a	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@

; 14876: 
; 14877: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]",
; 14878: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber, ItemLevel);

  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00255	83 c4 28	 add	 esp, 40			; 00000028H
  00258	5f		 pop	 edi
  00259	5b		 pop	 ebx
  0025a	5e		 pop	 esi

; 14910: }

  0025b	8b e5		 mov	 esp, ebp
  0025d	5d		 pop	 ebp
  0025e	c3		 ret	 0
$LN11@GCReqmoveD:

; 14842: 
; 14843: 		return;
; 14844: 	}
; 14845: 
; 14846: 	if ( ItemLevel == 10 )

  0025f	8b 55 ec	 mov	 edx, DWORD PTR _ItemLevel$[ebp]

; 14847: 		cSquareNumber = iENTER_LEVEL;

  00262	8a c8		 mov	 cl, al
  00264	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00267	74 03		 je	 SHORT $LN10@GCReqmoveD
  00269	8a 4d ff	 mov	 cl, BYTE PTR _cSquareNumber$[ebp]
$LN10@GCReqmoveD:

; 14848: 
; 14849: 	if ( cSquareNumber != iENTER_LEVEL )

  0026c	0f b6 c9	 movzx	 ecx, cl
  0026f	89 4d f0	 mov	 DWORD PTR tv563[ebp], ecx
  00272	3b c8		 cmp	 ecx, eax
  00274	74 77		 je	 SHORT $LN5@GCReqmoveD

; 14850: 	{
; 14851: 		if ( cSquareNumber > iENTER_LEVEL )
; 14852: 		{
; 14853: 			bEnterCheck = 2;
; 14854: 		}
; 14855: 		else

  00276	7f 30		 jg	 SHORT $LN42@GCReqmoveD

; 14856: 		{
; 14857: 			bEnterCheck = 1;
; 14858: 		}
; 14859: 	}
; 14860: 
; 14861: 	if ( bEnterCheck == 1 )
; 14862: 	{
; 14863: 		pResult.Result = 3;
; 14864: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00278	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0027c	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0027f	52		 push	 edx
  00280	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00283	50		 push	 eax
  00284	51		 push	 ecx
  00285	c6 45 fb 03	 mov	 BYTE PTR _pResult$[ebp+3], 3
  00289	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14865: 
; 14866: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]",
; 14867: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber, ItemLevel);

  0028e	8b 55 ec	 mov	 edx, DWORD PTR _ItemLevel$[ebp]
  00291	8b 45 f0	 mov	 eax, DWORD PTR tv563[ebp]
  00294	0f bf 8e 96 00
	00 00		 movsx	 ecx, WORD PTR [esi+150]
  0029b	52		 push	 edx
  0029c	0f b7 96 90 00
	00 00		 movzx	 edx, WORD PTR [esi+144]
  002a3	50		 push	 eax
  002a4	51		 push	 ecx
  002a5	52		 push	 edx

; 14868: 
; 14869: 		return;

  002a6	eb 2e		 jmp	 SHORT $LN57@GCReqmoveD
$LN42@GCReqmoveD:

; 14870: 	}
; 14871: 
; 14872: 	if ( bEnterCheck == 2 )
; 14873: 	{
; 14874: 		pResult.Result = 4;
; 14875: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  002a8	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  002ac	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  002af	50		 push	 eax
  002b0	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  002b3	51		 push	 ecx
  002b4	52		 push	 edx
  002b5	c6 45 fb 04	 mov	 BYTE PTR _pResult$[ebp+3], 4
  002b9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14876: 
; 14877: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]",
; 14878: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber, ItemLevel);

  002be	8b 45 ec	 mov	 eax, DWORD PTR _ItemLevel$[ebp]
  002c1	8b 4d f0	 mov	 ecx, DWORD PTR tv563[ebp]
  002c4	0f bf 96 96 00
	00 00		 movsx	 edx, WORD PTR [esi+150]
  002cb	50		 push	 eax
  002cc	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  002d3	51		 push	 ecx
  002d4	52		 push	 edx
  002d5	50		 push	 eax
$LN57@GCReqmoveD:
  002d6	57		 push	 edi
  002d7	53		 push	 ebx
  002d8	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  002dd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002e3	83 c4 28	 add	 esp, 40			; 00000028H
  002e6	5f		 pop	 edi
  002e7	5b		 pop	 ebx
  002e8	5e		 pop	 esi

; 14910: }

  002e9	8b e5		 mov	 esp, ebp
  002eb	5d		 pop	 ebp
  002ec	c3		 ret	 0
$LN5@GCReqmoveD:

; 14879: 
; 14880: 		return;
; 14881: 	}
; 14882: 
; 14883: 	LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare success [%d][%d] RemoveItem[%s][%d][%d][%d]",
; 14884: 		lpObj->AccountID, lpObj->Name, lpObj->Level, cSquareNumber, lpObj->pInventory[cInvitationItemPos].GetName(),
; 14885: 		cInvitationItemPos, ItemLevel, lpObj->pInventory[cInvitationItemPos].m_Number);

  002ed	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  002f3	03 4d dc	 add	 ecx, DWORD PTR tv592[ebp]
  002f6	8b 01		 mov	 eax, DWORD PTR [ecx]
  002f8	50		 push	 eax
  002f9	52		 push	 edx
  002fa	8b 55 e0	 mov	 edx, DWORD PTR tv591[ebp]
  002fd	52		 push	 edx
  002fe	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00303	0f bf 8e 96 00
	00 00		 movsx	 ecx, WORD PTR [esi+150]
  0030a	50		 push	 eax
  0030b	8b 45 f0	 mov	 eax, DWORD PTR tv563[ebp]
  0030e	50		 push	 eax
  0030f	51		 push	 ecx
  00310	57		 push	 edi
  00311	53		 push	 ebx
  00312	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  00317	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14886: 
; 14887: 	if ( sitem->m_Type == ITEMGET(14,19) || (sitem->m_Type == ITEMGET(13,46) && sitem->m_Durability == 1.0f) )

  0031d	8b 55 d8	 mov	 edx, DWORD PTR _sitem$[ebp]
  00320	0f b7 4a 06	 movzx	 ecx, WORD PTR [edx+6]
  00324	b8 13 1c 00 00	 mov	 eax, 7187		; 00001c13H
  00329	83 c4 24	 add	 esp, 36			; 00000024H
  0032c	66 3b c8	 cmp	 cx, ax
  0032f	74 74		 je	 SHORT $LN3@GCReqmoveD
  00331	d9 e8		 fld1
  00333	b8 2e 1a 00 00	 mov	 eax, 6702		; 00001a2eH
  00338	66 3b c8	 cmp	 cx, ax
  0033b	75 0e		 jne	 SHORT $LN4@GCReqmoveD
  0033d	d9 42 24	 fld	 DWORD PTR [edx+36]
  00340	d9 c1		 fld	 ST(1)
  00342	da e9		 fucompp
  00344	df e0		 fnstsw	 ax
  00346	f6 c4 44	 test	 ah, 68			; 00000044H
  00349	7b 58		 jnp	 SHORT $LN53@GCReqmoveD
$LN4@GCReqmoveD:

; 14892: 	}
; 14893: 	else if ( sitem->m_Type == ITEMGET(13,46) && sitem->m_Durability > 1.0f )

  0034b	b8 2e 1a 00 00	 mov	 eax, 6702		; 00001a2eH
  00350	66 3b c8	 cmp	 cx, ax
  00353	75 7d		 jne	 SHORT $LN55@GCReqmoveD
  00355	d8 5a 24	 fcomp	 DWORD PTR [edx+36]
  00358	df e0		 fnstsw	 ax
  0035a	f6 c4 05	 test	 ah, 5
  0035d	7a 75		 jp	 SHORT $LN46@GCReqmoveD

; 14894: 	{
; 14895: 		sitem->m_Durability -= 1.0f;

  0035f	d9 42 24	 fld	 DWORD PTR [edx+36]

; 14896: 		GCItemDurSend2(lpObj->m_Index, cInvitationItemPos,(BYTE)sitem->m_Durability, 0);

  00362	6a 00		 push	 0
  00364	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  0036a	d9 5d 0c	 fstp	 DWORD PTR tv627[ebp]
  0036d	d9 45 0c	 fld	 DWORD PTR tv627[ebp]
  00370	d9 7d 0e	 fnstcw	 WORD PTR tv624[ebp]
  00373	0f b7 45 0e	 movzx	 eax, WORD PTR tv624[ebp]
  00377	d9 52 24	 fst	 DWORD PTR [edx+36]
  0037a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0037f	89 45 d8	 mov	 DWORD PTR tv621[ebp], eax
  00382	8b 45 e8	 mov	 eax, DWORD PTR _cInvitationItemPos$[ebp]
  00385	d9 6d d8	 fldcw	 WORD PTR tv621[ebp]
  00388	db 5d d8	 fistp	 DWORD PTR tv619[ebp]
  0038b	8a 4d d8	 mov	 cl, BYTE PTR tv619[ebp]
  0038e	0f b6 d1	 movzx	 edx, cl
  00391	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00393	d9 6d 0e	 fldcw	 WORD PTR tv624[ebp]
  00396	52		 push	 edx
  00397	50		 push	 eax
  00398	51		 push	 ecx
  00399	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  0039e	83 c4 10	 add	 esp, 16			; 00000010H
  003a1	eb 31		 jmp	 SHORT $LN46@GCReqmoveD
$LN53@GCReqmoveD:

; 14886: 
; 14887: 	if ( sitem->m_Type == ITEMGET(14,19) || (sitem->m_Type == ITEMGET(13,46) && sitem->m_Durability == 1.0f) )

  003a3	dd d8		 fstp	 ST(0)
$LN3@GCReqmoveD:

; 14888: 	{
; 14889: 		gObjInventoryDeleteItem(aIndex, cInvitationItemPos);

  003a5	8b 55 e0	 mov	 edx, DWORD PTR tv591[ebp]
  003a8	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  003ab	52		 push	 edx
  003ac	57		 push	 edi
  003ad	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 14890: 		GCInventoryItemDeleteSend(aIndex, cInvitationItemPos, 1);

  003b2	8b 45 e8	 mov	 eax, DWORD PTR _cInvitationItemPos$[ebp]
  003b5	6a 01		 push	 1
  003b7	50		 push	 eax
  003b8	57		 push	 edi
  003b9	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 14891: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  003be	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  003c2	51		 push	 ecx
  003c3	8d 55 f8	 lea	 edx, DWORD PTR _pResult$[ebp]
  003c6	52		 push	 edx
  003c7	57		 push	 edi
  003c8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003cd	83 c4 20	 add	 esp, 32			; 00000020H
  003d0	eb 02		 jmp	 SHORT $LN46@GCReqmoveD
$LN55@GCReqmoveD:
  003d2	dd d8		 fstp	 ST(0)
$LN46@GCReqmoveD:

; 14897: 	}
; 14898: 
; 14899: 	lpObj->m_nEventExp = 0;

  003d4	33 c0		 xor	 eax, eax
  003d6	89 86 2c 12 00
	00		 mov	 DWORD PTR [esi+4652], eax

; 14900: 	lpObj->m_nEventScore = 0;

  003dc	89 86 28 12 00
	00		 mov	 DWORD PTR [esi+4648], eax

; 14901: 	lpObj->m_nEventMoney = 0;

  003e2	89 86 30 12 00
	00		 mov	 DWORD PTR [esi+4656], eax

; 14902: 	lpObj->m_bDevilSquareIndex = g_DevilSquare.GetDevilSquareIndex(movegateindex);

  003e8	8b 45 e4	 mov	 eax, DWORD PTR _movegateindex$[ebp]
  003eb	50		 push	 eax
  003ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  003f1	e8 00 00 00 00	 call	 ?GetDevilSquareIndex@CDevilSquare@@QAEHH@Z ; CDevilSquare::GetDevilSquareIndex

; 14903: 	lpObj->m_bDevilSquareAuth = true;
; 14904: 	lpObj->m_IfState.state = 0;
; 14905: 	lpObj->m_IfState.type = 0;
; 14906: 	lpObj->m_IfState.use = 0;

  003f6	81 a6 b8 11 00
	00 00 00 ff ff	 and	 DWORD PTR [esi+4536], -65536 ; ffff0000H

; 14907: 
; 14908: 	gObjMoveGate(lpObj->m_Index, movegateindex);

  00400	8b 16		 mov	 edx, DWORD PTR [esi]
  00402	88 86 34 12 00
	00		 mov	 BYTE PTR [esi+4660], al
  00408	c6 86 35 12 00
	00 01		 mov	 BYTE PTR [esi+4661], 1
  0040f	8b 4d e4	 mov	 ecx, DWORD PTR _movegateindex$[ebp]
  00412	51		 push	 ecx
  00413	52		 push	 edx
  00414	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14909: 	g_DevilSquare.m_DevilSquareGround[cSquareNumber].IncObjCount();

  00419	8b 4d f0	 mov	 ecx, DWORD PTR tv563[ebp]
  0041c	69 c9 20 05 00
	00		 imul	 ecx, 1312		; 00000520H
  00422	83 c4 08	 add	 esp, 8
  00425	81 c1 3c 00 00
	00		 add	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A+60
  0042b	e8 00 00 00 00	 call	 ?IncObjCount@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::IncObjCount
  00430	5f		 pop	 edi
  00431	5b		 pop	 ebx
  00432	5e		 pop	 esi

; 14910: }

  00433	8b e5		 mov	 esp, ebp
  00435	5d		 pop	 ebp
  00436	c3		 ret	 0
$LN27@GCReqmoveD:

; 14697: 	{
; 14698: 		LogAdd("return %s %d", __FILE__, __LINE__);

  00437	68 6a 39 00 00	 push	 14698			; 0000396aH
  0043c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00441	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00446	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0044c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0044f	5e		 pop	 esi

; 14910: }

  00450	8b e5		 mov	 esp, ebp
  00452	5d		 pop	 ebp
  00453	c3		 ret	 0
?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ENDP ; GCReqmoveDevilSquare
_TEXT	ENDS
PUBLIC	??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ; GCReqDevilSquareRemainTime
EXTRN	?GetLeftTime@CIllusionTempleEvent@@QAEEXZ:PROC	; CIllusionTempleEvent::GetLeftTime
EXTRN	?g_IllusionTemple@@3VCIllusionTempleEvent@@A:BYTE ; g_IllusionTemple
EXTRN	?GetRemainTime@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetRemainTime
EXTRN	?GetCurEnteredUser@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurEnteredUser
EXTRN	?CheckCanEnter@CChaosCastle@@QAE_NH@Z:PROC	; CChaosCastle::CheckCanEnter
EXTRN	?GetCurrentState@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurrentState
EXTRN	?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetUserLevelToEnter
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?GetRemainTime@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetRemainTime
EXTRN	?CheckCanEnter@CBloodCastle@@QAE_NH@Z:PROC	; CBloodCastle::CheckCanEnter
EXTRN	?GetRemainTime@CDevilSquare@@QAEHXZ:PROC	; CDevilSquare::GetRemainTime
;	COMDAT ??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\devilsquare.h
CONST	SEGMENT
??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'PK User][BloodCastle] [%s][%s] Move Fail [PK Level:%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'PK User][DevilSquare] [%s][%s] Move Fail [PK Level:%d]', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 7
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z PROC ; GCReqDevilSquareRemainTime, COMDAT

; 14925: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 14926: 	PMSG_RESULT_DEVILSQUARE_REMAINTIME pResult;
; 14927: 
; 14928: 	PHeadSetB((LPBYTE)&pResult, 0x91, sizeof(pResult));

  00008	6a 07		 push	 7
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000d	68 91 00 00 00	 push	 145			; 00000091H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14929: 	pResult.RemainTime = 0;
; 14930: 
; 14931: 	switch ( lpMsg->hEventType )

  00018	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001b	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0001f	48		 dec	 eax
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  00027	83 f8 04	 cmp	 eax, 4
  0002a	0f 87 e7 01 00
	00		 ja	 $LN28@GCReqDevil
  00030	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN33@GCReqDevil[eax*4]
$LN19@GCReqDevil:

; 14932: 	{
; 14933: 		case 1:
; 14934: #if (ENABLE_FIX_EVENTPK == 1)
; 14935: 			if ( gObj[aIndex].m_PK_Level >= 4 )

  00037	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00040	8b f0		 mov	 esi, eax
  00042	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00048	80 bc 0e 19 01
	00 00 04	 cmp	 BYTE PTR [esi+ecx+281], 4
  00050	7c 38		 jl	 SHORT $LN18@GCReqDevil

; 14936: 			{
; 14937: 				GCServerCmd(aIndex, 0x37, 0, 0);

  00052	6a 00		 push	 0
  00054	6a 00		 push	 0
  00056	6a 37		 push	 55			; 00000037H
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd

; 14938: 
; 14939: 				LogAddTD("[PK User][DevilSquare] [%s][%s] Move Fail [PK Level:%d]",
; 14940: 					gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level);

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00063	0f be 94 06 19
	01 00 00	 movsx	 edx, BYTE PTR [esi+eax+281]
  0006b	52		 push	 edx
  0006c	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00070	51		 push	 ecx
  00071	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00075	52		 push	 edx
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00081	83 c4 20	 add	 esp, 32			; 00000020H
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi

; 15052: }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN18@GCReqDevil:

; 14941: 
; 14942: 				return;
; 14943: 			}
; 14944: #endif
; 14945: 
; 14946: 			pResult.hEventType = 1;
; 14947: 
; 14948: 			if ( g_DevilSquare.GetState() == DevilSquare_CLOSE )

  0008a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_DevilSquare@@3VCDevilSquare@@A+4
  0008f	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00093	85 c0		 test	 eax, eax
  00095	75 0f		 jne	 SHORT $LN17@GCReqDevil

; 14949: 			{
; 14950: 				pResult.RemainTime = g_DevilSquare.GetRemainTime();

  00097	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  0009c	e8 00 00 00 00	 call	 ?GetRemainTime@CDevilSquare@@QAEHXZ ; CDevilSquare::GetRemainTime
  000a1	e9 6e 01 00 00	 jmp	 $LN29@GCReqDevil
$LN17@GCReqDevil:

; 14951: 			}
; 14952: 			else if ( g_DevilSquare.GetState() == DevilSquare_OPEN )

  000a6	83 f8 01	 cmp	 eax, 1
  000a9	75 09		 jne	 SHORT $LN15@GCReqDevil
$LN32@GCReqDevil:

; 14953: 			{
; 14954: 				pResult.RemainTime = 0;

  000ab	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 14955: 			}
; 14956: 			else

  000af	e9 63 01 00 00	 jmp	 $LN28@GCReqDevil
$LN15@GCReqDevil:

; 14957: 			{
; 14958: 				pResult.RemainTime = g_DevilSquare.GetRemainTime() + g_DevilSquare.m_iCloseTime;

  000b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  000b9	e8 00 00 00 00	 call	 ?GetRemainTime@CDevilSquare@@QAEHXZ ; CDevilSquare::GetRemainTime
  000be	02 05 30 00 00
	00		 add	 al, BYTE PTR ?g_DevilSquare@@3VCDevilSquare@@A+48

; 14959: 			}
; 14960: 			break;

  000c4	e9 4b 01 00 00	 jmp	 $LN29@GCReqDevil
$LN13@GCReqDevil:

; 14961: 
; 14962: 		case 2:
; 14963: #if( ENABLE_FIX_EVENTPK == 1 )
; 14964: 			if ( gObj[aIndex].m_PK_Level >= 4 )

  000c9	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d2	8b f0		 mov	 esi, eax
  000d4	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  000da	80 bc 0e 19 01
	00 00 04	 cmp	 BYTE PTR [esi+ecx+281], 4
  000e2	7c 38		 jl	 SHORT $LN12@GCReqDevil

; 14965: 			{
; 14966: 				GCServerCmd(aIndex, 0x38, 0, 0);

  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	6a 38		 push	 56			; 00000038H
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd

; 14967: 
; 14968: 				LogAddTD("[PK User][BloodCastle] [%s][%s] Move Fail [PK Level:%d]",
; 14969: 					gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level);

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f5	0f be 94 06 19
	01 00 00	 movsx	 edx, BYTE PTR [esi+eax+281]
  000fd	52		 push	 edx
  000fe	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00102	51		 push	 ecx
  00103	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00107	52		 push	 edx
  00108	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00113	83 c4 20	 add	 esp, 32			; 00000020H
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi

; 15052: }

  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
$LN12@GCReqDevil:

; 14970: 
; 14971: 				return;
; 14972: 			}
; 14973: #endif
; 14974: 
; 14975: 			pResult.hEventType = 2;
; 14976: 
; 14977: 			if ( g_BloodCastle.GetCurrentState(lpMsg->btItemLevel-1) == 1 )

  0011c	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00120	48		 dec	 eax
  00121	50		 push	 eax
  00122	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00127	c6 45 fb 02	 mov	 BYTE PTR _pResult$[ebp+3], 2
  0012b	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  00130	83 f8 01	 cmp	 eax, 1
  00133	75 2d		 jne	 SHORT $LN11@GCReqDevil

; 14978: 			{
; 14979: 				if ( g_BloodCastle.CheckCanEnter(lpMsg->btItemLevel-1) != false )

  00135	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00139	49		 dec	 ecx
  0013a	51		 push	 ecx
  0013b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00140	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  00145	84 c0		 test	 al, al

; 14980: 				{
; 14981: 					pResult.RemainTime = 0;
; 14982: 				}
; 14983: 				else

  00147	0f 85 5e ff ff
	ff		 jne	 $LN32@GCReqDevil

; 14984: 				{
; 14985: 					pResult.RemainTime = g_BloodCastle.GetRemainTime(lpMsg->btItemLevel-1);

  0014d	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  00151	4a		 dec	 edx
  00152	52		 push	 edx
  00153	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00158	e8 00 00 00 00	 call	 ?GetRemainTime@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetRemainTime

; 14986: 				}
; 14987: 			}
; 14988: 			else

  0015d	e9 b2 00 00 00	 jmp	 $LN29@GCReqDevil
$LN11@GCReqDevil:

; 14989: 			{
; 14990: 				pResult.RemainTime = g_BloodCastle.GetRemainTime(lpMsg->btItemLevel-1);

  00162	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00166	48		 dec	 eax
  00167	50		 push	 eax
  00168	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0016d	e8 00 00 00 00	 call	 ?GetRemainTime@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetRemainTime

; 14991: 			}
; 14992: 			break;

  00172	e9 9d 00 00 00	 jmp	 $LN29@GCReqDevil
$LN7@GCReqDevil:

; 14993: 
; 14994: 		case 4:
; 14995: 			{
; 14996: #if( ENABLE_FIX_EVENTPK == 1 )
; 14997: #else
; 14998: 			if ( gObj[aIndex].m_PK_Level >= 4 )
; 14999: 			{
; 15000: 				GCServerCmd(aIndex, 0x39, 0, 0);
; 15001: 
; 15002: 				LogAddTD("[PK User][ChaosCastle] [%s][%s] Move Fail [PK Level:%d]",
; 15003: 					gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level);
; 15004: 
; 15005: 				return;
; 15006: 			}
; 15007: #endif
; 15008: 
; 15009: 			int iENTER_LEVEL =  g_ChaosCastle.GetUserLevelToEnter(aIndex);

  00177	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0017a	51		 push	 ecx
  0017b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00180	e8 00 00 00 00	 call	 ?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetUserLevelToEnter
  00185	8b f0		 mov	 esi, eax

; 15010: 
; 15011: 			if ( iENTER_LEVEL == -1 )

  00187	83 fe ff	 cmp	 esi, -1
  0018a	0f 84 9c 00 00
	00		 je	 $LN22@GCReqDevil

; 15012: 				return;
; 15013: 
; 15014: 			pResult.hEventType = 4;
; 15015: 
; 15016: 			if ( g_ChaosCastle.GetCurrentState(iENTER_LEVEL) == 1 )

  00190	56		 push	 esi
  00191	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00196	c6 45 fb 04	 mov	 BYTE PTR _pResult$[ebp+3], 4
  0019a	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState

; 15017: 			{
; 15018: 				if ( g_ChaosCastle.CheckCanEnter(iENTER_LEVEL) != false )

  0019f	56		 push	 esi
  001a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  001a5	83 f8 01	 cmp	 eax, 1
  001a8	75 33		 jne	 SHORT $LN5@GCReqDevil
  001aa	e8 00 00 00 00	 call	 ?CheckCanEnter@CChaosCastle@@QAE_NH@Z ; CChaosCastle::CheckCanEnter

; 15022: 					pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  001af	56		 push	 esi
  001b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  001b5	84 c0		 test	 al, al
  001b7	74 12		 je	 SHORT $LN4@GCReqDevil

; 15019: 				{
; 15020: 					pResult.RemainTime = 0;
; 15021: 					pResult.RemainTime_LOW = 0;

  001b9	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  001bd	c6 45 fe 00	 mov	 BYTE PTR _pResult$[ebp+6], 0

; 15036: 				pResult.RemainTime_LOW = SET_NUMBERL(wREMAIN_TIME);
; 15037: 				pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  001c1	e8 00 00 00 00	 call	 ?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurEnteredUser
  001c6	88 45 fd	 mov	 BYTE PTR _pResult$[ebp+5], al

; 15038: 			}
; 15039: 			}
; 15040: 			break;

  001c9	eb 4c		 jmp	 SHORT $LN28@GCReqDevil
$LN4@GCReqDevil:

; 15023: 				}
; 15024: 				else
; 15025: 				{
; 15026: 					WORD wREMAIN_TIME = g_ChaosCastle.GetRemainTime(iENTER_LEVEL);

  001cb	e8 00 00 00 00	 call	 ?GetRemainTime@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetRemainTime
  001d0	0f b7 c0	 movzx	 eax, ax

; 15027: 					pResult.RemainTime = SET_NUMBERH(wREMAIN_TIME);

  001d3	8b d0		 mov	 edx, eax
  001d5	c1 ea 08	 shr	 edx, 8
  001d8	88 55 fc	 mov	 BYTE PTR _pResult$[ebp+4], dl

; 15028: 					pResult.RemainTime_LOW = SET_NUMBERL(wREMAIN_TIME);
; 15029: 					pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);
; 15030: 				}
; 15031: 			}
; 15032: 			else

  001db	eb 10		 jmp	 SHORT $LN30@GCReqDevil
$LN5@GCReqDevil:

; 15033: 			{
; 15034: 				WORD wREMAIN_TIME = g_ChaosCastle.GetRemainTime(iENTER_LEVEL);

  001dd	e8 00 00 00 00	 call	 ?GetRemainTime@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetRemainTime
  001e2	0f b7 c0	 movzx	 eax, ax

; 15035: 				pResult.RemainTime = SET_NUMBERH(wREMAIN_TIME);

  001e5	8b c8		 mov	 ecx, eax
  001e7	c1 e9 08	 shr	 ecx, 8
  001ea	88 4d fc	 mov	 BYTE PTR _pResult$[ebp+4], cl
$LN30@GCReqDevil:

; 15036: 				pResult.RemainTime_LOW = SET_NUMBERL(wREMAIN_TIME);
; 15037: 				pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  001ed	56		 push	 esi
  001ee	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  001f3	88 45 fe	 mov	 BYTE PTR _pResult$[ebp+6], al
  001f6	e8 00 00 00 00	 call	 ?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurEnteredUser
  001fb	88 45 fd	 mov	 BYTE PTR _pResult$[ebp+5], al

; 15038: 			}
; 15039: 			}
; 15040: 			break;

  001fe	eb 17		 jmp	 SHORT $LN28@GCReqDevil
$LN1@GCReqDevil:

; 15041: 
; 15042: 		case 5:
; 15043: 
; 15044: 			pResult.hEventType = 5;
; 15045: 			pResult.RemainTime = g_IllusionTemple.GetLeftTime();

  00200	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  00205	c6 45 fb 05	 mov	 BYTE PTR _pResult$[ebp+3], 5
  00209	e8 00 00 00 00	 call	 ?GetLeftTime@CIllusionTempleEvent@@QAEEXZ ; CIllusionTempleEvent::GetLeftTime

; 15046: 			pResult.EnteredUser = 0;

  0020e	66 c7 45 fd 00
	00		 mov	 WORD PTR _pResult$[ebp+5], 0
$LN29@GCReqDevil:

; 15041: 
; 15042: 		case 5:
; 15043: 
; 15044: 			pResult.hEventType = 5;
; 15045: 			pResult.RemainTime = g_IllusionTemple.GetLeftTime();

  00214	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al
$LN28@GCReqDevil:

; 15047: 			pResult.RemainTime_LOW = 0;
; 15048: 			break;
; 15049: 	}
; 15050: 
; 15051: 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00217	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0021b	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0021e	52		 push	 edx
  0021f	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00222	50		 push	 eax
  00223	51		 push	 ecx
  00224	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00229	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@GCReqDevil:
  0022c	5f		 pop	 edi
  0022d	5e		 pop	 esi

; 15052: }

  0022e	8b e5		 mov	 esp, ebp
  00230	5d		 pop	 ebp
  00231	c3		 ret	 0
  00232	8b ff		 npad	 2
$LN33@GCReqDevil:
  00234	00 00 00 00	 DD	 $LN19@GCReqDevil
  00238	00 00 00 00	 DD	 $LN13@GCReqDevil
  0023c	00 00 00 00	 DD	 $LN28@GCReqDevil
  00240	00 00 00 00	 DD	 $LN7@GCReqDevil
  00244	00 00 00 00	 DD	 $LN1@GCReqDevil
?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ENDP ; GCReqDevilSquareRemainTime
_TEXT	ENDS
PUBLIC	?AllSendMsg@@YAXPAEH@Z				; AllSendMsg
; Function compile flags: /Ogtp
;	COMDAT ?AllSendMsg@@YAXPAEH@Z
_TEXT	SEGMENT
_Msg$ = 8						; size = 4
_size$ = 12						; size = 4
?AllSendMsg@@YAXPAEH@Z PROC				; AllSendMsg, COMDAT

; 15058: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15059: 	for ( int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _size$[ebp]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  00013	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL5@AllSendMsg:

; 15060: 	{
; 15061: 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00018	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0001d	75 1a		 jne	 SHORT $LN4@AllSendMsg

; 15062: 		{
; 15063: 			if ( gObj[n].Type == OBJ_USER )

  0001f	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00024	75 13		 jne	 SHORT $LN4@AllSendMsg

; 15064: 			{
; 15065: 				DataSend(n, Msg, size);

  00026	8b 45 08	 mov	 eax, DWORD PTR _Msg$[ebp]
  00029	53		 push	 ebx
  0002a	50		 push	 eax
  0002b	57		 push	 edi
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@AllSendMsg:

; 15059: 	for ( int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  00039	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  0003f	47		 inc	 edi
  00040	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00046	7c d0		 jl	 SHORT $LL5@AllSendMsg
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 15066: 			}
; 15067: 		}
; 15068: 	}
; 15069: }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?AllSendMsg@@YAXPAEH@Z ENDP				; AllSendMsg
_TEXT	ENDS
PUBLIC	?AllSendSameMapMsg@@YAXPAEHE@Z			; AllSendSameMapMsg
; Function compile flags: /Ogtp
;	COMDAT ?AllSendSameMapMsg@@YAXPAEHE@Z
_TEXT	SEGMENT
_Msg$ = 8						; size = 4
_size$ = 12						; size = 4
_mapnumber$ = 16					; size = 1
?AllSendSameMapMsg@@YAXPAEHE@Z PROC			; AllSendSameMapMsg, COMDAT

; 15075: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15076: 	for ( int n=0;n<OBJMAX;n++)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _size$[ebp]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	33 ff		 xor	 edi, edi
  00010	33 f6		 xor	 esi, esi
$LL6@AllSendSam:

; 15077: 	{
; 15078: 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00012	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  00017	75 26		 jne	 SHORT $LN5@AllSendSam

; 15079: 		{
; 15080: 			if ( gObj[n].Type == OBJ_USER )

  00019	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  0001e	75 1f		 jne	 SHORT $LN5@AllSendSam

; 15081: 			{
; 15082: 				if ( gObj[n].MapNumber == mapnumber )

  00020	8a 4d 10	 mov	 cl, BYTE PTR _mapnumber$[ebp]
  00023	38 8c 06 23 01
	00 00		 cmp	 BYTE PTR [esi+eax+291], cl
  0002a	75 13		 jne	 SHORT $LN5@AllSendSam

; 15083: 				{
; 15084: 					DataSend(n, Msg, size);

  0002c	8b 55 08	 mov	 edx, DWORD PTR _Msg$[ebp]
  0002f	53		 push	 ebx
  00030	52		 push	 edx
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@AllSendSam:

; 15076: 	for ( int n=0;n<OBJMAX;n++)

  0003f	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00045	47		 inc	 edi
  00046	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  0004c	7c c4		 jl	 SHORT $LL6@AllSendSam
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 15085: 				}
; 15086: 			}
; 15087: 		}
; 15088: 	}
; 15089: }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?AllSendSameMapMsg@@YAXPAEHE@Z ENDP			; AllSendSameMapMsg
_TEXT	ENDS
PUBLIC	??_C@_0BM@JDNCDNDO@You?5lack?5items?5to?5exchange?$CB?$AA@ ; `string'
PUBLIC	??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ ; `string'
PUBLIC	??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ ; `string'
PUBLIC	??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ ; `string'
PUBLIC	??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ ; `string'
PUBLIC	?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ; GCRegEventChipRecv
EXTRN	?g_RenaCount@@3HA:DWORD				; g_RenaCount
EXTRN	?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z:PROC ; EventItemBagManager::OpenSpecial
EXTRN	?gObjDelteItemCountInInventory@@YAXHHHHH@Z:PROC	; gObjDelteItemCountInInventory
EXTRN	?g_StoneCount@@3HA:DWORD			; g_StoneCount
EXTRN	?gObjGetItemCountInIventory@@YAHHHHH@Z:PROC	; gObjGetItemCountInIventory
;	COMDAT ??_C@_0BM@JDNCDNDO@You?5lack?5items?5to?5exchange?$CB?$AA@
CONST	SEGMENT
??_C@_0BM@JDNCDNDO@You?5lack?5items?5to?5exchange?$CB?$AA@ DB 'You lack i'
	DB	'tems to exchange!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
CONST	SEGMENT
??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ DB '['
	DB	'EventChip] [%s][%s] Not Found EventChip (RegEventchip) #2 %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
CONST	SEGMENT
??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ DB '['
	DB	'EventChip] [%s][%s] Not Found EventChip (RegEventchip) #1 %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
CONST	SEGMENT
??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ DB '['
	DB	'EventChip] [%s][%s] Attempted ItemCopy using ChaosBox Window', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
CONST	SEGMENT
??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ DB '['
	DB	'EventChip] [%s][%s] Attempted ItemCopy using Trade Window', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z
_TEXT	SEGMENT
_Result$223066 = -8					; size = 6
_Result$223059 = -8					; size = 6
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z PROC	; GCRegEventChipRecv, COMDAT

; 15112: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 15113: #if (__CUSTOM__ == 1)
; 15114: 	if ( !EVENCHIP_TYPE_RANGE(lpMsg->Type) )

  00007	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0000a	b8 04 00 00 00	 mov	 eax, 4
  0000f	3a 47 03	 cmp	 al, BYTE PTR [edi+3]
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax
  00015	0f 84 30 02 00
	00		 je	 $LN14@GCRegEvent

; 15115: 		return;
; 15116: 
; 15117: 	LPOBJ lpObj = &gObj[aIndex];

  0001b	53		 push	 ebx
  0001c	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001f	56		 push	 esi
  00020	8b f3		 mov	 esi, ebx
  00022	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00028	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15118: 
; 15119: 	if ( lpObj->m_IfState.type == 1 )

  0002e	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  00034	c1 e8 06	 shr	 eax, 6
  00037	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0003c	83 f8 01	 cmp	 eax, 1
  0003f	75 1d		 jne	 SHORT $LN12@GCRegEvent

; 15120: 	{
; 15121: 		LogAddTD("[EventChip] [%s][%s] Attempted ItemCopy using Trade Window",
; 15122: 			lpObj->AccountID, lpObj->Name);

  00041	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  00044	51		 push	 ecx
  00045	83 c6 52	 add	 esi, 82			; 00000052H
  00048	56		 push	 esi
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	5f		 pop	 edi

; 15207: 
; 15208: #endif
; 15209: }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN12@GCRegEvent:

; 15123: 
; 15124: 		return;
; 15125: 	}
; 15126: 
; 15127: 	if ( lpObj->m_IfState.type == 7 )

  0005e	83 f8 07	 cmp	 eax, 7
  00061	75 1d		 jne	 SHORT $LN11@GCRegEvent

; 15128: 	{
; 15129: 		LogAddTD("[EventChip] [%s][%s] Attempted ItemCopy using ChaosBox Window",
; 15130: 			lpObj->AccountID, lpObj->Name);

  00063	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  00066	52		 push	 edx
  00067	83 c6 52	 add	 esi, 82			; 00000052H
  0006a	56		 push	 esi
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	5f		 pop	 edi

; 15207: 
; 15208: #endif
; 15209: }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN11@GCRegEvent:

; 15131: 
; 15132: 		return;
; 15133: 	}
; 15134: 
; 15135: 	if ( lpObj->UseEventServer != FALSE )

  00080	83 be e8 13 00
	00 00		 cmp	 DWORD PTR [esi+5096], 0
  00087	74 4e		 je	 SHORT $LN10@GCRegEvent

; 15136: 	{
; 15137: 		PMSG_REGEVENTCHIP_RESULT Result;
; 15138: 
; 15139: 		PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00089	6a 06		 push	 6
  0008b	8d 45 f8	 lea	 eax, DWORD PTR _Result$223059[ebp]
  0008e	68 95 00 00 00	 push	 149			; 00000095H
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15140: 		Result.ChipCount = -1;
; 15141: 		Result.Type = lpMsg->Type;
; 15142: 
; 15143: 		LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #1 %d",
; 15144: 			lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);

  00099	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0009d	8a 57 03	 mov	 dl, BYTE PTR [edi+3]
  000a0	83 c9 ff	 or	 ecx, -1
  000a3	50		 push	 eax
  000a4	66 89 4d fc	 mov	 WORD PTR _Result$223059[ebp+4], cx
  000a8	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  000ab	51		 push	 ecx
  000ac	83 c6 52	 add	 esi, 82			; 00000052H
  000af	56		 push	 esi
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
  000b5	88 55 fb	 mov	 BYTE PTR _Result$223059[ebp+3], dl
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 15145: 
; 15146: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000be	0f b6 55 f9	 movzx	 edx, BYTE PTR _Result$223059[ebp+1]
  000c2	52		 push	 edx
  000c3	8d 45 f8	 lea	 eax, DWORD PTR _Result$223059[ebp]
  000c6	50		 push	 eax
  000c7	53		 push	 ebx
  000c8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000cd	83 c4 28	 add	 esp, 40			; 00000028H
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	5f		 pop	 edi

; 15207: 
; 15208: #endif
; 15209: }

  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
$LN10@GCRegEvent:

; 15147: 
; 15148: 		return;
; 15149: 	}
; 15150: 
; 15151: 	int Pos = lpMsg->ChipPos + INVENTORY_BAG_START;
; 15152: 	CItem * sitem = &lpObj->pInventory[Pos];

  000d7	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  000db	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000de	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  000e4	03 8e c0 11 00
	00		 add	 ecx, DWORD PTR [esi+4544]

; 15153: 
; 15154: 	if ( !sitem->IsItem() )

  000ea	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ef	85 c0		 test	 eax, eax
  000f1	75 4e		 jne	 SHORT $LN9@GCRegEvent

; 15155: 	{
; 15156: 		PMSG_REGEVENTCHIP_RESULT Result;
; 15157: 
; 15158: 		PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  000f3	6a 06		 push	 6
  000f5	8d 4d f8	 lea	 ecx, DWORD PTR _Result$223066[ebp]
  000f8	68 95 00 00 00	 push	 149			; 00000095H
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15159: 		Result.ChipCount = -1;
; 15160: 		Result.Type = lpMsg->Type;
; 15161: 
; 15162: 		LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #2 %d",
; 15163: 			lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);

  00103	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00107	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  0010a	83 ca ff	 or	 edx, -1
  0010d	51		 push	 ecx
  0010e	66 89 55 fc	 mov	 WORD PTR _Result$223066[ebp+4], dx
  00112	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  00115	52		 push	 edx
  00116	83 c6 52	 add	 esi, 82			; 00000052H
  00119	56		 push	 esi
  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
  0011f	88 45 fb	 mov	 BYTE PTR _Result$223066[ebp+3], al
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 15164: 
; 15165: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  00128	0f b6 45 f9	 movzx	 eax, BYTE PTR _Result$223066[ebp+1]
  0012c	50		 push	 eax
  0012d	8d 4d f8	 lea	 ecx, DWORD PTR _Result$223066[ebp]
  00130	51		 push	 ecx
  00131	53		 push	 ebx
  00132	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00137	83 c4 28	 add	 esp, 40			; 00000028H
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	5f		 pop	 edi

; 15207: 
; 15208: #endif
; 15209: }

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
$LN9@GCRegEvent:

; 15166: 
; 15167: 		return;
; 15168: 	}
; 15169: 
; 15170: 	lpObj->UseEventServer = TRUE;

  00141	c7 86 e8 13 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+5096], 1

; 15171: 
; 15172: 	switch ( lpMsg->Type )

  0014b	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0014f	83 e8 00	 sub	 eax, 0
  00152	74 76		 je	 SHORT $LN6@GCRegEvent
  00154	48		 dec	 eax
  00155	0f 85 e4 00 00
	00		 jne	 $LN4@GCRegEvent

; 15186: 				}
; 15187: 			}
; 15188: 			break;
; 15189: 		case 0x01:
; 15190: 			{
; 15191: 				int count = gObjGetItemCountInIventory(lpObj->m_Index,14,21,1);	// Stone

  0015b	8b 16		 mov	 edx, DWORD PTR [esi]
  0015d	6a 01		 push	 1
  0015f	6a 15		 push	 21			; 00000015H
  00161	6a 0e		 push	 14			; 0000000eH
  00163	52		 push	 edx
  00164	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory

; 15192: 
; 15193: 				if(count >= g_StoneCount)

  00169	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_StoneCount@@3HA ; g_StoneCount
  0016f	83 c4 10	 add	 esp, 16			; 00000010H
  00172	3b c1		 cmp	 eax, ecx
  00174	7c 4a		 jl	 SHORT $LN2@GCRegEvent

; 15194: 				{
; 15195: 					gObjDelteItemCountInInventory(lpObj->m_Index,14,21,1,g_StoneCount);

  00176	8b 06		 mov	 eax, DWORD PTR [esi]
  00178	51		 push	 ecx
  00179	6a 01		 push	 1
  0017b	6a 15		 push	 21			; 00000015H
  0017d	6a 0e		 push	 14			; 0000000eH
  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 ?gObjDelteItemCountInInventory@@YAXHHHHH@Z ; gObjDelteItemCountInInventory

; 15196: 					g_EventItemBagManager.OpenSpecial(EventBagSpecial::GoldenArcher, lpObj->m_Index, lpObj->MapNumber, lpObj->X, lpObj->Y);

  00185	0f b6 8e 21 01
	00 00		 movzx	 ecx, BYTE PTR [esi+289]
  0018c	0f b6 96 20 01
	00 00		 movzx	 edx, BYTE PTR [esi+288]
  00193	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  0019a	83 c4 14	 add	 esp, 20			; 00000014H
  0019d	51		 push	 ecx
  0019e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001a0	52		 push	 edx
  001a1	50		 push	 eax
  001a2	51		 push	 ecx
  001a3	6a 12		 push	 18			; 00000012H
  001a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  001aa	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial

; 15204: 	}
; 15205: 
; 15206: 	lpObj->UseEventServer = FALSE;

  001af	c7 86 e8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5096], 0
  001b9	5e		 pop	 esi
  001ba	5b		 pop	 ebx
  001bb	5f		 pop	 edi

; 15207: 
; 15208: #endif
; 15209: }

  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c3		 ret	 0
$LN2@GCRegEvent:

; 15197: 				}
; 15198: 				else
; 15199: 				{
; 15200: 					MsgOutput(lpObj->m_Index,"You lack items to exchange!");

  001c0	8b 16		 mov	 edx, DWORD PTR [esi]
  001c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JDNCDNDO@You?5lack?5items?5to?5exchange?$CB?$AA@
  001c7	52		 push	 edx

; 15201: 				}
; 15202: 			}
; 15203: 			break;

  001c8	eb 6d		 jmp	 SHORT $LN20@GCRegEvent
$LN6@GCRegEvent:

; 15173: 	{
; 15174: 		case 0x00:
; 15175: 			{
; 15176: 				int count = gObjGetItemCountInIventory(lpObj->m_Index,14,21,0);	// Rena

  001ca	8b 06		 mov	 eax, DWORD PTR [esi]
  001cc	6a 00		 push	 0
  001ce	6a 15		 push	 21			; 00000015H
  001d0	6a 0e		 push	 14			; 0000000eH
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory

; 15177: 
; 15178: 				if(count >= g_RenaCount)

  001d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_RenaCount@@3HA ; g_RenaCount
  001de	83 c4 10	 add	 esp, 16			; 00000010H
  001e1	3b c1		 cmp	 eax, ecx
  001e3	7c 4a		 jl	 SHORT $LN5@GCRegEvent

; 15179: 				{
; 15180: 					gObjDelteItemCountInInventory(lpObj->m_Index,14,21,0,g_RenaCount);

  001e5	51		 push	 ecx
  001e6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001e8	6a 00		 push	 0
  001ea	6a 15		 push	 21			; 00000015H
  001ec	6a 0e		 push	 14			; 0000000eH
  001ee	51		 push	 ecx
  001ef	e8 00 00 00 00	 call	 ?gObjDelteItemCountInInventory@@YAXHHHHH@Z ; gObjDelteItemCountInInventory

; 15181: 					g_EventItemBagManager.OpenSpecial(EventBagSpecial::GoldenArcher, lpObj->m_Index, lpObj->MapNumber, lpObj->X, lpObj->Y);

  001f4	0f b6 96 21 01
	00 00		 movzx	 edx, BYTE PTR [esi+289]
  001fb	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00202	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  00209	83 c4 14	 add	 esp, 20			; 00000014H
  0020c	52		 push	 edx
  0020d	8b 16		 mov	 edx, DWORD PTR [esi]
  0020f	50		 push	 eax
  00210	51		 push	 ecx
  00211	52		 push	 edx
  00212	6a 12		 push	 18			; 00000012H
  00214	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  00219	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial

; 15204: 	}
; 15205: 
; 15206: 	lpObj->UseEventServer = FALSE;

  0021e	c7 86 e8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5096], 0
  00228	5e		 pop	 esi
  00229	5b		 pop	 ebx
  0022a	5f		 pop	 edi

; 15207: 
; 15208: #endif
; 15209: }

  0022b	8b e5		 mov	 esp, ebp
  0022d	5d		 pop	 ebp
  0022e	c3		 ret	 0
$LN5@GCRegEvent:

; 15182: 				}
; 15183: 				else
; 15184: 				{
; 15185: 					MsgOutput(lpObj->m_Index,"You lack items to exchange!");

  0022f	8b 06		 mov	 eax, DWORD PTR [esi]
  00231	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JDNCDNDO@You?5lack?5items?5to?5exchange?$CB?$AA@
  00236	50		 push	 eax
$LN20@GCRegEvent:
  00237	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0023c	83 c4 08	 add	 esp, 8
$LN4@GCRegEvent:

; 15204: 	}
; 15205: 
; 15206: 	lpObj->UseEventServer = FALSE;

  0023f	c7 86 e8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5096], 0
  00249	5e		 pop	 esi
  0024a	5b		 pop	 ebx
$LN14@GCRegEvent:
  0024b	5f		 pop	 edi

; 15207: 
; 15208: #endif
; 15209: }

  0024c	8b e5		 mov	 esp, ebp
  0024e	5d		 pop	 ebp
  0024f	c3		 ret	 0
?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ENDP	; GCRegEventChipRecv
_TEXT	ENDS
PUBLIC	??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@ ; `string'
PUBLIC	??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ; GCGetMutoNumRecv
EXTRN	?DataSendEventChip@@YAXPADH@Z:PROC		; DataSendEventChip
EXTRN	?gObjFind10EventChip@@YAHH@Z:PROC		; gObjFind10EventChip
;	COMDAT ??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@
CONST	SEGMENT
??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@ DB '['
	DB	'EventChip] [%s][%s] Request MutoNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@
CONST	SEGMENT
??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@ DB 0c0H
	DB	0ccH, 0b9H, 0ccH, ' ', 0b7H, 0e7H, 0b0H, 0a1H, 0b5H, 0e5H, 0c0H
	DB	0c7H, ' ', 0bcH, 0fdH, 0c0H, 0daH, 0b0H, 0a1H, ' ', 0c0H, 0d6H
	DB	0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z
_TEXT	SEGMENT
_pMsg$ = -292						; size = 20
_Result$223102 = -272					; size = 10
_msg$223098 = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z PROC	; GCGetMutoNumRecv, COMDAT

; 15221: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 15222: 	if ( gObj[aIndex].MutoNumber != 0 )

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001d	8b f7		 mov	 esi, edi
  0001f	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00025	83 bc 06 e4 13
	00 00 00	 cmp	 DWORD PTR [esi+eax+5092], 0
  0002d	74 34		 je	 SHORT $LN3@GCGetMutoN

; 15223: 	{
; 15224: 		char msg[255];
; 15225: 		wsprintf(msg, "   ");

  0002f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$223098[ebp]
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 15226: 		GCServerMsgStringSend(msg, aIndex, 1);

  00041	6a 01		 push	 1
  00043	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$223098[ebp]
  00049	57		 push	 edi
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 15257: 
; 15258: 	LogAddTD("[EventChip] [%s][%s] Request MutoNumber",
; 15259: 		gObj[aIndex].AccountID, gObj[aIndex].Name);

  00050	83 c4 14	 add	 esp, 20			; 00000014H
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 15260: }

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	33 cd		 xor	 ecx, ebp
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
$LN3@GCGetMutoN:

; 15227: 		return;
; 15228: 	}
; 15229: 
; 15230: 	if ( gObj[aIndex].UseEventServer != FALSE )

  00063	83 bc 06 e8 13
	00 00 00	 cmp	 DWORD PTR [esi+eax+5096], 0
  0006b	8d 84 06 e8 13
	00 00		 lea	 eax, DWORD PTR [esi+eax+5096]
  00072	0f 85 d1 00 00
	00		 jne	 $LN4@GCGetMutoN

; 15231: 		return;
; 15232: 
; 15233: 	gObj[aIndex].UseEventServer = TRUE;
; 15234: 
; 15235: 	if ( !gObjFind10EventChip(aIndex) )

  00078	57		 push	 edi
  00079	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  0007f	e8 00 00 00 00	 call	 ?gObjFind10EventChip@@YAHH@Z ; gObjFind10EventChip
  00084	83 c4 04	 add	 esp, 4
  00087	85 c0		 test	 eax, eax
  00089	75 5e		 jne	 SHORT $LN1@GCGetMutoN

; 15236: 	{
; 15237: 		PMSG_GETMUTONUMBER_RESULT Result;
; 15238: 
; 15239: 		PHeadSetB((LPBYTE)&Result, 0x96, sizeof(Result));

  0008b	6a 0a		 push	 10			; 0000000aH
  0008d	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _Result$223102[ebp]
  00093	68 96 00 00 00	 push	 150			; 00000096H
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15240: 		Result.MutoNum[0] = -1;

  0009e	83 c8 ff	 or	 eax, -1
  000a1	66 89 85 f4 fe
	ff ff		 mov	 WORD PTR _Result$223102[ebp+4], ax

; 15241: 		Result.MutoNum[1] = 0;
; 15242: 		Result.MutoNum[2] = 0;
; 15243: 
; 15244: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000a8	0f b6 85 f1 fe
	ff ff		 movzx	 eax, BYTE PTR _Result$223102[ebp+1]
  000af	33 c9		 xor	 ecx, ecx
  000b1	89 8d f6 fe ff
	ff		 mov	 DWORD PTR _Result$223102[ebp+6], ecx
  000b7	50		 push	 eax
  000b8	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _Result$223102[ebp]
  000be	51		 push	 ecx
  000bf	57		 push	 edi
  000c0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 15245: 		gObj[aIndex].UseEventServer = FALSE;

  000c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cb	83 c4 18	 add	 esp, 24			; 00000018H
  000ce	5f		 pop	 edi
  000cf	c7 84 16 e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+5096], 0
  000da	5e		 pop	 esi

; 15260: }

  000db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000de	33 cd		 xor	 ecx, ebp
  000e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
$LN1@GCGetMutoN:

; 15246: 
; 15247: 		return;
; 15248: 	}
; 15249: 
; 15250: 	PMSG_REQ_REGISTER_MUTONUM pMsg;
; 15251: 
; 15252: 	PHeadSetB((LPBYTE)&pMsg, 0x03, sizeof(pMsg));

  000e9	6a 14		 push	 20			; 00000014H
  000eb	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  000f1	6a 03		 push	 3
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15253: 	pMsg.iINDEX = aIndex;
; 15254: 	strcpy(pMsg.szUID, gObj[aIndex].AccountID);

  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ff	8d 44 0e 52	 lea	 eax, DWORD PTR [esi+ecx+82]
  00103	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp+8]
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010c	89 bd e0 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+4], edi
  00112	2b d0		 sub	 edx, eax
$LL6@GCGetMutoN:
  00114	8a 08		 mov	 cl, BYTE PTR [eax]
  00116	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00119	40		 inc	 eax
  0011a	84 c9		 test	 cl, cl
  0011c	75 f6		 jne	 SHORT $LL6@GCGetMutoN

; 15255: 
; 15256: 	DataSendEventChip((PCHAR)&pMsg, sizeof(pMsg));

  0011e	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  00124	6a 14		 push	 20			; 00000014H
  00126	52		 push	 edx
  00127	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 15257: 
; 15258: 	LogAddTD("[EventChip] [%s][%s] Request MutoNumber",
; 15259: 		gObj[aIndex].AccountID, gObj[aIndex].Name);

  0012c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00131	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00135	51		 push	 ecx
  00136	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  0013a	52		 push	 edx
  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00146	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@GCGetMutoN:

; 15260: }

  00149	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014c	5f		 pop	 edi
  0014d	33 cd		 xor	 ecx, ebp
  0014f	5e		 pop	 esi
  00150	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ENDP	; GCGetMutoNumRecv
_TEXT	ENDS
PUBLIC	?GCUseEndEventChipRescv@@YAXH@Z			; GCUseEndEventChipRescv
; Function compile flags: /Ogtp
;	COMDAT ?GCUseEndEventChipRescv@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?GCUseEndEventChipRescv@@YAXH@Z PROC			; GCUseEndEventChipRescv, COMDAT

; 15266: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 15267: 	if ( !gObjIsConnectedGP(aIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 1d		 jne	 SHORT $LN2@GCUseEndEv

; 15268: 	{
; 15269: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00014	68 a5 3b 00 00	 push	 15269			; 00003ba5H
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00023	6a 02		 push	 2
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	5e		 pop	 esi

; 15278: 	}
; 15279: }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN2@GCUseEndEv:

; 15270: 		return;
; 15271: 	}
; 15272: 
; 15273: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 9 )

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00037	8b c6		 mov	 eax, esi
  00039	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0003f	8b 94 08 b8 11
	00 00		 mov	 edx, DWORD PTR [eax+ecx+4536]
  00046	f6 c2 03	 test	 dl, 3
  00049	74 35		 je	 SHORT $LN1@GCUseEndEv
  0004b	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00051	81 fa 40 02 00
	00		 cmp	 edx, 576		; 00000240H
  00057	75 27		 jne	 SHORT $LN1@GCUseEndEv

; 15274: 	{
; 15275: 		gObj[aIndex].m_IfState.state = 0;

  00059	83 a4 08 b8 11
	00 00 c3	 and	 DWORD PTR [eax+ecx+4536], -61 ; ffffffc3H

; 15276: 		gObj[aIndex].m_IfState.type = 0;

  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00067	81 a4 08 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [eax+ecx+4536], -65473 ; ffff003fH

; 15277: 		gObj[aIndex].m_IfState.use = 0;

  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00078	83 a4 08 b8 11
	00 00 fc	 and	 DWORD PTR [eax+ecx+4536], -4 ; fffffffcH
$LN1@GCUseEndEv:
  00080	5e		 pop	 esi

; 15278: 	}
; 15279: }

  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?GCUseEndEventChipRescv@@YAXH@Z ENDP			; GCUseEndEventChipRescv
_TEXT	ENDS
PUBLIC	??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ ; `string'
PUBLIC	??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ; GCUseRenaChangeZenRecv
;	COMDAT ??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@
CONST	SEGMENT
??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ DB '['
	DB	'EventChip] [%s][%s] Request Change Rena', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@
CONST	SEGMENT
??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ DB '['
	DB	'EventChip] [%s][%s] Request Change Stones', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z PROC ; GCUseRenaChangeZenRecv, COMDAT

; 15291: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 15292: 	if ( gObj[aIndex].UseEventServer )

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001a	8b f7		 mov	 esi, edi
  0001c	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00022	83 bc 06 e8 13
	00 00 00	 cmp	 DWORD PTR [esi+eax+5096], 0
  0002a	0f 85 85 00 00
	00		 jne	 $LN1@GCUseRenaC

; 15293: 		return;
; 15294: 
; 15295: 	gObj[aIndex].UseEventServer = TRUE;

  00030	c7 84 06 e8 13
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax+5096], 1

; 15296: 
; 15297: 	PMSG_REQ_RESET_EVENTCHIP pMsg;
; 15298: 
; 15299: 	if ( lpMsg->btType == 1 )	// Stone?

  0003b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0003e	80 78 03 01	 cmp	 BYTE PTR [eax+3], 1

; 15300: 		PHeadSetB((LPBYTE)&pMsg, 0x09, sizeof(pMsg));

  00042	6a 14		 push	 20			; 00000014H
  00044	75 08		 jne	 SHORT $LN4@GCUseRenaC
  00046	6a 09		 push	 9
  00048	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0004b	51		 push	 ecx

; 15301: 	else

  0004c	eb 06		 jmp	 SHORT $LN10@GCUseRenaC
$LN4@GCUseRenaC:

; 15302: 		PHeadSetB((LPBYTE)&pMsg, 0x04, sizeof(pMsg));

  0004e	6a 04		 push	 4
  00050	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00053	52		 push	 edx
$LN10@GCUseRenaC:
  00054	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15303: 
; 15304: 	pMsg.iINDEX = aIndex;
; 15305: 	strcpy(pMsg.szUID, gObj[aIndex].AccountID);

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005e	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00062	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp+8]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	89 7d ec	 mov	 DWORD PTR _pMsg$[ebp+4], edi
  0006b	2b d0		 sub	 edx, eax
  0006d	8d 49 00	 npad	 3
$LL8@GCUseRenaC:
  00070	8a 08		 mov	 cl, BYTE PTR [eax]
  00072	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00075	40		 inc	 eax
  00076	84 c9		 test	 cl, cl
  00078	75 f6		 jne	 SHORT $LL8@GCUseRenaC

; 15306: 
; 15307: 	DataSendEventChip((PCHAR)&pMsg, sizeof(pMsg));

  0007a	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0007d	6a 14		 push	 20			; 00000014H
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 15308: 
; 15309: 	if ( lpMsg->btType == 0x01 )
; 15310: 		LogAddTD("[EventChip] [%s][%s] Request Change Stones", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008a	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0008d	83 c4 08	 add	 esp, 8
  00090	80 7a 03 01	 cmp	 BYTE PTR [edx+3], 1
  00094	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00098	51		 push	 ecx
  00099	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  0009d	52		 push	 edx
  0009e	75 07		 jne	 SHORT $LN2@GCUseRenaC
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@

; 15311: 	else

  000a5	eb 05		 jmp	 SHORT $LN11@GCUseRenaC
$LN2@GCUseRenaC:

; 15312: 		LogAddTD("[EventChip] [%s][%s] Request Change Rena", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@
$LN11@GCUseRenaC:
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCUseRenaC:

; 15313: }

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	5f		 pop	 edi
  000b9	33 cd		 xor	 ecx, ebp
  000bb	5e		 pop	 esi
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ENDP ; GCUseRenaChangeZenRecv
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGRequestQuestInfo@@YAXH@Z			; CGRequestQuestInfo
EXTRN	?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z:PROC ; CQuestInfo::GetQuestInfo
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
; Function compile flags: /Ogtp
;	COMDAT ?CGRequestQuestInfo@@YAXH@Z
_TEXT	SEGMENT
_questcount$ = -76					; size = 4
_lpObj$ = -72						; size = 4
_aIndex$GSCopy$ = -68					; size = 4
_foundquest$ = -64					; size = 4
_pMsg$ = -60						; size = 54
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?CGRequestQuestInfo@@YAXH@Z PROC			; CGRequestQuestInfo, COMDAT

; 15325: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 15326: 	LPOBJ lpObj = &gObj[aIndex];

  00013	89 45 bc	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], eax
  00016	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0001c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00022	53		 push	 ebx

; 15327: 
; 15328: 	if ( lpObj->m_SendQuestInfo != 0 )

  00023	33 db		 xor	 ebx, ebx
  00025	89 45 b8	 mov	 DWORD PTR _lpObj$[ebp], eax
  00028	38 98 56 14 00
	00		 cmp	 BYTE PTR [eax+5206], bl
  0002e	0f 85 82 00 00
	00		 jne	 $LN7@CGRequestQ

; 15329: 		return;
; 15330: 
; 15331: 	int questcount = g_QuestInfo.GetQeustCount();

  00034	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?g_QuestInfo@@3VCQuestInfo@@A+4
  0003a	56		 push	 esi
  0003b	57		 push	 edi
  0003c	89 4d b4	 mov	 DWORD PTR _questcount$[ebp], ecx

; 15332: 	int foundquest = 0;
; 15333: 
; 15334: 	PMSG_SEND_QEUSTINFO pMsg;
; 15335: 	LPQUEST_INFO lpQuestInfo;
; 15336: 
; 15337: 	memcpy(pMsg.State, lpObj->m_Quest, sizeof(pMsg.State));

  0003f	8d b0 24 14 00
	00		 lea	 esi, DWORD PTR [eax+5156]
  00045	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0004a	8d 7d c8	 lea	 edi, DWORD PTR _pMsg$[ebp+4]
  0004d	f3 a5		 rep movsd
  0004f	89 5d c0	 mov	 DWORD PTR _foundquest$[ebp], ebx
  00052	66 a5		 movsw
$LL5@CGRequestQ:

; 15341: 	{
; 15342: 		lpQuestInfo = g_QuestInfo.GetQuestInfo(i);

  00054	53		 push	 ebx
  00055	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0005a	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo

; 15343: 
; 15344: 		if ( lpQuestInfo )

  0005f	85 c0		 test	 eax, eax
  00061	74 0c		 je	 SHORT $LN4@CGRequestQ

; 15345: 		{
; 15346: 			foundquest++;

  00063	8b 45 c0	 mov	 eax, DWORD PTR _foundquest$[ebp]
  00066	40		 inc	 eax
  00067	89 45 c0	 mov	 DWORD PTR _foundquest$[ebp], eax

; 15347: 
; 15348: 			if ( foundquest == questcount )

  0006a	3b 45 b4	 cmp	 eax, DWORD PTR _questcount$[ebp]
  0006d	74 09		 je	 SHORT $LN12@CGRequestQ
$LN4@CGRequestQ:

; 15338: 
; 15339: 	int i;
; 15340: 	for (i=0;i<MAX_QUEST_INFO;i++)

  0006f	43		 inc	 ebx
  00070	81 fb c8 00 00
	00		 cmp	 ebx, 200		; 000000c8H
  00076	7c dc		 jl	 SHORT $LL5@CGRequestQ
$LN12@CGRequestQ:

; 15349: 			{
; 15350: 				break;
; 15351: 			}
; 15352: 		}
; 15353: 	}
; 15354: 
; 15355: 	int iSize = i/4+5;

  00078	8b c3		 mov	 eax, ebx
  0007a	99		 cdq
  0007b	83 e2 03	 and	 edx, 3
  0007e	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  00081	c1 fe 02	 sar	 esi, 2
  00084	83 c6 05	 add	 esi, 5

; 15356: 
; 15357: 	PHeadSetB((LPBYTE)&pMsg, 0xA0, iSize);

  00087	56		 push	 esi
  00088	8d 55 c4	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0008b	68 a0 00 00 00	 push	 160			; 000000a0H
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15358: 	pMsg.Count = i;
; 15359: 	DataSend(aIndex, (LPBYTE)&pMsg, iSize);

  00096	8b 4d bc	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00099	56		 push	 esi
  0009a	8d 45 c4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009d	50		 push	 eax
  0009e	51		 push	 ecx
  0009f	88 5d c7	 mov	 BYTE PTR _pMsg$[ebp+3], bl
  000a2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 15360: 	lpObj->m_SendQuestInfo = true;

  000a7	8b 55 b8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000aa	83 c4 18	 add	 esp, 24			; 00000018H
  000ad	5f		 pop	 edi
  000ae	c6 82 56 14 00
	00 01		 mov	 BYTE PTR [edx+5206], 1
  000b5	5e		 pop	 esi
$LN7@CGRequestQ:

; 15361: 
; 15362: }

  000b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b9	33 cd		 xor	 ecx, ebp
  000bb	5b		 pop	 ebx
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?CGRequestQuestInfo@@YAXH@Z ENDP			; CGRequestQuestInfo
_TEXT	ENDS
PUBLIC	?GCSendQuestInfo@@YAXHH@Z			; GCSendQuestInfo
EXTRN	?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::GetQuestStateBYTE
; Function compile flags: /Ogtp
;	COMDAT ?GCSendQuestInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_QuestIndex$ = 12					; size = 4
?GCSendQuestInfo@@YAXHH@Z PROC				; GCSendQuestInfo, COMDAT

; 15379: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 15380: 	CGRequestQuestInfo(aIndex);

  00008	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo

; 15381: 
; 15382: 	LPOBJ lpObj = &gObj[aIndex];

  00011	8b f7		 mov	 esi, edi
  00013	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00019	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15383: 	PMSG_SETQUEST pMsg;
; 15384: 
; 15385: 	PHeadSetB((LPBYTE)&pMsg, 0xA1, sizeof(pMsg));

  0001f	6a 05		 push	 5
  00021	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00024	68 a1 00 00 00	 push	 161			; 000000a1H
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15386: 	pMsg.QuestIndex = QuestIndex;

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 15387: 	pMsg.State = g_QuestInfo.GetQuestStateBYTE(lpObj, QuestIndex);

  00035	50		 push	 eax
  00036	56		 push	 esi
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0003c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  0003f	e8 00 00 00 00	 call	 ?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestStateBYTE
  00044	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 15388: 
; 15389: 	if ( pMsg.State != 0 )

  00047	84 c0		 test	 al, al
  00049	74 0f		 je	 SHORT $LN1@GCSendQues

; 15390: 		DataSend(aIndex, (UCHAR*)&pMsg, sizeof(pMsg));

  0004b	6a 05		 push	 5
  0004d	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00050	51		 push	 ecx
  00051	57		 push	 edi
  00052	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCSendQues:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 15391: }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?GCSendQuestInfo@@YAXHH@Z ENDP				; GCSendQuestInfo
_TEXT	ENDS
PUBLIC	?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z	; CGSetQuestState
EXTRN	?SetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@HH@Z:PROC ; CQuestInfo::SetQuestState
; Function compile flags: /Ogtp
;	COMDAT ?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z PROC		; CGSetQuestState, COMDAT

; 15406: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 15407: 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b f3		 mov	 esi, ebx
  0000d	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00013	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	57		 push	 edi

; 15408: 	PMSG_SETQUEST_RESULT pMsg;
; 15409: 
; 15410: 	PHeadSetB((LPBYTE)&pMsg, 0xA2, sizeof(pMsg));

  0001a	6a 06		 push	 6
  0001c	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	68 a2 00 00 00	 push	 162			; 000000a2H
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15411: 	pMsg.QuestIndex = lpMsg->QuestIndex;

  0002a	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0002d	8a 47 03	 mov	 al, BYTE PTR [edi+3]

; 15412: 	pMsg.Result = g_QuestInfo.SetQuestState(lpObj, lpMsg->QuestIndex, lpMsg->State);

  00030	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	51		 push	 ecx
  00038	0f b6 d0	 movzx	 edx, al
  0003b	52		 push	 edx
  0003c	56		 push	 esi
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00042	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00045	e8 00 00 00 00	 call	 ?SetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@HH@Z ; CQuestInfo::SetQuestState
  0004a	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 15413: 	pMsg.State = g_QuestInfo.GetQuestStateBYTE(lpObj, lpMsg->QuestIndex);

  0004d	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00051	50		 push	 eax
  00052	56		 push	 esi
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00058	e8 00 00 00 00	 call	 ?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestStateBYTE

; 15414: 
; 15415: 	DataSend(aIndex, (UCHAR*)&pMsg, sizeof(pMsg));

  0005d	6a 06		 push	 6
  0005f	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00062	51		 push	 ecx
  00063	53		 push	 ebx
  00064	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00067	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 15416: }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z ENDP		; CGSetQuestState
_TEXT	ENDS
PUBLIC	?GCSendQuestPrize@@YAXHEE@Z			; GCSendQuestPrize
; Function compile flags: /Ogtp
;	COMDAT ?GCSendQuestPrize@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_Type$ = 12						; size = 1
_Count$ = 16						; size = 1
?GCSendQuestPrize@@YAXHEE@Z PROC			; GCSendQuestPrize, COMDAT

; 15432: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 15433: 	CGRequestQuestInfo(aIndex);

  00008	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo

; 15434: 	LPOBJ lpObj = &gObj[aIndex];

  00011	8b f7		 mov	 esi, edi
  00013	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00019	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15435: 
; 15436: 	PMSG_SETQUEST_PRIZE pMsg;
; 15437: 
; 15438: 	PHeadSetB((LPBYTE)&pMsg, 0xA3, sizeof(pMsg));

  0001f	6a 07		 push	 7
  00021	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00024	68 a3 00 00 00	 push	 163			; 000000a3H
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15439: 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0002f	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 15440: 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 15441: 	pMsg.Type = Type;

  00031	8a 45 0c	 mov	 al, BYTE PTR _Type$[ebp]
  00034	c1 e9 08	 shr	 ecx, 8
  00037	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0003a	8a 16		 mov	 dl, BYTE PTR [esi]

; 15442: 	pMsg.Count = Count;

  0003c	8a 4d 10	 mov	 cl, BYTE PTR _Count$[ebp]
  0003f	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl

; 15443: 
; 15444: 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00042	6a 07		 push	 7
  00044	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00047	52		 push	 edx
  00048	57		 push	 edi
  00049	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0004c	88 4d fe	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  0004f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 15445: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, sizeof(pMsg));

  00054	6a 07		 push	 7
  00056	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00059	50		 push	 eax
  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00060	83 c4 28	 add	 esp, 40			; 00000028H
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi

; 15446: }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?GCSendQuestPrize@@YAXHEE@Z ENDP			; GCSendQuestPrize
_TEXT	ENDS
PUBLIC	??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ; CGRequestEnterBloodCastle
EXTRN	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDeleteQuestItem
EXTRN	?EnterUserBridge@CBloodCastle@@QAEHHH@Z:PROC	; CBloodCastle::EnterUserBridge
EXTRN	?CheckEnterLevel@CBloodCastle@@QAEHHH@Z:PROC	; CBloodCastle::CheckEnterLevel
;	COMDAT ??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle'
	DB	' (Invisible Cloak Serial:%d)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z
_TEXT	SEGMENT
tv580 = -288						; size = 4
_iBC_INDEX$ = -284					; size = 4
_btInvisibleCourtItemPos$ = -280			; size = 1
tv612 = -276						; size = 4
_dwITEM_SERIAL$ = -276					; size = 4
tv581 = -272						; size = 4
tv651 = -270						; size = 2
_btBridgeNumber$ = -269					; size = 1
tv648 = -268						; size = 4
tv646 = -268						; size = 4
tv584 = -268						; size = 4
_i$223276 = -268					; size = 4
_pResult$ = -264					; size = 4
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z PROC ; CGRequestEnterBloodCastle, COMDAT

; 15493: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 15494: 	if ( !OBJMAX_RANGE(iIndex))

  0001a	85 ff		 test	 edi, edi
  0001c	78 0f		 js	 SHORT $LN51@CGRequestE
  0001e	33 c0		 xor	 eax, eax
  00020	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	75 27		 jne	 SHORT $LN39@CGRequestE
$LN51@CGRequestE:

; 15495: 	{
; 15496: 		LogAdd("return %s %d", __FILE__, __LINE__);

  0002d	68 88 3c 00 00	 push	 15496			; 00003c88H
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi

; 15684: }

  00046	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN39@CGRequestE:

; 15497: 		return;
; 15498: 	}
; 15499: 	
; 15500: 	BYTE btBridgeNumber = lpMsg->iBridgeNumber - 1;

  00054	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00057	53		 push	 ebx
  00058	56		 push	 esi
  00059	fe c8		 dec	 al
  0005b	88 85 f3 fe ff
	ff		 mov	 BYTE PTR _btBridgeNumber$[ebp], al

; 15501: 	BYTE btInvisibleCourtItemPos = lpMsg->iItemPos;

  00061	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]

; 15502: 	int iITEM_LEVEL = 0;
; 15503: 	DWORD dwITEM_SERIAL = 0;
; 15504: 	PMSG_RESULT_MOVEBLOODCASTLE pResult;
; 15505: 
; 15506: 	PHeadSetB((LPBYTE)&pResult, 0x9A, sizeof(pResult));

  00065	6a 04		 push	 4
  00067	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  0006d	68 9a 00 00 00	 push	 154			; 0000009aH
  00072	51		 push	 ecx
  00073	88 85 e8 fe ff
	ff		 mov	 BYTE PTR _btInvisibleCourtItemPos$[ebp], al
  00079	33 db		 xor	 ebx, ebx
  0007b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15507: 	pResult.Result = 0;
; 15508: 
; 15509: 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00085	8b f7		 mov	 esi, edi
  00087	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	88 9d fb fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], bl
  00096	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  0009b	0f 85 ae 04 00
	00		 jne	 $LN55@CGRequestE
  000a1	83 7c 06 04 02	 cmp	 DWORD PTR [esi+eax+4], 2
  000a6	0f 8e a3 04 00
	00		 jle	 $LN55@CGRequestE

; 15510: 		return;
; 15511: 
; 15512: 	if ( gObj[iIndex].m_IfState.use && gObj[iIndex].m_IfState.type != 12 )

  000ac	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  000b3	f6 c1 03	 test	 cl, 3
  000b6	74 12		 je	 SHORT $LN36@CGRequestE
  000b8	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  000be	81 f9 00 03 00
	00		 cmp	 ecx, 768		; 00000300H
  000c4	0f 85 85 04 00
	00		 jne	 $LN55@CGRequestE
$LN36@CGRequestE:

; 15513: 		return;
; 15514: 
; 15515: #ifndef BEREZNUK
; 15516: 	if( gObj[iIndex].m_PK_Level >= 4 )

  000ca	80 bc 06 19 01
	00 00 04	 cmp	 BYTE PTR [esi+eax+281], 4
  000d2	7c 1b		 jl	 SHORT $LN35@CGRequestE

; 15517: 	{
; 15518: 		pResult.Result = 7;
; 15519: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  000d4	0f b6 95 f9 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  000db	52		 push	 edx
  000dc	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  000e2	c6 85 fb fe ff
	ff 07		 mov	 BYTE PTR _pResult$[ebp+3], 7
  000e9	50		 push	 eax

; 15520: 		return;

  000ea	e9 57 04 00 00	 jmp	 $LN64@CGRequestE
$LN35@CGRequestE:

; 15521: 	}
; 15522: #endif
; 15523: 
; 15524: 	if ( g_BloodCastle.CheckCanEnter(btBridgeNumber) == false )

  000ef	0f b6 8d f3 fe
	ff ff		 movzx	 ecx, BYTE PTR _btBridgeNumber$[ebp]
  000f6	51		 push	 ecx
  000f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  000fc	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  00101	84 c0		 test	 al, al
  00103	75 1b		 jne	 SHORT $LN34@CGRequestE

; 15525: 	{
; 15526: 		pResult.Result = 2;
; 15527: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00105	0f b6 95 f9 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0010c	52		 push	 edx
  0010d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00113	c6 85 fb fe ff
	ff 02		 mov	 BYTE PTR _pResult$[ebp+3], 2
  0011a	50		 push	 eax

; 15528: 		return;

  0011b	e9 26 04 00 00	 jmp	 $LN64@CGRequestE
$LN34@CGRequestE:

; 15529: 	}
; 15530: 
; 15531: 	if ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].IsItem() == TRUE )

  00120	0f b6 85 e8 fe
	ff ff		 movzx	 eax, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0012d	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  00134	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv580[ebp], eax
  0013a	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00140	03 c8		 add	 ecx, eax
  00142	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv581[ebp], eax
  00148	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0014d	83 f8 01	 cmp	 eax, 1
  00150	0f 85 da 03 00
	00		 jne	 $LN33@CGRequestE

; 15532: 	{
; 15533: 		if ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,18) )

  00156	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015c	8b 8c 16 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4544]
  00163	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv581[ebp]
  00169	8d 84 16 c0 11
	00 00		 lea	 eax, DWORD PTR [esi+edx+4544]
  00170	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv584[ebp], ecx
  00176	0f b7 49 06	 movzx	 ecx, WORD PTR [ecx+6]
  0017a	ba 12 1a 00 00	 mov	 edx, 6674		; 00001a12H
  0017f	66 3b ca	 cmp	 cx, dx
  00182	75 3e		 jne	 SHORT $LN32@CGRequestE

; 15534: 		{
; 15535: 			iITEM_LEVEL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Level;

  00184	8b 00		 mov	 eax, DWORD PTR [eax]
  00186	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv581[ebp]
  0018c	0f bf 5c 08 08	 movsx	 ebx, WORD PTR [eax+ecx+8]

; 15536: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Number;

  00191	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN67@CGRequestE:
  00194	89 95 ec fe ff
	ff		 mov	 DWORD PTR _dwITEM_SERIAL$[ebp], edx

; 15537: 			
; 15538: 			if ( BC_CLOACK_LEVEL_RANGE(iITEM_LEVEL)==FALSE)

  0019a	85 db		 test	 ebx, ebx
  0019c	78 10		 js	 SHORT $LN52@CGRequestE
  0019e	33 c0		 xor	 eax, eax
  001a0	83 fb 08	 cmp	 ebx, 8
  001a3	0f 9e c0	 setle	 al
  001a6	85 c0		 test	 eax, eax
  001a8	0f 85 a7 00 00
	00		 jne	 $LN22@CGRequestE
$LN52@CGRequestE:

; 15539: 			{
; 15540: 				pResult.Result = 1;
; 15541: 				DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  001ae	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001b5	50		 push	 eax
  001b6	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  001bc	51		 push	 ecx

; 15542: 				return;

  001bd	e9 7d 03 00 00	 jmp	 $LN65@CGRequestE
$LN32@CGRequestE:

; 15543: 			}
; 15544: 		}
; 15545: 		else if ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,47) &&
; 15546: 				  gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability > 0.0f ) //#unk

  001c2	ba 2f 1a 00 00	 mov	 edx, 6703		; 00001a2fH
  001c7	66 3b ca	 cmp	 cx, dx
  001ca	0f 85 4f 03 00
	00		 jne	 $LN29@CGRequestE
  001d0	d9 ee		 fldz
  001d2	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv584[ebp]
  001d8	d8 58 24	 fcomp	 DWORD PTR [eax+36]
  001db	df e0		 fnstsw	 ax
  001dd	f6 c4 05	 test	 ah, 5
  001e0	0f 8a 39 03 00
	00		 jp	 $LN29@CGRequestE

; 15547: 		{
; 15548: #if (__CUSTOM__ == 1)
; 15549: 			if ( gObj[iIndex].ChangeUP2 == TRUE )

  001e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ec	80 bc 0e 94 00
	00 00 01	 cmp	 BYTE PTR [esi+ecx+148], 1
  001f4	75 07		 jne	 SHORT $LN28@CGRequestE

; 15550: #else
; 15551: 			if ( g_MasterExp.IsEnabled(&gObj[iIndex]) )
; 15552: #endif
; 15553: 			{
; 15554: 				iITEM_LEVEL = 8;

  001f6	bb 08 00 00 00	 mov	 ebx, 8

; 15555: 			}
; 15556: 			else

  001fb	eb 3d		 jmp	 SHORT $LN24@CGRequestE
$LN28@CGRequestE:

; 15557: 			{
; 15558: 				for ( int i=0;i<MAX_CLOACK_LEVEL;i++)

  001fd	89 9d f4 fe ff
	ff		 mov	 DWORD PTR _i$223276[ebp], ebx
$LL54@CGRequestE:

; 15559: 				{
; 15560: 					if ( g_BloodCastle.CheckEnterLevel(iIndex, i+1) == 0 )

  00203	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$223276[ebp]
  00209	40		 inc	 eax
  0020a	50		 push	 eax
  0020b	57		 push	 edi
  0020c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00211	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv612[ebp], eax
  00217	e8 00 00 00 00	 call	 ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CheckEnterLevel
  0021c	85 c0		 test	 eax, eax
  0021e	74 13		 je	 SHORT $LN49@CGRequestE

; 15557: 			{
; 15558: 				for ( int i=0;i<MAX_CLOACK_LEVEL;i++)

  00220	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv612[ebp]
  00226	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _i$223276[ebp], eax
  0022c	83 f8 09	 cmp	 eax, 9
  0022f	7c d2		 jl	 SHORT $LL54@CGRequestE

; 15559: 				{
; 15560: 					if ( g_BloodCastle.CheckEnterLevel(iIndex, i+1) == 0 )

  00231	eb 07		 jmp	 SHORT $LN24@CGRequestE
$LN49@CGRequestE:

; 15561: 					{
; 15562: 						iITEM_LEVEL = i+1;

  00233	8b 9d f4 fe ff
	ff		 mov	 ebx, DWORD PTR _i$223276[ebp]
  00239	43		 inc	 ebx
$LN24@CGRequestE:

; 15563: 						break;
; 15564: 					}
; 15565: 				}
; 15566: 			}
; 15567: 
; 15568: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Number;

  0023a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00240	8b 84 16 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+edx+4544]
  00247	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv581[ebp]
  0024d	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]

; 15569: 
; 15570: 			if ( BC_CLOACK_LEVEL_RANGE(iITEM_LEVEL) == FALSE )
; 15571: 			{
; 15572: 				pResult.Result = 1;
; 15573: 				DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15574: 				return;

  00250	e9 3f ff ff ff	 jmp	 $LN67@CGRequestE
$LN22@CGRequestE:

; 15588: 		return;
; 15589: 	}
; 15590: 
; 15591: //#endif
; 15592: 	
; 15593: 	int iRESULT = g_BloodCastle.CheckEnterLevel(iIndex, iITEM_LEVEL);

  00255	53		 push	 ebx
  00256	57		 push	 edi
  00257	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0025c	e8 00 00 00 00	 call	 ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CheckEnterLevel

; 15594: 
; 15595: 	if ( iRESULT== 0 )

  00261	85 c0		 test	 eax, eax
  00263	0f 85 7c 02 00
	00		 jne	 $LN19@CGRequestE

; 15596: 	{
; 15597: 		pResult.Result = 0;
; 15598: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00269	0f b6 95 f9 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00270	88 85 fb fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al
  00276	52		 push	 edx
  00277	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  0027d	50		 push	 eax
  0027e	57		 push	 edi
  0027f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00284	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15614: 		}
; 15615: 
; 15616: 		return;
; 15617: 	}
; 15618: 		
; 15619: 	int iBC_INDEX = g_BloodCastle.EnterUserBridge(iITEM_LEVEL-1, iIndex);

  00287	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0028a	57		 push	 edi
  0028b	50		 push	 eax
  0028c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00291	e8 00 00 00 00	 call	 ?EnterUserBridge@CBloodCastle@@QAEHHH@Z ; CBloodCastle::EnterUserBridge
  00296	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _iBC_INDEX$[ebp], eax

; 15620: 
; 15621: 	if ( iBC_INDEX == -1 )

  0029c	83 f8 ff	 cmp	 eax, -1
  0029f	75 1b		 jne	 SHORT $LN15@CGRequestE

; 15622: 	{
; 15623: 		pResult.Result = 5;
; 15624: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  002a1	0f b6 8d f9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  002a8	51		 push	 ecx
  002a9	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  002af	c6 85 fb fe ff
	ff 05		 mov	 BYTE PTR _pResult$[ebp+3], 5
  002b6	52		 push	 edx

; 15625: 		return;

  002b7	e9 8a 02 00 00	 jmp	 $LN64@CGRequestE
$LN15@CGRequestE:

; 15626: 	}
; 15627: 
; 15628: 	if ( (gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,18) ||
; 15629: 		(gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,47)) &&
; 15630: 		gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability == 1.0f ))

  002bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c1	8b 84 06 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+eax+4544]
  002c8	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv581[ebp]
  002ce	0f b7 4c 10 06	 movzx	 ecx, WORD PTR [eax+edx+6]
  002d3	03 c2		 add	 eax, edx
  002d5	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv584[ebp], eax
  002db	b8 12 1a 00 00	 mov	 eax, 6674		; 00001a12H
  002e0	66 3b c8	 cmp	 cx, ax
  002e3	0f 84 bc 00 00
	00		 je	 $LN13@CGRequestE
  002e9	d9 e8		 fld1
  002eb	b8 2f 1a 00 00	 mov	 eax, 6703		; 00001a2fH
  002f0	66 3b c8	 cmp	 cx, ax
  002f3	75 18		 jne	 SHORT $LN14@CGRequestE
  002f5	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv584[ebp]
  002fb	d9 40 24	 fld	 DWORD PTR [eax+36]
  002fe	d9 c1		 fld	 ST(1)
  00300	da e9		 fucompp
  00302	df e0		 fnstsw	 ax
  00304	f6 c4 44	 test	 ah, 68			; 00000044H
  00307	0f 8b 96 00 00
	00		 jnp	 $LN60@CGRequestE
$LN14@CGRequestE:

; 15635: 	}
; 15636: 	else if (gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,47) && gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability > 1.0f )

  0030d	b8 2f 1a 00 00	 mov	 eax, 6703		; 00001a2fH
  00312	66 3b c8	 cmp	 cx, ax
  00315	0f 85 c0 00 00
	00		 jne	 $LN62@CGRequestE
  0031b	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv584[ebp]
  00321	d8 59 24	 fcomp	 DWORD PTR [ecx+36]
  00324	df e0		 fnstsw	 ax
  00326	f6 c4 05	 test	 ah, 5
  00329	0f 8a ae 00 00
	00		 jp	 $LN11@CGRequestE

; 15637: 	{
; 15638: 		gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability -= 1.0f;

  0032f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15639: 		GCItemDurSend2(iIndex, btInvisibleCourtItemPos,(BYTE)gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability, 0);

  00334	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv651[ebp]
  0033a	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  00341	d9 44 11 24	 fld	 DWORD PTR [ecx+edx+36]
  00345	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  0034b	8d 44 11 24	 lea	 eax, DWORD PTR [ecx+edx+36]
  0034f	6a 00		 push	 0
  00351	d9 18		 fstp	 DWORD PTR [eax]
  00353	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00358	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  0035f	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv651[ebp]
  00366	d9 44 11 24	 fld	 DWORD PTR [ecx+edx+36]
  0036a	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _btInvisibleCourtItemPos$[ebp]
  00370	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00375	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv648[ebp], eax
  0037b	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv648[ebp]
  00381	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv646[ebp]
  00387	8a 95 f4 fe ff
	ff		 mov	 dl, BYTE PTR tv646[ebp]
  0038d	0f b6 c2	 movzx	 eax, dl
  00390	50		 push	 eax
  00391	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv651[ebp]
  00397	51		 push	 ecx
  00398	57		 push	 edi
  00399	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  0039e	83 c4 10	 add	 esp, 16			; 00000010H
  003a1	eb 3a		 jmp	 SHORT $LN11@CGRequestE
$LN60@CGRequestE:

; 15626: 	}
; 15627: 
; 15628: 	if ( (gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,18) ||
; 15629: 		(gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,47)) &&
; 15630: 		gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability == 1.0f ))

  003a3	dd d8		 fstp	 ST(0)
$LN13@CGRequestE:

; 15631: 	{
; 15632: 		gObjInventoryDeleteItem(iIndex, btInvisibleCourtItemPos);

  003a5	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv580[ebp]
  003ab	52		 push	 edx
  003ac	57		 push	 edi
  003ad	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 15633: 		GCInventoryItemDeleteSend(iIndex, btInvisibleCourtItemPos, 1);

  003b2	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _btInvisibleCourtItemPos$[ebp]
  003b8	6a 01		 push	 1
  003ba	50		 push	 eax
  003bb	57		 push	 edi
  003bc	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 15634: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  003c1	0f b6 8d f9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  003c8	51		 push	 ecx
  003c9	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  003cf	52		 push	 edx
  003d0	57		 push	 edi
  003d1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003d6	83 c4 20	 add	 esp, 32			; 00000020H
  003d9	eb 02		 jmp	 SHORT $LN11@CGRequestE
$LN62@CGRequestE:
  003db	dd d8		 fstp	 ST(0)
$LN11@CGRequestE:

; 15640: 	}
; 15641: 
; 15642: 	gObj[iIndex].m_cBloodCastleIndex = iITEM_LEVEL-1;

  003dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003e3	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  003e6	88 84 0e 36 12
	00 00		 mov	 BYTE PTR [esi+ecx+4662], al

; 15643: 	gObj[iIndex].m_cBloodCastleSubIndex = iBC_INDEX;

  003ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003f3	8a 85 e4 fe ff
	ff		 mov	 al, BYTE PTR _iBC_INDEX$[ebp]
  003f9	88 84 16 37 12
	00 00		 mov	 BYTE PTR [esi+edx+4663], al

; 15644: 	gObj[iIndex].m_iBloodCastleEXP = 0;

  00400	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00406	c7 84 0e 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+ecx+4664], 0

; 15645: 	gObj[iIndex].m_IfState.state = 0;

  00411	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00416	83 a4 06 b8 11
	00 00 c3	 and	 DWORD PTR [esi+eax+4536], -61 ; ffffffc3H

; 15646: 	gObj[iIndex].m_IfState.type = 0;

  0041e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00423	81 a4 06 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [esi+eax+4536], -65473 ; ffff003fH

; 15647: 	gObj[iIndex].m_IfState.use = 0;

  0042e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00433	83 a4 06 b8 11
	00 00 fc	 and	 DWORD PTR [esi+eax+4536], -4 ; fffffffcH

; 15648: 
; 15649: 	g_BloodCastle.SearchUserDeleteQuestItem(iIndex);

  0043b	57		 push	 edi
  0043c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00441	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem

; 15650: 	char szTemp[256];
; 15651: 	wsprintf(szTemp, lMsg.Get(MSGGET(4, 147)), iITEM_LEVEL);

  00446	53		 push	 ebx
  00447	68 93 04 00 00	 push	 1171			; 00000493H
  0044c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00451	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00456	50		 push	 eax
  00457	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  0045d	52		 push	 edx
  0045e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 15652: 	GCServerMsgStringSend(szTemp, iIndex, 1);

  00464	6a 01		 push	 1
  00466	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0046c	57		 push	 edi
  0046d	50		 push	 eax
  0046e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 15653: 
; 15654: 	switch ( iITEM_LEVEL )

  00473	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00476	83 c4 18	 add	 esp, 24			; 00000018H
  00479	83 f8 07	 cmp	 eax, 7
  0047c	77 31		 ja	 SHORT $LN9@CGRequestE
  0047e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN68@CGRequestE[eax*4]
$LN8@CGRequestE:

; 15655: 	{
; 15656: 		case 1:
; 15657: 			gObjMoveGate(iIndex, 66);

  00485	6a 42		 push	 66			; 00000042H

; 15658: 			break;

  00487	eb 1d		 jmp	 SHORT $LN66@CGRequestE
$LN7@CGRequestE:

; 15659: 		case 2:
; 15660: 			gObjMoveGate(iIndex, 67);

  00489	6a 43		 push	 67			; 00000043H

; 15661: 			break;

  0048b	eb 19		 jmp	 SHORT $LN66@CGRequestE
$LN6@CGRequestE:

; 15662: 		case 3:
; 15663: 			gObjMoveGate(iIndex, 68);

  0048d	6a 44		 push	 68			; 00000044H

; 15664: 			break;

  0048f	eb 15		 jmp	 SHORT $LN66@CGRequestE
$LN5@CGRequestE:

; 15665: 		case 4:
; 15666: 			gObjMoveGate(iIndex, 69);

  00491	6a 45		 push	 69			; 00000045H

; 15667: 			break;

  00493	eb 11		 jmp	 SHORT $LN66@CGRequestE
$LN4@CGRequestE:

; 15668: 		case 5:
; 15669: 			gObjMoveGate(iIndex, 70);

  00495	6a 46		 push	 70			; 00000046H

; 15670: 			break;

  00497	eb 0d		 jmp	 SHORT $LN66@CGRequestE
$LN3@CGRequestE:

; 15671: 		case 6:
; 15672: 			gObjMoveGate(iIndex, 71);

  00499	6a 47		 push	 71			; 00000047H

; 15673: 			break;

  0049b	eb 09		 jmp	 SHORT $LN66@CGRequestE
$LN2@CGRequestE:

; 15674: 		case 7:
; 15675: 			gObjMoveGate(iIndex, 80);

  0049d	6a 50		 push	 80			; 00000050H

; 15676: 			break;

  0049f	eb 05		 jmp	 SHORT $LN66@CGRequestE
$LN1@CGRequestE:

; 15677: 		case 8:
; 15678: 			gObjMoveGate(iIndex,271);

  004a1	68 0f 01 00 00	 push	 271			; 0000010fH
$LN66@CGRequestE:
  004a6	57		 push	 edi
  004a7	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  004ac	83 c4 08	 add	 esp, 8
$LN9@CGRequestE:

; 15679: 			break;
; 15680: 	}
; 15681: 
; 15682: 	LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%d)",
; 15683: 		iITEM_LEVEL, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);

  004af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004b4	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dwITEM_SERIAL$[ebp]
  004ba	51		 push	 ecx
  004bb	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  004bf	52		 push	 edx
  004c0	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  004c4	50		 push	 eax
  004c5	53		 push	 ebx
  004c6	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  004cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004d1	83 c4 14	 add	 esp, 20			; 00000014H
  004d4	5e		 pop	 esi
  004d5	5b		 pop	 ebx
  004d6	5f		 pop	 edi

; 15684: }

  004d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004da	33 cd		 xor	 ecx, ebp
  004dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004e1	8b e5		 mov	 esp, ebp
  004e3	5d		 pop	 ebp
  004e4	c3		 ret	 0
$LN19@CGRequestE:

; 15599: 	}
; 15600: 	else 
; 15601: 	{
; 15602: 		if ( iRESULT == -1 )

  004e5	83 f8 ff	 cmp	 eax, -1
  004e8	75 18		 jne	 SHORT $LN17@CGRequestE

; 15603: 		{
; 15604: 			pResult.Result = 4;
; 15605: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  004ea	0f b6 8d f9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  004f1	51		 push	 ecx
  004f2	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  004f8	c6 85 fb fe ff
	ff 04		 mov	 BYTE PTR _pResult$[ebp+3], 4
  004ff	52		 push	 edx

; 15606: 			return;

  00500	eb 44		 jmp	 SHORT $LN64@CGRequestE
$LN17@CGRequestE:

; 15607: 		}
; 15608: 
; 15609: 		if ( iRESULT == 1 )

  00502	83 f8 01	 cmp	 eax, 1
  00505	75 48		 jne	 SHORT $LN55@CGRequestE

; 15610: 		{
; 15611: 			pResult.Result = 3;
; 15612: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00507	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0050e	50		 push	 eax
  0050f	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00515	c6 85 fb fe ff
	ff 03		 mov	 BYTE PTR _pResult$[ebp+3], 3
  0051c	51		 push	 ecx

; 15613: 			return;

  0051d	eb 27		 jmp	 SHORT $LN64@CGRequestE
$LN29@CGRequestE:

; 15575: 			}
; 15576: 		}
; 15577: 		else
; 15578: 		{
; 15579: 			pResult.Result = 1;
; 15580: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0051f	0f b6 95 f9 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00526	52		 push	 edx
  00527	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  0052d	50		 push	 eax

; 15581: 			return;

  0052e	eb 0f		 jmp	 SHORT $LN65@CGRequestE
$LN33@CGRequestE:

; 15587: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00530	0f b6 8d f9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00537	51		 push	 ecx
  00538	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  0053e	52		 push	 edx
$LN65@CGRequestE:

; 15582: 		}
; 15583: 	}
; 15584: 	else
; 15585: 	{
; 15586: 		pResult.Result = 1;

  0053f	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+3], 1
$LN64@CGRequestE:

; 15587: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00546	57		 push	 edi
  00547	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0054c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN55@CGRequestE:

; 15684: }

  0054f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00552	5e		 pop	 esi
  00553	5b		 pop	 ebx
  00554	33 cd		 xor	 ecx, ebp
  00556	5f		 pop	 edi
  00557	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0055c	8b e5		 mov	 esp, ebp
  0055e	5d		 pop	 ebp
  0055f	c3		 ret	 0
$LN68@CGRequestE:
  00560	00 00 00 00	 DD	 $LN8@CGRequestE
  00564	00 00 00 00	 DD	 $LN7@CGRequestE
  00568	00 00 00 00	 DD	 $LN6@CGRequestE
  0056c	00 00 00 00	 DD	 $LN5@CGRequestE
  00570	00 00 00 00	 DD	 $LN4@CGRequestE
  00574	00 00 00 00	 DD	 $LN3@CGRequestE
  00578	00 00 00 00	 DD	 $LN2@CGRequestE
  0057c	00 00 00 00	 DD	 $LN1@CGRequestE
?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ENDP ; CGRequestEnterBloodCastle
_TEXT	ENDS
PUBLIC	?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ; CGRequestRepositionUserInChaosCastle
EXTRN	?ObjSetPosition@CChaosCastle@@QAEHHHH@Z:PROC	; CChaosCastle::ObjSetPosition
; Function compile flags: /Ogtp
;	COMDAT ?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z PROC ; CGRequestRepositionUserInChaosCastle, COMDAT

; 15954: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 15955: 	if ( !gObjIsConnected(aIndex) )

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 5e		 je	 SHORT $LN1@CGRequestR

; 15956: 		return;
; 15957: 
; 15958: 	if ( !CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001a	56		 push	 esi
  0001b	8b f7		 mov	 esi, edi
  0001d	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00023	0f b6 84 0e 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+291]
  0002b	3c 35		 cmp	 al, 53			; 00000035H
  0002d	74 0d		 je	 SHORT $LN10@CGRequestR
  0002f	3c 12		 cmp	 al, 18			; 00000012H
  00031	72 3e		 jb	 SHORT $LN11@CGRequestR
  00033	b2 17		 mov	 dl, 23			; 00000017H
  00035	3a d0		 cmp	 dl, al
  00037	1b c0		 sbb	 eax, eax
  00039	40		 inc	 eax
  0003a	74 35		 je	 SHORT $LN11@CGRequestR
$LN10@CGRequestR:

; 15959: 		return;
; 15960: 
; 15961: 	if ( g_ChaosCastle.ObjSetPosition(aIndex, gObj[aIndex].X, gObj[aIndex].Y) == TRUE )

  0003c	0f b6 84 0e 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+289]
  00044	0f b6 8c 0e 20
	01 00 00	 movzx	 ecx, BYTE PTR [esi+ecx+288]
  0004c	50		 push	 eax
  0004d	51		 push	 ecx
  0004e	57		 push	 edi
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00054	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  00059	83 f8 01	 cmp	 eax, 1
  0005c	75 13		 jne	 SHORT $LN11@CGRequestR

; 15962: 		gObj[aIndex].m_iChaosCastleBlowTime = GetTickCount();

  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00064	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006a	89 84 16 40 12
	00 00		 mov	 DWORD PTR [esi+edx+4672], eax
$LN11@CGRequestR:
  00071	5e		 pop	 esi
$LN1@CGRequestR:
  00072	5f		 pop	 edi

; 15963: }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ENDP ; CGRequestRepositionUserInChaosCastle
_TEXT	ENDS
PUBLIC	?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ; CGRequestEventEnterCount
EXTRN	?EGReqBloodCastleEnterCount@@YAXH@Z:PROC	; EGReqBloodCastleEnterCount
; Function compile flags: /Ogtp
;	COMDAT ?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z PROC ; CGRequestEventEnterCount, COMDAT

; 15970: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15971: 	if ( !lpMsg )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 15		 je	 SHORT $LN2@CGRequestE@2

; 15972: 		return;
; 15973: 
; 15974: 	switch ( lpMsg->btEventType )

  0000a	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  0000e	83 e8 02	 sub	 eax, 2
  00011	75 0c		 jne	 SHORT $LN2@CGRequestE@2

; 15975: 	{
; 15976: 		case 0x02:
; 15977: 			EGReqBloodCastleEnterCount(aIndex);

  00013	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?EGReqBloodCastleEnterCount@@YAXH@Z ; EGReqBloodCastleEnterCount
  0001c	83 c4 04	 add	 esp, 4
$LN2@CGRequestE@2:

; 15978: 			break;
; 15979: 	}
; 15980: }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ENDP ; CGRequestEventEnterCount
_TEXT	ENDS
PUBLIC	??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ; CGRequestLottoRegister
;	COMDAT ??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@
CONST	SEGMENT
??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@ DB '['
	DB	'Mu_2Anv_Event] [%s][%s] Register Lotto Number (Serial: %s-%s-'
	DB	'%s)', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z PROC ; CGRequestLottoRegister, COMDAT

; 15995: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 15996: 	PMSG_REQ_2ANIV_SERIAL pMsg;
; 15997: 
; 15998: 	PHeadSetB((LPBYTE)&pMsg, 0x08, sizeof(pMsg));

  00019	6a 28		 push	 40			; 00000028H
  0001b	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001e	6a 08		 push	 8
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15999: 
; 16000: 	if ( gObj[aIndex].UseEventServer )

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	8b f3		 mov	 esi, ebx
  0002d	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00033	33 c9		 xor	 ecx, ecx
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	39 8c 06 e8 13
	00 00		 cmp	 DWORD PTR [esi+eax+5096], ecx
  0003f	0f 85 83 00 00
	00		 jne	 $LN2@CGRequestL

; 16001: 		return;
; 16002: 
; 16003: 	gObj[aIndex].UseEventServer = TRUE;

  00045	c7 84 06 e8 13
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax+5096], 1

; 16004: 	pMsg.iINDEX = aIndex;
; 16005: 	pMsg.iMEMB_GUID = gObj[aIndex].DBNumber;

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	89 5d d8	 mov	 DWORD PTR _pMsg$[ebp+4], ebx
  00058	8b 54 06 30	 mov	 edx, DWORD PTR [esi+eax+48]

; 16006: 	memcpy(pMsg.szUID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);

  0005c	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00060	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+36], edx
  00063	8b 10		 mov	 edx, DWORD PTR [eax]
  00065	89 55 dc	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00068	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006b	89 55 e0	 mov	 DWORD PTR _pMsg$[ebp+12], edx
  0006e	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]

; 16007: 	pMsg.szUID[MAX_ACCOUNT_LEN] = 0;
; 16008: 	memcpy(pMsg.SERIAL1, lpMsg->SERIAL1, 4);

  00072	8b 57 03	 mov	 edx, DWORD PTR [edi+3]
  00075	66 89 45 e4	 mov	 WORD PTR _pMsg$[ebp+16], ax

; 16009: 	pMsg.SERIAL1[4] = 0;
; 16010: 	memcpy(pMsg.SERIAL2, lpMsg->SERIAL2, 4);

  00079	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007c	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  0007f	89 55 e7	 mov	 DWORD PTR _pMsg$[ebp+19], edx

; 16011: 	pMsg.SERIAL2[4] = 0;
; 16012: 	memcpy(pMsg.SERIAL3, lpMsg->SERIAL3, 4);

  00082	8b 57 0d	 mov	 edx, DWORD PTR [edi+13]

; 16013: 	pMsg.SERIAL3[4] = 0;
; 16014: 
; 16015: 	DataSendEventChip((PCHAR)&pMsg, sizeof(pMsg));

  00085	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00088	6a 28		 push	 40			; 00000028H
  0008a	50		 push	 eax
  0008b	88 4d e6	 mov	 BYTE PTR _pMsg$[ebp+18], cl
  0008e	88 4d eb	 mov	 BYTE PTR _pMsg$[ebp+23], cl
  00091	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+28], cl
  00094	89 55 f1	 mov	 DWORD PTR _pMsg$[ebp+29], edx
  00097	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+33], cl
  0009a	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 16016: 
; 16017: 	LogAddTD("[Mu_2Anv_Event] [%s][%s] Register Lotto Number (Serial: %s-%s-%s)",
; 16018: 		gObj[aIndex].AccountID, gObj[aIndex].Name, pMsg.SERIAL1, pMsg.SERIAL2, pMsg.SERIAL3);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a4	8d 4d f1	 lea	 ecx, DWORD PTR _pMsg$[ebp+29]
  000a7	51		 push	 ecx
  000a8	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp+24]
  000ab	52		 push	 edx
  000ac	8d 4d e7	 lea	 ecx, DWORD PTR _pMsg$[ebp+19]
  000af	51		 push	 ecx
  000b0	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  000b4	52		 push	 edx
  000b5	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c5	83 c4 20	 add	 esp, 32			; 00000020H
$LN2@CGRequestL:

; 16019: }

  000c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	33 cd		 xor	 ecx, ebp
  000cf	5b		 pop	 ebx
  000d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ENDP ; CGRequestLottoRegister
_TEXT	ENDS
PUBLIC	??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@ ; `string'
PUBLIC	??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@ ; `string'
PUBLIC	??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z ; CGReqMoveOtherServer
EXTRN	?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HHH@Z:PROC ; GJSetCharacterInfo
EXTRN	?gEnableServerDivision@@3HA:DWORD		; gEnableServerDivision
;	COMDAT ??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@
CONST	SEGMENT
??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@ DB '[CharTr'
	DB	'asfer] Request Character Trasfer [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@
CONST	SEGMENT
??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@ DB 0b9H
	DB	0aeH, 0c1H, 0a6H, ' ', 0b9H, 0dfH, 0bbH, 0fdH, 0bdH, 0c3H, ' c'
	DB	'hange@webzen.co.kr', 0b7H, 0ceH, ' ', 0b9H, 0aeH, 0c0H, 0c7H, 0c7H
	DB	0d8H, ' ', 0c1H, 0d6H, 0bdH, 0c3H, 0b1H, 0e2H, 0b9H, 0d9H, 0b6H
	DB	0f8H, 0b4H, 0cfH, 0b4H, 0d9H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@
CONST	SEGMENT
??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@ DB '[Char'
	DB	'Trasfer] Fail (JoominNumber) [%s][%s]', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z
_TEXT	SEGMENT
_pResult$ = -24						; size = 4
_pCharTransfer$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z PROC ; CGReqMoveOtherServer, COMDAT

; 16032: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 16033: 	if ( !gEnableServerDivision)

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gEnableServerDivision@@3HA, 0 ; gEnableServerDivision
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001f	0f 84 29 01 00
	00		 je	 $LN5@CGReqMoveO

; 16034: 		return;
; 16035: 
; 16036: 	if ( !gObjIsConnectedGP(aIndex))

  00025	57		 push	 edi
  00026	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0002b	83 c4 04	 add	 esp, 4
  0002e	85 c0		 test	 eax, eax
  00030	75 2a		 jne	 SHORT $LN3@CGReqMoveO

; 16037: 	{
; 16038: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00032	68 a6 3e 00 00	 push	 16038			; 00003ea6H
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00041	6a 02		 push	 2
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00049	83 c4 10	 add	 esp, 16			; 00000010H
  0004c	5f		 pop	 edi
  0004d	5b		 pop	 ebx

; 16078: }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00051	33 cd		 xor	 ecx, ebp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN3@CGReqMoveO:
  0005c	56		 push	 esi

; 16039: 		return;
; 16040: 	}
; 16041: 
; 16042: 	LPOBJ lpObj = &gObj[aIndex];

  0005d	8b f7		 mov	 esi, edi
  0005f	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00065	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16043: 
; 16044: 	if ( lpObj->m_MoveOtherServer )

  0006b	80 be 68 14 00
	00 00		 cmp	 BYTE PTR [esi+5224], 0
  00072	0f 85 d5 00 00
	00		 jne	 $LN7@CGReqMoveO

; 16045: 		return;
; 16046: 
; 16047: 	lpObj->m_MoveOtherServer = true;
; 16048: 
; 16049: 	PMSG_DEFRESULT pResult;
; 16050: 	PHeadSetB((LPBYTE)&pResult, 0x99, sizeof(pResult));

  00078	6a 04		 push	 4
  0007a	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0007d	68 99 00 00 00	 push	 153			; 00000099H
  00082	50		 push	 eax
  00083	c6 86 68 14 00
	00 01		 mov	 BYTE PTR [esi+5224], 1
  0008a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16051: 	
; 16052: 	if ( !gObjJoominCheck(aIndex, lpMsg->LastJoominNumber))

  0008f	83 c3 03	 add	 ebx, 3
  00092	53		 push	 ebx
  00093	57		 push	 edi
  00094	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	85 c0		 test	 eax, eax
  0009e	75 4f		 jne	 SHORT $LN1@CGReqMoveO

; 16053: 	{
; 16054: 		pResult.result = 0;
; 16055: 
; 16056: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000a0	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  000a4	51		 push	 ecx
  000a5	8d 55 e8	 lea	 edx, DWORD PTR _pResult$[ebp]
  000a8	52		 push	 edx
  000a9	57		 push	 edi
  000aa	88 45 eb	 mov	 BYTE PTR _pResult$[ebp+3], al
  000ad	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16057: 		lpObj->m_MoveOtherServer = false;
; 16058: 
; 16059: 		LogAddTD("[CharTrasfer] Fail (JoominNumber) [%s][%s]",
; 16060: 			lpObj->AccountID, lpObj->Name);

  000b2	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000b5	50		 push	 eax
  000b6	8d 4e 52	 lea	 ecx, DWORD PTR [esi+82]
  000b9	51		 push	 ecx
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@
  000bf	c6 86 68 14 00
	00 00		 mov	 BYTE PTR [esi+5224], 0
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 16061: 
; 16062: 		GCServerMsgStringSend("  change@webzen.co.kr  ", lpObj->m_Index, 1);

  000cc	8b 16		 mov	 edx, DWORD PTR [esi]
  000ce	6a 01		 push	 1
  000d0	52		 push	 edx
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@
  000d6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000db	83 c4 24	 add	 esp, 36			; 00000024H
  000de	5e		 pop	 esi
  000df	5f		 pop	 edi
  000e0	5b		 pop	 ebx

; 16078: }

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e4	33 cd		 xor	 ecx, ebp
  000e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
$LN1@CGReqMoveO:

; 16063: 
; 16064: 		return;
; 16065: 	}
; 16066: 
; 16067: 	SDHP_CHARACTER_TRANSFER pCharTransfer;
; 16068: 
; 16069: 	GJSetCharacterInfo(lpObj, lpObj->m_Index, FALSE);

  000ef	8b 06		 mov	 eax, DWORD PTR [esi]
  000f1	6a 01		 push	 1
  000f3	6a 00		 push	 0
  000f5	50		 push	 eax
  000f6	56		 push	 esi
  000f7	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HHH@Z ; GJSetCharacterInfo

; 16070: 	PHeadSetB((LPBYTE)&pCharTransfer, 0xCF, sizeof(pCharTransfer));

  000fc	6a 10		 push	 16			; 00000010H
  000fe	8d 4d ec	 lea	 ecx, DWORD PTR _pCharTransfer$[ebp]
  00101	68 cf 00 00 00	 push	 207			; 000000cfH
  00106	51		 push	 ecx
  00107	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16071: 	pCharTransfer.Number = aIndex;

  0010c	66 89 7d fa	 mov	 WORD PTR _pCharTransfer$[ebp+14], di

; 16072: 	memcpy(pCharTransfer.Account, lpObj->AccountID, sizeof(pCharTransfer.Account));

  00110	8b 56 52	 mov	 edx, DWORD PTR [esi+82]
  00113	8d 7e 52	 lea	 edi, DWORD PTR [esi+82]
  00116	89 55 ef	 mov	 DWORD PTR _pCharTransfer$[ebp+3], edx
  00119	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0011c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0011f	89 45 f3	 mov	 DWORD PTR _pCharTransfer$[ebp+7], eax
  00122	66 8b 4f 08	 mov	 cx, WORD PTR [edi+8]

; 16073: 
; 16074: 	cDBSMng.Send((PCHAR)&pCharTransfer, sizeof(pCharTransfer));

  00126	6a 10		 push	 16			; 00000010H
  00128	8d 55 ec	 lea	 edx, DWORD PTR _pCharTransfer$[ebp]
  0012b	66 89 4d f7	 mov	 WORD PTR _pCharTransfer$[ebp+11], cx
  0012f	52		 push	 edx
  00130	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00135	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 16075: 
; 16076: 	LogAddTD("[CharTrasfer] Request Character Trasfer [%s][%s]",
; 16077: 		lpObj->AccountID, lpObj->Name);

  0013a	83 c6 5d	 add	 esi, 93			; 0000005dH
  0013d	56		 push	 esi
  0013e	57		 push	 edi
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0014a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CGReqMoveO:
  0014d	5e		 pop	 esi
$LN5@CGReqMoveO:

; 16078: }

  0014e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00151	5f		 pop	 edi
  00152	33 cd		 xor	 ecx, ebp
  00154	5b		 pop	 ebx
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z ENDP ; CGReqMoveOtherServer
_TEXT	ENDS
PUBLIC	?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z ; GCPacketCheckSumRecv
EXTRN	?AddCheckSum@CPacketCheckSum@@QAEXHHK@Z:PROC	; CPacketCheckSum::AddCheckSum
EXTRN	?gPacketCheckSum@@3VCPacketCheckSum@@A:BYTE	; gPacketCheckSum
; Function compile flags: /Ogtp
;	COMDAT ?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z PROC ; GCPacketCheckSumRecv, COMDAT

; 16084: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16085: 	gPacketCheckSum.AddCheckSum(aIndex, aRecv->funcindex, aRecv->CheckSum);

  00003	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  0000d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ?gPacketCheckSum@@3VCPacketCheckSum@@A ; gPacketCheckSum
  00018	e8 00 00 00 00	 call	 ?AddCheckSum@CPacketCheckSum@@QAEXHHK@Z ; CPacketCheckSum::AddCheckSum

; 16086: }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z ENDP ; GCPacketCheckSumRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z	; GCNPggSendCheckSum
; Function compile flags: /Ogtp
;	COMDAT ?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_pggAuthData$ = 12					; size = 4
?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z PROC	; GCNPggSendCheckSum, COMDAT

; 16092: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _pggAuthData$[ebp]

; 16093: 	PMSG_NPROTECTGGCHECKSUM pMsg;
; 16094: 
; 16095: 	PHeadSetBE((LPBYTE)&pMsg, 0x73, sizeof(pMsg));

  00014	6a 14		 push	 20			; 00000014H
  00016	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 73		 push	 115			; 00000073H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 16096: 	memcpy(&pMsg.m_ggadCheckSum, pggAuthData, sizeof(pMsg.m_ggadCheckSum));

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00029	89 55 f0	 mov	 DWORD PTR _pMsg$[ebp+8], edx

; 16097: 
; 16098: 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0002c	6a 14		 push	 20			; 00000014H
  0002e	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00031	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00034	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00037	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+4], ecx
  0003a	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0003d	52		 push	 edx
  0003e	50		 push	 eax
  0003f	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+16], ecx
  00042	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16099: }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	83 c4 18	 add	 esp, 24			; 00000018H
  0004d	33 cd		 xor	 ecx, ebp
  0004f	5e		 pop	 esi
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z ENDP	; GCNPggSendCheckSum
_TEXT	ENDS
PUBLIC	?GCNPggCheckSumRecv@@YAXPAUPMSG_NPROTECTGGCHECKSUM@@H@Z ; GCNPggCheckSumRecv
; Function compile flags: /Ogtp
;	COMDAT ?GCNPggCheckSumRecv@@YAXPAUPMSG_NPROTECTGGCHECKSUM@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCNPggCheckSumRecv@@YAXPAUPMSG_NPROTECTGGCHECKSUM@@H@Z PROC ; GCNPggCheckSumRecv, COMDAT

; 16106: 	/*LPOBJ lpObj = &gObj[aIndex];
; 16107: 
; 16108: 	if ( !gObjIsConnected(aIndex))
; 16109: 		return;
; 16110: 
; 16111: 	LogAddTD("[NPgg] Recv Checksum = %x,AuthValue = %x [%s][%s]",
; 16112: 		lpMsg->m_ggadCheckSum.dwIndex, lpObj->NPggCSAuth.m_AuthAnswer.dwIndex,
; 16113: 		lpObj->AccountID, lpObj->Name);
; 16114: 
; 16115: 	memcpy(&gObj[aIndex].NPggCSAuth.m_AuthAnswer, &lpMsg->m_ggadCheckSum, sizeof(lpObj->NPggCSAuth.m_AuthAnswer));
; 16116: 
; 16117: 	DWORD dwGGErrCode = gObj[aIndex].NPggCSAuth.CheckAuthAnswer();
; 16118: 
; 16119: 	if ( dwGGErrCode )
; 16120: 	{
; 16121: 		LogAddTD("[NPgg] Invalid Checksum Detect Checksum = %x,AuthValue = %x [%s][%s]",
; 16122: 			lpMsg->m_ggadCheckSum.dwIndex, lpObj->NPggCSAuth.m_AuthAnswer.dwIndex,
; 16123: 			lpObj->AccountID, lpObj->Name);
; 16124: 
; 16125: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 177)), aIndex, 0);
; 16126: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 178)), aIndex, 0);
; 16127: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 179)), aIndex, 0);
; 16128: 
; 16129: 		CloseClient(aIndex);
; 16130: 
; 16131: 		return;
; 16132: 	}
; 16133: 
; 16134: 	lpObj->m_NPggCheckSumSendTime = GetTickCount();
; 16135: 	lpObj->m_bSentGGAuth = false;
; 16136: 
; 16137: 	LogAddTD("[NPgg] Checksum Clear %x [%s][%s]",
; 16138: 		lpMsg->m_ggadCheckSum.dwIndex, lpObj->AccountID, lpObj->Name);
; 16139: 		*/
; 16140: }

  00000	c3		 ret	 0
?GCNPggCheckSumRecv@@YAXPAUPMSG_NPROTECTGGCHECKSUM@@H@Z ENDP ; GCNPggCheckSumRecv
_TEXT	ENDS
PUBLIC	??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@ ; `string'
PUBLIC	??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z ; CGDuelStartRequestRecv
EXTRN	?IsDuelEnable@@YA_NH@Z:PROC			; IsDuelEnable
EXTRN	?gNonPK@@3HA:DWORD				; gNonPK
;	COMDAT ??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@
CONST	SEGMENT
??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@ DB '['
	DB	'Duel] [%s][%s] Requested to Start Duel to [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@ DB 'error '
	DB	': %s %d (%d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z
_TEXT	SEGMENT
_szDuelName$ = -312					; size = 11
_szDuelName2$ = -300					; size = 11
tv641 = -288						; size = 4
_iDuelIndex$ = -284					; size = 4
tv640 = -280						; size = 4
_pMsg$ = -276						; size = 15
_szTempText$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z PROC ; CGDuelStartRequestRecv, COMDAT

; 16154: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 16155: 	int iDuelIndex = -1;
; 16156: 	char szTempText[256];
; 16157: 
; 16158: 	if ( gObj[aIndex].CloseType != -1 )

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	53		 push	 ebx
  0001a	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001d	8b c3		 mov	 eax, ebx
  0001f	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00025	80 7c 08 0d ff	 cmp	 BYTE PTR [eax+ecx+13], -1
  0002a	56		 push	 esi
  0002b	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  0002e	57		 push	 edi
  0002f	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00032	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv640[ebp], eax
  00038	89 b5 e0 fe ff
	ff		 mov	 DWORD PTR tv641[ebp], esi
  0003e	0f 85 26 05 00
	00		 jne	 $LN37@CGDuelStar

; 16159: 		return;
; 16160: 	
; 16161: 	if ( gNonPK )

  00044	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gNonPK@@3HA, 0 ; gNonPK
  0004b	74 2c		 je	 SHORT $LN35@CGDuelStar

; 16162: 	{
; 16163: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 174)), aIndex, 1);

  0004d	6a 01		 push	 1
  0004f	53		 push	 ebx
  00050	68 ae 04 00 00	 push	 1198			; 000004aeH
$LN83@CGDuelStar:
  00055	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0005a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx

; 16360: }

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006e	33 cd		 xor	 ecx, ebp
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN35@CGDuelStar:

; 16164: 		return;
; 16165: 	}
; 16166: 
; 16167: 	if ( !gPkLimitFree )

  00079	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00080	75 13		 jne	 SHORT $LN33@CGDuelStar

; 16168: 	{
; 16169: 		if ( gObj[aIndex].m_PK_Level >= 6 )

  00082	80 be 19 01 00
	00 06		 cmp	 BYTE PTR [esi+281], 6
  00089	7c 0a		 jl	 SHORT $LN33@CGDuelStar

; 16170: 		{
; 16171: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 175)), aIndex, 1);

  0008b	6a 01		 push	 1
  0008d	53		 push	 ebx
  0008e	68 af 04 00 00	 push	 1199			; 000004afH

; 16172: 			return;

  00093	eb c0		 jmp	 SHORT $LN83@CGDuelStar
$LN33@CGDuelStar:

; 16173: 		}
; 16174: 	}
; 16175: 
; 16176: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUserReserved) )

  00095	8b 86 48 12 00
	00		 mov	 eax, DWORD PTR [esi+4680]
  0009b	85 c0		 test	 eax, eax
  0009d	78 35		 js	 SHORT $LN77@CGDuelStar
  0009f	33 d2		 xor	 edx, edx
  000a1	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  000a6	0f 9e c2	 setle	 dl
  000a9	8b c2		 mov	 eax, edx
  000ab	85 c0		 test	 eax, eax
  000ad	74 25		 je	 SHORT $LN77@CGDuelStar

; 16177: 	{
; 16178: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 159)), aIndex, 1);

  000af	6a 01		 push	 1
  000b1	53		 push	 ebx
  000b2	68 9f 04 00 00	 push	 1183			; 0000049fH
$LN85@CGDuelStar:
  000b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000bc	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16179: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), aIndex, 1);

  000ca	6a 01		 push	 1
  000cc	53		 push	 ebx
  000cd	68 a1 04 00 00	 push	 1185			; 000004a1H

; 16180: 		return;

  000d2	eb 81		 jmp	 SHORT $LN83@CGDuelStar
$LN77@CGDuelStar:

; 16181: 	}
; 16182: 
; 16183: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUser ) )

  000d4	8b 86 50 12 00
	00		 mov	 eax, DWORD PTR [esi+4688]
  000da	85 c0		 test	 eax, eax
  000dc	78 1a		 js	 SHORT $LN31@CGDuelStar
  000de	33 c9		 xor	 ecx, ecx
  000e0	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  000e5	0f 9e c1	 setle	 cl
  000e8	8b c1		 mov	 eax, ecx
  000ea	85 c0		 test	 eax, eax
  000ec	74 0a		 je	 SHORT $LN31@CGDuelStar

; 16184: 	{
; 16185: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 160)), aIndex, 1);

  000ee	6a 01		 push	 1
  000f0	53		 push	 ebx
  000f1	68 a0 04 00 00	 push	 1184			; 000004a0H

; 16186: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), aIndex, 1);
; 16187: 		return;

  000f6	eb bf		 jmp	 SHORT $LN85@CGDuelStar
$LN31@CGDuelStar:

; 16188: 	}
; 16189: 
; 16190: 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  000f8	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  000ff	3c 35		 cmp	 al, 53			; 00000035H
  00101	74 0d		 je	 SHORT $LN67@CGDuelStar
  00103	3c 12		 cmp	 al, 18			; 00000012H
  00105	72 16		 jb	 SHORT $LN30@CGDuelStar
  00107	b2 17		 mov	 dl, 23			; 00000017H
  00109	3a d0		 cmp	 dl, al
  0010b	1b c0		 sbb	 eax, eax
  0010d	40		 inc	 eax
  0010e	74 0d		 je	 SHORT $LN30@CGDuelStar
$LN67@CGDuelStar:

; 16191: 	{
; 16192: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 207)), aIndex, 1);

  00110	6a 01		 push	 1
  00112	53		 push	 ebx
  00113	68 cf 04 00 00	 push	 1231			; 000004cfH

; 16193: 		return;

  00118	e9 38 ff ff ff	 jmp	 $LN83@CGDuelStar
$LN30@CGDuelStar:

; 16194: 	}
; 16195: 
; 16196: 	LPOBJ lpObj = &gObj[aIndex];
; 16197: 
; 16198: 	if ( !PacketCheckTime(lpObj ) )

  0011d	56		 push	 esi
  0011e	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00123	83 c4 04	 add	 esp, 4
  00126	85 c0		 test	 eax, eax
  00128	0f 84 3c 04 00
	00		 je	 $LN37@CGDuelStar

; 16199: 		return;
; 16200: 
; 16201: 	iDuelIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  0012e	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00132	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00136	66 c1 e0 08	 shl	 ax, 8
  0013a	0f b7 f0	 movzx	 esi, ax
  0013d	0b f1		 or	 esi, ecx
  0013f	89 b5 e4 fe ff
	ff		 mov	 DWORD PTR _iDuelIndex$[ebp], esi

; 16202: 
; 16203: 	if ( !OBJMAX_RANGE(iDuelIndex) )

  00145	7c 0f		 jl	 SHORT $LN68@CGDuelStar
  00147	33 c0		 xor	 eax, eax
  00149	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0014f	0f 9e c0	 setle	 al
  00152	85 c0		 test	 eax, eax
  00154	75 2a		 jne	 SHORT $LN28@CGDuelStar
$LN68@CGDuelStar:

; 16204: 	{
; 16205: 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, iDuelIndex);

  00156	56		 push	 esi
  00157	68 4d 3f 00 00	 push	 16205			; 00003f4dH
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0016c	83 c4 10	 add	 esp, 16			; 00000010H
  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	5b		 pop	 ebx

; 16360: }

  00172	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00175	33 cd		 xor	 ecx, ebp
  00177	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	c3		 ret	 0
$LN28@CGDuelStar:

; 16206: 		return;
; 16207: 	}
; 16208: 
; 16209: 	if ( iDuelIndex == aIndex  )

  00180	3b f3		 cmp	 esi, ebx
  00182	0f 84 e2 03 00
	00		 je	 $LN37@CGDuelStar

; 16210: 		return;
; 16211: 
; 16212: 	if ( !gPkLimitFree )

  00188	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  0018f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00195	75 1f		 jne	 SHORT $LN25@CGDuelStar

; 16213: 	{
; 16214: 		if ( gObj[iDuelIndex].m_PK_Level >= 6 )

  00197	8b d6		 mov	 edx, esi
  00199	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  0019f	80 bc 0a 19 01
	00 00 06	 cmp	 BYTE PTR [edx+ecx+281], 6
  001a7	7c 0d		 jl	 SHORT $LN25@CGDuelStar

; 16215: 		{
; 16216: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 176)), aIndex, 1);

  001a9	6a 01		 push	 1
  001ab	53		 push	 ebx
  001ac	68 b0 04 00 00	 push	 1200			; 000004b0H

; 16217: 			return;

  001b1	e9 9f fe ff ff	 jmp	 $LN83@CGDuelStar
$LN25@CGDuelStar:

; 16218: 		}
; 16219: 	}
; 16220: 
; 16221: 	char szDuelName[MAX_ACCOUNT_LEN+1]={0};

  001b6	33 c0		 xor	 eax, eax

; 16222: 	char szDuelName2[MAX_ACCOUNT_LEN+1]={0};
; 16223: 	memcpy(szDuelName, gObj[iDuelIndex].Name, MAX_ACCOUNT_LEN);

  001b8	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  001be	8b 54 0e 61	 mov	 edx, DWORD PTR [esi+ecx+97]
  001c2	89 85 c9 fe ff
	ff		 mov	 DWORD PTR _szDuelName$[ebp+1], eax
  001c8	89 85 cd fe ff
	ff		 mov	 DWORD PTR _szDuelName$[ebp+5], eax
  001ce	66 89 85 d1 fe
	ff ff		 mov	 WORD PTR _szDuelName$[ebp+9], ax
  001d5	89 85 d5 fe ff
	ff		 mov	 DWORD PTR _szDuelName2$[ebp+1], eax
  001db	89 85 d9 fe ff
	ff		 mov	 DWORD PTR _szDuelName2$[ebp+5], eax
  001e1	66 89 85 dd fe
	ff ff		 mov	 WORD PTR _szDuelName2$[ebp+9], ax
  001e8	8b 44 0e 5d	 mov	 eax, DWORD PTR [esi+ecx+93]
  001ec	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _szDuelName$[ebp], eax
  001f2	0f b7 44 0e 65	 movzx	 eax, WORD PTR [esi+ecx+101]

; 16224: 	szDuelName[MAX_ACCOUNT_LEN] = 0;
; 16225: 	memcpy(szDuelName2, lpMsg->szName, MAX_ACCOUNT_LEN);

  001f7	8b 4f 05	 mov	 ecx, DWORD PTR [edi+5]
  001fa	66 89 85 d0 fe
	ff ff		 mov	 WORD PTR _szDuelName$[ebp+8], ax
  00201	0f b7 47 0d	 movzx	 eax, WORD PTR [edi+13]
  00205	89 95 cc fe ff
	ff		 mov	 DWORD PTR _szDuelName$[ebp+4], edx
  0020b	8b 57 09	 mov	 edx, DWORD PTR [edi+9]
  0020e	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _szDuelName2$[ebp], ecx
  00214	66 89 85 dc fe
	ff ff		 mov	 WORD PTR _szDuelName2$[ebp+8], ax
  0021b	c6 85 d2 fe ff
	ff 00		 mov	 BYTE PTR _szDuelName$[ebp+10], 0
  00222	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _szDuelName2$[ebp+4], edx

; 16226: 	szDuelName2[MAX_ACCOUNT_LEN] = 0;

  00228	c6 85 de fe ff
	ff 00		 mov	 BYTE PTR _szDuelName2$[ebp+10], 0

; 16227: 
; 16228: 	if ( strcmp(szDuelName, szDuelName2) )

  0022f	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _szDuelName2$[ebp]
  00235	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _szDuelName$[ebp]
  0023b	eb 03 8d 49 00	 npad	 5
$LL73@CGDuelStar:
  00240	8a 10		 mov	 dl, BYTE PTR [eax]
  00242	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00244	75 1a		 jne	 SHORT $LN74@CGDuelStar
  00246	84 d2		 test	 dl, dl
  00248	74 12		 je	 SHORT $LN75@CGDuelStar
  0024a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0024d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00250	75 0e		 jne	 SHORT $LN74@CGDuelStar
  00252	83 c0 02	 add	 eax, 2
  00255	83 c1 02	 add	 ecx, 2
  00258	84 d2		 test	 dl, dl
  0025a	75 e4		 jne	 SHORT $LL73@CGDuelStar
$LN75@CGDuelStar:
  0025c	33 c0		 xor	 eax, eax
  0025e	eb 05		 jmp	 SHORT $LN76@CGDuelStar
$LN74@CGDuelStar:
  00260	1b c0		 sbb	 eax, eax
  00262	83 d8 ff	 sbb	 eax, -1
$LN76@CGDuelStar:
  00265	85 c0		 test	 eax, eax
  00267	74 0d		 je	 SHORT $LN24@CGDuelStar

; 16229: 	{
; 16230: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 162)), aIndex, 1);

  00269	6a 01		 push	 1
  0026b	53		 push	 ebx
  0026c	68 a2 04 00 00	 push	 1186			; 000004a2H

; 16231: 		return;

  00271	e9 df fd ff ff	 jmp	 $LN83@CGDuelStar
$LN24@CGDuelStar:

; 16232: 	}
; 16233: 
; 16234: 	if ( IsDuelEnable(iDuelIndex) == FALSE )

  00276	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _iDuelIndex$[ebp]
  0027c	51		 push	 ecx
  0027d	e8 00 00 00 00	 call	 ?IsDuelEnable@@YA_NH@Z	; IsDuelEnable
  00282	83 c4 04	 add	 esp, 4
  00285	84 c0		 test	 al, al
  00287	75 0d		 jne	 SHORT $LN23@CGDuelStar

; 16235: 	{
; 16236: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 163)), aIndex, 1);

  00289	6a 01		 push	 1
  0028b	53		 push	 ebx
  0028c	68 a3 04 00 00	 push	 1187			; 000004a3H

; 16237: 		return;

  00291	e9 bf fd ff ff	 jmp	 $LN83@CGDuelStar
$LN23@CGDuelStar:

; 16238: 	}
; 16239: 
; 16240: 	if ( lpObj->lpGuild && lpObj->lpGuild->WarState == 1 )

  00296	8b bd e0 fe ff
	ff		 mov	 edi, DWORD PTR tv641[ebp]
  0029c	8b 87 18 06 00
	00		 mov	 eax, DWORD PTR [edi+1560]
  002a2	85 c0		 test	 eax, eax
  002a4	74 16		 je	 SHORT $LN22@CGDuelStar
  002a6	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  002ad	75 0d		 jne	 SHORT $LN22@CGDuelStar

; 16241: 	{
; 16242: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 164)), aIndex, 1);

  002af	6a 01		 push	 1
  002b1	53		 push	 ebx
  002b2	68 a4 04 00 00	 push	 1188			; 000004a4H

; 16243: 		return;

  002b7	e9 99 fd ff ff	 jmp	 $LN83@CGDuelStar
$LN22@CGDuelStar:

; 16244: 	}
; 16245: 
; 16246: 	if ( gObj[iDuelIndex].lpGuild && gObj[iDuelIndex].lpGuild->WarState == 1 )

  002bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c2	8b 84 16 18 06
	00 00		 mov	 eax, DWORD PTR [esi+edx+1560]
  002c9	85 c0		 test	 eax, eax
  002cb	74 16		 je	 SHORT $LN21@CGDuelStar
  002cd	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  002d4	75 0d		 jne	 SHORT $LN21@CGDuelStar

; 16247: 	{
; 16248: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 165)), aIndex, 1);

  002d6	6a 01		 push	 1
  002d8	53		 push	 ebx
  002d9	68 a5 04 00 00	 push	 1189			; 000004a5H

; 16249: 		return;

  002de	e9 72 fd ff ff	 jmp	 $LN83@CGDuelStar
$LN21@CGDuelStar:

; 16250: 	}
; 16251: 
; 16252: 	if ( gObjIsConnected(iDuelIndex) == FALSE )

  002e3	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  002e9	50		 push	 eax
  002ea	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  002ef	83 c4 04	 add	 esp, 4
  002f2	85 c0		 test	 eax, eax
  002f4	0f 84 70 02 00
	00		 je	 $LN37@CGDuelStar

; 16253: 		return;
; 16254: 
; 16255: 	if ( gObj[iDuelIndex].Type == OBJ_MONSTER )

  002fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00300	80 7c 0e 50 02	 cmp	 BYTE PTR [esi+ecx+80], 2
  00305	0f 84 5f 02 00
	00		 je	 $LN37@CGDuelStar

; 16256: 		return;
; 16257: 
; 16258: 	if ( gObj[iDuelIndex].CloseCount >= 0 )

  0030b	80 7c 0e 0c 00	 cmp	 BYTE PTR [esi+ecx+12], 0
  00310	0f 8d 54 02 00
	00		 jge	 $LN37@CGDuelStar

; 16259: 		return;
; 16260: 
; 16261: 	BOOL bRetVal = FALSE;
; 16262: 
; 16263: 	int n;
; 16264: 	for (n=0;n<MAX_SELF_DEFENSE;n++)

  00316	33 c0		 xor	 eax, eax
  00318	8d 97 c4 05 00
	00		 lea	 edx, DWORD PTR [edi+1476]
  0031e	8b ff		 npad	 2
$LL17@CGDuelStar:

; 16265: 	{
; 16266: 		if ( lpObj->SelfDefense[n] >= 0 )

  00320	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00323	7d 45		 jge	 SHORT $LN63@CGDuelStar

; 16259: 		return;
; 16260: 
; 16261: 	BOOL bRetVal = FALSE;
; 16262: 
; 16263: 	int n;
; 16264: 	for (n=0;n<MAX_SELF_DEFENSE;n++)

  00325	40		 inc	 eax
  00326	83 c2 04	 add	 edx, 4
  00329	83 f8 07	 cmp	 eax, 7
  0032c	7c f2		 jl	 SHORT $LL17@CGDuelStar

; 16277: 	}
; 16278: 
; 16279: 	for (n=0;n<MAX_SELF_DEFENSE;n++)

  0032e	33 c0		 xor	 eax, eax
  00330	8d 94 0e c4 05
	00 00		 lea	 edx, DWORD PTR [esi+ecx+1476]
$LL12@CGDuelStar:

; 16280: 	{
; 16281: 		if ( gObj[iDuelIndex].SelfDefense[n] >= 0 )

  00337	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0033a	7d 2e		 jge	 SHORT $LN63@CGDuelStar

; 16277: 	}
; 16278: 
; 16279: 	for (n=0;n<MAX_SELF_DEFENSE;n++)

  0033c	40		 inc	 eax
  0033d	83 c2 04	 add	 edx, 4
  00340	83 f8 07	 cmp	 eax, 7
  00343	7c f2		 jl	 SHORT $LL12@CGDuelStar

; 16282: 		{
; 16283: 			bRetVal = TRUE;
; 16284: 			break;
; 16285: 		}
; 16286: 	}
; 16287: 
; 16288: 	if ( bRetVal )
; 16289: 	{
; 16290: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 189)), aIndex, 1);
; 16291: 		return;
; 16292: 	}
; 16293: 
; 16294: 	if ( DS_MAP_RANGE(gObj[iDuelIndex].MapNumber ) )

  00345	8a 84 0e 23 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+291]
  0034c	3c 09		 cmp	 al, 9
  0034e	74 0d		 je	 SHORT $LN71@CGDuelStar
  00350	33 d2		 xor	 edx, edx
  00352	3c 20		 cmp	 al, 32			; 00000020H
  00354	0f 94 c2	 sete	 dl
  00357	8b c2		 mov	 eax, edx
  00359	85 c0		 test	 eax, eax
  0035b	74 1a		 je	 SHORT $LN7@CGDuelStar
$LN71@CGDuelStar:

; 16295: 	{
; 16296: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 180)), aIndex, 1);

  0035d	6a 01		 push	 1
  0035f	53		 push	 ebx
  00360	68 b4 04 00 00	 push	 1204			; 000004b4H

; 16297: 		return;

  00365	e9 eb fc ff ff	 jmp	 $LN83@CGDuelStar
$LN63@CGDuelStar:

; 16267: 		{
; 16268: 			bRetVal = TRUE;
; 16269: 			break;
; 16270: 		}
; 16271: 	}
; 16272: 
; 16273: 	if ( bRetVal )
; 16274: 	{
; 16275: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 189)), aIndex, 1);

  0036a	6a 01		 push	 1
  0036c	53		 push	 ebx
  0036d	68 bd 04 00 00	 push	 1213			; 000004bdH

; 16276: 		return;

  00372	e9 de fc ff ff	 jmp	 $LN83@CGDuelStar
$LN7@CGDuelStar:

; 16298: 	}
; 16299: 
; 16300: 	if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) )

  00377	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv640[ebp]
  0037d	0f b6 84 08 23
	01 00 00	 movzx	 eax, BYTE PTR [eax+ecx+291]
  00385	3c 34		 cmp	 al, 52			; 00000034H
  00387	74 0d		 je	 SHORT $LN72@CGDuelStar
  00389	3c 0b		 cmp	 al, 11			; 0000000bH
  0038b	72 16		 jb	 SHORT $LN78@CGDuelStar
  0038d	b2 11		 mov	 dl, 17			; 00000011H
  0038f	3a d0		 cmp	 dl, al
  00391	1b c0		 sbb	 eax, eax
  00393	40		 inc	 eax
  00394	74 0d		 je	 SHORT $LN78@CGDuelStar
$LN72@CGDuelStar:

; 16301: 	{
; 16302: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 166)), aIndex, 1);

  00396	6a 01		 push	 1
  00398	53		 push	 ebx
  00399	68 a6 04 00 00	 push	 1190			; 000004a6H

; 16303: 		return;

  0039e	e9 b2 fc ff ff	 jmp	 $LN83@CGDuelStar
$LN78@CGDuelStar:

; 16304: 	}
; 16305: 
; 16306: 	if ( lpObj->m_IfState.use > 0 )

  003a3	b0 03		 mov	 al, 3
  003a5	84 87 b8 11 00
	00		 test	 BYTE PTR [edi+4536], al
  003ab	76 0d		 jbe	 SHORT $LN5@CGDuelStar

; 16307: 	{
; 16308: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 167)), aIndex, 1);

  003ad	6a 01		 push	 1
  003af	53		 push	 ebx
  003b0	68 a7 04 00 00	 push	 1191			; 000004a7H

; 16309: 		return;

  003b5	e9 9b fc ff ff	 jmp	 $LN83@CGDuelStar
$LN5@CGDuelStar:

; 16310: 	}
; 16311: 
; 16312: 	if ( gObj[iDuelIndex].m_IfState.use > 0 )

  003ba	84 84 0e b8 11
	00 00		 test	 BYTE PTR [esi+ecx+4536], al
  003c1	76 45		 jbe	 SHORT $LN4@CGDuelStar

; 16313: 	{
; 16314: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 168)), gObj[iDuelIndex].Name);

  003c3	8d 44 0e 5d	 lea	 eax, DWORD PTR [esi+ecx+93]
  003c7	50		 push	 eax
  003c8	68 a8 04 00 00	 push	 1192			; 000004a8H
$LN84@CGDuelStar:
  003cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003d2	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003d7	50		 push	 eax
  003d8	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTempText$[ebp]
  003de	51		 push	 ecx
  003df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 16315: 		GCServerMsgStringSend(szTempText, aIndex, 1);

  003e5	6a 01		 push	 1
  003e7	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTempText$[ebp]
  003ed	53		 push	 ebx
  003ee	52		 push	 edx
  003ef	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003f4	83 c4 18	 add	 esp, 24			; 00000018H
  003f7	5f		 pop	 edi
  003f8	5e		 pop	 esi
  003f9	5b		 pop	 ebx

; 16360: }

  003fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fd	33 cd		 xor	 ecx, ebp
  003ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00404	8b e5		 mov	 esp, ebp
  00406	5d		 pop	 ebp
  00407	c3		 ret	 0
$LN4@CGDuelStar:

; 16316: 		return;
; 16317: 	}
; 16318: 
; 16319: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUserRequested) )

  00408	8b 84 0e 4c 12
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4684]
  0040f	85 c0		 test	 eax, eax
  00411	78 1c		 js	 SHORT $LN79@CGDuelStar
  00413	33 d2		 xor	 edx, edx
  00415	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0041a	0f 9e c2	 setle	 dl
  0041d	8b c2		 mov	 eax, edx
  0041f	85 c0		 test	 eax, eax
  00421	74 0c		 je	 SHORT $LN79@CGDuelStar

; 16320: 	{
; 16321: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 169)), gObj[iDuelIndex].Name);

  00423	8d 44 0e 5d	 lea	 eax, DWORD PTR [esi+ecx+93]
  00427	50		 push	 eax
  00428	68 a9 04 00 00	 push	 1193			; 000004a9H

; 16322: 		GCServerMsgStringSend(szTempText, aIndex, 1);
; 16323: 		return;

  0042d	eb 9e		 jmp	 SHORT $LN84@CGDuelStar
$LN79@CGDuelStar:

; 16324: 	}
; 16325: 
; 16326: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUserReserved) )

  0042f	8b 84 0e 48 12
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4680]
  00436	85 c0		 test	 eax, eax
  00438	78 1f		 js	 SHORT $LN81@CGDuelStar
  0043a	33 d2		 xor	 edx, edx
  0043c	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00441	0f 9e c2	 setle	 dl
  00444	8b c2		 mov	 eax, edx
  00446	85 c0		 test	 eax, eax
  00448	74 0f		 je	 SHORT $LN81@CGDuelStar

; 16327: 	{
; 16328: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 170)), gObj[iDuelIndex].Name);

  0044a	8d 44 0e 5d	 lea	 eax, DWORD PTR [esi+ecx+93]
  0044e	50		 push	 eax
  0044f	68 aa 04 00 00	 push	 1194			; 000004aaH

; 16329: 		GCServerMsgStringSend(szTempText, aIndex, 1);
; 16330: 		return;

  00454	e9 74 ff ff ff	 jmp	 $LN84@CGDuelStar
$LN81@CGDuelStar:

; 16331: 	}
; 16332: 
; 16333: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUser) )

  00459	8b 84 0e 50 12
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4688]
  00460	85 c0		 test	 eax, eax
  00462	78 1f		 js	 SHORT $LN82@CGDuelStar
  00464	33 d2		 xor	 edx, edx
  00466	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0046b	0f 9e c2	 setle	 dl
  0046e	8b c2		 mov	 eax, edx
  00470	85 c0		 test	 eax, eax
  00472	74 0f		 je	 SHORT $LN82@CGDuelStar

; 16334: 	{
; 16335: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 171)), gObj[iDuelIndex].Name);

  00474	8d 44 0e 5d	 lea	 eax, DWORD PTR [esi+ecx+93]
  00478	50		 push	 eax
  00479	68 ab 04 00 00	 push	 1195			; 000004abH

; 16336: 		GCServerMsgStringSend(szTempText, aIndex, 1);
; 16337: 		return;

  0047e	e9 4a ff ff ff	 jmp	 $LN84@CGDuelStar
$LN82@CGDuelStar:

; 16338: 	}
; 16339: 
; 16340: 	lpObj->m_iDuelUserReserved = iDuelIndex;

  00483	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _iDuelIndex$[ebp]
  00489	89 8f 48 12 00
	00		 mov	 DWORD PTR [edi+4680], ecx

; 16341: 	lpObj->m_iDuelUser = -1;

  0048f	c7 87 50 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [edi+4688], -1

; 16342: 	gObj[iDuelIndex].m_iDuelUserRequested = aIndex;

  00499	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0049e	89 9c 06 4c 12
	00 00		 mov	 DWORD PTR [esi+eax+4684], ebx

; 16343: 
; 16344: 	PMSG_REQ_DUEL_OK pMsg;
; 16345: 
; 16346: 	pMsg.h.c = 0xC1;
; 16347: 	pMsg.h.headcode = 0xAC;
; 16348: 	pMsg.h.size = sizeof(pMsg);
; 16349: 	pMsg.NumberH = SET_NUMBERH(aIndex);
; 16350: 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 16351: 	memcpy(pMsg.szName, gObj[aIndex].Name, sizeof(pMsg.szName));

  004a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004aa	8b d3		 mov	 edx, ebx
  004ac	c1 ea 08	 shr	 edx, 8
  004af	88 95 ef fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+3], dl
  004b5	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv640[ebp]
  004bb	c6 85 ec fe ff
	ff c1		 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  004c2	66 c7 85 ed fe
	ff ff 0f ac	 mov	 WORD PTR _pMsg$[ebp+1], 44047 ; 0000ac0fH
  004cb	88 9d f0 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], bl
  004d1	8b 54 02 5d	 mov	 edx, DWORD PTR [edx+eax+93]
  004d5	89 95 f1 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+5], edx
  004db	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv640[ebp]
  004e1	8b 54 02 61	 mov	 edx, DWORD PTR [edx+eax+97]
  004e5	89 95 f5 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+9], edx
  004eb	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv640[ebp]
  004f1	66 8b 44 02 65	 mov	 ax, WORD PTR [edx+eax+101]

; 16352: 
; 16353: 	DataSend(iDuelIndex, (LPBYTE)&pMsg, pMsg.h.size);

  004f6	6a 0f		 push	 15			; 0000000fH
  004f8	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  004fe	52		 push	 edx
  004ff	51		 push	 ecx
  00500	66 89 85 f9 fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+13], ax
  00507	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16354: 
; 16355: 	wsprintf(szTempText, lMsg.Get(MSGGET(4, 172)), gObj[iDuelIndex].Name);

  0050c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00511	83 c4 0c	 add	 esp, 12			; 0000000cH
  00514	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00518	51		 push	 ecx
  00519	68 ac 04 00 00	 push	 1196			; 000004acH
  0051e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00523	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00528	50		 push	 eax
  00529	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTempText$[ebp]
  0052f	52		 push	 edx
  00530	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 16356: 	GCServerMsgStringSend(szTempText, aIndex, 1);

  00536	6a 01		 push	 1
  00538	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  0053e	53		 push	 ebx
  0053f	50		 push	 eax
  00540	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 16357: 
; 16358: 	LogAddTD("[Duel] [%s][%s] Requested to Start Duel to [%s][%s]",
; 16359: 		lpObj->AccountID, lpObj->Name, gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);

  00545	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0054a	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0054e	51		 push	 ecx
  0054f	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00553	52		 push	 edx
  00554	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00557	50		 push	 eax
  00558	83 c7 52	 add	 edi, 82			; 00000052H
  0055b	57		 push	 edi
  0055c	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@
  00561	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00567	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN37@CGDuelStar:

; 16360: }

  0056a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0056d	5f		 pop	 edi
  0056e	5e		 pop	 esi
  0056f	33 cd		 xor	 ecx, ebp
  00571	5b		 pop	 ebx
  00572	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00577	8b e5		 mov	 esp, ebp
  00579	5d		 pop	 ebp
  0057a	c3		 ret	 0
?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z ENDP ; CGDuelStartRequestRecv
_TEXT	ENDS
PUBLIC	??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z ; CGDuelEndRequestRecv
;	COMDAT ??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Duel] [%s][%s] Duel Ended [%s][%s]', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -48					; size = 4
_pMsg$223586 = -44					; size = 17
_pMsg$223575 = -24					; size = 17
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z PROC ; CGDuelEndRequestRecv, COMDAT

; 16363: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]

; 16364: 	int iDuelIndex = -1;
; 16365: 
; 16366: 	if ( gObj[aIndex].CloseType != -1 ) 

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	57		 push	 edi
  00019	8b fa		 mov	 edi, edx
  0001b	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00021	80 7c 07 0d ff	 cmp	 BYTE PTR [edi+eax+13], -1

; 16407: 		{
; 16408: 			gObj[iDuelIndex].m_iDuelUser = -1;

  00026	89 55 d0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], edx
  00029	0f 85 8d 01 00
	00		 jne	 $LN1@CGDuelEndR

; 16367: 		return;
; 16368: 
; 16369: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUserReserved) )

  0002f	8b 8c 07 48 12
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4680]
  00036	53		 push	 ebx
  00037	56		 push	 esi
  00038	8d b4 07 48 12
	00 00		 lea	 esi, DWORD PTR [edi+eax+4680]
  0003f	85 c9		 test	 ecx, ecx
  00041	78 1c		 js	 SHORT $LN16@CGDuelEndR
  00043	33 db		 xor	 ebx, ebx
  00045	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0004b	0f 9e c3	 setle	 bl
  0004e	8b cb		 mov	 ecx, ebx
  00050	85 c9		 test	 ecx, ecx
  00052	74 0b		 je	 SHORT $LN16@CGDuelEndR

; 16370: 	{
; 16371: 		gObj[aIndex].m_iDuelUserReserved = -1;

  00054	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN16@CGDuelEndR:

; 16372: 	}
; 16373: 
; 16374: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUser) )

  0005f	8b 8c 07 50 12
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4688]
  00066	85 c9		 test	 ecx, ecx
  00068	0f 88 32 01 00
	00		 js	 $LN18@CGDuelEndR
  0006e	33 db		 xor	 ebx, ebx
  00070	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00076	0f 9e c3	 setle	 bl
  00079	8b cb		 mov	 ecx, ebx
  0007b	85 c9		 test	 ecx, ecx
  0007d	0f 84 1d 01 00
	00		 je	 $LN18@CGDuelEndR

; 16375: 	{
; 16376: 		iDuelIndex = gObj[aIndex].m_iDuelUser;

  00083	8b 9c 07 50 12
	00 00		 mov	 ebx, DWORD PTR [edi+eax+4688]

; 16377: 		gObj[aIndex].m_iDuelUser = -1;

  0008a	c7 84 07 50 12
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edi+eax+4688], -1

; 16378: 
; 16379: 		PMSG_ANS_END_DUEL pMsg;
; 16380: 
; 16381: 		pMsg.h.c = 0xC1;
; 16382: 		pMsg.h.headcode = 0xAA;
; 16383: 		pMsg.h.size = sizeof(pMsg);
; 16384: 		pMsg.h.subcode = 0x03;
; 16385: 		pMsg.bResult = 0;
; 16386: 		
; 16387: 		pMsg.NumberH = SET_NUMBERH(iDuelIndex);
; 16388: 		pMsg.NumberL = SET_NUMBERL(iDuelIndex);
; 16389: 		memcpy(pMsg.szName, gObj[iDuelIndex].Name, sizeof(pMsg.szName));

  00095	8b f3		 mov	 esi, ebx
  00097	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0009d	8b c3		 mov	 eax, ebx
  0009f	c1 e8 08	 shr	 eax, 8
  000a2	88 45 ed	 mov	 BYTE PTR _pMsg$223575[ebp+5], al
  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000aa	c6 45 e8 c1	 mov	 BYTE PTR _pMsg$223575[ebp], 193 ; 000000c1H
  000ae	c7 45 e9 11 aa
	03 00		 mov	 DWORD PTR _pMsg$223575[ebp+1], 240145 ; 0003aa11H
  000b5	88 5d ee	 mov	 BYTE PTR _pMsg$223575[ebp+6], bl
  000b8	8b 4c 06 5d	 mov	 ecx, DWORD PTR [esi+eax+93]
  000bc	89 4d ef	 mov	 DWORD PTR _pMsg$223575[ebp+7], ecx
  000bf	8b 4c 06 61	 mov	 ecx, DWORD PTR [esi+eax+97]
  000c3	89 4d f3	 mov	 DWORD PTR _pMsg$223575[ebp+11], ecx
  000c6	66 8b 44 06 65	 mov	 ax, WORD PTR [esi+eax+101]

; 16390: 
; 16391: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000cb	6a 11		 push	 17			; 00000011H
  000cd	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$223575[ebp]
  000d0	51		 push	 ecx
  000d1	52		 push	 edx
  000d2	66 89 45 f7	 mov	 WORD PTR _pMsg$223575[ebp+15], ax
  000d6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16392: 
; 16393: 		if ( iDuelIndex == aIndex )

  000db	8b 45 d0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e1	3b d8		 cmp	 ebx, eax
  000e3	0f 84 d1 00 00
	00		 je	 $LN19@CGDuelEndR

; 16401: 		return;
; 16402: 	}
; 16403: 
; 16404: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUser) )

  000e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ef	8b 8c 16 50 12
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4688]
  000f6	85 c9		 test	 ecx, ecx
  000f8	0f 88 bc 00 00
	00		 js	 $LN19@CGDuelEndR
  000fe	33 d2		 xor	 edx, edx
  00100	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00106	0f 9e c2	 setle	 dl
  00109	85 d2		 test	 edx, edx
  0010b	0f 84 a9 00 00
	00		 je	 $LN19@CGDuelEndR

; 16405: 	{
; 16406: 		if ( gObj[iDuelIndex].m_iDuelUser == aIndex )

  00111	3b c8		 cmp	 ecx, eax
  00113	0f 85 a1 00 00
	00		 jne	 $LN19@CGDuelEndR

; 16407: 		{
; 16408: 			gObj[iDuelIndex].m_iDuelUser = -1;

  00119	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011f	c7 84 0e 50 12
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+ecx+4688], -1

; 16409: 
; 16410: 			PMSG_ANS_END_DUEL pMsg;
; 16411: 
; 16412: 			pMsg.h.c = 0xC1;
; 16413: 			pMsg.h.headcode = 0xAA;
; 16414: 			pMsg.h.size = sizeof(pMsg);
; 16415: 			pMsg.h.subcode = 0x03;
; 16416: 			pMsg.bResult = 0;
; 16417: 			pMsg.NumberH = SET_NUMBERH(aIndex);

  0012a	8b d0		 mov	 edx, eax

; 16418: 			pMsg.NumberL = SET_NUMBERL(aIndex);

  0012c	88 45 da	 mov	 BYTE PTR _pMsg$223586[ebp+6], al

; 16419: 			memcpy(pMsg.szName, gObj[aIndex].Name, sizeof(pMsg.szName));

  0012f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00134	c1 ea 08	 shr	 edx, 8
  00137	c6 45 d4 c1	 mov	 BYTE PTR _pMsg$223586[ebp], 193 ; 000000c1H
  0013b	c7 45 d5 11 aa
	03 00		 mov	 DWORD PTR _pMsg$223586[ebp+1], 240145 ; 0003aa11H
  00142	88 55 d9	 mov	 BYTE PTR _pMsg$223586[ebp+5], dl
  00145	8b 4c 07 5d	 mov	 ecx, DWORD PTR [edi+eax+93]
  00149	89 4d db	 mov	 DWORD PTR _pMsg$223586[ebp+7], ecx
  0014c	8b 54 07 61	 mov	 edx, DWORD PTR [edi+eax+97]

; 16420: 
; 16421: 			DataSend(iDuelIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00150	6a 11		 push	 17			; 00000011H
  00152	8d 4d d4	 lea	 ecx, DWORD PTR _pMsg$223586[ebp]
  00155	89 55 df	 mov	 DWORD PTR _pMsg$223586[ebp+11], edx
  00158	66 8b 44 07 65	 mov	 ax, WORD PTR [edi+eax+101]
  0015d	51		 push	 ecx
  0015e	53		 push	 ebx
  0015f	66 89 45 e3	 mov	 WORD PTR _pMsg$223586[ebp+15], ax
  00163	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16422: 
; 16423: 			LogAddTD("[Duel] [%s][%s] Duel Ended [%s][%s]",
; 16424: 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 16425: 				gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);

  00168	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016d	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  00171	52		 push	 edx
  00172	8d 4c 06 52	 lea	 ecx, DWORD PTR [esi+eax+82]
  00176	51		 push	 ecx
  00177	8d 54 07 5d	 lea	 edx, DWORD PTR [edi+eax+93]
  0017b	52		 push	 edx
  0017c	8d 44 07 52	 lea	 eax, DWORD PTR [edi+eax+82]
  00180	50		 push	 eax
  00181	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN?$FL@
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0018c	83 c4 20	 add	 esp, 32			; 00000020H
  0018f	5e		 pop	 esi
  00190	5b		 pop	 ebx
  00191	5f		 pop	 edi

; 16426: 		}
; 16427: 	}
; 16428: }

  00192	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00195	33 cd		 xor	 ecx, ebp
  00197	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019c	8b e5		 mov	 esp, ebp
  0019e	5d		 pop	 ebp
  0019f	c3		 ret	 0
$LN18@CGDuelEndR:

; 16394: 		{
; 16395: 			return;
; 16396: 		}
; 16397: 	}
; 16398: 	else
; 16399: 	{
; 16400: 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, iDuelIndex);

  001a0	6a ff		 push	 -1
  001a2	68 10 40 00 00	 push	 16400			; 00004010H
  001a7	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  001b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001b7	83 c4 10	 add	 esp, 16			; 00000010H
$LN19@CGDuelEndR:
  001ba	5e		 pop	 esi
  001bb	5b		 pop	 ebx
$LN1@CGDuelEndR:

; 16426: 		}
; 16427: 	}
; 16428: }

  001bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bf	33 cd		 xor	 ecx, ebp
  001c1	5f		 pop	 edi
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c3		 ret	 0
?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z ENDP ; CGDuelEndRequestRecv
_TEXT	ENDS
PUBLIC	?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z ; CGDuelOkRequestRecv
; Function compile flags: /Ogtp
;	COMDAT ?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z PROC	; CGDuelOkRequestRecv, COMDAT

; 16444: 	/*int iDuelIndex = -1;
; 16445: 
; 16446: 	PMSG_ANS_START_DUEL pMsgSend;
; 16447: 	
; 16448: 	pMsgSend.h.c = 0xC1;
; 16449: 	pMsgSend.h.headcode = 0xAA;
; 16450: 	pMsgSend.h.size = sizeof(pMsgSend);
; 16451: 
; 16452: 	if ( gObj[aIndex].CloseType != -1 ) 
; 16453: 		return;
; 16454: 	
; 16455: 	iDuelIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);
; 16456: 
; 16457: 	if ( OBJMAX_RANGE(iDuelIndex) )
; 16458: 	{
; 16459: 		if ( !gObjIsConnected(iDuelIndex) )
; 16460: 			return;
; 16461: 
; 16462: 		if ( gObj[iDuelIndex].Type == OBJ_MONSTER )
; 16463: 			return;
; 16464: 
; 16465: 		if ( gObj[iDuelIndex].CloseCount >= 0 )
; 16466: 			return;
; 16467: 
; 16468: 		if ( lpMsg->bDuelOK )
; 16469: 		{
; 16470: 			if ( BC_MAP_RANGE(gObj[iDuelIndex].MapNumber) ||
; 16471: 				 CC_MAP_RANGE(gObj[iDuelIndex].MapNumber) ||
; 16472: 				 DS_MAP_RANGE(gObj[iDuelIndex].MapNumber) )
; 16473: 			{
; 16474: 				GCServerMsgStringSend(lMsg.Get(MSGGET(4, 207)), aIndex, 1);
; 16475: 				gObj[aIndex].m_iDuelUserRequested = -1;
; 16476: 				gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16477: 				memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 16478: 				pMsgSend.bDuelStart = false;
; 16479: 
; 16480: 				DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16481: 				return;
; 16482: 			}
; 16483: 		}
; 16484: 
; 16485: 		if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUser ) )
; 16486: 		{
; 16487: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 160)), aIndex, 1);
; 16488: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), aIndex, 1);
; 16489: 			gObj[aIndex].m_iDuelUserRequested = -1;
; 16490: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16491: 			memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 16492: 			pMsgSend.bDuelStart = false;
; 16493: 
; 16494: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16495: 			return;
; 16496: 		}
; 16497: 
; 16498: 		if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUserReserved) )
; 16499: 		{
; 16500: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 173)), aIndex, 1);
; 16501: 			gObj[aIndex].m_iDuelUserRequested = -1;
; 16502: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16503: 			memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 16504: 			pMsgSend.bDuelStart = false;
; 16505: 
; 16506: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16507: 			return;
; 16508: 		}
; 16509: 
; 16510: 		if ( gObj[iDuelIndex].m_iDuelUserReserved == aIndex )
; 16511: 		{
; 16512: 			char szDuelName[MAX_ACCOUNT_LEN+1]={0};
; 16513: 			char szDuelName2[MAX_ACCOUNT_LEN+1]={0};
; 16514: 			memcpy(szDuelName, gObj[iDuelIndex].Name, MAX_ACCOUNT_LEN);
; 16515: 			szDuelName[MAX_ACCOUNT_LEN] = 0;
; 16516: 			memcpy(szDuelName2, lpMsg->szName, MAX_ACCOUNT_LEN);
; 16517: 			szDuelName2[MAX_ACCOUNT_LEN] = 0;
; 16518: 
; 16519: 			if ( !strcmp(szDuelName, szDuelName2))
; 16520: 			{
; 16521: 				if ( lpMsg->bDuelOK == false)
; 16522: 				{
; 16523: 					gObj[aIndex].m_iDuelUserRequested = -1;
; 16524: 					gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16525: 					memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 16526: 					pMsgSend.bDuelStart = false;
; 16527: 
; 16528: 					DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16529: 				}
; 16530: 				else if ( lpMsg->bDuelOK == true )
; 16531: 				{
; 16532: 					gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16533: 					gObj[iDuelIndex].m_btDuelScore = 0;
; 16534: 					gObj[iDuelIndex].m_iDuelUser = aIndex;
; 16535: 					gObj[iDuelIndex].m_iDuelTickCount = GetTickCount();
; 16536: 					gObj[aIndex].m_iDuelUserRequested = -1;
; 16537: 					gObj[aIndex].m_iDuelUserReserved = -1;
; 16538: 					gObj[aIndex].m_btDuelScore = 0;
; 16539: 					gObj[aIndex].m_iDuelUser = iDuelIndex;
; 16540: 					gObj[aIndex].m_iDuelTickCount = GetTickCount();
; 16541: 
; 16542: 					pMsgSend.bDuelStart = true;
; 16543: 					pMsgSend.NumberH = SET_NUMBERH(iDuelIndex);
; 16544: 					pMsgSend.NumberL = SET_NUMBERL(iDuelIndex);
; 16545: 					memcpy(pMsgSend.szName, szDuelName, sizeof(pMsgSend.szName));
; 16546: 
; 16547: 					DataSend(aIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16548: 
; 16549: 					pMsgSend.NumberH = SET_NUMBERH(aIndex);
; 16550: 					pMsgSend.NumberL = SET_NUMBERL(aIndex);
; 16551: 					memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 16552: 
; 16553: 					DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16554: 
; 16555: 					GCSendDuelScore(gObj[aIndex].m_Index, gObj[iDuelIndex].m_Index);
; 16556: 
; 16557: 					LogAddTD("[Duel] [%s][%s] Duel Started [%s][%s]", gObj[aIndex].AccountID, gObj[aIndex].Name,gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 16558: 				}
; 16559: 			}
; 16560: 			else
; 16561: 			{
; 16562: 				gObj[aIndex].m_iDuelUserRequested = -1;
; 16563: 				gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16564: 				pMsgSend.bDuelStart = false;
; 16565: 
; 16566: 				DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16567: 				return;
; 16568: 			}
; 16569: 		}
; 16570: 		else
; 16571: 		{
; 16572: 			gObj[aIndex].m_iDuelUserRequested = -1;
; 16573: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16574: 			pMsgSend.bDuelStart = false;
; 16575: 
; 16576: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16577: 			return;
; 16578: 		}
; 16579: 	}*/
; 16580: }

  00000	c3		 ret	 0
?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z ENDP	; CGDuelOkRequestRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z	; GCSendGetItemInfoForParty
EXTRN	?GetPartyCount@PartyClass@@QAEHH@Z:PROC		; PartyClass::GetPartyCount
EXTRN	?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z:PROC ; CItemSystemFor380::Is380OptionItem
; Function compile flags: /Ogtp
;	COMDAT ?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z
_TEXT	SEGMENT
_pMsg$223628 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpItem$ = 12						; size = 4
?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z PROC	; GCSendGetItemInfoForParty, COMDAT

; 16633: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _lpItem$[ebp]
  00017	57		 push	 edi

; 16634: 	LPOBJ lpObj = &gObj[aIndex];

  00018	8b f8		 mov	 edi, eax
  0001a	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00020	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16635: 
; 16636: 	if ( lpObj->PartyNumber >= 0)

  00026	83 bf 0c 06 00
	00 00		 cmp	 DWORD PTR [edi+1548], 0
  0002d	0f 8c df 00 00
	00		 jl	 $LN2@GCSendGetI

; 16637: 	{
; 16638: 		PMSG_GETITEMINFO_FOR_PARTY pMsg;
; 16639: 
; 16640: 		pMsg.h.c = 0xC1;
; 16641: 		pMsg.h.headcode = 0x47;
; 16642: 		pMsg.h.size = sizeof(pMsg);
; 16643: 		pMsg.NumberH = SET_NUMBERH(aIndex);

  00033	8b c8		 mov	 ecx, eax

; 16644: 		pMsg.NumberL = SET_NUMBERL(aIndex);

  00035	88 45 f0	 mov	 BYTE PTR _pMsg$223628[ebp+4], al

; 16645: 		pMsg.ItemInfo = lpItem->m_Type & (ITEMGET(MAX_TYPE_ITEMS-1, MAX_SUBTYPE_ITEMS-1));

  00038	0f bf 46 0a	 movsx	 eax, WORD PTR [esi+10]
  0003c	c1 e9 08	 shr	 ecx, 8
  0003f	25 ff 1f 00 00	 and	 eax, 8191		; 00001fffH

; 16646: 
; 16647: 		if ( lpItem->m_Option1 )

  00044	80 be 94 00 00
	00 00		 cmp	 BYTE PTR [esi+148], 0
  0004b	c6 45 ec c1	 mov	 BYTE PTR _pMsg$223628[ebp], 193 ; 000000c1H
  0004f	66 c7 45 ed 10
	47		 mov	 WORD PTR _pMsg$223628[ebp+1], 18192 ; 00004710H
  00055	88 4d ef	 mov	 BYTE PTR _pMsg$223628[ebp+3], cl
  00058	89 45 f4	 mov	 DWORD PTR _pMsg$223628[ebp+8], eax
  0005b	74 08		 je	 SHORT $LN11@GCSendGetI

; 16648: 			pMsg.ItemInfo |= 0x2000;

  0005d	0d 00 20 00 00	 or	 eax, 8192		; 00002000H
  00062	89 45 f4	 mov	 DWORD PTR _pMsg$223628[ebp+8], eax
$LN11@GCSendGetI:

; 16649: 
; 16650: 		if ( lpItem->m_Option2 )

  00065	80 be 95 00 00
	00 00		 cmp	 BYTE PTR [esi+149], 0
  0006c	74 08		 je	 SHORT $LN10@GCSendGetI

; 16651: 			pMsg.ItemInfo |= 0x4000;

  0006e	0d 00 40 00 00	 or	 eax, 16384		; 00004000H
  00073	89 45 f4	 mov	 DWORD PTR _pMsg$223628[ebp+8], eax
$LN10@GCSendGetI:

; 16652: 
; 16653: 		if ( lpItem->m_Option3 )

  00076	80 be 96 00 00
	00 00		 cmp	 BYTE PTR [esi+150], 0
  0007d	74 08		 je	 SHORT $LN9@GCSendGetI

; 16654: 			pMsg.ItemInfo |= 0x8000;

  0007f	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00084	89 45 f4	 mov	 DWORD PTR _pMsg$223628[ebp+8], eax
$LN9@GCSendGetI:

; 16655: 
; 16656: 		if ( lpItem->m_NewOption )

  00087	80 be 97 00 00
	00 00		 cmp	 BYTE PTR [esi+151], 0
  0008e	74 08		 je	 SHORT $LN8@GCSendGetI

; 16657: 			pMsg.ItemInfo |= 0x10000;

  00090	0d 00 00 01 00	 or	 eax, 65536		; 00010000H
  00095	89 45 f4	 mov	 DWORD PTR _pMsg$223628[ebp+8], eax
$LN8@GCSendGetI:

; 16658: 
; 16659: 		if ( lpItem->m_SetOption )

  00098	80 be ae 00 00
	00 00		 cmp	 BYTE PTR [esi+174], 0
  0009f	74 08		 je	 SHORT $LN7@GCSendGetI

; 16660: 			pMsg.ItemInfo |= 0x20000;

  000a1	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  000a6	89 45 f4	 mov	 DWORD PTR _pMsg$223628[ebp+8], eax
$LN7@GCSendGetI:

; 16661: 
; 16662: 		if ( g_kItemSystemFor380.Is380OptionItem( (lpItem != NULL)?((CItem *)&lpItem->m_Number):NULL) == TRUE )

  000a9	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  000ac	52		 push	 edx
  000ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kItemSystemFor380@@3VCItemSystemFor380@@A ; g_kItemSystemFor380
  000b2	e8 00 00 00 00	 call	 ?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380OptionItem
  000b7	83 f8 01	 cmp	 eax, 1
  000ba	75 07		 jne	 SHORT $LN6@GCSendGetI

; 16663: 			pMsg.ItemInfo |= 0x40000;

  000bc	81 4d f4 00 00
	04 00		 or	 DWORD PTR _pMsg$223628[ebp+8], 262144 ; 00040000H
$LN6@GCSendGetI:

; 16664: 
; 16665: 		pMsg.Level = lpItem->m_Level;
; 16666: 		
; 16667: 		int partycount = gParty.GetPartyCount(lpObj->PartyNumber);

  000c3	8b 8f 0c 06 00
	00		 mov	 ecx, DWORD PTR [edi+1548]
  000c9	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  000cc	51		 push	 ecx
  000cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000d2	88 45 f8	 mov	 BYTE PTR _pMsg$223628[ebp+12], al
  000d5	e8 00 00 00 00	 call	 ?GetPartyCount@PartyClass@@QAEHH@Z ; PartyClass::GetPartyCount

; 16668: 
; 16669: 		if ( partycount >= 0 )

  000da	85 c0		 test	 eax, eax
  000dc	78 34		 js	 SHORT $LN2@GCSendGetI

; 16670: 		{
; 16671: 			for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  000de	33 f6		 xor	 esi, esi
$LL4@GCSendGetI:

; 16672: 			{
; 16673: 				int number = gParty.m_PartyS[lpObj->PartyNumber].Number[n];

  000e0	8b 87 0c 06 00
	00		 mov	 eax, DWORD PTR [edi+1548]
  000e6	8b d0		 mov	 edx, eax
  000e8	c1 e2 04	 shl	 edx, 4
  000eb	2b d0		 sub	 edx, eax
  000ed	03 d6		 add	 edx, esi
  000ef	8b 04 95 0c 00
	00 00		 mov	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[edx*4+12]

; 16674: 
; 16675: 				if ( number >= 0 )

  000f6	85 c0		 test	 eax, eax
  000f8	78 12		 js	 SHORT $LN3@GCSendGetI

; 16676: 				{
; 16677: 					DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  000fa	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$223628[ebp+1]
  000fe	51		 push	 ecx
  000ff	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$223628[ebp]
  00102	52		 push	 edx
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCSendGetI:

; 16670: 		{
; 16671: 			for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  0010c	46		 inc	 esi
  0010d	83 fe 05	 cmp	 esi, 5
  00110	7c ce		 jl	 SHORT $LL4@GCSendGetI
$LN2@GCSendGetI:

; 16678: 				}
; 16679: 			}
; 16680: 		}
; 16681: 	}
; 16682: }

  00112	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	5f		 pop	 edi
  00116	33 cd		 xor	 ecx, ebp
  00118	5e		 pop	 esi
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z ENDP	; GCSendGetItemInfoForParty
_TEXT	ENDS
PUBLIC	?GCSendEffectInfo@@YAXHE@Z			; GCSendEffectInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCSendEffectInfo@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_btType$ = 12						; size = 1
?GCSendEffectInfo@@YAXHE@Z PROC				; GCSendEffectInfo, COMDAT

; 16696: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16697: 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 5f		 js	 SHORT $LN3@GCSendEffe@2
  0000d	33 c9		 xor	 ecx, ecx
  0000f	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	74 51		 je	 SHORT $LN3@GCSendEffe@2

; 16698: 	{
; 16699: 		return;
; 16700: 	}
; 16701: 
; 16702: 	LPOBJ lpObj = &gObj[aIndex];

  0001b	56		 push	 esi
  0001c	8b f0		 mov	 esi, eax
  0001e	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00024	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16703: 	PMSG_EFFECTINFO pMsg;
; 16704: 
; 16705: 	pMsg.h.c = 0xC1;
; 16706: 	pMsg.h.headcode = 0x48;
; 16707: 	pMsg.h.size = sizeof(pMsg);
; 16708: 	pMsg.NumberH = SET_NUMBERH(aIndex);

  0002a	8b c8		 mov	 ecx, eax
  0002c	c1 e9 08	 shr	 ecx, 8
  0002f	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 16709: 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 16710: 	pMsg.btType = btType;

  00032	8a 4d 0c	 mov	 cl, BYTE PTR _btType$[ebp]
  00035	c6 45 f8 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  00039	66 c7 45 f9 06
	48		 mov	 WORD PTR _pMsg$[ebp+1], 18438 ; 00004806H
  0003f	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00042	88 4d fd	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 16711: 
; 16712: 	if ( btType == 17 )

  00045	80 f9 11	 cmp	 cl, 17			; 00000011H
  00048	75 0f		 jne	 SHORT $LN1@GCSendEffe@2

; 16713: 	{
; 16714: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0004a	6a 06		 push	 6
  0004c	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0004f	52		 push	 edx
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCSendEffe@2:

; 16715: 	}
; 16716: 
; 16717: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00059	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0005d	50		 push	 eax
  0005e	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00061	51		 push	 ecx
  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	5e		 pop	 esi
$LN3@GCSendEffe@2:

; 16718: }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?GCSendEffectInfo@@YAXHE@Z ENDP				; GCSendEffectInfo
_TEXT	ENDS
PUBLIC	?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ; CGRequestPetItemCommand
EXTRN	?ChangeCommand@CDarkSpirit@@QAEXHH@Z:PROC	; CDarkSpirit::ChangeCommand
EXTRN	?gDarkSpirit@@3PAVCDarkSpirit@@A:BYTE		; gDarkSpirit
; Function compile flags: /Ogtp
;	COMDAT ?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z PROC ; CGRequestPetItemCommand, COMDAT

; 16724: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 16725: 	if ( !gObjIsConnectedGP(aIndex))

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 44		 je	 SHORT $LN4@CGRequestP

; 16726: 	{
; 16727: 		//LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);
; 16728: 		return;
; 16729: 	}
; 16730: 
; 16731: 	if ( !OBJMAX_RANGE(aIndex))

  00014	85 f6		 test	 esi, esi
  00016	78 40		 js	 SHORT $LN4@CGRequestP
  00018	33 c0		 xor	 eax, eax
  0001a	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00020	0f 9e c0	 setle	 al
  00023	85 c0		 test	 eax, eax
  00025	74 31		 je	 SHORT $LN4@CGRequestP

; 16732: 		return;
; 16733: 
; 16734: 	LPOBJ lpObj = &gObj[aIndex];
; 16735: 
; 16736: 	if ( lpMsg->PetType )

  00027	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002a	80 78 03 00	 cmp	 BYTE PTR [eax+3], 0
  0002e	75 28		 jne	 SHORT $LN4@CGRequestP

; 16737: 		return;
; 16738: 
; 16739: 	int iTargetIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);
; 16740: 	gDarkSpirit[aIndex].ChangeCommand(lpMsg->Command, iTargetIndex);

  00030	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00034	66 c1 e1 08	 shl	 cx, 8
  00038	0f b7 d1	 movzx	 edx, cx
  0003b	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  0003f	0b d1		 or	 edx, ecx
  00041	52		 push	 edx
  00042	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00046	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00049	c1 e1 04	 shl	 ecx, 4
  0004c	52		 push	 edx
  0004d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  00053	e8 00 00 00 00	 call	 ?ChangeCommand@CDarkSpirit@@QAEXHH@Z ; CDarkSpirit::ChangeCommand
$LN4@CGRequestP:
  00058	5e		 pop	 esi

; 16741: }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ENDP ; CGRequestPetItemCommand
_TEXT	ENDS
PUBLIC	??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ; CGRequestPetItemInfo
;	COMDAT ??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\include\prodef.h
CONST	SEGMENT
??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Chaos nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid TargetTrade nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Trade nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid WareHouse nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@ DB 'error-L2 :'
	DB	' Index %s %d', 00H				; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z
_TEXT	SEGMENT
tv760 = -32						; size = 4
tv758 = -32						; size = 4
tv747 = -32						; size = 4
tv744 = -32						; size = 4
tv723 = -32						; size = 4
tv721 = -32						; size = 4
tv806 = -28						; size = 4
tv804 = -28						; size = 4
tv793 = -28						; size = 4
tv791 = -28						; size = 4
tv778 = -28						; size = 4
tv776 = -28						; size = 4
_aIndex$GSCopy$ = -28					; size = 4
tv810 = -22						; size = 2
tv796 = -22						; size = 2
tv781 = -22						; size = 2
tv764 = -22						; size = 2
tv750 = -22						; size = 2
tv726 = -22						; size = 2
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z PROC ; CGRequestPetItemInfo, COMDAT

; 16747: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 16748: 	if ( !gObjIsConnectedGP(aIndex))

  00018	57		 push	 edi

; 16899: 				{
; 16900: 					pMsg.Exp = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Exp;

  00019	89 7d e4	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], edi
  0001c	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	75 28		 jne	 SHORT $LN37@CGRequestP@2

; 16749: 	{
; 16750: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00028	68 6e 41 00 00	 push	 16750			; 0000416eH
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	5f		 pop	 edi
  00041	5b		 pop	 ebx

; 16905: 				}
; 16906: 			}
; 16907: 		}
; 16908: 	}	
; 16909: }

  00042	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00045	33 cd		 xor	 ecx, ebp
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN37@CGRequestP@2:

; 16751: 		return;
; 16752: 	}
; 16753: 
; 16754: 	if ( !OBJMAX_RANGE(aIndex))

  00050	85 ff		 test	 edi, edi
  00052	0f 88 94 05 00
	00		 js	 $LN1@CGRequestP@2
  00058	33 c0		 xor	 eax, eax
  0005a	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00060	0f 9e c0	 setle	 al
  00063	85 c0		 test	 eax, eax
  00065	0f 84 81 05 00
	00		 je	 $LN1@CGRequestP@2

; 16755: 		return;
; 16756: 
; 16757: 	LPOBJ lpObj = &gObj[aIndex];

  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00071	8b c7		 mov	 eax, edi
  00073	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00079	56		 push	 esi
  0007a	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 16758: 
; 16759: 	if ( lpMsg->PetType != 0 && lpMsg->PetType != 1 )

  0007d	8a 43 03	 mov	 al, BYTE PTR [ebx+3]
  00080	84 c0		 test	 al, al
  00082	74 08		 je	 SHORT $LN35@CGRequestP@2
  00084	3c 01		 cmp	 al, 1
  00086	0f 85 5f 05 00
	00		 jne	 $LN60@CGRequestP@2
$LN35@CGRequestP@2:

; 16760: 		return;
; 16761: 	
; 16762: 	PMSG_SEND_PET_ITEMINFO pMsg;
; 16763: 
; 16764: 	pMsg.h.set((LPBYTE)&pMsg, 0xA9, sizeof(pMsg));
; 16765: 	pMsg.PetType = lpMsg->PetType;
; 16766: 	pMsg.InvenType = lpMsg->InvenType;

  0008c	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  00090	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 16767: 	pMsg.nPos = lpMsg->nPos;

  00093	8a 43 05	 mov	 al, BYTE PTR [ebx+5]
  00096	66 c7 45 ec c1
	10		 mov	 WORD PTR _pMsg$[ebp], 4289 ; 000010c1H
  0009c	c6 45 ee a9	 mov	 BYTE PTR _pMsg$[ebp+2], 169 ; 000000a9H
  000a0	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  000a3	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 16768: 
; 16769: 	if ( lpMsg->InvenType == 0 )	// Inventory

  000a6	84 c9		 test	 cl, cl
  000a8	0f 85 87 00 00
	00		 jne	 $LN34@CGRequestP@2

; 16770: 	{
; 16771: 		if ( !INVENTORY_RANGE(lpMsg->nPos))

  000ae	b2 ec		 mov	 dl, 236			; 000000ecH
  000b0	3a d0		 cmp	 dl, al
  000b2	1b c9		 sbb	 ecx, ecx
  000b4	41		 inc	 ecx

; 16772: 		{
; 16773: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d",
; 16774: 				lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 16775: 
; 16776: 			return;

  000b5	0f 84 21 04 00
	00		 je	 $LN64@CGRequestP@2

; 16777: 		}
; 16778: 
; 16779: 		if ( lpObj->pInventory[lpMsg->nPos].IsItem() )

  000bb	0f b6 c8	 movzx	 ecx, al
  000be	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  000c4	03 8e c0 11 00
	00		 add	 ecx, DWORD PTR [esi+4544]
  000ca	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000cf	85 c0		 test	 eax, eax
  000d1	0f 84 14 05 00
	00		 je	 $LN60@CGRequestP@2

; 16780: 		{
; 16781: 			pMsg.Exp = lpObj->pInventory[lpMsg->nPos].m_PetItem_Exp;

  000d7	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]

; 16782: 			pMsg.Level = lpObj->pInventory[lpMsg->nPos].m_PetItem_Level;
; 16783: 			pMsg.Life = (BYTE)(lpObj->pInventory[lpMsg->nPos].m_Durability);

  000db	d9 7d ea	 fnstcw	 WORD PTR tv810[ebp]
  000de	8b 96 c0 11 00
	00		 mov	 edx, DWORD PTR [esi+4544]
  000e4	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  000ea	8b 8c 10 bc 00
	00 00		 mov	 ecx, DWORD PTR [eax+edx+188]
  000f1	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  000f4	8b 96 c0 11 00
	00		 mov	 edx, DWORD PTR [esi+4544]
  000fa	8a 8c 10 b8 00
	00 00		 mov	 cl, BYTE PTR [eax+edx+184]
  00101	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  00104	8b 96 c0 11 00
	00		 mov	 edx, DWORD PTR [esi+4544]

; 16784: 
; 16785: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0010a	6a 10		 push	 16			; 00000010H
  0010c	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0010f	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  00113	0f b7 45 ea	 movzx	 eax, WORD PTR tv810[ebp]
  00117	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0011c	89 45 e4	 mov	 DWORD PTR tv806[ebp], eax
  0011f	51		 push	 ecx
  00120	57		 push	 edi
  00121	d9 6d e4	 fldcw	 WORD PTR tv806[ebp]
  00124	db 5d e4	 fistp	 DWORD PTR tv804[ebp]
  00127	8a 45 e4	 mov	 al, BYTE PTR tv804[ebp]
  0012a	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  0012d	d9 6d ea	 fldcw	 WORD PTR tv810[ebp]

; 16786: 		}
; 16787: 	}

  00130	e9 ae 04 00 00	 jmp	 $LN61@CGRequestP@2
$LN34@CGRequestP@2:

; 16788: 	else if ( lpMsg->InvenType == 1 )	// Warehouse

  00135	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  00139	80 f9 01	 cmp	 cl, 1
  0013c	0f 85 bb 00 00
	00		 jne	 $LN30@CGRequestP@2

; 16789: 	{
; 16790: 		if ( lpObj->LoadWareHouseInfo != false )

  00142	80 be ec 13 00
	00 00		 cmp	 BYTE PTR [esi+5100], 0
  00149	0f 84 9c 04 00
	00		 je	 $LN60@CGRequestP@2

; 16791: 		{
; 16792: 			if ( !WAREHOUSE_RANGE(lpMsg->nPos))

  0014f	b2 ef		 mov	 dl, 239			; 000000efH
  00151	3a d0		 cmp	 dl, al
  00153	1b c9		 sbb	 ecx, ecx
  00155	41		 inc	 ecx
  00156	75 2b		 jne	 SHORT $LN28@CGRequestP@2

; 16793: 			{
; 16794: 				LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid WareHouse nPos %d",
; 16795: 					lpObj->AccountID, lpObj->Name, lpMsg->nPos);

  00158	0f b6 c0	 movzx	 eax, al
  0015b	50		 push	 eax
  0015c	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  0015f	51		 push	 ecx
  00160	83 c6 52	 add	 esi, 82			; 00000052H
  00163	56		 push	 esi
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0016f	83 c4 10	 add	 esp, 16			; 00000010H
  00172	5e		 pop	 esi
  00173	5f		 pop	 edi
  00174	5b		 pop	 ebx

; 16905: 				}
; 16906: 			}
; 16907: 		}
; 16908: 	}	
; 16909: }

  00175	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00178	33 cd		 xor	 ecx, ebp
  0017a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
$LN28@CGRequestP@2:

; 16796: 
; 16797: 				return;
; 16798: 			}
; 16799: 
; 16800: 			if ( lpObj->pWarehouse[lpMsg->nPos].IsItem() )

  00183	0f b6 c8	 movzx	 ecx, al
  00186	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0018c	03 8e f8 11 00
	00		 add	 ecx, DWORD PTR [esi+4600]
  00192	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00197	85 c0		 test	 eax, eax
  00199	0f 84 4c 04 00
	00		 je	 $LN60@CGRequestP@2

; 16801: 			{
; 16802: 				pMsg.Exp = lpObj->pWarehouse[lpMsg->nPos].m_PetItem_Exp;

  0019f	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]

; 16803: 				pMsg.Level = lpObj->pWarehouse[lpMsg->nPos].m_PetItem_Level;
; 16804: 				pMsg.Life = (BYTE)lpObj->pWarehouse[lpMsg->nPos].m_Durability;

  001a3	d9 7d ea	 fnstcw	 WORD PTR tv796[ebp]
  001a6	8b 96 f8 11 00
	00		 mov	 edx, DWORD PTR [esi+4600]
  001ac	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  001b2	8b 8c 10 bc 00
	00 00		 mov	 ecx, DWORD PTR [eax+edx+188]
  001b9	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  001bc	8b 96 f8 11 00
	00		 mov	 edx, DWORD PTR [esi+4600]
  001c2	8a 8c 10 b8 00
	00 00		 mov	 cl, BYTE PTR [eax+edx+184]
  001c9	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  001cc	8b 96 f8 11 00
	00		 mov	 edx, DWORD PTR [esi+4600]

; 16805: 
; 16806: 				DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  001d2	6a 10		 push	 16			; 00000010H
  001d4	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  001d7	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  001db	0f b7 45 ea	 movzx	 eax, WORD PTR tv796[ebp]
  001df	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001e4	89 45 e4	 mov	 DWORD PTR tv793[ebp], eax
  001e7	51		 push	 ecx
  001e8	57		 push	 edi
  001e9	d9 6d e4	 fldcw	 WORD PTR tv793[ebp]
  001ec	db 5d e4	 fistp	 DWORD PTR tv791[ebp]
  001ef	8a 45 e4	 mov	 al, BYTE PTR tv791[ebp]
  001f2	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  001f5	d9 6d ea	 fldcw	 WORD PTR tv796[ebp]

; 16807: 			}
; 16808: 		}
; 16809: 	}

  001f8	e9 e6 03 00 00	 jmp	 $LN61@CGRequestP@2
$LN30@CGRequestP@2:

; 16810: 	else if ( lpMsg->InvenType == 2 )	// Trade

  001fd	80 f9 02	 cmp	 cl, 2
  00200	0f 85 d3 00 00
	00		 jne	 $LN25@CGRequestP@2

; 16811: 	{
; 16812: 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 1 )

  00206	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  0020c	8b d1		 mov	 edx, ecx
  0020e	80 e2 03	 and	 dl, 3
  00211	80 fa 01	 cmp	 dl, 1
  00214	0f 82 d1 03 00
	00		 jb	 $LN60@CGRequestP@2
  0021a	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00220	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00223	0f 85 c2 03 00
	00		 jne	 $LN60@CGRequestP@2

; 16813: 			return;
; 16814: 
; 16815: 		if ( !TRADE_BOX_RANGE(lpMsg->nPos))

  00229	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0022e	3a c8		 cmp	 cl, al
  00230	1b c9		 sbb	 ecx, ecx
  00232	41		 inc	 ecx
  00233	75 2b		 jne	 SHORT $LN22@CGRequestP@2

; 16816: 		{
; 16817: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Trade nPos %d",
; 16818: 				lpObj->AccountID, lpObj->Name, lpMsg->nPos);

  00235	0f b6 d0	 movzx	 edx, al
  00238	52		 push	 edx
  00239	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0023c	50		 push	 eax
  0023d	83 c6 52	 add	 esi, 82			; 00000052H
  00240	56		 push	 esi
  00241	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  00246	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0024c	83 c4 10	 add	 esp, 16			; 00000010H
  0024f	5e		 pop	 esi
  00250	5f		 pop	 edi
  00251	5b		 pop	 ebx

; 16905: 				}
; 16906: 			}
; 16907: 		}
; 16908: 	}	
; 16909: }

  00252	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00255	33 cd		 xor	 ecx, ebp
  00257	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025c	8b e5		 mov	 esp, ebp
  0025e	5d		 pop	 ebp
  0025f	c3		 ret	 0
$LN22@CGRequestP@2:

; 16819: 
; 16820: 			return;
; 16821: 		}
; 16822: 
; 16823: 		if ( lpObj->Trade[lpMsg->nPos].IsItem() )

  00260	0f b6 c8	 movzx	 ecx, al
  00263	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00269	03 8e e8 11 00
	00		 add	 ecx, DWORD PTR [esi+4584]
  0026f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00274	85 c0		 test	 eax, eax
  00276	0f 84 6f 03 00
	00		 je	 $LN60@CGRequestP@2

; 16824: 		{
; 16825: 			pMsg.Exp = lpObj->Trade[lpMsg->nPos].m_PetItem_Exp;

  0027c	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]

; 16826: 			pMsg.Level = lpObj->Trade[lpMsg->nPos].m_PetItem_Level;
; 16827: 			pMsg.Life = (BYTE)lpObj->Trade[lpMsg->nPos].m_Durability;

  00280	d9 7d ea	 fnstcw	 WORD PTR tv781[ebp]
  00283	8b 8e e8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4584]
  00289	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0028f	8b 94 08 bc 00
	00 00		 mov	 edx, DWORD PTR [eax+ecx+188]
  00296	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00299	8b 8e e8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4584]
  0029f	0f b6 94 08 b8
	00 00 00	 movzx	 edx, BYTE PTR [eax+ecx+184]
  002a7	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  002aa	8b 8e e8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4584]

; 16828: 
; 16829: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  002b0	6a 10		 push	 16			; 00000010H
  002b2	d9 44 08 24	 fld	 DWORD PTR [eax+ecx+36]
  002b6	0f b7 45 ea	 movzx	 eax, WORD PTR tv781[ebp]
  002ba	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002bf	89 45 e4	 mov	 DWORD PTR tv778[ebp], eax
  002c2	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002c5	50		 push	 eax
  002c6	d9 6d e4	 fldcw	 WORD PTR tv778[ebp]
  002c9	57		 push	 edi
  002ca	db 5d e4	 fistp	 DWORD PTR tv776[ebp]
  002cd	0f b6 55 e4	 movzx	 edx, BYTE PTR tv776[ebp]
  002d1	d9 6d ea	 fldcw	 WORD PTR tv781[ebp]

; 16830: 		}
; 16831: 	}

  002d4	e9 07 03 00 00	 jmp	 $LN62@CGRequestP@2
$LN25@CGRequestP@2:

; 16832: 	else if ( lpMsg->InvenType == 3 )	// Target Trade

  002d9	80 f9 03	 cmp	 cl, 3
  002dc	0f 85 31 01 00
	00		 jne	 $LN19@CGRequestP@2

; 16833: 	{
; 16834: 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 1 )

  002e2	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  002e8	8b d1		 mov	 edx, ecx
  002ea	80 e2 03	 and	 dl, 3
  002ed	80 fa 01	 cmp	 dl, 1
  002f0	0f 82 f5 02 00
	00		 jb	 $LN60@CGRequestP@2
  002f6	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  002fc	83 f9 40	 cmp	 ecx, 64			; 00000040H
  002ff	0f 85 e6 02 00
	00		 jne	 $LN60@CGRequestP@2

; 16835: 			return;
; 16836: 
; 16837: 		int iTargetIndex = gObj[aIndex].TargetNumber;

  00305	0f bf be 38 06
	00 00		 movsx	 edi, WORD PTR [esi+1592]

; 16838: 
; 16839: 		if ( iTargetIndex < 0 )

  0030c	85 ff		 test	 edi, edi
  0030e	0f 88 d7 02 00
	00		 js	 $LN60@CGRequestP@2

; 16840: 			return;
; 16841: 
; 16842: 		if ( !OBJMAX_RANGE(iTargetIndex) )

  00314	33 c9		 xor	 ecx, ecx
  00316	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0031c	0f 9e c1	 setle	 cl
  0031f	85 c9		 test	 ecx, ecx
  00321	0f 84 c4 02 00
	00		 je	 $LN60@CGRequestP@2

; 16843: 			return;
; 16844: 
; 16845: 		if ( gObj[iTargetIndex].m_IfState.use < 1 || gObj[iTargetIndex].m_IfState.type != 1 )

  00327	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0032d	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00333	8b 8c 0f b8 11
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+4536]
  0033a	8b d1		 mov	 edx, ecx
  0033c	80 e2 03	 and	 dl, 3
  0033f	80 fa 01	 cmp	 dl, 1
  00342	0f 82 a3 02 00
	00		 jb	 $LN60@CGRequestP@2
  00348	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0034e	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00351	0f 85 94 02 00
	00		 jne	 $LN60@CGRequestP@2

; 16846: 			return;
; 16847: 
; 16848: 		if ( !TRADE_BOX_RANGE(lpMsg->nPos))

  00357	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0035c	3a c8		 cmp	 cl, al
  0035e	1b c9		 sbb	 ecx, ecx
  00360	41		 inc	 ecx
  00361	75 2b		 jne	 SHORT $LN12@CGRequestP@2

; 16849: 		{
; 16850: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid TargetTrade nPos %d",
; 16851: 				lpObj->AccountID, lpObj->Name, lpMsg->nPos);

  00363	0f b6 d0	 movzx	 edx, al
  00366	52		 push	 edx
  00367	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0036a	50		 push	 eax
  0036b	83 c6 52	 add	 esi, 82			; 00000052H
  0036e	56		 push	 esi
  0036f	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  00374	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0037a	83 c4 10	 add	 esp, 16			; 00000010H
  0037d	5e		 pop	 esi
  0037e	5f		 pop	 edi
  0037f	5b		 pop	 ebx

; 16905: 				}
; 16906: 			}
; 16907: 		}
; 16908: 	}	
; 16909: }

  00380	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00383	33 cd		 xor	 ecx, ebp
  00385	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0038a	8b e5		 mov	 esp, ebp
  0038c	5d		 pop	 ebp
  0038d	c3		 ret	 0
$LN12@CGRequestP@2:

; 16852: 
; 16853: 			return;
; 16854: 		}
; 16855: 
; 16856: 		if ( gObj[iTargetIndex].Trade[lpMsg->nPos].IsItem() )

  0038e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00394	0f b6 c8	 movzx	 ecx, al
  00397	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0039d	03 8c 17 e8 11
	00 00		 add	 ecx, DWORD PTR [edi+edx+4584]
  003a4	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003a9	85 c0		 test	 eax, eax
  003ab	0f 84 3a 02 00
	00		 je	 $LN60@CGRequestP@2

; 16857: 		{
; 16858: 			pMsg.Exp = gObj[iTargetIndex].Trade[lpMsg->nPos].m_PetItem_Exp;

  003b1	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]

; 16859: 			pMsg.Level = gObj[iTargetIndex].Trade[lpMsg->nPos].m_PetItem_Level;
; 16860: 			pMsg.Life = (BYTE)gObj[iTargetIndex].Trade[lpMsg->nPos].m_Durability;

  003b5	d9 7d ea	 fnstcw	 WORD PTR tv764[ebp]
  003b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003be	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  003c4	8b 94 0f e8 11
	00 00		 mov	 edx, DWORD PTR [edi+ecx+4584]
  003cb	8b 94 10 bc 00
	00 00		 mov	 edx, DWORD PTR [eax+edx+188]
  003d2	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  003d5	8b 94 0f e8 11
	00 00		 mov	 edx, DWORD PTR [edi+ecx+4584]
  003dc	0f b6 94 10 b8
	00 00 00	 movzx	 edx, BYTE PTR [eax+edx+184]
  003e4	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  003e7	8b 8c 0f e8 11
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+4584]
  003ee	d9 44 08 24	 fld	 DWORD PTR [eax+ecx+36]
  003f2	0f b7 45 ea	 movzx	 eax, WORD PTR tv764[ebp]

; 16861: 
; 16862: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  003f6	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  003f9	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003fe	89 45 e0	 mov	 DWORD PTR tv760[ebp], eax
  00401	d9 6d e0	 fldcw	 WORD PTR tv760[ebp]
  00404	db 5d e0	 fistp	 DWORD PTR tv758[ebp]
  00407	0f b6 55 e0	 movzx	 edx, BYTE PTR tv758[ebp]
  0040b	d9 6d ea	 fldcw	 WORD PTR tv764[ebp]

; 16863: 		}
; 16864: 	}

  0040e	e9 c6 01 00 00	 jmp	 $LN63@CGRequestP@2
$LN19@CGRequestP@2:

; 16865: 	else if ( lpMsg->InvenType == 4 )	// Chaos

  00413	80 f9 04	 cmp	 cl, 4
  00416	0f 85 ae 00 00
	00		 jne	 $LN9@CGRequestP@2

; 16866: 	{
; 16867: 		if ( !CHAOS_BOX_RANGE(lpMsg->nPos) )

  0041c	b2 1f		 mov	 dl, 31			; 0000001fH
  0041e	3a d0		 cmp	 dl, al
  00420	1b c9		 sbb	 ecx, ecx
  00422	41		 inc	 ecx
  00423	75 2b		 jne	 SHORT $LN8@CGRequestP@2

; 16868: 		{
; 16869: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Chaos nPos %d",
; 16870: 				lpObj->AccountID, lpObj->Name, lpMsg->nPos);

  00425	0f b6 c0	 movzx	 eax, al
  00428	50		 push	 eax
  00429	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  0042c	51		 push	 ecx
  0042d	83 c6 52	 add	 esi, 82			; 00000052H
  00430	56		 push	 esi
  00431	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  00436	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0043c	83 c4 10	 add	 esp, 16			; 00000010H
  0043f	5e		 pop	 esi
  00440	5f		 pop	 edi
  00441	5b		 pop	 ebx

; 16905: 				}
; 16906: 			}
; 16907: 		}
; 16908: 	}	
; 16909: }

  00442	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00445	33 cd		 xor	 ecx, ebp
  00447	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0044c	8b e5		 mov	 esp, ebp
  0044e	5d		 pop	 ebp
  0044f	c3		 ret	 0
$LN8@CGRequestP@2:

; 16871: 
; 16872: 			return;
; 16873: 		}
; 16874: 
; 16875: 		if ( lpObj->pChaosBox[lpMsg->nPos].IsItem() )

  00450	0f b6 c8	 movzx	 ecx, al
  00453	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00459	03 8e 10 12 00
	00		 add	 ecx, DWORD PTR [esi+4624]
  0045f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00464	85 c0		 test	 eax, eax
  00466	0f 84 7f 01 00
	00		 je	 $LN60@CGRequestP@2

; 16876: 		{
; 16877: 			pMsg.Exp = lpObj->pChaosBox[lpMsg->nPos].m_PetItem_Exp;

  0046c	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]

; 16878: 			pMsg.Level = lpObj->pChaosBox[lpMsg->nPos].m_PetItem_Level;
; 16879: 			pMsg.Life = (BYTE)lpObj->pChaosBox[lpMsg->nPos].m_Durability;

  00470	d9 7d ea	 fnstcw	 WORD PTR tv750[ebp]
  00473	8b 96 10 12 00
	00		 mov	 edx, DWORD PTR [esi+4624]
  00479	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0047f	8b 8c 10 bc 00
	00 00		 mov	 ecx, DWORD PTR [eax+edx+188]
  00486	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  00489	8b 96 10 12 00
	00		 mov	 edx, DWORD PTR [esi+4624]
  0048f	8a 8c 10 b8 00
	00 00		 mov	 cl, BYTE PTR [eax+edx+184]
  00496	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  00499	8b 96 10 12 00
	00		 mov	 edx, DWORD PTR [esi+4624]

; 16880: 
; 16881: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0049f	6a 10		 push	 16			; 00000010H
  004a1	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  004a4	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  004a8	0f b7 45 ea	 movzx	 eax, WORD PTR tv750[ebp]
  004ac	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  004b1	89 45 e0	 mov	 DWORD PTR tv747[ebp], eax
  004b4	51		 push	 ecx
  004b5	57		 push	 edi
  004b6	d9 6d e0	 fldcw	 WORD PTR tv747[ebp]
  004b9	db 5d e0	 fistp	 DWORD PTR tv744[ebp]
  004bc	8a 45 e0	 mov	 al, BYTE PTR tv744[ebp]
  004bf	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  004c2	d9 6d ea	 fldcw	 WORD PTR tv750[ebp]

; 16882: 		}
; 16883: 	}

  004c5	e9 19 01 00 00	 jmp	 $LN61@CGRequestP@2
$LN9@CGRequestP@2:

; 16884: 	else if ( lpMsg->InvenType == 5 )	// Personal Shop

  004ca	80 f9 05	 cmp	 cl, 5
  004cd	0f 85 18 01 00
	00		 jne	 $LN60@CGRequestP@2

; 16885: 	{
; 16886: 		if ( !INVENTORY_RANGE(lpMsg->nPos) )

  004d3	b2 ec		 mov	 dl, 236			; 000000ecH
  004d5	3a d0		 cmp	 dl, al
  004d7	1b c9		 sbb	 ecx, ecx
  004d9	41		 inc	 ecx
  004da	75 2b		 jne	 SHORT $LN4@CGRequestP@2
$LN64@CGRequestP@2:

; 16887: 		{
; 16888: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d",
; 16889: 				lpObj->AccountID, lpObj->Name, lpMsg->nPos);

  004dc	0f b6 c0	 movzx	 eax, al
  004df	50		 push	 eax
  004e0	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  004e3	51		 push	 ecx
  004e4	83 c6 52	 add	 esi, 82			; 00000052H
  004e7	56		 push	 esi
  004e8	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  004ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004f3	83 c4 10	 add	 esp, 16			; 00000010H
  004f6	5e		 pop	 esi
  004f7	5f		 pop	 edi
  004f8	5b		 pop	 ebx

; 16905: 				}
; 16906: 			}
; 16907: 		}
; 16908: 	}	
; 16909: }

  004f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004fc	33 cd		 xor	 ecx, ebp
  004fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00503	8b e5		 mov	 esp, ebp
  00505	5d		 pop	 ebp
  00506	c3		 ret	 0
$LN4@CGRequestP@2:

; 16890: 
; 16891: 			return;
; 16892: 		}
; 16893: 
; 16894: 		if ( lpObj->m_iPShopDealerIndex != -1 )

  00507	8b 96 88 12 00
	00		 mov	 edx, DWORD PTR [esi+4744]
  0050d	83 fa ff	 cmp	 edx, -1
  00510	0f 84 d5 00 00
	00		 je	 $LN60@CGRequestP@2

; 16895: 		{
; 16896: 			if ( OBJMAX_RANGE(lpObj->m_iPShopDealerIndex))

  00516	85 d2		 test	 edx, edx
  00518	0f 88 cd 00 00
	00		 js	 $LN60@CGRequestP@2
  0051e	33 c9		 xor	 ecx, ecx
  00520	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00526	0f 9e c1	 setle	 cl
  00529	85 c9		 test	 ecx, ecx
  0052b	0f 84 ba 00 00
	00		 je	 $LN60@CGRequestP@2

; 16897: 			{
; 16898: 				if ( gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].IsItem() )

  00531	0f b6 c8	 movzx	 ecx, al
  00534	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  0053a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0053f	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00545	03 8c 02 c0 11
	00 00		 add	 ecx, DWORD PTR [edx+eax+4544]
  0054c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00551	85 c0		 test	 eax, eax
  00553	0f 84 92 00 00
	00		 je	 $LN60@CGRequestP@2

; 16899: 				{
; 16900: 					pMsg.Exp = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Exp;

  00559	8b 96 88 12 00
	00		 mov	 edx, DWORD PTR [esi+4744]

; 16901: 					pMsg.Level = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Level;
; 16902: 					pMsg.Life = (BYTE)gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_Durability;

  0055f	d9 7d ea	 fnstcw	 WORD PTR tv726[ebp]
  00562	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  00566	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  0056c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00572	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00578	8b 94 0a c0 11
	00 00		 mov	 edx, DWORD PTR [edx+ecx+4544]
  0057f	8b 94 02 bc 00
	00 00		 mov	 edx, DWORD PTR [edx+eax+188]
  00586	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00589	8b 96 88 12 00
	00		 mov	 edx, DWORD PTR [esi+4744]
  0058f	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  00595	8b 94 0a c0 11
	00 00		 mov	 edx, DWORD PTR [edx+ecx+4544]
  0059c	0f b6 94 02 b8
	00 00 00	 movzx	 edx, BYTE PTR [edx+eax+184]
  005a4	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  005a7	8b 96 88 12 00
	00		 mov	 edx, DWORD PTR [esi+4744]
  005ad	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  005b3	8b 8c 0a c0 11
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+4544]
  005ba	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  005be	0f b7 45 ea	 movzx	 eax, WORD PTR tv726[ebp]
  005c2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  005c7	89 45 e0	 mov	 DWORD PTR tv723[ebp], eax

; 16903: 
; 16904: 					DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  005ca	8b cf		 mov	 ecx, edi
  005cc	d9 6d e0	 fldcw	 WORD PTR tv723[ebp]
  005cf	db 5d e0	 fistp	 DWORD PTR tv721[ebp]
  005d2	0f b6 55 e0	 movzx	 edx, BYTE PTR tv721[ebp]
  005d6	d9 6d ea	 fldcw	 WORD PTR tv726[ebp]
$LN63@CGRequestP@2:
  005d9	6a 10		 push	 16			; 00000010H
  005db	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  005de	50		 push	 eax
  005df	51		 push	 ecx
$LN62@CGRequestP@2:

; 16901: 					pMsg.Level = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Level;
; 16902: 					pMsg.Life = (BYTE)gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_Durability;

  005e0	88 55 f8	 mov	 BYTE PTR _pMsg$[ebp+12], dl
$LN61@CGRequestP@2:

; 16903: 
; 16904: 					DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  005e3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005e8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN60@CGRequestP@2:
  005eb	5e		 pop	 esi
$LN1@CGRequestP@2:

; 16905: 				}
; 16906: 			}
; 16907: 		}
; 16908: 	}	
; 16909: }

  005ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005ef	5f		 pop	 edi
  005f0	33 cd		 xor	 ecx, ebp
  005f2	5b		 pop	 ebx
  005f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f8	8b e5		 mov	 esp, ebp
  005fa	5d		 pop	 ebp
  005fb	c3		 ret	 0
?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ENDP ; CGRequestPetItemInfo
_TEXT	ENDS
PUBLIC	??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z ; GCGuildViewportInfo
EXTRN	?SearchUnion@TUnion@@QAEPAVTUnionInfo@@H@Z:PROC	; TUnion::SearchUnion
EXTRN	?UnionManager@@3VTUnion@@A:BYTE			; UnionManager
EXTRN	?SearchGuild_Number@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@H@Z:PROC ; CGuildClass::SearchGuild_Number
;	COMDAT ??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@
CONST	SEGMENT
??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@ DB 0a1H
	DB	0daH, 0a1H, 0daH, 0a1H, 0d9H, ' ', 0b1H, 0e6H, 0b5H, 0e5H, ' ', 0c1H
	DB	0a4H, 0baH, 0b8H, ' ', 0c3H, 0a3H, 0c0H, 0bbH, 0bcH, 0f6H, ' ', 0beH
	DB	0f8H, 0c0H, 0bdH, '. ', 0c0H, 0ccH, 0b8H, 0a7H, ' : [%s] ', 0b9H
	DB	0f8H, 0c8H, 0a3H, ' : %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -68					; size = 4
_pMsg$223774 = -64					; size = 60
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z PROC ; GCGuildViewportInfo, COMDAT

; 16929: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 16930: 	if ( !gObjIsConnectedGP(aIndex))

  00018	56		 push	 esi

; 16964: 	}
; 16965: 	else
; 16966: 	{
; 16967: 		LogAddTD("    .  : [%s]  : %d",
; 16968: 			lpObj->Name, dwGuildNumber);

  00019	89 75 bc	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0001c	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	75 28		 jne	 SHORT $LN6@GCGuildVie@3

; 16931: 	{
; 16932: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00028	68 24 42 00 00	 push	 16932			; 00004224H
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 16969: 	}
; 16970: }

  00042	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00045	33 cd		 xor	 ecx, ebp
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN6@GCGuildVie@3:

; 16933: 		return;
; 16934: 	}
; 16935: 
; 16936: 	if ( !OBJMAX_RANGE(aIndex))

  00050	85 f6		 test	 esi, esi
  00052	0f 88 cd 00 00
	00		 js	 $LN1@GCGuildVie@3
  00058	33 c0		 xor	 eax, eax
  0005a	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00060	0f 9e c0	 setle	 al
  00063	85 c0		 test	 eax, eax
  00065	0f 84 ba 00 00
	00		 je	 $LN1@GCGuildVie@3

; 16937: 		return;
; 16938: 
; 16939: 	LPOBJ lpObj = &gObj[aIndex];

  0006b	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00071	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00077	53		 push	 ebx

; 16940: 	DWORD dwGuildNumber = aRecv->GuildNumber;

  00078	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]

; 16941: 	_GUILD_INFO_STRUCT * lpGuildInfo = Guild.SearchGuild_Number(dwGuildNumber);

  0007b	53		 push	 ebx
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00081	e8 00 00 00 00	 call	 ?SearchGuild_Number@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@H@Z ; CGuildClass::SearchGuild_Number
  00086	8b f8		 mov	 edi, eax

; 16942: 
; 16943: 	if ( lpGuildInfo )

  00088	85 ff		 test	 edi, edi
  0008a	0f 84 81 00 00
	00		 je	 $LN4@GCGuildVie@3

; 16944: 	{
; 16945: 		PMSG_ANS_GUILDVIEWPORT pMsg;
; 16946: 
; 16947: 		pMsg.h.c = 0xC1;
; 16948: 		pMsg.h.headcode = 0x66;
; 16949: 		pMsg.h.size = sizeof(pMsg);
; 16950: 		pMsg.GuildNumber = lpGuildInfo->Number;
; 16951: 		pMsg.btGuildType = lpGuildInfo->btGuildType;

  00090	8a 8f 40 07 00
	00		 mov	 cl, BYTE PTR [edi+1856]

; 16952: 
; 16953: 		TUnionInfo * pUnionInfo = UnionManager.SearchUnion(lpGuildInfo->iGuildUnion);

  00096	8b 97 44 07 00
	00		 mov	 edx, DWORD PTR [edi+1860]
  0009c	8b 07		 mov	 eax, DWORD PTR [edi]
  0009e	88 4d c8	 mov	 BYTE PTR _pMsg$223774[ebp+8], cl
  000a1	52		 push	 edx
  000a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  000a7	c6 45 c0 c1	 mov	 BYTE PTR _pMsg$223774[ebp], 193 ; 000000c1H
  000ab	66 c7 45 c1 3c
	66		 mov	 WORD PTR _pMsg$223774[ebp+1], 26172 ; 0000663cH
  000b1	89 45 c4	 mov	 DWORD PTR _pMsg$223774[ebp+4], eax
  000b4	e8 00 00 00 00	 call	 ?SearchUnion@TUnion@@QAEPAVTUnionInfo@@H@Z ; TUnion::SearchUnion

; 16954: 
; 16955: 		if ( pUnionInfo )

  000b9	85 c0		 test	 eax, eax
  000bb	74 0e		 je	 SHORT $LN3@GCGuildVie@3

; 16956: 			memcpy(pMsg.UnionName, pUnionInfo->m_szMasterGuild, MAX_GUILD_LEN);

  000bd	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000c0	89 4d c9	 mov	 DWORD PTR _pMsg$223774[ebp+9], ecx
  000c3	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000c6	89 55 cd	 mov	 DWORD PTR _pMsg$223774[ebp+13], edx

; 16957: 		else

  000c9	eb 04		 jmp	 SHORT $LN2@GCGuildVie@3
$LN3@GCGuildVie@3:

; 16958: 			pMsg.UnionName[0] = '\0';

  000cb	c6 45 c9 00	 mov	 BYTE PTR _pMsg$223774[ebp+9], 0
$LN2@GCGuildVie@3:

; 16959: 
; 16960: 		strcpy(pMsg.GuildName, lpGuildInfo->Name);

  000cf	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000d2	8d 55 d1	 lea	 edx, DWORD PTR _pMsg$223774[ebp+17]
  000d5	2b d0		 sub	 edx, eax
$LL11@GCGuildVie@3:
  000d7	8a 08		 mov	 cl, BYTE PTR [eax]
  000d9	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000dc	40		 inc	 eax
  000dd	84 c9		 test	 cl, cl
  000df	75 f6		 jne	 SHORT $LL11@GCGuildVie@3

; 16961: 		memcpy(pMsg.Mark, lpGuildInfo->Mark, sizeof(pMsg.Mark));

  000e1	8d 77 0d	 lea	 esi, DWORD PTR [edi+13]
  000e4	b9 08 00 00 00	 mov	 ecx, 8
  000e9	8d 7d d9	 lea	 edi, DWORD PTR _pMsg$223774[ebp+25]

; 16962: 
; 16963: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  000ec	6a 3c		 push	 60			; 0000003cH
  000ee	8d 45 c0	 lea	 eax, DWORD PTR _pMsg$223774[ebp]
  000f1	f3 a5		 rep movsd
  000f3	8b 4d bc	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  000f6	50		 push	 eax
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16964: 	}
; 16965: 	else
; 16966: 	{
; 16967: 		LogAddTD("    .  : [%s]  : %d",
; 16968: 			lpObj->Name, dwGuildNumber);

  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00100	5b		 pop	 ebx
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi

; 16969: 	}
; 16970: }

  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
$LN4@GCGuildVie@3:

; 16964: 	}
; 16965: 	else
; 16966: 	{
; 16967: 		LogAddTD("    .  : [%s]  : %d",
; 16968: 			lpObj->Name, dwGuildNumber);

  00111	53		 push	 ebx
  00112	83 c6 5d	 add	 esi, 93			; 0000005dH
  00115	56		 push	 esi
  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00121	83 c4 0c	 add	 esp, 12			; 0000000cH
  00124	5b		 pop	 ebx
$LN1@GCGuildVie@3:

; 16969: 	}
; 16970: }

  00125	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00128	5f		 pop	 edi
  00129	33 cd		 xor	 ecx, ebp
  0012b	5e		 pop	 esi
  0012c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c3		 ret	 0
?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z ENDP ; GCGuildViewportInfo
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	_aRecv$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z ; CGGuildAssignStatus
EXTRN	?GDGuildReqAssignStatus@@YAXHHPADH@Z:PROC	; GDGuildReqAssignStatus
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z
_TEXT	SEGMENT
tv389 = -52						; size = 4
_szTargetName$ = -48					; size = 11
_aRecv$GSCopy$ = -36					; size = 4
_aIndex$GSCopy$ = -32					; size = 4
_iSubMasterCount$223801 = -28				; size = 4
tv392 = -21						; size = 1
_pMsg$ = -20						; size = 15
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z PROC ; CGGuildAssignStatus, COMDAT

; 16979: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 16980: 	if ( !gObjIsConnectedGP(aIndex))

  00018	53		 push	 ebx

; 17066: 		{
; 17067: 			if ( iBattleMasterCount < ((lpObj->Level / 200 ) +1) )

  00019	89 7d dc	 mov	 DWORD PTR _aRecv$GSCopy$[ebp], edi
  0001c	89 5d e0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0001f	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN25@CGGuildAss

; 16981: 	{
; 16982: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  0002b	68 56 42 00 00	 push	 16982			; 00004256H
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	5f		 pop	 edi
  00044	5b		 pop	 ebx

; 17091: 	}
; 17092: }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	33 cd		 xor	 ecx, ebp
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN25@CGGuildAss:

; 16983: 		return;
; 16984: 	}
; 16985: 
; 16986: 	if ( !OBJMAX_RANGE(aIndex))

  00053	85 db		 test	 ebx, ebx
  00055	0f 88 9b 02 00
	00		 js	 $LN1@CGGuildAss
  0005b	33 c0		 xor	 eax, eax
  0005d	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00063	0f 9e c0	 setle	 al
  00066	85 c0		 test	 eax, eax
  00068	0f 84 88 02 00
	00		 je	 $LN1@CGGuildAss

; 16987: 		return;
; 16988: 
; 16989: 	LPOBJ lpObj = &gObj[aIndex];
; 16990: 	PMSG_GUILD_ASSIGN_STATUS_RESULT pMsg={0};
; 16991: 	
; 16992: 	pMsg.h.set((LPBYTE)&pMsg, 0xE1, sizeof(pMsg));
; 16993: 	pMsg.btType = aRecv->btType;
; 16994: 	memcpy(pMsg.szTagetName, aRecv->szTagetName, sizeof(pMsg.szTagetName));

  0006e	8b 4f 09	 mov	 ecx, DWORD PTR [edi+9]
  00071	33 c0		 xor	 eax, eax
  00073	8b d3		 mov	 edx, ebx
  00075	89 45 ed	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00078	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  0007e	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00084	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  00087	89 45 f5	 mov	 DWORD PTR _pMsg$[ebp+9], eax
  0008a	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+13], ax
  0008e	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00091	83 c7 05	 add	 edi, 5
  00094	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00097	88 45 eb	 mov	 BYTE PTR tv392[ebp], al
  0009a	8b 07		 mov	 eax, DWORD PTR [edi]
  0009c	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  0009f	66 8b 47 08	 mov	 ax, WORD PTR [edi+8]
  000a3	66 c7 45 ec c1
	0f		 mov	 WORD PTR _pMsg$[ebp], 4033 ; 00000fc1H
  000a9	c6 45 ee e1	 mov	 BYTE PTR _pMsg$[ebp+2], 225 ; 000000e1H
  000ad	89 4d f5	 mov	 DWORD PTR _pMsg$[ebp+9], ecx
  000b0	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+13], ax

; 16995: 
; 16996: #if (ENABLETEST_ARCA == 1)
; 16997: 	int iArcaBattleState = g_ArcaBattle.GetState();
; 16998: 	if( iArcaBattleState > AB_STATE_CLOSED && iArcaBattleState < AB_STATE_CLOSE )
; 16999: 	{
; 17000: 		pMsg.btResult = 33;	//Define me
; 17001:         DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 17002: 		return;
; 17003: 	}
; 17004: #endif
; 17005: 
; 17006: 	if ( lpObj->GuildNumber <= 0 || lpObj->lpGuild == NULL )

  000b4	83 ba 14 06 00
	00 00		 cmp	 DWORD PTR [edx+1556], 0
  000bb	56		 push	 esi
  000bc	89 55 cc	 mov	 DWORD PTR tv389[ebp], edx
  000bf	0f 8e 1d 02 00
	00		 jle	 $LN22@CGGuildAss
  000c5	8b b2 18 06 00
	00		 mov	 esi, DWORD PTR [edx+1560]
  000cb	85 f6		 test	 esi, esi
  000cd	0f 84 0f 02 00
	00		 je	 $LN22@CGGuildAss

; 17010: 		return;
; 17011: 	}
; 17012: 
; 17013: 	if ( gObj[aIndex].GuildStatus != G_MASTER )

  000d3	81 ba 28 06 00
	00 80 00 00 00	 cmp	 DWORD PTR [edx+1576], 128 ; 00000080H
  000dd	74 0f		 je	 SHORT $LN21@CGGuildAss
$LN56@CGGuildAss:

; 17014: 	{
; 17015: 		pMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 17016: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  000df	6a 0f		 push	 15			; 0000000fH
  000e1	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000e4	c6 45 f0 11	 mov	 BYTE PTR _pMsg$[ebp+4], 17 ; 00000011H
  000e8	51		 push	 ecx

; 17017: 		return;

  000e9	e9 fe 01 00 00	 jmp	 $LN54@CGGuildAss
$LN21@CGGuildAss:

; 17018: 	}
; 17019: 
; 17020: 	char szTargetName[MAX_ACCOUNT_LEN+1]={0};

  000ee	33 c0		 xor	 eax, eax
  000f0	89 45 d1	 mov	 DWORD PTR _szTargetName$[ebp+1], eax
  000f3	89 45 d5	 mov	 DWORD PTR _szTargetName$[ebp+5], eax
  000f6	66 89 45 d9	 mov	 WORD PTR _szTargetName$[ebp+9], ax

; 17021: 	memcpy(szTargetName, aRecv->szTagetName, MAX_ACCOUNT_LEN);

  000fa	8b 07		 mov	 eax, DWORD PTR [edi]
  000fc	89 45 d0	 mov	 DWORD PTR _szTargetName$[ebp], eax
  000ff	66 8b 47 08	 mov	 ax, WORD PTR [edi+8]
  00103	89 4d d4	 mov	 DWORD PTR _szTargetName$[ebp+4], ecx
  00106	66 89 45 d8	 mov	 WORD PTR _szTargetName$[ebp+8], ax

; 17022: 
; 17023: 	if ( !strcmp(gObj[aIndex].Name, szTargetName))

  0010a	8d 4d d0	 lea	 ecx, DWORD PTR _szTargetName$[ebp]
  0010d	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
$LL43@CGGuildAss:
  00110	8a 10		 mov	 dl, BYTE PTR [eax]
  00112	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00114	75 1a		 jne	 SHORT $LN44@CGGuildAss
  00116	84 d2		 test	 dl, dl
  00118	74 12		 je	 SHORT $LN45@CGGuildAss
  0011a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0011d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00120	75 0e		 jne	 SHORT $LN44@CGGuildAss
  00122	83 c0 02	 add	 eax, 2
  00125	83 c1 02	 add	 ecx, 2
  00128	84 d2		 test	 dl, dl
  0012a	75 e4		 jne	 SHORT $LL43@CGGuildAss
$LN45@CGGuildAss:
  0012c	33 c0		 xor	 eax, eax
  0012e	eb 05		 jmp	 SHORT $LN46@CGGuildAss
$LN44@CGGuildAss:
  00130	1b c0		 sbb	 eax, eax
  00132	83 d8 ff	 sbb	 eax, -1
$LN46@CGGuildAss:
  00135	85 c0		 test	 eax, eax

; 17024: 	{
; 17025: 		pMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 17026: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 17027: 		return;

  00137	74 a6		 je	 SHORT $LN56@CGGuildAss

; 17028: 	}
; 17029: 
; 17030: 	if ( lpObj->lpGuild == NULL )
; 17031: 		return;
; 17032: 
; 17033: 	if ( aRecv->btType == 1 || aRecv->btType == 2 )

  00139	8a 45 eb	 mov	 al, BYTE PTR tv392[ebp]
  0013c	3c 01		 cmp	 al, 1
  0013e	74 31		 je	 SHORT $LN17@CGGuildAss
  00140	3c 02		 cmp	 al, 2
  00142	74 2d		 je	 SHORT $LN17@CGGuildAss

; 17080: 			return;
; 17081: 		}
; 17082: 		else
; 17083: 		{
; 17084: 			return;
; 17085: 		}
; 17086: 	}
; 17087: 	
; 17088: 	if ( aRecv->btType == 3 )

  00144	3c 03		 cmp	 al, 3
  00146	0f 85 a9 01 00
	00		 jne	 $LN53@CGGuildAss

; 17089: 	{
; 17090: 		GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  0014c	8b 55 dc	 mov	 edx, DWORD PTR _aRecv$GSCopy$[ebp]
  0014f	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00153	50		 push	 eax
  00154	57		 push	 edi
  00155	6a 03		 push	 3
  00157	53		 push	 ebx
  00158	e8 00 00 00 00	 call	 ?GDGuildReqAssignStatus@@YAXHHPADH@Z ; GDGuildReqAssignStatus
  0015d	83 c4 10	 add	 esp, 16			; 00000010H
  00160	5e		 pop	 esi
  00161	5f		 pop	 edi
  00162	5b		 pop	 ebx

; 17091: 	}
; 17092: }

  00163	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00166	33 cd		 xor	 ecx, ebp
  00168	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
$LN17@CGGuildAss:

; 17036: 		int iBattleMasterCount = 0;

  00171	33 db		 xor	 ebx, ebx
  00173	8d 96 41 04 00
	00		 lea	 edx, DWORD PTR [esi+1089]
  00179	8d 8e 04 06 00
	00		 lea	 ecx, DWORD PTR [esi+1540]
  0017f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iSubMasterCount$223801[ebp], 0
  00186	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  00189	8d a4 24 00 00
	00 00		 npad	 7
$LL16@CGGuildAss:

; 17039: 		{
; 17040: 			if ( lpObj->lpGuild->Use[n] > 0 )

  00190	80 7a ff 00	 cmp	 BYTE PTR [edx-1], 0
  00194	76 13		 jbe	 SHORT $LN15@CGGuildAss

; 17041: 			{
; 17042: 				if ( lpObj->lpGuild->GuildStatus[n] == G_SUB_MASTER )

  00196	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00199	83 f8 40	 cmp	 eax, 64			; 00000040H
  0019c	75 05		 jne	 SHORT $LN12@CGGuildAss

; 17043: 				{
; 17044: 					iSubMasterCount++;

  0019e	ff 45 e4	 inc	 DWORD PTR _iSubMasterCount$223801[ebp]
  001a1	eb 06		 jmp	 SHORT $LN15@CGGuildAss
$LN12@CGGuildAss:

; 17045: 				}
; 17046: 				else if ( lpObj->lpGuild->GuildStatus[n] == G_BATTLE_MASTER )

  001a3	83 f8 20	 cmp	 eax, 32			; 00000020H
  001a6	75 01		 jne	 SHORT $LN15@CGGuildAss

; 17047: 				{
; 17048: 					iBattleMasterCount++;

  001a8	43		 inc	 ebx
$LN15@CGGuildAss:

; 17039: 		{
; 17040: 			if ( lpObj->lpGuild->Use[n] > 0 )

  001a9	80 3a 00	 cmp	 BYTE PTR [edx], 0
  001ac	76 12		 jbe	 SHORT $LN49@CGGuildAss

; 17041: 			{
; 17042: 				if ( lpObj->lpGuild->GuildStatus[n] == G_SUB_MASTER )

  001ae	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b0	83 f8 40	 cmp	 eax, 64			; 00000040H
  001b3	75 05		 jne	 SHORT $LN35@CGGuildAss

; 17043: 				{
; 17044: 					iSubMasterCount++;

  001b5	ff 45 e4	 inc	 DWORD PTR _iSubMasterCount$223801[ebp]
  001b8	eb 06		 jmp	 SHORT $LN49@CGGuildAss
$LN35@CGGuildAss:

; 17045: 				}
; 17046: 				else if ( lpObj->lpGuild->GuildStatus[n] == G_BATTLE_MASTER )

  001ba	83 f8 20	 cmp	 eax, 32			; 00000020H
  001bd	75 01		 jne	 SHORT $LN49@CGGuildAss

; 17047: 				{
; 17048: 					iBattleMasterCount++;

  001bf	43		 inc	 ebx
$LN49@CGGuildAss:

; 17039: 		{
; 17040: 			if ( lpObj->lpGuild->Use[n] > 0 )

  001c0	80 7a 01 00	 cmp	 BYTE PTR [edx+1], 0
  001c4	76 13		 jbe	 SHORT $LN50@CGGuildAss

; 17041: 			{
; 17042: 				if ( lpObj->lpGuild->GuildStatus[n] == G_SUB_MASTER )

  001c6	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001c9	83 f8 40	 cmp	 eax, 64			; 00000040H
  001cc	75 05		 jne	 SHORT $LN37@CGGuildAss

; 17043: 				{
; 17044: 					iSubMasterCount++;

  001ce	ff 45 e4	 inc	 DWORD PTR _iSubMasterCount$223801[ebp]
  001d1	eb 06		 jmp	 SHORT $LN50@CGGuildAss
$LN37@CGGuildAss:

; 17045: 				}
; 17046: 				else if ( lpObj->lpGuild->GuildStatus[n] == G_BATTLE_MASTER )

  001d3	83 f8 20	 cmp	 eax, 32			; 00000020H
  001d6	75 01		 jne	 SHORT $LN50@CGGuildAss

; 17047: 				{
; 17048: 					iBattleMasterCount++;

  001d8	43		 inc	 ebx
$LN50@CGGuildAss:

; 17039: 		{
; 17040: 			if ( lpObj->lpGuild->Use[n] > 0 )

  001d9	80 7a 02 00	 cmp	 BYTE PTR [edx+2], 0
  001dd	76 13		 jbe	 SHORT $LN51@CGGuildAss

; 17041: 			{
; 17042: 				if ( lpObj->lpGuild->GuildStatus[n] == G_SUB_MASTER )

  001df	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001e2	83 f8 40	 cmp	 eax, 64			; 00000040H
  001e5	75 05		 jne	 SHORT $LN39@CGGuildAss

; 17043: 				{
; 17044: 					iSubMasterCount++;

  001e7	ff 45 e4	 inc	 DWORD PTR _iSubMasterCount$223801[ebp]
  001ea	eb 06		 jmp	 SHORT $LN51@CGGuildAss
$LN39@CGGuildAss:

; 17045: 				}
; 17046: 				else if ( lpObj->lpGuild->GuildStatus[n] == G_BATTLE_MASTER )

  001ec	83 f8 20	 cmp	 eax, 32			; 00000020H
  001ef	75 01		 jne	 SHORT $LN51@CGGuildAss

; 17047: 				{
; 17048: 					iBattleMasterCount++;

  001f1	43		 inc	 ebx
$LN51@CGGuildAss:

; 17039: 		{
; 17040: 			if ( lpObj->lpGuild->Use[n] > 0 )

  001f2	80 7a 03 00	 cmp	 BYTE PTR [edx+3], 0
  001f6	76 13		 jbe	 SHORT $LN52@CGGuildAss

; 17041: 			{
; 17042: 				if ( lpObj->lpGuild->GuildStatus[n] == G_SUB_MASTER )

  001f8	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  001fb	83 f8 40	 cmp	 eax, 64			; 00000040H
  001fe	75 05		 jne	 SHORT $LN41@CGGuildAss

; 17043: 				{
; 17044: 					iSubMasterCount++;

  00200	ff 45 e4	 inc	 DWORD PTR _iSubMasterCount$223801[ebp]
  00203	eb 06		 jmp	 SHORT $LN52@CGGuildAss
$LN41@CGGuildAss:

; 17045: 				}
; 17046: 				else if ( lpObj->lpGuild->GuildStatus[n] == G_BATTLE_MASTER )

  00205	83 f8 20	 cmp	 eax, 32			; 00000020H
  00208	75 01		 jne	 SHORT $LN52@CGGuildAss

; 17047: 				{
; 17048: 					iBattleMasterCount++;

  0020a	43		 inc	 ebx
$LN52@CGGuildAss:

; 17034: 	{
; 17035: 		int iSubMasterCount = 0;

  0020b	83 c1 14	 add	 ecx, 20			; 00000014H
  0020e	83 c2 05	 add	 edx, 5

; 17037: 
; 17038: 		for ( int n=0;n<MAX_USER_GUILD;n++)

  00211	4e		 dec	 esi
  00212	0f 85 78 ff ff
	ff		 jne	 $LL16@CGGuildAss

; 17049: 				}
; 17050: 			}
; 17051: 		}
; 17052: 
; 17053: 		if ( aRecv->btGuildStatus == G_SUB_MASTER )

  00218	8b 4d dc	 mov	 ecx, DWORD PTR _aRecv$GSCopy$[ebp]
  0021b	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  0021e	3c 40		 cmp	 al, 64			; 00000040H
  00220	75 3d		 jne	 SHORT $LN9@CGGuildAss

; 17054: 		{
; 17055: 			if ( iSubMasterCount == 0 )

  00222	39 75 e4	 cmp	 DWORD PTR _iSubMasterCount$223801[ebp], esi
  00225	75 25		 jne	 SHORT $LN8@CGGuildAss

; 17056: 			{
; 17057: 				GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  00227	0f b6 55 eb	 movzx	 edx, BYTE PTR tv392[ebp]
  0022b	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0022e	6a 40		 push	 64			; 00000040H
  00230	57		 push	 edi
  00231	52		 push	 edx
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ?GDGuildReqAssignStatus@@YAXHHPADH@Z ; GDGuildReqAssignStatus
  00238	83 c4 10	 add	 esp, 16			; 00000010H
  0023b	5e		 pop	 esi
  0023c	5f		 pop	 edi
  0023d	5b		 pop	 ebx

; 17091: 	}
; 17092: }

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00241	33 cd		 xor	 ecx, ebp
  00243	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00248	8b e5		 mov	 esp, ebp
  0024a	5d		 pop	 ebp
  0024b	c3		 ret	 0
$LN8@CGGuildAss:

; 17058: 				return;
; 17059: 			}
; 17060: 
; 17061: 			pMsg.btResult = GUILD_ANS_NOTEXIST_EXTRA_STATUS;
; 17062: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0024c	8b 55 e0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0024f	6a 0f		 push	 15			; 0000000fH
  00251	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00254	51		 push	 ecx
  00255	c6 45 f0 12	 mov	 BYTE PTR _pMsg$[ebp+4], 18 ; 00000012H
  00259	52		 push	 edx

; 17063: 			return;

  0025a	e9 8e 00 00 00	 jmp	 $LN55@CGGuildAss
$LN9@CGGuildAss:

; 17064: 		}
; 17065: 		else if ( aRecv->btGuildStatus == G_BATTLE_MASTER )

  0025f	3c 20		 cmp	 al, 32			; 00000020H
  00261	75 56		 jne	 SHORT $LN6@CGGuildAss

; 17066: 		{
; 17067: 			if ( iBattleMasterCount < ((lpObj->Level / 200 ) +1) )

  00263	8b 45 cc	 mov	 eax, DWORD PTR tv389[ebp]
  00266	0f bf 88 96 00
	00 00		 movsx	 ecx, WORD PTR [eax+150]
  0026d	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00272	f7 e9		 imul	 ecx
  00274	c1 fa 06	 sar	 edx, 6
  00277	8b ca		 mov	 ecx, edx
  00279	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0027c	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  00280	3b da		 cmp	 ebx, edx
  00282	7d 25		 jge	 SHORT $LN5@CGGuildAss

; 17068: 			{
; 17069: 				GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  00284	0f b6 45 eb	 movzx	 eax, BYTE PTR tv392[ebp]
  00288	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0028b	6a 20		 push	 32			; 00000020H
  0028d	57		 push	 edi
  0028e	50		 push	 eax
  0028f	51		 push	 ecx
  00290	e8 00 00 00 00	 call	 ?GDGuildReqAssignStatus@@YAXHHPADH@Z ; GDGuildReqAssignStatus
  00295	83 c4 10	 add	 esp, 16			; 00000010H
  00298	5e		 pop	 esi
  00299	5f		 pop	 edi
  0029a	5b		 pop	 ebx

; 17091: 	}
; 17092: }

  0029b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029e	33 cd		 xor	 ecx, ebp
  002a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a5	8b e5		 mov	 esp, ebp
  002a7	5d		 pop	 ebp
  002a8	c3		 ret	 0
$LN5@CGGuildAss:

; 17070: 				return;
; 17071: 			}
; 17072: 
; 17073: 			pMsg.btResult = GUILD_ANS_NOTEXIST_EXTRA_STATUS;
; 17074: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  002a9	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  002ac	6a 0f		 push	 15			; 0000000fH
  002ae	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  002b1	52		 push	 edx
  002b2	c6 45 f0 12	 mov	 BYTE PTR _pMsg$[ebp+4], 18 ; 00000012H
  002b6	50		 push	 eax

; 17075: 			return;

  002b7	eb 34		 jmp	 SHORT $LN55@CGGuildAss
$LN6@CGGuildAss:

; 17076: 		}
; 17077: 		else if ( aRecv->btGuildStatus == G_PERSON )

  002b9	84 c0		 test	 al, al
  002bb	75 38		 jne	 SHORT $LN53@CGGuildAss

; 17078: 		{
; 17079: 			GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  002bd	0f b6 4d eb	 movzx	 ecx, BYTE PTR tv392[ebp]
  002c1	8b 55 e0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  002c4	6a 00		 push	 0
  002c6	57		 push	 edi
  002c7	51		 push	 ecx
  002c8	52		 push	 edx
  002c9	e8 00 00 00 00	 call	 ?GDGuildReqAssignStatus@@YAXHHPADH@Z ; GDGuildReqAssignStatus
  002ce	83 c4 10	 add	 esp, 16			; 00000010H
  002d1	5e		 pop	 esi
  002d2	5f		 pop	 edi
  002d3	5b		 pop	 ebx

; 17091: 	}
; 17092: }

  002d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d7	33 cd		 xor	 ecx, ebp
  002d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002de	8b e5		 mov	 esp, ebp
  002e0	5d		 pop	 ebp
  002e1	c3		 ret	 0
$LN22@CGGuildAss:

; 17007: 	{
; 17008: 		pMsg.btResult = GUILD_ANS_NOTEXIST_GUILD;
; 17009: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  002e2	6a 0f		 push	 15			; 0000000fH
  002e4	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002e7	c6 45 f0 10	 mov	 BYTE PTR _pMsg$[ebp+4], 16 ; 00000010H
  002eb	50		 push	 eax
$LN54@CGGuildAss:
  002ec	53		 push	 ebx
$LN55@CGGuildAss:
  002ed	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002f2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN53@CGGuildAss:
  002f5	5e		 pop	 esi
$LN1@CGGuildAss:

; 17091: 	}
; 17092: }

  002f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f9	5f		 pop	 edi
  002fa	33 cd		 xor	 ecx, ebp
  002fc	5b		 pop	 ebx
  002fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00302	8b e5		 mov	 esp, ebp
  00304	5d		 pop	 ebp
  00305	c3		 ret	 0
?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z ENDP ; CGGuildAssignStatus
_TEXT	ENDS
PUBLIC	?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z ; CGGuildAssignType
EXTRN	?GDGuildReqAssignType@@YAXHH@Z:PROC		; GDGuildReqAssignType
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z PROC ; CGGuildAssignType, COMDAT

; 17098: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 17099: 	if ( !gObjIsConnectedGP(aIndex))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	75 1d		 jne	 SHORT $LN5@CGGuildAss@2

; 17100: 	{
; 17101: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00017	68 cd 42 00 00	 push	 17101			; 000042cdH
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 17115: 	{
; 17116: 		pMsg.btResult = GUILD_ANS_NOTEXIST_GUILD;
; 17117: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	5e		 pop	 esi

; 17129: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN5@CGGuildAss@2:

; 17102: 		return;
; 17103: 	}
; 17104: 
; 17105: 	if ( !OBJMAX_RANGE(aIndex))

  00034	85 f6		 test	 esi, esi
  00036	0f 88 98 00 00
	00		 js	 $LN6@CGGuildAss@2
  0003c	33 c0		 xor	 eax, eax
  0003e	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00044	0f 9e c0	 setle	 al
  00047	85 c0		 test	 eax, eax
  00049	0f 84 85 00 00
	00		 je	 $LN6@CGGuildAss@2

; 17106: 		return;
; 17107: 
; 17108: 	LPOBJ lpObj = &gObj[aIndex];

  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17109: 	PMSG_GUILD_ASSIGN_TYPE_RESULT pMsg={0};
; 17110: 	
; 17111: 	pMsg.h.set((LPBYTE)&pMsg, 0xE2, sizeof(pMsg));
; 17112: 	pMsg.btGuildType = aRecv->btGuildType;

  00055	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00058	8b c6		 mov	 eax, esi
  0005a	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00060	03 c1		 add	 eax, ecx
  00062	8a 4a 03	 mov	 cl, BYTE PTR [edx+3]
  00065	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+1], 0
  0006c	66 c7 45 f8 c1
	05		 mov	 WORD PTR _pMsg$[ebp], 1473 ; 000005c1H
  00072	c6 45 fa e2	 mov	 BYTE PTR _pMsg$[ebp+2], 226 ; 000000e2H
  00076	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 17113: 	
; 17114: 	if ( lpObj->GuildNumber <= 0 || lpObj->lpGuild == NULL )

  00079	83 b8 14 06 00
	00 00		 cmp	 DWORD PTR [eax+1556], 0
  00080	7e 3f		 jle	 SHORT $LN2@CGGuildAss@2
  00082	83 b8 18 06 00
	00 00		 cmp	 DWORD PTR [eax+1560], 0
  00089	74 36		 je	 SHORT $LN2@CGGuildAss@2

; 17118: 		return;
; 17119: 	}
; 17120: 
; 17121: 	if ( gObj[aIndex].GuildStatus != G_MASTER )

  0008b	81 b8 28 06 00
	00 80 00 00 00	 cmp	 DWORD PTR [eax+1576], 128 ; 00000080H
  00095	74 18		 je	 SHORT $LN1@CGGuildAss@2

; 17122: 	{
; 17123: 		pMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 17124: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00097	6a 05		 push	 5
  00099	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009c	50		 push	 eax
  0009d	56		 push	 esi
  0009e	c6 45 fc 11	 mov	 BYTE PTR _pMsg$[ebp+4], 17 ; 00000011H
  000a2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000aa	5e		 pop	 esi

; 17129: }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
$LN1@CGGuildAss@2:

; 17125: 		return;
; 17126: 	}
; 17127: 	
; 17128: 	GDGuildReqAssignType(aIndex, aRecv->btGuildType);

  000af	0f b6 c9	 movzx	 ecx, cl
  000b2	51		 push	 ecx
  000b3	56		 push	 esi
  000b4	e8 00 00 00 00	 call	 ?GDGuildReqAssignType@@YAXHH@Z ; GDGuildReqAssignType
  000b9	83 c4 08	 add	 esp, 8
  000bc	5e		 pop	 esi

; 17129: }

  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
$LN2@CGGuildAss@2:

; 17115: 	{
; 17116: 		pMsg.btResult = GUILD_ANS_NOTEXIST_GUILD;
; 17117: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  000c1	6a 05		 push	 5
  000c3	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000c6	52		 push	 edx
  000c7	56		 push	 esi
  000c8	c6 45 fc 10	 mov	 BYTE PTR _pMsg$[ebp+4], 16 ; 00000010H
  000cc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@CGGuildAss@2:
  000d4	5e		 pop	 esi

; 17129: }

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z ENDP ; CGGuildAssignType
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z ; CGRelationShipReqJoinBreakOff
EXTRN	?GDUnionBreakOff@@YAXHH@Z:PROC			; GDUnionBreakOff
EXTRN	?g_GuildMaxAllianceMember@@3HA:DWORD		; g_GuildMaxAllianceMember
EXTRN	?GetGuildRelationShipCount@TUnion@@QAEHHH@Z:PROC ; TUnion::GetGuildRelationShipCount
EXTRN	?g_CastleMinGuildMember@@3HA:DWORD		; g_CastleMinGuildMember
EXTRN	?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z:PROC ; gObjGetRelationShip
; Function compile flags: /Ogtp
;	COMDAT ?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z
_TEXT	SEGMENT
_iTargetUserIndex$ = -60				; size = 4
tv567 = -56						; size = 4
_szCastleOwnerGuildName$223881 = -52			; size = 9
_btRelationShip$ = -37					; size = 1
tv561 = -36						; size = 4
_lpGuildInfo$ = -36					; size = 4
_aIndex$GSCopy$ = -32					; size = 4
_ErrMsg$ = -28						; size = 8
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z PROC ; CGRelationShipReqJoinBreakOff, COMDAT

; 17135: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 17136: 	if ( g_CastleSiegeSync.GetCastleState() >= 5 && g_CastleSiegeSync.GetCastleState() <= 7 )

  00010	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+4
  00015	53		 push	 ebx
  00016	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00019	83 c0 fb	 add	 eax, -5			; fffffffbH
  0001c	57		 push	 edi
  0001d	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 17222: 	}
; 17223: 
; 17224: 	PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS ErrMsg={0};

  00020	89 5d e0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00023	83 f8 02	 cmp	 eax, 2
  00026	77 29		 ja	 SHORT $LN46@CGRelation

; 17137: 	{
; 17138: 		MsgOutput(aIndex, lMsg.Get(MSGGET(6, 196)));

  00028	68 c4 06 00 00	 push	 1732			; 000006c4H
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00032	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00037	50		 push	 eax
  00038	53		 push	 ebx
  00039	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0003e	83 c4 08	 add	 esp, 8
  00041	5f		 pop	 edi
  00042	5b		 pop	 ebx

; 17396: }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	33 cd		 xor	 ecx, ebp
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN46@CGRelation:

; 17139: 		return;
; 17140: 	}
; 17141: 
; 17142: #if (ENABLETEST_ARCA == 1)
; 17143: 	int iArcaBattleState = g_ArcaBattle.GetState();
; 17144: 
; 17145: 	if( iArcaBattleState > AB_STATE_CLOSED && iArcaBattleState < AB_STATE_CLOSE )
; 17146: 	{
; 17147: #if( AB_DEBUG_TRACE == 1 )
; 17148: 		TRACE_LOG("aIndex, 0x51, 0xA5");
; 17149: #endif
; 17150: 		GCResultSend(aIndex, 0x51, 0xA4);
; 17151: 		return;
; 17152: 	}
; 17153: #endif
; 17154: 
; 17155: 	int iTargetUserIndex = -1;
; 17156: 	
; 17157: 	/*if( aRecv->btRelationShipType == 2 && aRecv->btRequestType == 2 )
; 17158: 	{
; 17159: 		char szGuild[9]={0};
; 17160: 		memcpy(szGuild,aRecv->szGuild,8);
; 17161: 
; 17162: 		_GUILD_INFO_STRUCT* lpGuild = Guild.SearchGuild(szGuild);
; 17163: 
; 17164: 		if( lpGuild )
; 17165: 		{
; 17166: 			iTargetUserIndex = lpGuild->Index[0];
; 17167: 		}
; 17168: 	}
; 17169: 	else
; 17170: 	{*/
; 17171: 		iTargetUserIndex = MAKE_NUMBERW(aRecv->btTargetUserIndexH, aRecv->btTargetUserIndexL);

  00051	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  00055	0f b6 57 06	 movzx	 edx, BYTE PTR [edi+6]
  00059	66 c1 e1 08	 shl	 cx, 8
  0005d	56		 push	 esi
  0005e	0f b7 f1	 movzx	 esi, cx
  00061	0b f2		 or	 esi, edx
  00063	89 75 c4	 mov	 DWORD PTR _iTargetUserIndex$[ebp], esi

; 17172: 	//}
; 17173: 
; 17174: 	if ( !OBJMAX_RANGE(aIndex) )

  00066	85 db		 test	 ebx, ebx
  00068	0f 88 2f 05 00
	00		 js	 $LN65@CGRelation
  0006e	33 c0		 xor	 eax, eax
  00070	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00076	0f 9e c0	 setle	 al
  00079	85 c0		 test	 eax, eax
  0007b	0f 84 1c 05 00
	00		 je	 $LN65@CGRelation

; 17175: 		return;
; 17176: 
; 17177: 	if ( !PacketCheckTime(&gObj[aIndex]))

  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00086	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  0008c	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00095	83 c4 04	 add	 esp, 4
  00098	85 c0		 test	 eax, eax
  0009a	0f 84 fd 04 00
	00		 je	 $LN65@CGRelation

; 17178: 		return;
; 17179: 
; 17180: 	if ( !OBJMAX_RANGE(iTargetUserIndex) || gObjIsConnected(&gObj[iTargetUserIndex]) == FALSE )

  000a0	85 f6		 test	 esi, esi
  000a2	0f 88 e5 04 00
	00		 js	 $LN42@CGRelation
  000a8	33 c0		 xor	 eax, eax
  000aa	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  000b0	0f 9e c0	 setle	 al
  000b3	85 c0		 test	 eax, eax
  000b5	0f 84 d2 04 00
	00		 je	 $LN42@CGRelation
  000bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c1	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  000c7	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000d0	83 c4 04	 add	 esp, 4
  000d3	85 c0		 test	 eax, eax
  000d5	0f 84 b2 04 00
	00		 je	 $LN42@CGRelation

; 17183: 		return;
; 17184: 	}
; 17185: 
; 17186: #if (ENABLETEST_NEWPVP == 1)
; 17187: 	if( g_NewPVP.IsDuel(gObj[aIndex]) || g_NewPVP.IsDuel(gObj[iTargetUserIndex]) )

  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e1	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  000e4	50		 push	 eax
  000e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000ea	89 45 dc	 mov	 DWORD PTR tv561[ebp], eax
  000ed	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  000f2	85 c0		 test	 eax, eax
  000f4	0f 85 86 04 00
	00		 jne	 $LN40@CGRelation
  000fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00100	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00103	50		 push	 eax
  00104	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00109	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  0010e	85 c0		 test	 eax, eax
  00110	0f 85 6a 04 00
	00		 jne	 $LN40@CGRelation

; 17191: 	}
; 17192: 	// ----
; 17193: 	if( g_NewPVP.IsObserver(gObj[aIndex]) || g_NewPVP.IsObserver(gObj[iTargetUserIndex]) )

  00116	8b 4d dc	 mov	 ecx, DWORD PTR tv561[ebp]
  00119	51		 push	 ecx
  0011a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0011f	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00124	85 c0		 test	 eax, eax
  00126	0f 85 25 04 00
	00		 jne	 $LN38@CGRelation
  0012c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00132	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00135	50		 push	 eax
  00136	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0013b	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00140	85 c0		 test	 eax, eax
  00142	0f 85 09 04 00
	00		 jne	 $LN38@CGRelation

; 17196: 		 return;
; 17197: 	}
; 17198: #endif
; 17199: 
; 17200: 	if ( !gObj[aIndex].lpGuild || !gObj[iTargetUserIndex].lpGuild )

  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014d	83 bc 03 18 06
	00 00 00	 cmp	 DWORD PTR [ebx+eax+1560], 0
  00155	0f 84 f2 03 00
	00		 je	 $LN36@CGRelation
  0015b	83 bc 06 18 06
	00 00 00	 cmp	 DWORD PTR [esi+eax+1560], 0
  00163	0f 84 e4 03 00
	00		 je	 $LN36@CGRelation

; 17204: 	}
; 17205: 
; 17206: 	if ( gObj[aIndex].GuildStatus != G_MASTER && gObj[iTargetUserIndex].GuildStatus != G_MASTER)

  00169	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0016e	39 8c 03 28 06
	00 00		 cmp	 DWORD PTR [ebx+eax+1576], ecx
  00175	74 16		 je	 SHORT $LN35@CGRelation
  00177	39 8c 06 28 06
	00 00		 cmp	 DWORD PTR [esi+eax+1576], ecx
  0017e	74 0d		 je	 SHORT $LN35@CGRelation

; 17207: 	{
; 17208: 		GCResultSend(aIndex, 0x51, 4);

  00180	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00183	6a 04		 push	 4
  00185	6a 51		 push	 81			; 00000051H
  00187	51		 push	 ecx

; 17209: 		return;

  00188	e9 08 04 00 00	 jmp	 $LN66@CGRelation
$LN35@CGRelation:

; 17210: 	}
; 17211: 
; 17212: 	if ( gObj[aIndex].m_IfState.use > 0 )

  0018d	b1 03		 mov	 cl, 3
  0018f	84 8c 03 b8 11
	00 00		 test	 BYTE PTR [ebx+eax+4536], cl
  00196	76 0d		 jbe	 SHORT $LN34@CGRelation

; 17213: 	{
; 17214: 		GCResultSend(aIndex, 0x51, 6);

  00198	8b 55 e0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0019b	6a 06		 push	 6
  0019d	6a 51		 push	 81			; 00000051H
  0019f	52		 push	 edx

; 17215: 		return;

  001a0	e9 f0 03 00 00	 jmp	 $LN66@CGRelation
$LN34@CGRelation:

; 17216: 	}
; 17217: 
; 17218: 	if ( gObj[iTargetUserIndex].m_IfState.use > 0 )

  001a5	84 8c 06 b8 11
	00 00		 test	 BYTE PTR [esi+eax+4536], cl
  001ac	76 07		 jbe	 SHORT $LN33@CGRelation

; 17219: 	{
; 17220: 		GCResultSend(aIndex, 0x51, 6);

  001ae	6a 06		 push	 6

; 17221: 		return;

  001b0	e9 da 03 00 00	 jmp	 $LN67@CGRelation
$LN33@CGRelation:

; 17225: 
; 17226: 	PHeadSetB((LPBYTE)&ErrMsg, 0xE6, sizeof(ErrMsg));

  001b5	6a 08		 push	 8
  001b7	33 c0		 xor	 eax, eax
  001b9	8d 4d e4	 lea	 ecx, DWORD PTR _ErrMsg$[ebp]
  001bc	68 e6 00 00 00	 push	 230			; 000000e6H
  001c1	51		 push	 ecx
  001c2	c6 45 e4 00	 mov	 BYTE PTR _ErrMsg$[ebp], 0
  001c6	89 45 e5	 mov	 DWORD PTR _ErrMsg$[ebp+1], eax
  001c9	66 89 45 e9	 mov	 WORD PTR _ErrMsg$[ebp+5], ax
  001cd	88 45 eb	 mov	 BYTE PTR _ErrMsg$[ebp+7], al
  001d0	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17227: 	ErrMsg.btResult = 0;
; 17228: 	ErrMsg.btRequestType = aRecv->btRequestType;

  001d5	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]

; 17229: 	ErrMsg.btRelationShipType = aRecv->btRelationShipType;
; 17230: 	ErrMsg.btTargetUserIndexH = aRecv->btTargetUserIndexH;

  001d9	8a 4f 05	 mov	 cl, BYTE PTR [edi+5]
  001dc	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  001df	88 55 e8	 mov	 BYTE PTR _ErrMsg$[ebp+4], dl

; 17231: 	ErrMsg.btTargetUserIndexL = aRecv->btTargetUserIndexL;

  001e2	0f b6 57 06	 movzx	 edx, BYTE PTR [edi+6]
  001e6	88 4d ea	 mov	 BYTE PTR _ErrMsg$[ebp+6], cl

; 17232: 
; 17233: 	LPOBJ lpObj = &gObj[aIndex];

  001e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ef	88 55 eb	 mov	 BYTE PTR _ErrMsg$[ebp+7], dl
  001f2	03 d9		 add	 ebx, ecx

; 17234: 	LPOBJ lpTargetObj = &gObj[iTargetUserIndex];

  001f4	03 ce		 add	 ecx, esi

; 17235: 
; 17236: 	if ( lpObj->GuildStatus != G_MASTER || lpTargetObj->GuildStatus != G_MASTER)

  001f6	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fe	c6 45 e9 00	 mov	 BYTE PTR _ErrMsg$[ebp+5], 0
  00202	88 45 e7	 mov	 BYTE PTR _ErrMsg$[ebp+3], al
  00205	89 4d c8	 mov	 DWORD PTR tv567[ebp], ecx
  00208	39 93 28 06 00
	00		 cmp	 DWORD PTR [ebx+1576], edx
  0020e	0f 85 30 03 00
	00		 jne	 $LN31@CGRelation
  00214	39 91 28 06 00
	00		 cmp	 DWORD PTR [ecx+1576], edx
  0021a	0f 85 24 03 00
	00		 jne	 $LN31@CGRelation

; 17241: 	}
; 17242: 
; 17243: #if (__GENS_SYSTEM__ == 1)
; 17244: 
; 17245: 	if( gGensSystem.m_CheckForAlliance )

  00220	80 3d 52 00 00
	00 00		 cmp	 BYTE PTR ?gGensSystem@@3VCGensSystem@@A+82, 0
  00227	74 46		 je	 SHORT $LN27@CGRelation

; 17246: 	{
; 17247: 		if( aRecv->btRelationShipType != 2 )

  00229	3c 02		 cmp	 al, 2
  0022b	74 42		 je	 SHORT $LN27@CGRelation

; 17248: 		{
; 17249: 			if ( lpTargetObj->m_GensInfo.btFamily == GENS_NONE )

  0022d	8a 81 ac 26 00
	00		 mov	 al, BYTE PTR [ecx+9900]
  00233	84 c0		 test	 al, al
  00235	75 2a		 jne	 SHORT $LN28@CGRelation

; 17250: 			{
; 17251: 				ErrMsg.btResult = GUILD_ANS_ALLYMASTER_NOGENS;

  00237	c6 45 e9 a1	 mov	 BYTE PTR _ErrMsg$[ebp+5], 161 ; 000000a1H
$LN69@CGRelation:

; 17252: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0023b	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  0023f	8b 55 e0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00242	50		 push	 eax
  00243	8d 4d e4	 lea	 ecx, DWORD PTR _ErrMsg$[ebp]
  00246	51		 push	 ecx
  00247	52		 push	 edx
$LN70@CGRelation:
  00248	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0024d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00250	5e		 pop	 esi
  00251	5f		 pop	 edi
  00252	5b		 pop	 ebx

; 17396: }

  00253	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00256	33 cd		 xor	 ecx, ebp
  00258	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025d	8b e5		 mov	 esp, ebp
  0025f	5d		 pop	 ebp
  00260	c3		 ret	 0
$LN28@CGRelation:

; 17253: 				return;
; 17254: 			}
; 17255: 
; 17256: 			if ( lpObj->m_GensInfo.btFamily != lpTargetObj->m_GensInfo.btFamily )

  00261	38 83 ac 26 00
	00		 cmp	 BYTE PTR [ebx+9900], al
  00267	74 06		 je	 SHORT $LN27@CGRelation

; 17257: 			{
; 17258: 				ErrMsg.btResult = GUILD_ANS_DIFFERENT_GENS;

  00269	c6 45 e9 a3	 mov	 BYTE PTR _ErrMsg$[ebp+5], 163 ; 000000a3H

; 17259: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 17260: 				return;

  0026d	eb cc		 jmp	 SHORT $LN69@CGRelation
$LN27@CGRelation:

; 17261: 			}
; 17262: 		}
; 17263: 	}
; 17264: #endif
; 17265: 
; 17266: 	_GUILD_INFO_STRUCT * lpGuildInfo = gObj[aIndex].lpGuild;

  0026f	8b 83 18 06 00
	00		 mov	 eax, DWORD PTR [ebx+1560]

; 17267: 	_GUILD_INFO_STRUCT * lpTargetGuildInfo = gObj[iTargetUserIndex].lpGuild;

  00275	8b b1 18 06 00
	00		 mov	 esi, DWORD PTR [ecx+1560]

; 17268: 	BYTE btRelationShip = gObjGetRelationShip(lpObj, lpTargetObj);

  0027b	51		 push	 ecx
  0027c	53		 push	 ebx
  0027d	89 45 dc	 mov	 DWORD PTR _lpGuildInfo$[ebp], eax
  00280	e8 00 00 00 00	 call	 ?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjGetRelationShip

; 17269: 
; 17270: 	if ( aRecv->btRequestType == 1 )

  00285	8a 4f 04	 mov	 cl, BYTE PTR [edi+4]
  00288	83 c4 08	 add	 esp, 8
  0028b	88 45 db	 mov	 BYTE PTR _btRelationShip$[ebp], al
  0028e	80 f9 01	 cmp	 cl, 1
  00291	0f 85 66 01 00
	00		 jne	 $LN26@CGRelation

; 17271: 	{
; 17272: 		if ( aRecv->btRelationShipType == 1 )

  00297	8a 4f 03	 mov	 cl, BYTE PTR [edi+3]
  0029a	80 f9 01	 cmp	 cl, 1
  0029d	0f 85 26 01 00
	00		 jne	 $LN25@CGRelation

; 17273: 		{
; 17274: 			if ( lpTargetGuildInfo->Count < g_CastleMinGuildMember )

  002a3	0f b6 4e 2d	 movzx	 ecx, BYTE PTR [esi+45]
  002a7	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?g_CastleMinGuildMember@@3HA ; g_CastleMinGuildMember
  002ad	7d 13		 jge	 SHORT $LN24@CGRelation

; 17275: 			{
; 17276: 				ErrMsg.btResult = GUILD_ANS_CANNOT_BE_UNION_MASTER;
; 17277: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  002af	0f b6 55 e5	 movzx	 edx, BYTE PTR _ErrMsg$[ebp+1]
  002b3	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  002b6	52		 push	 edx
  002b7	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  002ba	50		 push	 eax
  002bb	c6 45 e9 1d	 mov	 BYTE PTR _ErrMsg$[ebp+5], 29 ; 0000001dH
  002bf	51		 push	 ecx

; 17278: 				return;

  002c0	eb 86		 jmp	 SHORT $LN70@CGRelation
$LN24@CGRelation:

; 17279: 			}
; 17280: 
; 17281: 			if ( lpTargetGuildInfo->iGuildUnion != 0 && lpTargetGuildInfo->iGuildUnion == lpTargetGuildInfo->Number )

  002c2	8b 86 44 07 00
	00		 mov	 eax, DWORD PTR [esi+1860]
  002c8	85 c0		 test	 eax, eax
  002ca	74 2f		 je	 SHORT $LN64@CGRelation
  002cc	3b 06		 cmp	 eax, DWORD PTR [esi]
  002ce	75 2b		 jne	 SHORT $LN64@CGRelation

; 17282: 			{
; 17283: 				if ( UnionManager.GetGuildRelationShipCount(lpTargetGuildInfo->iGuildUnion, 1) >= g_GuildMaxAllianceMember  )

  002d0	6a 01		 push	 1
  002d2	50		 push	 eax
  002d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  002d8	e8 00 00 00 00	 call	 ?GetGuildRelationShipCount@TUnion@@QAEHHH@Z ; TUnion::GetGuildRelationShipCount
  002dd	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_GuildMaxAllianceMember@@3HA ; g_GuildMaxAllianceMember
  002e3	7c 16		 jl	 SHORT $LN64@CGRelation

; 17284: 				{
; 17285: 					ErrMsg.btResult = GUILD_ANS_EXCEED_MAX_UNION_MEMBER;
; 17286: 					DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  002e5	0f b6 55 e5	 movzx	 edx, BYTE PTR _ErrMsg$[ebp+1]
  002e9	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  002ec	52		 push	 edx
  002ed	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  002f0	50		 push	 eax
  002f1	c6 45 e9 1e	 mov	 BYTE PTR _ErrMsg$[ebp+5], 30 ; 0000001eH
  002f5	51		 push	 ecx

; 17287: 					return;

  002f6	e9 4d ff ff ff	 jmp	 $LN70@CGRelation
$LN64@CGRelation:

; 17288: 				}
; 17289: 			}
; 17290: 		
; 17291: 			char szCastleOwnerGuildName[MAX_GUILD_LEN+1]={0};
; 17292: 			memcpy(szCastleOwnerGuildName, g_CastleSiegeSync.GetCastleOwnerGuild(), MAX_GUILD_LEN);

  002fb	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+24
  00301	33 c0		 xor	 eax, eax
  00303	89 45 cd	 mov	 DWORD PTR _szCastleOwnerGuildName$223881[ebp+1], eax
  00306	89 45 d1	 mov	 DWORD PTR _szCastleOwnerGuildName$223881[ebp+5], eax
  00309	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+28
  0030e	89 45 d0	 mov	 DWORD PTR _szCastleOwnerGuildName$223881[ebp+4], eax

; 17293: 
; 17294: 			if ( !strcmp(lpGuildInfo->Name, szCastleOwnerGuildName))

  00311	8b 45 dc	 mov	 eax, DWORD PTR _lpGuildInfo$[ebp]
  00314	89 55 cc	 mov	 DWORD PTR _szCastleOwnerGuildName$223881[ebp], edx
  00317	8d 4d cc	 lea	 ecx, DWORD PTR _szCastleOwnerGuildName$223881[ebp]
  0031a	83 c0 04	 add	 eax, 4
  0031d	8d 49 00	 npad	 3
$LL59@CGRelation:
  00320	8a 10		 mov	 dl, BYTE PTR [eax]
  00322	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00324	75 1a		 jne	 SHORT $LN60@CGRelation
  00326	84 d2		 test	 dl, dl
  00328	74 12		 je	 SHORT $LN61@CGRelation
  0032a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0032d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00330	75 0e		 jne	 SHORT $LN60@CGRelation
  00332	83 c0 02	 add	 eax, 2
  00335	83 c1 02	 add	 ecx, 2
  00338	84 d2		 test	 dl, dl
  0033a	75 e4		 jne	 SHORT $LL59@CGRelation
$LN61@CGRelation:
  0033c	33 c0		 xor	 eax, eax
  0033e	eb 05		 jmp	 SHORT $LN62@CGRelation
$LN60@CGRelation:
  00340	1b c0		 sbb	 eax, eax
  00342	83 d8 ff	 sbb	 eax, -1
$LN62@CGRelation:
  00345	85 c0		 test	 eax, eax
  00347	75 16		 jne	 SHORT $LN21@CGRelation

; 17295: 			{
; 17296: 				ErrMsg.btResult = GUILD_ANS_EXIST_UNION;
; 17297: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00349	0f b6 4d e5	 movzx	 ecx, BYTE PTR _ErrMsg$[ebp+1]
  0034d	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00350	51		 push	 ecx
  00351	8d 55 e4	 lea	 edx, DWORD PTR _ErrMsg$[ebp]
  00354	52		 push	 edx
  00355	c6 45 e9 17	 mov	 BYTE PTR _ErrMsg$[ebp+5], 23 ; 00000017H
  00359	50		 push	 eax

; 17298: 				return;

  0035a	e9 e9 fe ff ff	 jmp	 $LN70@CGRelation
$LN21@CGRelation:

; 17299: 			}
; 17300: 
; 17301: 			if ( lpGuildInfo->iGuildUnion )

  0035f	8b 4d dc	 mov	 ecx, DWORD PTR _lpGuildInfo$[ebp]
  00362	83 b9 44 07 00
	00 00		 cmp	 DWORD PTR [ecx+1860], 0
  00369	74 16		 je	 SHORT $LN20@CGRelation

; 17302: 			{
; 17303: 				ErrMsg.btResult = GUILD_ANS_EXIST_UNION;
; 17304: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0036b	0f b6 55 e5	 movzx	 edx, BYTE PTR _ErrMsg$[ebp+1]
  0036f	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00372	52		 push	 edx
  00373	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00376	50		 push	 eax
  00377	c6 45 e9 17	 mov	 BYTE PTR _ErrMsg$[ebp+5], 23 ; 00000017H
  0037b	51		 push	 ecx

; 17305: 				return;

  0037c	e9 c7 fe ff ff	 jmp	 $LN70@CGRelation
$LN20@CGRelation:

; 17306: 			}
; 17307: 
; 17308: 			if ( btRelationShip == 2 )

  00381	80 7d db 02	 cmp	 BYTE PTR _btRelationShip$[ebp], 2
  00385	75 16		 jne	 SHORT $LN19@CGRelation

; 17309: 			{
; 17310: 				ErrMsg.btResult = GUILD_ANS_EXIST_RELATIONSHIP_RIVAL;
; 17311: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00387	0f b6 55 e5	 movzx	 edx, BYTE PTR _ErrMsg$[ebp+1]
  0038b	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0038e	52		 push	 edx
  0038f	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00392	50		 push	 eax
  00393	c6 45 e9 16	 mov	 BYTE PTR _ErrMsg$[ebp+5], 22 ; 00000016H
  00397	51		 push	 ecx

; 17312: 				return;

  00398	e9 ab fe ff ff	 jmp	 $LN70@CGRelation
$LN19@CGRelation:

; 17313: 			}
; 17314: 
; 17315: 			if ( lpTargetGuildInfo->iGuildUnion && lpTargetGuildInfo->Number != lpTargetGuildInfo->iGuildUnion )

  0039d	8b 86 44 07 00
	00		 mov	 eax, DWORD PTR [esi+1860]
  003a3	85 c0		 test	 eax, eax
  003a5	0f 84 b9 00 00
	00		 je	 $LN63@CGRelation
  003ab	39 06		 cmp	 DWORD PTR [esi], eax
  003ad	0f 84 b1 00 00
	00		 je	 $LN63@CGRelation

; 17316: 			{
; 17317: 				ErrMsg.btResult = GUIDL_ANS_NOT_UNION_MASTER;
; 17318: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  003b3	0f b6 55 e5	 movzx	 edx, BYTE PTR _ErrMsg$[ebp+1]
  003b7	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  003ba	52		 push	 edx
  003bb	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  003be	50		 push	 eax
  003bf	c6 45 e9 1b	 mov	 BYTE PTR _ErrMsg$[ebp+5], 27 ; 0000001bH
  003c3	51		 push	 ecx

; 17319: 				return;

  003c4	e9 7f fe ff ff	 jmp	 $LN70@CGRelation
$LN25@CGRelation:

; 17320: 			}
; 17321: 		}
; 17322: 		else if ( aRecv->btRelationShipType == 2 )

  003c9	80 f9 02	 cmp	 cl, 2
  003cc	0f 85 92 00 00
	00		 jne	 $LN63@CGRelation

; 17323: 		{
; 17324: 			if ( lpGuildInfo->iGuildRival || lpTargetGuildInfo->iGuildRival )

  003d2	8b 55 dc	 mov	 edx, DWORD PTR _lpGuildInfo$[ebp]
  003d5	83 ba 48 07 00
	00 00		 cmp	 DWORD PTR [edx+1864], 0
  003dc	75 16		 jne	 SHORT $LN14@CGRelation
  003de	83 be 48 07 00
	00 00		 cmp	 DWORD PTR [esi+1864], 0
  003e5	75 0d		 jne	 SHORT $LN14@CGRelation

; 17329: 			}
; 17330: 
; 17331: 			if ( btRelationShip == 1 )

  003e7	3c 01		 cmp	 al, 1
  003e9	75 79		 jne	 SHORT $LN63@CGRelation

; 17332: 			{
; 17333: 				ErrMsg.btResult = GUILD_ANS_EXIST_RELATIONSHIP_UNION;

  003eb	c6 45 e9 15	 mov	 BYTE PTR _ErrMsg$[ebp+5], 21 ; 00000015H

; 17334: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 17335: 				return;

  003ef	e9 47 fe ff ff	 jmp	 $LN69@CGRelation
$LN14@CGRelation:

; 17325: 			{
; 17326: 				ErrMsg.btResult = GUILD_ANS_EXIST_RIVAL;

  003f4	c6 45 e9 18	 mov	 BYTE PTR _ErrMsg$[ebp+5], 24 ; 00000018H

; 17327: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 17328: 				return;

  003f8	e9 3e fe ff ff	 jmp	 $LN69@CGRelation
$LN26@CGRelation:

; 17336: 			}
; 17337: 		}
; 17338: 	}
; 17339: 	else if ( aRecv->btRequestType == 2 )

  003fd	80 f9 02	 cmp	 cl, 2
  00400	75 62		 jne	 SHORT $LN63@CGRelation

; 17340: 	{
; 17341: 		if ( aRecv->btRelationShipType == 1 )

  00402	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00405	3c 01		 cmp	 al, 1
  00407	75 22		 jne	 SHORT $LN10@CGRelation

; 17342: 		{
; 17343: 			if ( lpGuildInfo->iGuildUnion == 0 )

  00409	8b 45 dc	 mov	 eax, DWORD PTR _lpGuildInfo$[ebp]
  0040c	83 b8 44 07 00
	00 00		 cmp	 DWORD PTR [eax+1860], 0
  00413	75 4f		 jne	 SHORT $LN63@CGRelation
$LN5@CGRelation:

; 17344: 			{
; 17345: 				ErrMsg.btResult = GUILD_ANS_NOTEXIST_UNION;
; 17346: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00415	0f b6 4d e5	 movzx	 ecx, BYTE PTR _ErrMsg$[ebp+1]
  00419	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0041c	51		 push	 ecx
  0041d	8d 55 e4	 lea	 edx, DWORD PTR _ErrMsg$[ebp]
  00420	52		 push	 edx
  00421	c6 45 e9 19	 mov	 BYTE PTR _ErrMsg$[ebp+5], 25 ; 00000019H
  00425	50		 push	 eax

; 17347: 				return;

  00426	e9 1d fe ff ff	 jmp	 $LN70@CGRelation
$LN10@CGRelation:

; 17348: 			}
; 17349: 		}
; 17350: 		else if ( aRecv->btRelationShipType == 2 )

  0042b	3c 02		 cmp	 al, 2
  0042d	75 35		 jne	 SHORT $LN63@CGRelation

; 17351: 		{
; 17352: 			if ( !lpGuildInfo->iGuildRival || !lpTargetGuildInfo->iGuildRival )

  0042f	8b 55 dc	 mov	 edx, DWORD PTR _lpGuildInfo$[ebp]
  00432	8b 8a 48 07 00
	00		 mov	 ecx, DWORD PTR [edx+1864]
  00438	85 c9		 test	 ecx, ecx
  0043a	74 d9		 je	 SHORT $LN5@CGRelation
  0043c	8b 86 48 07 00
	00		 mov	 eax, DWORD PTR [esi+1864]
  00442	85 c0		 test	 eax, eax
  00444	74 cf		 je	 SHORT $LN5@CGRelation

; 17353: 			{
; 17354: 				ErrMsg.btResult = GUILD_ANS_NOTEXIST_UNION;
; 17355: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 17356: 				return;
; 17357: 			}
; 17358: 
; 17359: 			if ( lpGuildInfo->iGuildRival != lpTargetGuildInfo->Number || lpGuildInfo->Number != lpTargetGuildInfo->iGuildRival )

  00446	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  00448	75 04		 jne	 SHORT $LN3@CGRelation
  0044a	39 02		 cmp	 DWORD PTR [edx], eax
  0044c	74 16		 je	 SHORT $LN63@CGRelation
$LN3@CGRelation:

; 17360: 			{
; 17361: 				ErrMsg.btResult = GUILD_ANS_NOT_GUILD_RIVAL;
; 17362: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0044e	0f b6 4d e5	 movzx	 ecx, BYTE PTR _ErrMsg$[ebp+1]
  00452	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00455	51		 push	 ecx
  00456	8d 55 e4	 lea	 edx, DWORD PTR _ErrMsg$[ebp]
  00459	52		 push	 edx
  0045a	c6 45 e9 1c	 mov	 BYTE PTR _ErrMsg$[ebp+5], 28 ; 0000001cH
  0045e	50		 push	 eax

; 17363: 				return;

  0045f	e9 e4 fd ff ff	 jmp	 $LN70@CGRelation
$LN63@CGRelation:

; 17364: 			}
; 17365: 		}
; 17366: 	}		
; 17367: 	
; 17368: 	if ( aRecv->btRequestType == 2 )

  00464	80 7f 04 02	 cmp	 BYTE PTR [edi+4], 2
  00468	75 2d		 jne	 SHORT $LN1@CGRelation

; 17369: 	{
; 17370: 		if ( aRecv->btRelationShipType == 1 )

  0046a	80 7f 03 01	 cmp	 BYTE PTR [edi+3], 1
  0046e	75 27		 jne	 SHORT $LN1@CGRelation

; 17371: 		{
; 17372: 			GDUnionBreakOff(aIndex, lpGuildInfo->iGuildUnion);

  00470	8b 4d dc	 mov	 ecx, DWORD PTR _lpGuildInfo$[ebp]
  00473	8b 91 44 07 00
	00		 mov	 edx, DWORD PTR [ecx+1860]
  00479	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0047c	52		 push	 edx
  0047d	50		 push	 eax
  0047e	e8 00 00 00 00	 call	 ?GDUnionBreakOff@@YAXHH@Z ; GDUnionBreakOff
  00483	83 c4 08	 add	 esp, 8
  00486	5e		 pop	 esi
  00487	5f		 pop	 edi
  00488	5b		 pop	 ebx

; 17396: }

  00489	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0048c	33 cd		 xor	 ecx, ebp
  0048e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00493	8b e5		 mov	 esp, ebp
  00495	5d		 pop	 ebp
  00496	c3		 ret	 0
$LN1@CGRelation:

; 17373: 			return;
; 17374: 		}
; 17375: 	}
; 17376: 
; 17377: 	lpObj->m_IfState.use = 1;
; 17378: 	lpObj->m_IfState.type = 14;
; 17379: 	lpObj->m_IfState.state = 0;

  00497	8b 8b b8 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4536]

; 17380: 	lpObj->m_InterfaceTime = GetTickCount();

  0049d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  004a3	81 e1 81 03 ff
	ff		 and	 ecx, -64639		; ffff0381H
  004a9	81 c9 81 03 00
	00		 or	 ecx, 897		; 00000381H
  004af	89 8b b8 11 00
	00		 mov	 DWORD PTR [ebx+4536], ecx
  004b5	ff d6		 call	 esi
  004b7	89 83 bc 11 00
	00		 mov	 DWORD PTR [ebx+4540], eax

; 17381: 
; 17382: 	lpTargetObj->m_IfState.use = 1;
; 17383: 	lpTargetObj->m_IfState.type = 14;
; 17384: 	lpTargetObj->m_IfState.state = 0;

  004bd	8b 5d c8	 mov	 ebx, DWORD PTR tv567[ebp]
  004c0	8b 93 b8 11 00
	00		 mov	 edx, DWORD PTR [ebx+4536]
  004c6	81 e2 81 03 ff
	ff		 and	 edx, -64639		; ffff0381H
  004cc	81 ca 81 03 00
	00		 or	 edx, 897		; 00000381H
  004d2	89 93 b8 11 00
	00		 mov	 DWORD PTR [ebx+4536], edx

; 17385: 	lpTargetObj->m_InterfaceTime = GetTickCount();

  004d8	ff d6		 call	 esi
  004da	89 83 bc 11 00
	00		 mov	 DWORD PTR [ebx+4540], eax

; 17386: 
; 17387: 	PMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ pMsg={0};

  004e0	33 c0		 xor	 eax, eax

; 17388: 
; 17389: 	PHeadSetB((LPBYTE)&pMsg, 0xE5, sizeof(pMsg));

  004e2	6a 10		 push	 16			; 00000010H
  004e4	89 45 ed	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  004e7	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  004ea	89 45 f5	 mov	 DWORD PTR _pMsg$[ebp+9], eax
  004ed	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+13], ax
  004f1	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+15], al
  004f4	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  004f7	68 e5 00 00 00	 push	 229			; 000000e5H
  004fc	50		 push	 eax
  004fd	c6 45 ec 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00501	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17390: 	pMsg.btTargetUserIndexL = SET_NUMBERL(aIndex);

  00506	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]

; 17391: 	pMsg.btTargetUserIndexH = SET_NUMBERH(aIndex);
; 17392: 	pMsg.btRequestType = aRecv->btRequestType;

  00509	8a 4f 04	 mov	 cl, BYTE PTR [edi+4]

; 17393: 	pMsg.btRelationShipType = aRecv->btRelationShipType;

  0050c	8a 57 03	 mov	 dl, BYTE PTR [edi+3]
  0050f	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al
  00512	c1 e8 08	 shr	 eax, 8
  00515	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 17394: 	
; 17395: 	DataSend(iTargetUserIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00518	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0051c	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0051f	50		 push	 eax
  00520	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00523	88 55 ef	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  00526	8b 55 c4	 mov	 edx, DWORD PTR _iTargetUserIndex$[ebp]
  00529	51		 push	 ecx
  0052a	52		 push	 edx
  0052b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00530	83 c4 18	 add	 esp, 24			; 00000018H
  00533	5e		 pop	 esi
  00534	5f		 pop	 edi
  00535	5b		 pop	 ebx

; 17396: }

  00536	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00539	33 cd		 xor	 ecx, ebp
  0053b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00540	8b e5		 mov	 esp, ebp
  00542	5d		 pop	 ebp
  00543	c3		 ret	 0
$LN31@CGRelation:

; 17237: 	{
; 17238: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;

  00544	c6 45 e9 11	 mov	 BYTE PTR _ErrMsg$[ebp+5], 17 ; 00000011H

; 17239: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 17240: 		return;

  00548	e9 ee fc ff ff	 jmp	 $LN69@CGRelation
$LN36@CGRelation:

; 17201: 	{
; 17202: 		GCResultSend(aIndex, 0x51, 5);

  0054d	6a 05		 push	 5

; 17203: 		return;

  0054f	eb 3e		 jmp	 SHORT $LN67@CGRelation
$LN38@CGRelation:

; 17194: 	{
; 17195: 		 GCServerMsgStringSend(lMsg.Get(3432), aIndex, 1);

  00551	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00554	6a 01		 push	 1
  00556	51		 push	 ecx
  00557	68 68 0d 00 00	 push	 3432			; 00000d68H
$LN71@CGRelation:
  0055c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00561	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00566	50		 push	 eax
  00567	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0056c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0056f	5e		 pop	 esi
  00570	5f		 pop	 edi
  00571	5b		 pop	 ebx

; 17396: }

  00572	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00575	33 cd		 xor	 ecx, ebp
  00577	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0057c	8b e5		 mov	 esp, ebp
  0057e	5d		 pop	 ebp
  0057f	c3		 ret	 0
$LN40@CGRelation:

; 17188: 	{
; 17189: 		 GCServerMsgStringSend(lMsg.Get(3431), aIndex, 1);

  00580	8b 55 e0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00583	6a 01		 push	 1
  00585	52		 push	 edx
  00586	68 67 0d 00 00	 push	 3431			; 00000d67H

; 17190: 		 return;

  0058b	eb cf		 jmp	 SHORT $LN71@CGRelation
$LN42@CGRelation:

; 17181: 	{
; 17182: 		GCResultSend(aIndex, 0x51, 3);

  0058d	6a 03		 push	 3
$LN67@CGRelation:
  0058f	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00592	6a 51		 push	 81			; 00000051H
  00594	50		 push	 eax
$LN66@CGRelation:
  00595	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0059a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN65@CGRelation:

; 17396: }

  0059d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005a0	5e		 pop	 esi
  005a1	5f		 pop	 edi
  005a2	33 cd		 xor	 ecx, ebp
  005a4	5b		 pop	 ebx
  005a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005aa	8b e5		 mov	 esp, ebp
  005ac	5d		 pop	 ebp
  005ad	c3		 ret	 0
?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z ENDP ; CGRelationShipReqJoinBreakOff
_TEXT	ENDS
PUBLIC	?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z ; CGRelationShipAnsJoinBreakOff
EXTRN	?GDRelationShipReqBreakOff@@YAXHHH@Z:PROC	; GDRelationShipReqBreakOff
EXTRN	?GDRelationShipReqJoin@@YAXHHH@Z:PROC		; GDRelationShipReqJoin
; Function compile flags: /Ogtp
;	COMDAT ?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z
_TEXT	SEGMENT
_ErrMsg$223937 = -8					; size = 8
tv276 = 8						; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z PROC ; CGRelationShipAnsJoinBreakOff, COMDAT

; 17402: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 17403: 	int iTargetUserIndex = MAKE_NUMBERW(aRecv->btTargetUserIndexH, aRecv->btTargetUserIndexL);
; 17404: 
; 17405: 	if ( !OBJMAX_RANGE(aIndex) || !OBJMAX_RANGE(iTargetUserIndex))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  0000e	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  00012	0f b6 4e 07	 movzx	 ecx, BYTE PTR [esi+7]
  00016	66 c1 e0 08	 shl	 ax, 8
  0001a	57		 push	 edi
  0001b	0f b7 f8	 movzx	 edi, ax
  0001e	0b f9		 or	 edi, ecx
  00020	85 db		 test	 ebx, ebx
  00022	0f 88 5c 01 00
	00		 js	 $LN12@CGRelation@2
  00028	33 c0		 xor	 eax, eax
  0002a	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00030	0f 9e c0	 setle	 al
  00033	85 c0		 test	 eax, eax
  00035	0f 84 49 01 00
	00		 je	 $LN12@CGRelation@2
  0003b	85 ff		 test	 edi, edi
  0003d	0f 88 41 01 00
	00		 js	 $LN12@CGRelation@2
  00043	33 c0		 xor	 eax, eax
  00045	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0004b	0f 9e c0	 setle	 al
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 2e 01 00
	00		 je	 $LN12@CGRelation@2

; 17406: 		return;
; 17407: 
; 17408: 	if ( !PacketCheckTime(&gObj[aIndex]))

  00056	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005c	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00062	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0006b	83 c4 04	 add	 esp, 4
  0006e	85 c0		 test	 eax, eax
  00070	0f 84 0e 01 00
	00		 je	 $LN12@CGRelation@2

; 17409: 		return;
; 17410: 
; 17411: 	if ( gObjIsConnected(&gObj[iTargetUserIndex]) == FALSE )

  00076	8b c7		 mov	 eax, edi
  00078	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0007e	89 45 08	 mov	 DWORD PTR tv276[ebp], eax
  00081	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0008d	83 c4 04	 add	 esp, 4
  00090	85 c0		 test	 eax, eax
  00092	75 17		 jne	 SHORT $LN10@CGRelation@2

; 17412: 	{
; 17413: 		GCResultSend(aIndex, 0x51, 3);

  00094	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00097	6a 03		 push	 3
  00099	6a 51		 push	 81			; 00000051H
  0009b	52		 push	 edx
  0009c	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx

; 17456: 		}
; 17457: 	}
; 17458: }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
$LN10@CGRelation@2:

; 17414: 		return;
; 17415: 	}
; 17416: 
; 17417: 	if ( aRecv->btResult == 1 )

  000ab	80 7e 05 01	 cmp	 BYTE PTR [esi+5], 1
  000af	75 33		 jne	 SHORT $LN9@CGRelation@2

; 17418: 	{
; 17419: 		if ( aRecv->btRequestType == 1 )

  000b1	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  000b4	3c 01		 cmp	 al, 1
  000b6	75 14		 jne	 SHORT $LN8@CGRelation@2

; 17420: 		{
; 17421: 			GDRelationShipReqJoin(iTargetUserIndex, aIndex, aRecv->btRelationShipType);

  000b8	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  000bc	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000bf	50		 push	 eax
  000c0	51		 push	 ecx
  000c1	57		 push	 edi
  000c2	e8 00 00 00 00	 call	 ?GDRelationShipReqJoin@@YAXHHH@Z ; GDRelationShipReqJoin
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ca	eb 68		 jmp	 SHORT $LN5@CGRelation@2
$LN8@CGRelation@2:

; 17422: 		}
; 17423: 		else if ( aRecv->btRequestType == 2 )

  000cc	3c 02		 cmp	 al, 2
  000ce	75 64		 jne	 SHORT $LN5@CGRelation@2

; 17424: 		{
; 17425: 			GDRelationShipReqBreakOff(aIndex, iTargetUserIndex, aRecv->btRelationShipType);

  000d0	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  000d4	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000d7	52		 push	 edx
  000d8	57		 push	 edi
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?GDRelationShipReqBreakOff@@YAXHHH@Z ; GDRelationShipReqBreakOff
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17426: 		}
; 17427: 	}
; 17428: 	else

  000e2	eb 50		 jmp	 SHORT $LN5@CGRelation@2
$LN9@CGRelation@2:

; 17429: 	{
; 17430: 		PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS ErrMsg ={0};
; 17431: 
; 17432: 		PHeadSetB((LPBYTE)&ErrMsg, 0xE6, sizeof(ErrMsg));

  000e4	6a 08		 push	 8
  000e6	33 c0		 xor	 eax, eax
  000e8	8d 4d f8	 lea	 ecx, DWORD PTR _ErrMsg$223937[ebp]
  000eb	68 e6 00 00 00	 push	 230			; 000000e6H
  000f0	51		 push	 ecx
  000f1	c6 45 f8 00	 mov	 BYTE PTR _ErrMsg$223937[ebp], 0
  000f5	89 45 f9	 mov	 DWORD PTR _ErrMsg$223937[ebp+1], eax
  000f8	66 89 45 fd	 mov	 WORD PTR _ErrMsg$223937[ebp+5], ax
  000fc	88 45 ff	 mov	 BYTE PTR _ErrMsg$223937[ebp+7], al
  000ff	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17433: 		ErrMsg.btResult = 0;
; 17434: 		ErrMsg.btRequestType = aRecv->btRequestType;
; 17435: 		ErrMsg.btRelationShipType = aRecv->btRelationShipType;

  00104	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  00107	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]

; 17436: 		ErrMsg.btTargetUserIndexH = aRecv->btTargetUserIndexH;

  0010b	8a 4e 06	 mov	 cl, BYTE PTR [esi+6]
  0010e	88 45 fb	 mov	 BYTE PTR _ErrMsg$223937[ebp+3], al

; 17437: 		ErrMsg.btTargetUserIndexL = aRecv->btTargetUserIndexL;
; 17438: 		ErrMsg.btResult = GUILD_ANS_CANCLE_REQUEST;
; 17439: 
; 17440: 		DataSend(iTargetUserIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00111	0f b6 45 f9	 movzx	 eax, BYTE PTR _ErrMsg$223937[ebp+1]
  00115	88 4d fe	 mov	 BYTE PTR _ErrMsg$223937[ebp+6], cl
  00118	50		 push	 eax
  00119	88 55 fc	 mov	 BYTE PTR _ErrMsg$223937[ebp+4], dl
  0011c	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  00120	8d 4d f8	 lea	 ecx, DWORD PTR _ErrMsg$223937[ebp]
  00123	51		 push	 ecx
  00124	57		 push	 edi
  00125	88 55 ff	 mov	 BYTE PTR _ErrMsg$223937[ebp+7], dl
  00128	c6 45 fd 20	 mov	 BYTE PTR _ErrMsg$223937[ebp+5], 32 ; 00000020H
  0012c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00131	83 c4 18	 add	 esp, 24			; 00000018H
$LN5@CGRelation@2:

; 17441: 	}
; 17442: 
; 17443: 	if ( gObj[aIndex].m_IfState.use )

  00134	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013a	8b 84 0b b8 11
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+4536]
  00141	be fc ff ff ff	 mov	 esi, -4			; fffffffcH
  00146	a8 03		 test	 al, 3
  00148	74 19		 je	 SHORT $LN3@CGRelation@2

; 17444: 	{
; 17445: 		if ( gObj[aIndex].m_IfState.type == 14 )

  0014a	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0014f	3d 80 03 00 00	 cmp	 eax, 896		; 00000380H
  00154	75 0d		 jne	 SHORT $LN3@CGRelation@2

; 17446: 		{
; 17447: 			gObj[aIndex].m_IfState.use = 0;

  00156	21 b4 0b b8 11
	00 00		 and	 DWORD PTR [ebx+ecx+4536], esi
  0015d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN3@CGRelation@2:

; 17448: 		}
; 17449: 	}
; 17450: 
; 17451: 	if ( gObj[iTargetUserIndex].m_IfState.use )

  00163	8b 55 08	 mov	 edx, DWORD PTR tv276[ebp]
  00166	8b 84 0a b8 11
	00 00		 mov	 eax, DWORD PTR [edx+ecx+4536]
  0016d	a8 03		 test	 al, 3
  0016f	74 13		 je	 SHORT $LN12@CGRelation@2

; 17452: 	{
; 17453: 		if ( gObj[iTargetUserIndex].m_IfState.type == 14 )

  00171	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00176	3d 80 03 00 00	 cmp	 eax, 896		; 00000380H
  0017b	75 07		 jne	 SHORT $LN12@CGRelation@2

; 17454: 		{
; 17455: 			gObj[iTargetUserIndex].m_IfState.use = 0;

  0017d	21 b4 0a b8 11
	00 00		 and	 DWORD PTR [edx+ecx+4536], esi
$LN12@CGRelation@2:
  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx

; 17456: 		}
; 17457: 	}
; 17458: }

  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z ENDP ; CGRelationShipAnsJoinBreakOff
_TEXT	ENDS
PUBLIC	?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z	; CGUnionList
EXTRN	?GDUnionListSend@@YAXHH@Z:PROC			; GDUnionListSend
; Function compile flags: /Ogtp
;	COMDAT ?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z PROC	; CGUnionList, COMDAT

; 17464: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 17465: 	if ( !OBJMAX_RANGE(aIndex))

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	78 72		 js	 SHORT $LN7@CGUnionLis
  0000b	33 c0		 xor	 eax, eax
  0000d	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 63		 je	 SHORT $LN7@CGUnionLis

; 17466: 		return;
; 17467: 
; 17468: 	if ( !PacketCheckTime(&gObj[aIndex]))

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001f	56		 push	 esi
  00020	8b f7		 mov	 esi, edi
  00022	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00028	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00031	83 c4 04	 add	 esp, 4
  00034	85 c0		 test	 eax, eax
  00036	74 44		 je	 SHORT $LN11@CGUnionLis

; 17469: 		return;
; 17470: 
; 17471: 	LPOBJ lpObj = &gObj[aIndex];

  00038	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17472: 
; 17473: 	if ( lpObj == NULL )

  0003e	74 3c		 je	 SHORT $LN11@CGUnionLis

; 17474: 	{
; 17475: 		return;
; 17476: 	}
; 17477: 
; 17478: 	if ( gObjIsConnected(&gObj[aIndex]) == FALSE )

  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00046	83 c4 04	 add	 esp, 4
  00049	85 c0		 test	 eax, eax

; 17479: 	{
; 17480: 		GCResultSend(aIndex, 0x51, 3);
; 17481: 		return;

  0004b	74 14		 je	 SHORT $LN12@CGUnionLis

; 17482: 	}
; 17483: 
; 17484: 	if ( lpObj->lpGuild == NULL )

  0004d	8b b6 18 06 00
	00		 mov	 esi, DWORD PTR [esi+1560]
  00053	85 f6		 test	 esi, esi

; 17485: 	{
; 17486: 		GCResultSend(aIndex, 0x51, 3);
; 17487: 		return;

  00055	74 0a		 je	 SHORT $LN12@CGUnionLis

; 17488: 	}
; 17489: 
; 17490: 	if ( lpObj->lpGuild->iGuildUnion == 0 )

  00057	8b b6 44 07 00
	00		 mov	 esi, DWORD PTR [esi+1860]
  0005d	85 f6		 test	 esi, esi
  0005f	75 11		 jne	 SHORT $LN1@CGUnionLis
$LN12@CGUnionLis:

; 17491: 	{
; 17492: 		GCResultSend(aIndex, 0x51, 3);

  00061	6a 03		 push	 3
  00063	6a 51		 push	 81			; 00000051H
  00065	57		 push	 edi
  00066	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	5e		 pop	 esi
  0006f	5f		 pop	 edi

; 17497: 
; 17498: }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN1@CGUnionLis:

; 17493: 		return;
; 17494: 	}
; 17495: 
; 17496: 	GDUnionListSend(aIndex, lpObj->lpGuild->iGuildUnion);

  00072	56		 push	 esi
  00073	57		 push	 edi
  00074	e8 00 00 00 00	 call	 ?GDUnionListSend@@YAXHH@Z ; GDUnionListSend
  00079	83 c4 08	 add	 esp, 8
$LN11@CGUnionLis:
  0007c	5e		 pop	 esi
$LN7@CGUnionLis:
  0007d	5f		 pop	 edi

; 17497: 
; 17498: }

  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z ENDP	; CGUnionList
_TEXT	ENDS
PUBLIC	??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@ ; `string'
PUBLIC	??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z ; CGRelationShipReqKickOutUnionMember
EXTRN	?GDRelationShipReqKickOutUnionMember@@YAXHPAD@Z:PROC ; GDRelationShipReqKickOutUnionMember
;	COMDAT ??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@
CONST	SEGMENT
??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@ DB 0a1H, 0d9H, ' Term'
	DB	'inated Guild.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@
CONST	SEGMENT
??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@ DB 0a1H, 0daH, ' Termi'
	DB	'nated User.', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -28					; size = 4
_ErrMsg$ = -24						; size = 8
_szUnionMemberGuildName$ = -16				; size = 9
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z PROC ; CGRelationShipReqKickOutUnionMember, COMDAT

; 17503: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 17504: 	if ( !OBJMAX_RANGE(aIndex))

  00015	33 db		 xor	 ebx, ebx
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 17567: 
; 17568: 	if ( !strcmp(lpObj->lpGuild->Name, szUnionMemberGuildName))

  0001b	89 75 e4	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0001e	3b f3		 cmp	 esi, ebx
  00020	0f 8c b0 01 00
	00		 jl	 $LN10@CGRelation@3

; 17504: 	if ( !OBJMAX_RANGE(aIndex))

  00026	33 c0		 xor	 eax, eax
  00028	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0002e	0f 9e c0	 setle	 al
  00031	3b c3		 cmp	 eax, ebx
  00033	0f 84 9d 01 00
	00		 je	 $LN10@CGRelation@3

; 17505: 		return;
; 17506: 
; 17507: 	if ( ::PacketCheckTime(&gObj[aIndex]) == FALSE )

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003e	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00044	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0004d	83 c4 04	 add	 esp, 4
  00050	85 c0		 test	 eax, eax
  00052	0f 84 7e 01 00
	00		 je	 $LN10@CGRelation@3

; 17508: 		return;
; 17509: 
; 17510: 	LPOBJ lpObj = &gObj[aIndex];

  00058	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17511: 
; 17512: 	if ( lpObj == NULL )

  0005e	3b f3		 cmp	 esi, ebx
  00060	0f 84 70 01 00
	00		 je	 $LN10@CGRelation@3

; 17513: 		return;
; 17514: 
; 17515: 	if ( gObjIsConnected(&gObj[aIndex]) == FALSE )

  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0006c	83 c4 04	 add	 esp, 4
  0006f	85 c0		 test	 eax, eax
  00071	75 2c		 jne	 SHORT $LN6@CGRelation@3

; 17516: 	{
; 17517: 		GCResultSend(aIndex, 0x51, 3);

  00073	8b 75 e4	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00076	6a 03		 push	 3
  00078	6a 51		 push	 81			; 00000051H
  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 17518: 		MsgOutput(aIndex, " Terminated User.");

  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@
  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0008b	83 c4 14	 add	 esp, 20			; 00000014H
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx

; 17577: }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN6@CGRelation@3:

; 17519: 		return;
; 17520: 	}
; 17521: 
; 17522: 	if ( lpObj->lpGuild == NULL )

  0009f	39 9e 18 06 00
	00		 cmp	 DWORD PTR [esi+1560], ebx
  000a5	75 2c		 jne	 SHORT $LN5@CGRelation@3

; 17523: 	{
; 17524: 		GCResultSend(aIndex, 0x51, 3);

  000a7	8b 75 e4	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  000aa	6a 03		 push	 3
  000ac	6a 51		 push	 81			; 00000051H
  000ae	56		 push	 esi
  000af	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 17525: 		MsgOutput(aIndex, " Terminated Guild.");

  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@
  000b9	56		 push	 esi
  000ba	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000bf	83 c4 14	 add	 esp, 20			; 00000014H
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx

; 17577: }

  000c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c8	33 cd		 xor	 ecx, ebp
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
$LN5@CGRelation@3:

; 17526: 		return;
; 17527: 	}
; 17528: 
; 17529: 	PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS ErrMsg = {0};

  000d3	33 c0		 xor	 eax, eax

; 17530: 
; 17531: 	PHeadSetB((LPBYTE)&ErrMsg, 0xE6, sizeof(ErrMsg));

  000d5	6a 08		 push	 8
  000d7	89 45 e9	 mov	 DWORD PTR _ErrMsg$[ebp+1], eax
  000da	66 89 45 ed	 mov	 WORD PTR _ErrMsg$[ebp+5], ax
  000de	88 45 ef	 mov	 BYTE PTR _ErrMsg$[ebp+7], al
  000e1	8d 45 e8	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  000e4	68 e6 00 00 00	 push	 230			; 000000e6H
  000e9	50		 push	 eax
  000ea	88 5d e8	 mov	 BYTE PTR _ErrMsg$[ebp], bl
  000ed	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17532: 	ErrMsg.btResult = 0;
; 17533: 	ErrMsg.btRequestType = 2;
; 17534: 	ErrMsg.btRelationShipType = 1;

  000f2	c6 45 eb 01	 mov	 BYTE PTR _ErrMsg$[ebp+3], 1
  000f6	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _ErrMsg$[ebp+4], 2

; 17535: 	ErrMsg.btTargetUserIndexH = 0;
; 17536: 	ErrMsg.btTargetUserIndexL = 0;
; 17537: 
; 17538: #if (ENABLETEST_ARCA == 1)
; 17539: 	int iArcaBattleState = g_ArcaBattle.GetState();
; 17540: 
; 17541: 	if( iArcaBattleState > AB_STATE_CLOSED && iArcaBattleState < AB_STATE_CLOSE )
; 17542: 	{
; 17543: 		ErrMsg.btResult = 33;
; 17544: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 17545: 		return;
; 17546: 	}
; 17547: #endif
; 17548: 
; 17549: 	if ( lpObj->lpGuild->iGuildUnion == 0 )

  000fd	8b 8e 18 06 00
	00		 mov	 ecx, DWORD PTR [esi+1560]
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH
  00106	39 99 44 07 00
	00		 cmp	 DWORD PTR [ecx+1860], ebx
  0010c	75 16		 jne	 SHORT $LN4@CGRelation@3

; 17550: 	{
; 17551: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_UNION;
; 17552: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0010e	0f b6 55 e9	 movzx	 edx, BYTE PTR _ErrMsg$[ebp+1]
  00112	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00115	52		 push	 edx
  00116	8d 45 e8	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00119	50		 push	 eax
  0011a	c6 45 ed 19	 mov	 BYTE PTR _ErrMsg$[ebp+5], 25 ; 00000019H
  0011e	51		 push	 ecx

; 17553: 
; 17554: 		return;

  0011f	e9 aa 00 00 00	 jmp	 $LN18@CGRelation@3
$LN4@CGRelation@3:

; 17555: 	}
; 17556: 
; 17557: 	if ( lpObj->GuildStatus != GUILD_MASTER || lpObj->lpGuild->Number != lpObj->lpGuild->iGuildUnion)

  00124	81 be 28 06 00
	00 80 00 00 00	 cmp	 DWORD PTR [esi+1576], 128 ; 00000080H
  0012e	0f 85 89 00 00
	00		 jne	 $LN2@CGRelation@3
  00134	8b c1		 mov	 eax, ecx
  00136	8b 10		 mov	 edx, DWORD PTR [eax]
  00138	3b 90 44 07 00
	00		 cmp	 edx, DWORD PTR [eax+1860]
  0013e	0f 85 79 00 00
	00		 jne	 $LN2@CGRelation@3

; 17561: 
; 17562: 		return;
; 17563: 	}
; 17564: 
; 17565: 	char szUnionMemberGuildName[MAX_GUILD_LEN+1] = {0};
; 17566: 	memcpy(szUnionMemberGuildName, aRecv->szTargetGuildName, MAX_GUILD_LEN);

  00144	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00147	33 c0		 xor	 eax, eax
  00149	89 45 f1	 mov	 DWORD PTR _szUnionMemberGuildName$[ebp+1], eax
  0014c	89 45 f5	 mov	 DWORD PTR _szUnionMemberGuildName$[ebp+5], eax
  0014f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00152	89 45 f0	 mov	 DWORD PTR _szUnionMemberGuildName$[ebp], eax
  00155	89 4d f4	 mov	 DWORD PTR _szUnionMemberGuildName$[ebp+4], ecx

; 17567: 
; 17568: 	if ( !strcmp(lpObj->lpGuild->Name, szUnionMemberGuildName))

  00158	8b 86 18 06 00
	00		 mov	 eax, DWORD PTR [esi+1560]
  0015e	8d 4d f0	 lea	 ecx, DWORD PTR _szUnionMemberGuildName$[ebp]
  00161	83 c0 04	 add	 eax, 4
$LL14@CGRelation@3:
  00164	8a 10		 mov	 dl, BYTE PTR [eax]
  00166	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00168	75 1a		 jne	 SHORT $LN15@CGRelation@3
  0016a	3a d3		 cmp	 dl, bl
  0016c	74 12		 je	 SHORT $LN16@CGRelation@3
  0016e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00171	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00174	75 0e		 jne	 SHORT $LN15@CGRelation@3
  00176	83 c0 02	 add	 eax, 2
  00179	83 c1 02	 add	 ecx, 2
  0017c	3a d3		 cmp	 dl, bl
  0017e	75 e4		 jne	 SHORT $LL14@CGRelation@3
$LN16@CGRelation@3:
  00180	33 c0		 xor	 eax, eax
  00182	eb 05		 jmp	 SHORT $LN17@CGRelation@3
$LN15@CGRelation@3:
  00184	1b c0		 sbb	 eax, eax
  00186	83 d8 ff	 sbb	 eax, -1
$LN17@CGRelation@3:
  00189	3b c3		 cmp	 eax, ebx
  0018b	75 0f		 jne	 SHORT $LN1@CGRelation@3

; 17569: 	{
; 17570: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 17571: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0018d	0f b6 55 e9	 movzx	 edx, BYTE PTR _ErrMsg$[ebp+1]
  00191	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00194	52		 push	 edx
  00195	8d 45 e8	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00198	50		 push	 eax
  00199	51		 push	 ecx

; 17572: 
; 17573: 		return;

  0019a	eb 2e		 jmp	 SHORT $LN19@CGRelation@3
$LN1@CGRelation@3:

; 17574: 	}
; 17575: 
; 17576: 	GDRelationShipReqKickOutUnionMember(aIndex, szUnionMemberGuildName);

  0019c	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0019f	8d 55 f0	 lea	 edx, DWORD PTR _szUnionMemberGuildName$[ebp]
  001a2	52		 push	 edx
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?GDRelationShipReqKickOutUnionMember@@YAXHPAD@Z ; GDRelationShipReqKickOutUnionMember
  001a9	83 c4 08	 add	 esp, 8
  001ac	5f		 pop	 edi
  001ad	5e		 pop	 esi
  001ae	5b		 pop	 ebx

; 17577: }

  001af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b2	33 cd		 xor	 ecx, ebp
  001b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c3		 ret	 0
$LN2@CGRelation@3:

; 17560: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  001bd	0f b6 4d e9	 movzx	 ecx, BYTE PTR _ErrMsg$[ebp+1]
  001c1	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  001c4	51		 push	 ecx
  001c5	8d 55 e8	 lea	 edx, DWORD PTR _ErrMsg$[ebp]
  001c8	52		 push	 edx
  001c9	50		 push	 eax
$LN19@CGRelation@3:

; 17558: 	{
; 17559: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;

  001ca	c6 45 ed 11	 mov	 BYTE PTR _ErrMsg$[ebp+5], 17 ; 00000011H
$LN18@CGRelation@3:

; 17560: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  001ce	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@CGRelation@3:

; 17577: }

  001d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d9	5f		 pop	 edi
  001da	5e		 pop	 esi
  001db	33 cd		 xor	 ecx, ebp
  001dd	5b		 pop	 ebx
  001de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c3		 ret	 0
?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z ENDP ; CGRelationShipReqKickOutUnionMember
_TEXT	ENDS
PUBLIC	??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@ ; `string'
PUBLIC	?GCAnsMapSvrAuth@@YAXHH@Z			; GCAnsMapSvrAuth
;	COMDAT ??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@
CONST	SEGMENT
??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@ DB '[Ma'
	DB	'pServerMng] Packet Error JG [0x7B] - Index out of bound : %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCAnsMapSvrAuth@@YAXHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 5
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
?GCAnsMapSvrAuth@@YAXHH@Z PROC				; GCAnsMapSvrAuth, COMDAT

; 17681: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 17682: 	if ( !OBJMAX_RANGE(iIndex) )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	78 0f		 js	 SHORT $LN6@GCAnsMapSv
  0000e	33 c0		 xor	 eax, eax
  00010	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 16		 jne	 SHORT $LN1@GCAnsMapSv
$LN6@GCAnsMapSv:

; 17683: 	{
; 17684: 		LogAddC(2,"[MapServerMng] Packet Error JG [0x7B] - Index out of bound : %d",iIndex);

  0001d	56		 push	 esi
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@
  00023	6a 02		 push	 2
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	5e		 pop	 esi

; 17694: }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN1@GCAnsMapSv:

; 17685: 		return;
; 17686: 	}
; 17687: 
; 17688: 	PMSG_ANS_MAPSERVERAUTH pMsgResult;
; 17689: 
; 17690: 	PHeadSubSetB((LPBYTE)&pMsgResult, 0xB1, 0x01, sizeof(pMsgResult));

  00033	6a 05		 push	 5
  00035	6a 01		 push	 1
  00037	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0003a	68 b1 00 00 00	 push	 177			; 000000b1H
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 17691: 	pMsgResult.iResult = iResult;
; 17692: 
; 17693: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00045	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsgResult$[ebp+1]
  00049	8a 4d 0c	 mov	 cl, BYTE PTR _iResult$[ebp]
  0004c	52		 push	 edx
  0004d	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00050	50		 push	 eax
  00051	56		 push	 esi
  00052	88 4d fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], cl
  00055	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005d	5e		 pop	 esi

; 17694: }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?GCAnsMapSvrAuth@@YAXHH@Z ENDP				; GCAnsMapSvrAuth
_TEXT	ENDS
PUBLIC	?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z ; CGReqCastleSiegeState
EXTRN	?GS_GDReqOwnerGuildMaster@@YAXHH@Z:PROC		; GS_GDReqOwnerGuildMaster
EXTRN	?g_MapServerManager@@3VCMapServerManager@@A:BYTE ; g_MapServerManager
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z PROC ; CGReqCastleSiegeState, COMDAT

; 17699: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17700: #if (GS_CASTLE==1)
; 17701: 	GS_GDReqOwnerGuildMaster(g_MapServerManager.GetMapSvrGroup(),iIndex);

  00003	a1 00 6b 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92928
  00008	85 c0		 test	 eax, eax
  0000a	74 13		 je	 SHORT $LN3@CGReqCastl
  0000c	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00013	51		 push	 ecx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?GS_GDReqOwnerGuildMaster@@YAXHH@Z ; GS_GDReqOwnerGuildMaster
  0001a	83 c4 08	 add	 esp, 8

; 17702: #endif
; 17703: }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0

; 17700: #if (GS_CASTLE==1)
; 17701: 	GS_GDReqOwnerGuildMaster(g_MapServerManager.GetMapSvrGroup(),iIndex);

$LN3@CGReqCastl:
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00022	83 c8 ff	 or	 eax, -1
  00025	51		 push	 ecx
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?GS_GDReqOwnerGuildMaster@@YAXHH@Z ; GS_GDReqOwnerGuildMaster
  0002c	83 c4 08	 add	 esp, 8

; 17702: #endif
; 17703: }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z ENDP ; CGReqCastleSiegeState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsCastleSiegeState@@YAXHHPAD0@Z		; GCAnsCastleSiegeState
EXTRN	?GetCurRemainSec@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetCurRemainSec
EXTRN	?GetCastleLeftSiegeDate@CCastleSiege@@QAE?AU_SYSTEMTIME@@XZ:PROC ; CCastleSiege::GetCastleLeftSiegeDate
EXTRN	?GetCastleStateTerm@CCastleSiege@@QAEHPAU_SYSTEMTIME@@0@Z:PROC ; CCastleSiege::GetCastleStateTerm
EXTRN	?GetCastleState@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetCastleState
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCastleSiegeState@@YAXHHPAD0@Z
_TEXT	SEGMENT
_tmSiegeStartDate$ = -120				; size = 16
_iCastleState$ = -104					; size = 4
$T224064 = -100						; size = 16
_tmStateStartDate$ = -84				; size = 16
_tmStateEndDate$ = -68					; size = 16
_pMsgResult$ = -52					; size = 46
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpszGuildName$ = 16					; size = 4
_lpszGuildMaster$ = 20					; size = 4
?GCAnsCastleSiegeState@@YAXHHPAD0@Z PROC		; GCAnsCastleSiegeState, COMDAT

; 17734: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _lpszGuildName$[ebp]
  00013	8b 45 14	 mov	 eax, DWORD PTR _lpszGuildMaster$[ebp]

; 17735: #if (GS_CASTLE==1)
; 17736: 
; 17737: 	if(lpszGuildName == NULL || lpszGuildMaster == NULL)

  00016	85 c9		 test	 ecx, ecx
  00018	0f 84 60 01 00
	00		 je	 $LN2@GCAnsCastl
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 58 01 00
	00		 je	 $LN2@GCAnsCastl

; 17738: 		return;
; 17739: 
; 17740: 	PMSG_ANS_CASTLESIEGESTATE pMsgResult;
; 17741: 
; 17742: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x00,sizeof(pMsgResult));
; 17743: 	pMsgResult.btResult = iResult;

  00026	8a 55 0c	 mov	 dl, BYTE PTR _iResult$[ebp]
  00029	88 55 d0	 mov	 BYTE PTR _pMsgResult$[ebp+4], dl

; 17744: 
; 17745: 	memcpy(pMsgResult.cOwnerGuild,lpszGuildName,sizeof(pMsgResult.cOwnerGuild));

  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00031	89 4d e8	 mov	 DWORD PTR _pMsgResult$[ebp+28], ecx

; 17746: 	memcpy(pMsgResult.cOwnerGuildMaster,lpszGuildMaster,sizeof(pMsgResult.cOwnerGuildMaster));

  00034	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00037	89 55 e4	 mov	 DWORD PTR _pMsgResult$[ebp+24], edx
  0003a	8b 10		 mov	 edx, DWORD PTR [eax]
  0003c	89 4d f0	 mov	 DWORD PTR _pMsgResult$[ebp+36], ecx

; 17747: 
; 17748: 	_SYSTEMTIME tmStateStartDate = {0};
; 17749: 	_SYSTEMTIME tmStateEndDate = {0};

  0003f	33 c9		 xor	 ecx, ecx
  00041	89 55 ec	 mov	 DWORD PTR _pMsgResult$[ebp+32], edx
  00044	66 8b 50 08	 mov	 dx, WORD PTR [eax+8]
  00048	33 c0		 xor	 eax, eax
  0004a	53		 push	 ebx
  0004b	66 89 4d bc	 mov	 WORD PTR _tmStateEndDate$[ebp], cx
  0004f	56		 push	 esi

; 17750: 	_SYSTEMTIME tmSiegeStartDate = {0};
; 17751: 
; 17752: 	int iCastleState = g_CastleSiege.GetCastleState();

  00050	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00055	c7 45 cc c1 2e
	b2 00		 mov	 DWORD PTR _pMsgResult$[ebp], 11677377 ; 00b22ec1H
  0005c	66 89 55 f4	 mov	 WORD PTR _pMsgResult$[ebp+40], dx
  00060	66 89 45 ac	 mov	 WORD PTR _tmStateStartDate$[ebp], ax
  00064	89 45 ae	 mov	 DWORD PTR _tmStateStartDate$[ebp+2], eax
  00067	89 45 b2	 mov	 DWORD PTR _tmStateStartDate$[ebp+6], eax
  0006a	89 45 b6	 mov	 DWORD PTR _tmStateStartDate$[ebp+10], eax
  0006d	66 89 45 ba	 mov	 WORD PTR _tmStateStartDate$[ebp+14], ax
  00071	89 45 be	 mov	 DWORD PTR _tmStateEndDate$[ebp+2], eax
  00074	89 45 c2	 mov	 DWORD PTR _tmStateEndDate$[ebp+6], eax
  00077	89 45 c6	 mov	 DWORD PTR _tmStateEndDate$[ebp+10], eax
  0007a	66 89 45 ca	 mov	 WORD PTR _tmStateEndDate$[ebp+14], ax
  0007e	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 17753: 
; 17754: 	int bRETVAL = g_CastleSiege.GetCastleStateTerm(&tmStateStartDate,&tmStateEndDate);

  00083	8d 55 bc	 lea	 edx, DWORD PTR _tmStateEndDate$[ebp]
  00086	89 45 98	 mov	 DWORD PTR _iCastleState$[ebp], eax
  00089	52		 push	 edx
  0008a	8d 45 ac	 lea	 eax, DWORD PTR _tmStateStartDate$[ebp]
  0008d	50		 push	 eax
  0008e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00093	e8 00 00 00 00	 call	 ?GetCastleStateTerm@CCastleSiege@@QAEHPAU_SYSTEMTIME@@0@Z ; CCastleSiege::GetCastleStateTerm

; 17755: 
; 17756: 	tmSiegeStartDate = g_CastleSiege.GetCastleLeftSiegeDate();

  00098	8d 4d 9c	 lea	 ecx, DWORD PTR $T224064[ebp]
  0009b	51		 push	 ecx
  0009c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000a1	8b f0		 mov	 esi, eax
  000a3	e8 00 00 00 00	 call	 ?GetCastleLeftSiegeDate@CCastleSiege@@QAE?AU_SYSTEMTIME@@XZ ; CCastleSiege::GetCastleLeftSiegeDate
  000a8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ab	8b 18		 mov	 ebx, DWORD PTR [eax]
  000ad	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b0	89 55 8c	 mov	 DWORD PTR _tmSiegeStartDate$[ebp+4], edx
  000b3	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000b6	89 5d 88	 mov	 DWORD PTR _tmSiegeStartDate$[ebp], ebx
  000b9	89 4d 90	 mov	 DWORD PTR _tmSiegeStartDate$[ebp+8], ecx
  000bc	89 55 94	 mov	 DWORD PTR _tmSiegeStartDate$[ebp+12], edx

; 17757: 
; 17758: 	if(bRETVAL == 0)

  000bf	85 f6		 test	 esi, esi
  000c1	75 07		 jne	 SHORT $LN1@GCAnsCastl

; 17759: 		iCastleState = -1;

  000c3	c7 45 98 ff ff
	ff ff		 mov	 DWORD PTR _iCastleState$[ebp], -1
$LN1@GCAnsCastl:

; 17760: 
; 17761: 	int iRemainTime = g_CastleSiege.GetCurRemainSec();

  000ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000cf	e8 00 00 00 00	 call	 ?GetCurRemainSec@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCurRemainSec

; 17762: 	pMsgResult.cCastleSiegeState = iCastleState;

  000d4	0f b6 4d 98	 movzx	 ecx, BYTE PTR _iCastleState$[ebp]

; 17763: 
; 17764: 	pMsgResult.btStartYearH = SET_NUMBERH(tmStateStartDate.wYear);

  000d8	8b 55 ac	 mov	 edx, DWORD PTR _tmStateStartDate$[ebp]
  000db	c1 ea 08	 shr	 edx, 8
  000de	88 4d d1	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl

; 17765: 	pMsgResult.btStartYearL = SET_NUMBERL(tmStateStartDate.wYear);

  000e1	0f b6 4d ac	 movzx	 ecx, BYTE PTR _tmStateStartDate$[ebp]
  000e5	88 55 d2	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl

; 17766: 	pMsgResult.btStartMonth = (BYTE)tmStateStartDate.wMonth;

  000e8	0f b6 55 ae	 movzx	 edx, BYTE PTR _tmStateStartDate$[ebp+2]
  000ec	88 4d d3	 mov	 BYTE PTR _pMsgResult$[ebp+7], cl

; 17767: 	pMsgResult.btStartDay = (BYTE)tmStateStartDate.wDay;

  000ef	0f b6 4d b2	 movzx	 ecx, BYTE PTR _tmStateStartDate$[ebp+6]
  000f3	88 55 d4	 mov	 BYTE PTR _pMsgResult$[ebp+8], dl

; 17768: 	pMsgResult.btStartHour = (BYTE)tmStateStartDate.wHour;

  000f6	0f b6 55 b4	 movzx	 edx, BYTE PTR _tmStateStartDate$[ebp+8]
  000fa	88 4d d5	 mov	 BYTE PTR _pMsgResult$[ebp+9], cl

; 17769: 	pMsgResult.btStartMinute = (BYTE)tmStateStartDate.wMinute;

  000fd	0f b6 4d b6	 movzx	 ecx, BYTE PTR _tmStateStartDate$[ebp+10]
  00101	88 55 d6	 mov	 BYTE PTR _pMsgResult$[ebp+10], dl

; 17770: 
; 17771: 	pMsgResult.btEndYearH = SET_NUMBERH(tmStateEndDate.wYear);

  00104	8b 55 bc	 mov	 edx, DWORD PTR _tmStateEndDate$[ebp]
  00107	c1 ea 08	 shr	 edx, 8
  0010a	88 4d d7	 mov	 BYTE PTR _pMsgResult$[ebp+11], cl

; 17772: 	pMsgResult.btEndYearL = SET_NUMBERL(tmStateEndDate.wYear);

  0010d	0f b6 4d bc	 movzx	 ecx, BYTE PTR _tmStateEndDate$[ebp]
  00111	88 55 d8	 mov	 BYTE PTR _pMsgResult$[ebp+12], dl

; 17773: 	pMsgResult.btEndMonth = (BYTE)tmStateEndDate.wMonth;

  00114	0f b6 55 be	 movzx	 edx, BYTE PTR _tmStateEndDate$[ebp+2]
  00118	88 4d d9	 mov	 BYTE PTR _pMsgResult$[ebp+13], cl

; 17774: 	pMsgResult.btEndDay = (BYTE)tmStateEndDate.wDay;

  0011b	0f b6 4d c2	 movzx	 ecx, BYTE PTR _tmStateEndDate$[ebp+6]
  0011f	88 55 da	 mov	 BYTE PTR _pMsgResult$[ebp+14], dl

; 17775: 	pMsgResult.btEndHour = (BYTE)tmStateEndDate.wHour;

  00122	0f b6 55 c4	 movzx	 edx, BYTE PTR _tmStateEndDate$[ebp+8]
  00126	88 4d db	 mov	 BYTE PTR _pMsgResult$[ebp+15], cl

; 17776: 	pMsgResult.btEndMinute = (BYTE)tmStateEndDate.wMinute;

  00129	0f b6 4d c6	 movzx	 ecx, BYTE PTR _tmStateEndDate$[ebp+10]
  0012d	88 55 dc	 mov	 BYTE PTR _pMsgResult$[ebp+16], dl
  00130	88 4d dd	 mov	 BYTE PTR _pMsgResult$[ebp+17], cl

; 17777: 
; 17778: 	pMsgResult.btSiegeStartYearH = SET_NUMBERH(tmSiegeStartDate.wYear);
; 17779: 	pMsgResult.btSiegeStartYearL = SET_NUMBERL(tmSiegeStartDate.wYear);
; 17780: 	pMsgResult.btSiegeStartMonth = (BYTE)tmSiegeStartDate.wMonth;

  00133	0f b6 4d 8a	 movzx	 ecx, BYTE PTR _tmSiegeStartDate$[ebp+2]
  00137	8b d3		 mov	 edx, ebx
  00139	c1 ea 08	 shr	 edx, 8
  0013c	88 55 de	 mov	 BYTE PTR _pMsgResult$[ebp+18], dl

; 17781: 	pMsgResult.btSiegeStartDay = (BYTE)tmSiegeStartDate.wDay;

  0013f	0f b6 55 8e	 movzx	 edx, BYTE PTR _tmSiegeStartDate$[ebp+6]
  00143	88 4d e0	 mov	 BYTE PTR _pMsgResult$[ebp+20], cl

; 17782: 	pMsgResult.btSiegeStartHour = (BYTE)tmSiegeStartDate.wHour;

  00146	0f b6 4d 90	 movzx	 ecx, BYTE PTR _tmSiegeStartDate$[ebp+8]
  0014a	88 55 e1	 mov	 BYTE PTR _pMsgResult$[ebp+21], dl

; 17783: 	pMsgResult.btSiegeStartMinute = (BYTE)tmSiegeStartDate.wMinute;

  0014d	0f b6 55 92	 movzx	 edx, BYTE PTR _tmSiegeStartDate$[ebp+10]

; 17784: 
; 17785: 	pMsgResult.btCurRemainTime[0] = ((iRemainTime << 16) & 0xFFFF) << 8;
; 17786: 	pMsgResult.btCurRemainTime[1] = ((iRemainTime << 16) & 0xFFFF) & 0xFF;
; 17787: 	pMsgResult.btCurRemainTime[2] = ((iRemainTime & 0xFFFF) & 0xFFFF) << 8;
; 17788: 	pMsgResult.btCurRemainTime[3] = ((iRemainTime & 0xFFFF) & 0xFFFF) & 0xFF;

  00151	88 45 f9	 mov	 BYTE PTR _pMsgResult$[ebp+45], al

; 17789: 
; 17790: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00154	0f b6 45 cd	 movzx	 eax, BYTE PTR _pMsgResult$[ebp+1]
  00158	88 4d e2	 mov	 BYTE PTR _pMsgResult$[ebp+22], cl
  0015b	50		 push	 eax
  0015c	8d 4d cc	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
  0015f	88 55 e3	 mov	 BYTE PTR _pMsgResult$[ebp+23], dl
  00162	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00165	51		 push	 ecx
  00166	52		 push	 edx
  00167	88 5d df	 mov	 BYTE PTR _pMsgResult$[ebp+19], bl
  0016a	66 c7 45 f6 00
	00		 mov	 WORD PTR _pMsgResult$[ebp+42], 0
  00170	c6 45 f8 00	 mov	 BYTE PTR _pMsgResult$[ebp+44], 0
  00174	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017c	5e		 pop	 esi
  0017d	5b		 pop	 ebx
$LN2@GCAnsCastl:

; 17791: #endif
; 17792: }

  0017e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00181	33 cd		 xor	 ecx, ebp
  00183	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
?GCAnsCastleSiegeState@@YAXHHPAD0@Z ENDP		; GCAnsCastleSiegeState
_TEXT	ENDS
PUBLIC	??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsRegCastleSiege@@YAXHHPAD@Z		; GCAnsRegCastleSiege
;	COMDAT ??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\include\prodef.h
CONST	SEGMENT
??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@ DB '['
	DB	'CastleSiege] [%s][%s] Registered Castle Siege (GUILD:%s) - Re'
	DB	'sult:%d', 00H				; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?GCAnsRegCastleSiege@@YAXHHPAD@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpszGuildName$ = 16					; size = 4
?GCAnsRegCastleSiege@@YAXHHPAD@Z PROC			; GCAnsRegCastleSiege, COMDAT

; 17837: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _lpszGuildName$[ebp]
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 17838: #if (GS_CASTLE==1)
; 17839: 	if(lpszGuildName == NULL)

  00017	85 c0		 test	 eax, eax
  00019	74 73		 je	 SHORT $LN1@GCAnsRegCa

; 17840: 		return;
; 17841: 
; 17842: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  0001b	85 f6		 test	 esi, esi
  0001d	78 6f		 js	 SHORT $LN1@GCAnsRegCa
  0001f	33 c9		 xor	 ecx, ecx
  00021	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00027	0f 9e c1	 setle	 cl
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 60		 je	 SHORT $LN1@GCAnsRegCa

; 17843: 		return;
; 17844: 
; 17845: 	PMSG_ANS_REGCASTLESIEGE pMsgResult;
; 17846: 
; 17847: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xb2,0x01,sizeof(pMsgResult));
; 17848: 	pMsgResult.btResult = iResult;
; 17849: 
; 17850: 	memcpy(pMsgResult.szGuildName,lpszGuildName,sizeof(pMsgResult.szGuildName));

  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00033	53		 push	 ebx
  00034	8b 5d 0c	 mov	 ebx, DWORD PTR _iResult$[ebp]

; 17851: 
; 17852: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00037	6a 0d		 push	 13			; 0000000dH
  00039	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0003c	50		 push	 eax
  0003d	56		 push	 esi
  0003e	c7 45 ec c1 0d
	b2 01		 mov	 DWORD PTR _pMsgResult$[ebp], 28446145 ; 01b20dc1H
  00045	88 5d f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], bl
  00048	89 4d f1	 mov	 DWORD PTR _pMsgResult$[ebp+5], ecx
  0004b	89 55 f5	 mov	 DWORD PTR _pMsgResult$[ebp+9], edx
  0004e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17853: 
; 17854: 	if(gObjIsConnected(iIndex))

  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	85 c0		 test	 eax, eax
  0005e	74 2d		 je	 SHORT $LN10@GCAnsRegCa

; 17855: 	{
; 17856: 		LogAddTD("[CastleSiege] [%s][%s] Registered Castle Siege (GUILD:%s) - Result:%d",
; 17857: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,iResult);

  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0006c	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0006f	53		 push	 ebx
  00070	8d 90 1c 06 00
	00		 lea	 edx, DWORD PTR [eax+1564]
  00076	52		 push	 edx
  00077	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  0007a	51		 push	 ecx
  0007b	83 c0 52	 add	 eax, 82			; 00000052H
  0007e	50		 push	 eax
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0008a	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@GCAnsRegCa:
  0008d	5b		 pop	 ebx
$LN1@GCAnsRegCa:

; 17858: 	}
; 17859: #endif
; 17860: }

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00091	33 cd		 xor	 ecx, ebp
  00093	5e		 pop	 esi
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?GCAnsRegCastleSiege@@YAXHHPAD@Z ENDP			; GCAnsRegCastleSiege
_TEXT	ENDS
PUBLIC	??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z		; GCAnsGiveUpCastleSiege
;	COMDAT ??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\include\prodef.h
CONST	SEGMENT
??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@ DB '['
	DB	'CastleSiege] [%s][%s] GiveUp Castle Siege (GUILD:%s) - Result'
	DB	':%d', 00H					; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 14
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_bGiveUp$ = 16						; size = 1
_iMarkCount$ = 20					; size = 4
_lpszGuildName$ = 24					; size = 4
?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z PROC		; GCAnsGiveUpCastleSiege, COMDAT

; 17892: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 18	 mov	 eax, DWORD PTR _lpszGuildName$[ebp]
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 17893: #if (GS_CASTLE==1)
; 17894: 	if(lpszGuildName == NULL)

  00017	85 c0		 test	 eax, eax
  00019	0f 84 dd 00 00
	00		 je	 $LN1@GCAnsGiveU

; 17895: 		return;
; 17896: 
; 17897: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  0001f	85 f6		 test	 esi, esi
  00021	0f 88 d5 00 00
	00		 js	 $LN1@GCAnsGiveU
  00027	33 c9		 xor	 ecx, ecx
  00029	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0002f	0f 9e c1	 setle	 cl
  00032	85 c9		 test	 ecx, ecx
  00034	0f 84 c2 00 00
	00		 je	 $LN1@GCAnsGiveU

; 17898: 		return;
; 17899: 
; 17900: 	PMSG_ANS_GIVEUPCASTLESIEGE pMsgResult;
; 17901: 
; 17902: 	pMsgResult.h.set((BYTE *)&pMsgResult,0xB2,0x02,sizeof(pMsgResult));
; 17903: 
; 17904: 	pMsgResult.btResult = iResult;
; 17905: 	pMsgResult.btIsGiveUp = bGiveUp;
; 17906: 	memcpy(pMsgResult.szGuildName,lpszGuildName,sizeof(pMsgResult.szGuildName));

  0003a	8b 10		 mov	 edx, DWORD PTR [eax]
  0003c	8a 4d 10	 mov	 cl, BYTE PTR _bGiveUp$[ebp]
  0003f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00042	53		 push	 ebx
  00043	8b 5d 0c	 mov	 ebx, DWORD PTR _iResult$[ebp]
  00046	c7 45 ec c1 0e
	b2 02		 mov	 DWORD PTR _pMsgResult$[ebp], 45223617 ; 02b20ec1H
  0004d	88 5d f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], bl
  00050	88 4d f1	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  00053	89 55 f2	 mov	 DWORD PTR _pMsgResult$[ebp+6], edx
  00056	89 45 f6	 mov	 DWORD PTR _pMsgResult$[ebp+10], eax

; 17907: 
; 17908: 	if(pMsgResult.btResult == 1 && iMarkCount > 0)

  00059	80 fb 01	 cmp	 bl, 1
  0005c	75 54		 jne	 SHORT $LN3@GCAnsGiveU
  0005e	8b 4d 14	 mov	 ecx, DWORD PTR _iMarkCount$[ebp]
  00061	85 c9		 test	 ecx, ecx
  00063	7e 4d		 jle	 SHORT $LN3@GCAnsGiveU

; 17909: 	{
; 17910: 		gObj[iIndex].Money += iMarkCount * 3000;

  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006b	69 c9 b8 0b 00
	00		 imul	 ecx, 3000		; 00000bb8H
  00071	8b c6		 mov	 eax, esi
  00073	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00079	01 8c 10 cc 00
	00 00		 add	 DWORD PTR [eax+edx+204], ecx

; 17911: 
; 17912: 		if(gObj[iIndex].Money > 2000000000)

  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00086	ba 00 94 35 77	 mov	 edx, 2000000000		; 77359400H
  0008b	39 94 08 cc 00
	00 00		 cmp	 DWORD PTR [eax+ecx+204], edx
  00092	7e 0d		 jle	 SHORT $LN2@GCAnsGiveU

; 17913: 		{
; 17914: 			gObj[iIndex].Money = 2000000000;

  00094	89 94 08 cc 00
	00 00		 mov	 DWORD PTR [eax+ecx+204], edx
  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN2@GCAnsGiveU:

; 17915: 		}
; 17916: 
; 17917: 		GCMoneySend(iIndex,gObj[iIndex].Money);

  000a1	8b 8c 08 cc 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+204]
  000a8	51		 push	 ecx
  000a9	56		 push	 esi
  000aa	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  000af	83 c4 08	 add	 esp, 8
$LN3@GCAnsGiveU:

; 17918: 	}
; 17919: 
; 17920: 	DataSend(iIndex,(BYTE *)&pMsgResult,pMsgResult.h.size);

  000b2	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsgResult$[ebp+1]
  000b6	52		 push	 edx
  000b7	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  000ba	50		 push	 eax
  000bb	56		 push	 esi
  000bc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17921: 
; 17922: 	if(gObjIsConnected(iIndex))

  000c1	56		 push	 esi
  000c2	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000c7	83 c4 10	 add	 esp, 16			; 00000010H
  000ca	85 c0		 test	 eax, eax
  000cc	74 2d		 je	 SHORT $LN12@GCAnsGiveU

; 17923: 	{
; 17924: 		LogAddTD("[CastleSiege] [%s][%s] GiveUp Castle Siege (GUILD:%s) - Result:%d",
; 17925: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,iResult);

  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d4	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  000da	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  000dd	53		 push	 ebx
  000de	8d 90 1c 06 00
	00		 lea	 edx, DWORD PTR [eax+1564]
  000e4	52		 push	 edx
  000e5	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  000e8	51		 push	 ecx
  000e9	83 c0 52	 add	 eax, 82			; 00000052H
  000ec	50		 push	 eax
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000f8	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@GCAnsGiveU:
  000fb	5b		 pop	 ebx
$LN1@GCAnsGiveU:

; 17926: 	}
; 17927: #endif
; 17928: }

  000fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ff	33 cd		 xor	 ecx, ebp
  00101	5e		 pop	 esi
  00102	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z ENDP		; GCAnsGiveUpCastleSiege
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z ; CGReqGuildRegInfo
EXTRN	?GS_GDReqGuildMarkRegInfo@@YAXHH@Z:PROC		; GS_GDReqGuildMarkRegInfo
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\mapservermanager.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z PROC ; CGReqGuildRegInfo, COMDAT

; 17931: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17932: #if (GS_CASTLE==1)
; 17933: 	if(lpMsg == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	74 6f		 je	 SHORT $LN3@CGReqGuild

; 17934: 		return;
; 17935: 
; 17936: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00009	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000f	56		 push	 esi
  00010	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00013	8b c6		 mov	 eax, esi
  00015	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00020	8d 84 10 1c 06
	00 00		 lea	 eax, DWORD PTR [eax+edx+1564]
$LL8@CGReqGuild:
  00027	8a 10		 mov	 dl, BYTE PTR [eax]
  00029	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0002b	75 1a		 jne	 SHORT $LN9@CGReqGuild
  0002d	84 d2		 test	 dl, dl
  0002f	74 12		 je	 SHORT $LN10@CGReqGuild
  00031	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00034	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00037	75 0e		 jne	 SHORT $LN9@CGReqGuild
  00039	83 c0 02	 add	 eax, 2
  0003c	83 c1 02	 add	 ecx, 2
  0003f	84 d2		 test	 dl, dl
  00041	75 e4		 jne	 SHORT $LL8@CGReqGuild
$LN10@CGReqGuild:
  00043	33 c0		 xor	 eax, eax
  00045	eb 05		 jmp	 SHORT $LN11@CGReqGuild
$LN9@CGReqGuild:
  00047	1b c0		 sbb	 eax, eax
  00049	83 d8 ff	 sbb	 eax, -1
$LN11@CGReqGuild:
  0004c	85 c0		 test	 eax, eax
  0004e	74 27		 je	 SHORT $LN12@CGReqGuild

; 17937: 		return;
; 17938: 
; 17939: 	GS_GDReqGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

  00050	a1 00 6b 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92928
  00055	85 c0		 test	 eax, eax
  00057	74 11		 je	 SHORT $LN5@CGReqGuild
  00059	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  0005d	56		 push	 esi
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?GS_GDReqGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqGuildMarkRegInfo
  00064	83 c4 08	 add	 esp, 8
  00067	5e		 pop	 esi

; 17940: #endif
; 17941: }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0

; 17937: 		return;
; 17938: 
; 17939: 	GS_GDReqGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

$LN5@CGReqGuild:
  0006a	83 c8 ff	 or	 eax, -1
  0006d	56		 push	 esi
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?GS_GDReqGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqGuildMarkRegInfo
  00074	83 c4 08	 add	 esp, 8
$LN12@CGReqGuild:
  00077	5e		 pop	 esi
$LN3@CGReqGuild:

; 17940: #endif
; 17941: }

  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z ENDP ; CGReqGuildRegInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z ; GCAnsGuildRegInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z
_TEXT	SEGMENT
_pMsgResult$ = -24					; size = 19
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpMsgResult$ = 16					; size = 4
?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z PROC ; GCAnsGuildRegInfo, COMDAT

; 17957: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _lpMsgResult$[ebp]

; 17958: #if (GS_CASTLE==1)
; 17959: 	if(lpMsgResult == NULL)

  00013	85 c0		 test	 eax, eax
  00015	74 68		 je	 SHORT $LN3@GCAnsGuild

; 17960: 		return;
; 17961: 
; 17962: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0001a	85 c9		 test	 ecx, ecx
  0001c	78 61		 js	 SHORT $LN3@GCAnsGuild
  0001e	33 d2		 xor	 edx, edx
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c2	 setle	 dl
  00029	85 d2		 test	 edx, edx
  0002b	74 52		 je	 SHORT $LN3@GCAnsGuild

; 17963: 		return;
; 17964: 
; 17965: 	PMSG_ANS_GUILDREGINFO pMsgResult;
; 17966: 
; 17967: 	pMsgResult.h.set((BYTE *)&pMsgResult,0xB2,3,sizeof(pMsgResult));
; 17968: 	pMsgResult.btResult = iResult;

  0002d	8a 55 0c	 mov	 dl, BYTE PTR _iResult$[ebp]
  00030	88 55 ec	 mov	 BYTE PTR _pMsgResult$[ebp+4], dl

; 17969: 	pMsgResult.btGuildMark1 = DWORD((DWORD(lpMsgResult->iRegMarkCount) >> 16) &0xFFFF) >> 8;

  00033	0f b6 50 1b	 movzx	 edx, BYTE PTR [eax+27]
  00037	88 55 f5	 mov	 BYTE PTR _pMsgResult$[ebp+13], dl

; 17970: 	pMsgResult.btGuildMark2 = DWORD((DWORD(lpMsgResult->iRegMarkCount) >> 16) &0xFFFF) & 0xFF;

  0003a	0f b6 50 1a	 movzx	 edx, BYTE PTR [eax+26]
  0003e	88 55 f6	 mov	 BYTE PTR _pMsgResult$[ebp+14], dl

; 17971: 	pMsgResult.btGuildMark3 = DWORD((DWORD(lpMsgResult->iRegMarkCount) & 0xFFFF) &0xFFFF) >> 8;

  00041	0f b6 50 19	 movzx	 edx, BYTE PTR [eax+25]
  00045	88 55 f7	 mov	 BYTE PTR _pMsgResult$[ebp+15], dl

; 17972: 	pMsgResult.btGuildMark4 = DWORD((DWORD(lpMsgResult->iRegMarkCount) & 0xFFFF) &0xFFFF) & 0xFF;

  00048	0f b6 50 18	 movzx	 edx, BYTE PTR [eax+24]
  0004c	88 55 f8	 mov	 BYTE PTR _pMsgResult$[ebp+16], dl

; 17973: 
; 17974: 	pMsgResult.btRegRank = lpMsgResult->btRegRank;

  0004f	0f b6 50 1d	 movzx	 edx, BYTE PTR [eax+29]
  00053	88 55 fa	 mov	 BYTE PTR _pMsgResult$[ebp+18], dl

; 17975: 	pMsgResult.btIsGiveUp = lpMsgResult->bIsGiveUp;

  00056	0f b6 50 1c	 movzx	 edx, BYTE PTR [eax+28]
  0005a	88 55 f9	 mov	 BYTE PTR _pMsgResult$[ebp+17], dl

; 17976: 	memcpy(pMsgResult.szGuildName,lpMsgResult->szGuildName,sizeof(pMsgResult.szGuildName));

  0005d	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00060	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00063	89 55 ed	 mov	 DWORD PTR _pMsgResult$[ebp+5], edx

; 17977: 
; 17978: 	DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  00066	6a 13		 push	 19			; 00000013H
  00068	8d 55 e8	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  0006b	52		 push	 edx
  0006c	51		 push	 ecx
  0006d	c7 45 e8 c1 13
	b2 03		 mov	 DWORD PTR _pMsgResult$[ebp], 62002113 ; 03b213c1H
  00074	89 45 f1	 mov	 DWORD PTR _pMsgResult$[ebp+9], eax
  00077	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCAnsGuild:

; 17979: #endif
; 17980: }

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00082	33 cd		 xor	 ecx, ebp
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z ENDP ; GCAnsGuildRegInfo
_TEXT	ENDS
PUBLIC	_iIndex$GSCopy$
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z ; CGReqRegGuildMark
EXTRN	?GS_GDReqRegGuildMark@@YAXHHH@Z:PROC		; GS_GDReqRegGuildMark
; Function compile flags: /Ogtp
;	COMDAT ?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$ = -32					; size = 4
_iIndex$GSCopy$ = -28					; size = 4
_pMsgResult$224228 = -24				; size = 17
_pMsgResult$224223 = -24				; size = 17
_pMsgResult$224218 = -24				; size = 17
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z PROC ; CGReqRegGuildMark, COMDAT

; 17996: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00013	57		 push	 edi
  00014	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 18016: 	{
; 18017: 		gObj[iIndex].UseEventServer = FALSE;

  00017	89 45 e0	 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax

; 18058: 		return;
; 18059: 	}
; 18060: 
; 18061: 	GS_GDReqRegGuildMark(g_MapServerManager.GetMapSvrGroup(),iIndex,iItemPos);

  0001a	89 7d e4	 mov	 DWORD PTR _iIndex$GSCopy$[ebp], edi
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 1d 02 00
	00		 je	 $LN10@CGReqRegGu

; 17997: #if (GS_CASTLE==1)
; 17998: 	if(lpMsg == NULL)
; 17999: 		return;
; 18000: 
; 18001: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  00025	85 ff		 test	 edi, edi
  00027	0f 88 15 02 00
	00		 js	 $LN10@CGReqRegGu
  0002d	33 c0		 xor	 eax, eax
  0002f	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00035	0f 9e c0	 setle	 al
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 02 02 00
	00		 je	 $LN10@CGReqRegGu

; 18002: 		return;
; 18003: 
; 18004: 	if(gObj[iIndex].UseEventServer == TRUE)

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00045	56		 push	 esi
  00046	8b f7		 mov	 esi, edi
  00048	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0004e	b9 01 00 00 00	 mov	 ecx, 1
  00053	39 8c 06 e8 13
	00 00		 cmp	 DWORD PTR [esi+eax+5096], ecx
  0005a	0f 84 e1 01 00
	00		 je	 $LN29@CGReqRegGu

; 18005: 		return;
; 18006: 
; 18007: 	gObj[iIndex].UseEventServer = TRUE;

  00060	89 8c 06 e8 13
	00 00		 mov	 DWORD PTR [esi+eax+5096], ecx

; 18008: 
; 18009: 	if(g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_REGMARK)

  00067	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0006c	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00071	83 f8 03	 cmp	 eax, 3
  00074	74 20		 je	 SHORT $LN6@CGReqRegGu

; 18010: 	{
; 18011: 		gObj[iIndex].UseEventServer = FALSE;

  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007b	c7 84 06 e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+5096], 0
  00086	5e		 pop	 esi
  00087	5f		 pop	 edi

; 18062: #endif
; 18063: }

  00088	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008b	33 cd		 xor	 ecx, ebp
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
$LN6@CGReqRegGu:
  00096	53		 push	 ebx

; 18012: 		return;
; 18013: 	}
; 18014: 
; 18015: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00097	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  000a2	8d 84 1e 1c 06
	00 00		 lea	 eax, DWORD PTR [esi+ebx+1564]
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$LL25@CGReqRegGu:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b4	75 1a		 jne	 SHORT $LN26@CGReqRegGu
  000b6	84 d2		 test	 dl, dl
  000b8	74 12		 je	 SHORT $LN27@CGReqRegGu
  000ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c0	75 0e		 jne	 SHORT $LN26@CGReqRegGu
  000c2	83 c0 02	 add	 eax, 2
  000c5	83 c1 02	 add	 ecx, 2
  000c8	84 d2		 test	 dl, dl
  000ca	75 e4		 jne	 SHORT $LL25@CGReqRegGu
$LN27@CGReqRegGu:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN28@CGReqRegGu
$LN26@CGReqRegGu:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 d8 ff	 sbb	 eax, -1
$LN28@CGReqRegGu:
  000d5	85 c0		 test	 eax, eax
  000d7	75 18		 jne	 SHORT $LN5@CGReqRegGu

; 18016: 	{
; 18017: 		gObj[iIndex].UseEventServer = FALSE;

  000d9	89 84 1e e8 13
	00 00		 mov	 DWORD PTR [esi+ebx+5096], eax
  000e0	5b		 pop	 ebx
  000e1	5e		 pop	 esi
  000e2	5f		 pop	 edi

; 18062: #endif
; 18063: }

  000e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e6	33 cd		 xor	 ecx, ebp
  000e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
$LN5@CGReqRegGu:

; 18018: 		return;
; 18019: 	}
; 18020: 
; 18021: 	if(CHECK_INV_POS(lpMsg->btItemPos) == FALSE)

  000f1	8b 4d e0	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  000f4	8a 49 04	 mov	 cl, BYTE PTR [ecx+4]
  000f7	b2 3f		 mov	 dl, 63			; 0000003fH
  000f9	3a d1		 cmp	 dl, cl
  000fb	1b c0		 sbb	 eax, eax
  000fd	40		 inc	 eax
  000fe	75 18		 jne	 SHORT $LN4@CGReqRegGu

; 18022: 	{
; 18023: 		PMSG_ANS_REGGUILDMARK pMsgResult = {0};

  00100	89 45 e9	 mov	 DWORD PTR _pMsgResult$224218[ebp+1], eax
  00103	89 45 ed	 mov	 DWORD PTR _pMsgResult$224218[ebp+5], eax
  00106	89 45 f1	 mov	 DWORD PTR _pMsgResult$224218[ebp+9], eax
  00109	89 45 f5	 mov	 DWORD PTR _pMsgResult$224218[ebp+13], eax

; 18024: 
; 18025: 		pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x04,sizeof(pMsgResult));
; 18026: 		pMsgResult.btResult = 3;
; 18027: 
; 18028: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  0010c	6a 11		 push	 17			; 00000011H
  0010e	8d 45 e8	 lea	 eax, DWORD PTR _pMsgResult$224218[ebp]
  00111	50		 push	 eax
  00112	57		 push	 edi

; 18029: 		gObj[iIndex].UseEventServer = FALSE;
; 18030: 		return;

  00113	e9 04 01 00 00	 jmp	 $LN31@CGReqRegGu
$LN4@CGReqRegGu:

; 18031: 	}
; 18032: 
; 18033: 	int iItemPos = lpMsg->btItemPos + 12;
; 18034: 
; 18035: 	if(gObj[iIndex].pInventory[iItemPos].IsItem() == FALSE)

  00118	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011e	0f b6 d9	 movzx	 ebx, cl
  00121	8b 8c 16 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4544]
  00128	83 c3 0c	 add	 ebx, 12			; 0000000cH
  0012b	8b fb		 mov	 edi, ebx
  0012d	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  00133	03 cf		 add	 ecx, edi
  00135	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0013a	85 c0		 test	 eax, eax
  0013c	75 4b		 jne	 SHORT $LN3@CGReqRegGu

; 18036: 	{
; 18037: 		PMSG_ANS_REGGUILDMARK pMsgResult = {0};
; 18038: 
; 18039: 		pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x04,sizeof(pMsgResult));
; 18040: 		pMsgResult.btResult = 3;
; 18041: 
; 18042: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  0013e	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$GSCopy$[ebp]
  00141	89 45 e9	 mov	 DWORD PTR _pMsgResult$224223[ebp+1], eax
  00144	89 45 ed	 mov	 DWORD PTR _pMsgResult$224223[ebp+5], eax
  00147	89 45 f1	 mov	 DWORD PTR _pMsgResult$224223[ebp+9], eax
  0014a	89 45 f5	 mov	 DWORD PTR _pMsgResult$224223[ebp+13], eax
  0014d	6a 11		 push	 17			; 00000011H
  0014f	8d 45 e8	 lea	 eax, DWORD PTR _pMsgResult$224223[ebp]
  00152	50		 push	 eax
  00153	51		 push	 ecx
  00154	c7 45 e8 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$224223[ebp], 78778817 ; 04b211c1H
  0015b	c6 45 ec 03	 mov	 BYTE PTR _pMsgResult$224223[ebp+4], 3
  0015f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18043: 		gObj[iIndex].UseEventServer = FALSE;

  00164	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 18055: 
; 18056: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  0016a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016d	5b		 pop	 ebx
  0016e	c7 84 16 e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+5096], 0
  00179	5e		 pop	 esi
  0017a	5f		 pop	 edi

; 18062: #endif
; 18063: }

  0017b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017e	33 cd		 xor	 ecx, ebp
  00180	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
$LN3@CGReqRegGu:

; 18044: 		return;
; 18045: 	}
; 18046: 
; 18047: 	if(gObj[iIndex].pInventory[iItemPos].m_Type != ITEMGET(14,21)
; 18048: 		|| gObj[iIndex].pInventory[iItemPos].m_Level != 3
; 18049: 		|| gObj[iIndex].pInventory[iItemPos].m_Durability <= 0.0f)

  00189	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018e	8b 84 06 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+eax+4544]
  00195	ba 15 1c 00 00	 mov	 edx, 7189		; 00001c15H
  0019a	66 39 54 38 06	 cmp	 WORD PTR [eax+edi+6], dx
  0019f	75 63		 jne	 SHORT $LN1@CGReqRegGu
  001a1	66 83 7c 38 08
	03		 cmp	 WORD PTR [eax+edi+8], 3
  001a7	75 5b		 jne	 SHORT $LN1@CGReqRegGu
  001a9	d9 ee		 fldz
  001ab	d8 5c 38 24	 fcomp	 DWORD PTR [eax+edi+36]
  001af	df e0		 fnstsw	 ax
  001b1	f6 c4 01	 test	 ah, 1
  001b4	74 4e		 je	 SHORT $LN1@CGReqRegGu

; 18058: 		return;
; 18059: 	}
; 18060: 
; 18061: 	GS_GDReqRegGuildMark(g_MapServerManager.GetMapSvrGroup(),iIndex,iItemPos);

  001b6	a1 00 6b 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92928
  001bb	85 c0		 test	 eax, eax
  001bd	74 23		 je	 SHORT $LN22@CGReqRegGu
  001bf	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  001c3	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$GSCopy$[ebp]
  001c6	53		 push	 ebx
  001c7	51		 push	 ecx
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?GS_GDReqRegGuildMark@@YAXHHH@Z ; GS_GDReqRegGuildMark
  001ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d1	5b		 pop	 ebx
  001d2	5e		 pop	 esi
  001d3	5f		 pop	 edi

; 18062: #endif
; 18063: }

  001d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d7	33 cd		 xor	 ecx, ebp
  001d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001de	8b e5		 mov	 esp, ebp
  001e0	5d		 pop	 ebp
  001e1	c3		 ret	 0

; 18058: 		return;
; 18059: 	}
; 18060: 
; 18061: 	GS_GDReqRegGuildMark(g_MapServerManager.GetMapSvrGroup(),iIndex,iItemPos);

$LN22@CGReqRegGu:
  001e2	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$GSCopy$[ebp]
  001e5	53		 push	 ebx
  001e6	83 c8 ff	 or	 eax, -1
  001e9	51		 push	 ecx
  001ea	50		 push	 eax
  001eb	e8 00 00 00 00	 call	 ?GS_GDReqRegGuildMark@@YAXHHH@Z ; GS_GDReqRegGuildMark
  001f0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f3	5b		 pop	 ebx
  001f4	5e		 pop	 esi
  001f5	5f		 pop	 edi

; 18062: #endif
; 18063: }

  001f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f9	33 cd		 xor	 ecx, ebp
  001fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c3		 ret	 0
$LN1@CGReqRegGu:

; 18050: 	{
; 18051: 		PMSG_ANS_REGGUILDMARK pMsgResult = {0};

  00204	33 c0		 xor	 eax, eax

; 18055: 
; 18056: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  00206	6a 11		 push	 17			; 00000011H
  00208	8d 55 e8	 lea	 edx, DWORD PTR _pMsgResult$224228[ebp]
  0020b	89 45 e9	 mov	 DWORD PTR _pMsgResult$224228[ebp+1], eax
  0020e	89 45 ed	 mov	 DWORD PTR _pMsgResult$224228[ebp+5], eax
  00211	89 45 f1	 mov	 DWORD PTR _pMsgResult$224228[ebp+9], eax
  00214	89 45 f5	 mov	 DWORD PTR _pMsgResult$224228[ebp+13], eax
  00217	8b 45 e4	 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]
  0021a	52		 push	 edx
  0021b	50		 push	 eax
$LN31@CGReqRegGu:

; 18052: 
; 18053: 		pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x04,sizeof(pMsgResult));
; 18054: 		pMsgResult.btResult = 3;

  0021c	c7 45 e8 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$224228[ebp], 78778817 ; 04b211c1H
  00223	c6 45 ec 03	 mov	 BYTE PTR _pMsgResult$224228[ebp+4], 3

; 18055: 
; 18056: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  00227	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18057: 		gObj[iIndex].UseEventServer = FALSE;

  0022c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00232	83 c4 0c	 add	 esp, 12			; 0000000cH
  00235	c7 84 0e e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+ecx+5096], 0
  00240	5b		 pop	 ebx
$LN29@CGReqRegGu:
  00241	5e		 pop	 esi
$LN10@CGReqRegGu:

; 18062: #endif
; 18063: }

  00242	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00245	33 cd		 xor	 ecx, ebp
  00247	5f		 pop	 edi
  00248	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024d	8b e5		 mov	 esp, ebp
  0024f	5d		 pop	 ebp
  00250	c3		 ret	 0
?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z ENDP ; CGReqRegGuildMark
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z ; GCAnsRegGuildMark
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z
_TEXT	SEGMENT
tv378 = -52						; size = 4
tv226 = -52						; size = 4
tv380 = -46						; size = 2
_pMsgResult$ = -44					; size = 17
_pMsgResult$224245 = -24				; size = 17
_pMsgResult$224239 = -24				; size = 17
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpMsgResult$ = 16					; size = 4
?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z PROC ; GCAnsRegGuildMark, COMDAT

; 18069: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00014	56		 push	 esi
  00015	8b 75 10	 mov	 esi, DWORD PTR _lpMsgResult$[ebp]

; 18070: #if (GS_CASTLE==1)
; 18071: 	if(lpMsgResult == NULL)

  00018	85 f6		 test	 esi, esi
  0001a	0f 84 d1 01 00
	00		 je	 $LN9@GCAnsRegGu

; 18072: 		return;
; 18073: 
; 18074: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  00020	85 db		 test	 ebx, ebx
  00022	0f 88 c9 01 00
	00		 js	 $LN9@GCAnsRegGu
  00028	33 c0		 xor	 eax, eax
  0002a	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00030	0f 9e c0	 setle	 al
  00033	85 c0		 test	 eax, eax
  00035	0f 84 b6 01 00
	00		 je	 $LN9@GCAnsRegGu

; 18075: 		return;
; 18076: 
; 18077: 	if(gObj[iIndex].pInventory[lpMsgResult->iItemPos].IsItem() == FALSE)

  0003b	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00049	57		 push	 edi
  0004a	8b fb		 mov	 edi, ebx
  0004c	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00052	03 8c 07 c0 11
	00 00		 add	 ecx, DWORD PTR [edi+eax+4544]
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	85 c0		 test	 eax, eax
  00060	75 1f		 jne	 SHORT $LN6@GCAnsRegGu

; 18078: 	{
; 18079: 		PMSG_ANS_REGGUILDMARK pMsgResult = {0};

  00062	89 45 e9	 mov	 DWORD PTR _pMsgResult$224239[ebp+1], eax
  00065	89 45 ed	 mov	 DWORD PTR _pMsgResult$224239[ebp+5], eax
  00068	89 45 f1	 mov	 DWORD PTR _pMsgResult$224239[ebp+9], eax
  0006b	89 45 f5	 mov	 DWORD PTR _pMsgResult$224239[ebp+13], eax

; 18080: 
; 18081: 		pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x04,sizeof(pMsgResult));

  0006e	c7 45 e8 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$224239[ebp], 78778817 ; 04b211c1H

; 18082: 		pMsgResult.btResult = 3;

  00075	c6 45 ec 03	 mov	 BYTE PTR _pMsgResult$224239[ebp+4], 3

; 18083: 
; 18084: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  00079	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgResult$224239[ebp]

; 18085: 		gObj[iIndex].UseEventServer = FALSE;
; 18086: 		return;

  0007c	e9 52 01 00 00	 jmp	 $LN23@GCAnsRegGu
$LN6@GCAnsRegGu:

; 18087: 	}
; 18088: 
; 18089: 	if((gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Type != ITEMGET(14,21)
; 18090: 		&& gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Level == 3)
; 18091: 		|| gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Durability <= 0.0f)

  00081	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00084	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008a	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00090	03 84 0f c0 11
	00 00		 add	 eax, DWORD PTR [edi+ecx+4544]
  00097	ba 15 1c 00 00	 mov	 edx, 7189		; 00001c15H
  0009c	66 39 50 06	 cmp	 WORD PTR [eax+6], dx
  000a0	74 07		 je	 SHORT $LN19@GCAnsRegGu
  000a2	66 83 78 08 03	 cmp	 WORD PTR [eax+8], 3
  000a7	74 0e		 je	 SHORT $LN4@GCAnsRegGu
$LN19@GCAnsRegGu:
  000a9	d9 ee		 fldz
  000ab	d8 50 24	 fcom	 DWORD PTR [eax+36]
  000ae	df e0		 fnstsw	 ax
  000b0	f6 c4 01	 test	 ah, 1
  000b3	75 4c		 jne	 SHORT $LN5@GCAnsRegGu
  000b5	dd d8		 fstp	 ST(0)
$LN4@GCAnsRegGu:

; 18092: 	{
; 18093: 		PMSG_ANS_REGGUILDMARK pMsgResult = {0};

  000b7	33 c0		 xor	 eax, eax
  000b9	89 45 e9	 mov	 DWORD PTR _pMsgResult$224245[ebp+1], eax
  000bc	89 45 ed	 mov	 DWORD PTR _pMsgResult$224245[ebp+5], eax
  000bf	89 45 f1	 mov	 DWORD PTR _pMsgResult$224245[ebp+9], eax
  000c2	89 45 f5	 mov	 DWORD PTR _pMsgResult$224245[ebp+13], eax

; 18094: 
; 18095: 		pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x04,sizeof(pMsgResult));
; 18096: 		pMsgResult.btResult = 3;
; 18097: 
; 18098: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  000c5	6a 11		 push	 17			; 00000011H
  000c7	8d 45 e8	 lea	 eax, DWORD PTR _pMsgResult$224245[ebp]
  000ca	50		 push	 eax
  000cb	53		 push	 ebx
  000cc	c7 45 e8 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$224245[ebp], 78778817 ; 04b211c1H
  000d3	c6 45 ec 03	 mov	 BYTE PTR _pMsgResult$224245[ebp+4], 3
  000d7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18099: 		gObj[iIndex].UseEventServer = FALSE;

  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 18126: 	DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	c7 84 0f e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+ecx+5096], 0
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx

; 18129: #endif
; 18130: }

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f6	33 cd		 xor	 ecx, ebp
  000f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
$LN5@GCAnsRegGu:

; 18100: 		return;
; 18101: 	}
; 18102: 
; 18103: 	gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Durability -= 1.0f;

  00101	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00104	8b 84 0f c0 11
	00 00		 mov	 eax, DWORD PTR [edi+ecx+4544]
  0010b	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00111	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  00115	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  0011b	d9 5c 02 24	 fstp	 DWORD PTR [edx+eax+36]

; 18104: 
; 18105: 	if(gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Durability > 0.0f)

  0011f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00125	8b 8c 0f c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+4544]
  0012c	8d 44 02 24	 lea	 eax, DWORD PTR [edx+eax+36]
  00130	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00133	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00139	d8 5c 0a 24	 fcomp	 DWORD PTR [edx+ecx+36]
  0013d	df e0		 fnstsw	 ax
  0013f	f6 c4 05	 test	 ah, 5
  00142	7a 3e		 jp	 SHORT $LN2@GCAnsRegGu

; 18106: 	{
; 18107: 		GCItemDurSend(iIndex,lpMsgResult->iItemPos,(BYTE)gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Durability,0);

  00144	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00147	d9 7d d2	 fnstcw	 WORD PTR tv380[ebp]
  0014a	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00150	6a 00		 push	 0
  00152	d9 44 08 24	 fld	 DWORD PTR [eax+ecx+36]
  00156	0f b7 45 d2	 movzx	 eax, WORD PTR tv380[ebp]
  0015a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0015f	89 45 cc	 mov	 DWORD PTR tv378[ebp], eax
  00162	0f b6 46 18	 movzx	 eax, BYTE PTR [esi+24]
  00166	d9 6d cc	 fldcw	 WORD PTR tv378[ebp]
  00169	db 5d cc	 fistp	 DWORD PTR tv226[ebp]
  0016c	8a 4d cc	 mov	 cl, BYTE PTR tv226[ebp]
  0016f	0f b6 d1	 movzx	 edx, cl
  00172	52		 push	 edx
  00173	d9 6d d2	 fldcw	 WORD PTR tv380[ebp]
  00176	50		 push	 eax
  00177	53		 push	 ebx
  00178	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  0017d	83 c4 10	 add	 esp, 16			; 00000010H

; 18108: 	}
; 18109: 	else

  00180	eb 1a		 jmp	 SHORT $LN1@GCAnsRegGu
$LN2@GCAnsRegGu:

; 18110: 	{
; 18111: 		gObjInventoryDeleteItem(iIndex,lpMsgResult->iItemPos);

  00182	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00185	51		 push	 ecx
  00186	53		 push	 ebx
  00187	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 18112: 		GCInventoryItemDeleteSend(iIndex,lpMsgResult->iItemPos,1);

  0018c	0f b6 56 18	 movzx	 edx, BYTE PTR [esi+24]
  00190	6a 01		 push	 1
  00192	52		 push	 edx
  00193	53		 push	 ebx
  00194	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00199	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@GCAnsRegGu:

; 18113: 	}
; 18114: 
; 18115: 	PMSG_ANS_REGGUILDMARK pMsgResult;
; 18116: 
; 18117: 	pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x04,sizeof(pMsgResult));
; 18118: 	pMsgResult.btResult = iResult;

  0019c	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18119: 
; 18120: 	pMsgResult.btGuildMark1 = DWORD((DWORD(lpMsgResult->iRegMarkCount) >> 16) &0xFFFF) >> 8;

  0019f	0f b6 4e 1f	 movzx	 ecx, BYTE PTR [esi+31]

; 18121: 	pMsgResult.btGuildMark2 = DWORD((DWORD(lpMsgResult->iRegMarkCount) >> 16) &0xFFFF) & 0xFF;

  001a3	8a 56 1e	 mov	 dl, BYTE PTR [esi+30]
  001a6	88 45 d8	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18122: 	pMsgResult.btGuildMark3 = DWORD((DWORD(lpMsgResult->iRegMarkCount) & 0xFFFF) &0xFFFF) >> 8;

  001a9	0f b6 46 1d	 movzx	 eax, BYTE PTR [esi+29]
  001ad	88 4d e1	 mov	 BYTE PTR _pMsgResult$[ebp+13], cl

; 18123: 	pMsgResult.btGuildMark4 = DWORD((DWORD(lpMsgResult->iRegMarkCount) & 0xFFFF) &0xFFFF) & 0xFF;

  001b0	0f b6 4e 1c	 movzx	 ecx, BYTE PTR [esi+28]
  001b4	88 55 e2	 mov	 BYTE PTR _pMsgResult$[ebp+14], dl

; 18124: 
; 18125: 	memcpy(pMsgResult.szGuildName,lpMsgResult->szGuildName,sizeof(pMsgResult.szGuildName));

  001b7	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  001ba	88 45 e3	 mov	 BYTE PTR _pMsgResult$[ebp+15], al
  001bd	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001c0	88 4d e4	 mov	 BYTE PTR _pMsgResult$[ebp+16], cl
  001c3	c7 45 d4 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$[ebp], 78778817 ; 04b211c1H
  001ca	89 55 d9	 mov	 DWORD PTR _pMsgResult$[ebp+5], edx
  001cd	89 45 dd	 mov	 DWORD PTR _pMsgResult$[ebp+9], eax

; 18126: 	DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  001d0	8d 4d d4	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
$LN23@GCAnsRegGu:
  001d3	6a 11		 push	 17			; 00000011H
  001d5	51		 push	 ecx
  001d6	53		 push	 ebx
  001d7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18127: 
; 18128: 	gObj[iIndex].UseEventServer = FALSE;

  001dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e5	c7 84 17 e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+edx+5096], 0
  001f0	5f		 pop	 edi
$LN9@GCAnsRegGu:

; 18129: #endif
; 18130: }

  001f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f4	5e		 pop	 esi
  001f5	33 cd		 xor	 ecx, ebp
  001f7	5b		 pop	 ebx
  001f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fd	8b e5		 mov	 esp, ebp
  001ff	5d		 pop	 ebp
  00200	c3		 ret	 0
?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z ENDP ; GCAnsRegGuildMark
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsNpcBuy@@YAXHHHH@Z				; GCAnsNpcBuy
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsNpcBuy@@YAXHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
?GCAnsNpcBuy@@YAXHHHH@Z PROC				; GCAnsNpcBuy, COMDAT

; 18183: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18184: #if (GS_CASTLE==1)
; 18185: 	PMSG_ANS_NPCBUY pMsgResult;
; 18186: 
; 18187: 	pMsgResult.h.set((BYTE *)&pMsgResult,0xB2,0x05,sizeof(pMsgResult));
; 18188: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18189: 	pMsgResult.iNpcNumber = iNpcNumber;

  00013	8b 4d 10	 mov	 ecx, DWORD PTR _iNpcNumber$[ebp]

; 18190: 	pMsgResult.iNpcIndex = iNpcIndex;

  00016	8b 55 14	 mov	 edx, DWORD PTR _iNpcIndex$[ebp]
  00019	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18191: 
; 18192: 	DataSend(iIndex,(BYTE *)&pMsgResult,pMsgResult.h.size);

  0001c	6a 10		 push	 16			; 00000010H
  0001e	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00021	89 4d f4	 mov	 DWORD PTR _pMsgResult$[ebp+8], ecx
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00027	50		 push	 eax
  00028	51		 push	 ecx
  00029	c7 45 ec c1 10
	b2 05		 mov	 DWORD PTR _pMsgResult$[ebp], 95555777 ; 05b210c1H
  00030	89 55 f8	 mov	 DWORD PTR _pMsgResult$[ebp+12], edx
  00033	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18193: #endif
; 18194: }

  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?GCAnsNpcBuy@@YAXHHHH@Z ENDP				; GCAnsNpcBuy
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsNpcRepair@@YAXHHHHHH@Z			; GCAnsNpcRepair
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsNpcRepair@@YAXHHHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iNpcHP$ = 24						; size = 4
_iNpcMaxHP$ = 28					; size = 4
?GCAnsNpcRepair@@YAXHHHHHH@Z PROC			; GCAnsNpcRepair, COMDAT

; 18296: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18297: #if (GS_CASTLE==1)
; 18298: 	PMSG_ANS_NPCREPAIR pMsgResult;
; 18299: 
; 18300: 	pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x06,sizeof(pMsgResult));
; 18301: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18302: 	pMsgResult.iNpcNumber = iNpcNumber;
; 18303: 	pMsgResult.iNpcIndex = iNpcIndex;

  00013	8b 55 14	 mov	 edx, DWORD PTR _iNpcIndex$[ebp]
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _iNpcNumber$[ebp]
  00019	88 45 e8	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18304: 	pMsgResult.iNpcHP = iNpcHP;

  0001c	8b 45 18	 mov	 eax, DWORD PTR _iNpcHP$[ebp]
  0001f	89 55 f0	 mov	 DWORD PTR _pMsgResult$[ebp+12], edx

; 18305: 	pMsgResult.iNpcMaxHP = iNpcMaxHP;
; 18306: 
; 18307: 	DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  00022	6a 18		 push	 24			; 00000018H
  00024	8d 55 e4	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00027	89 45 f4	 mov	 DWORD PTR _pMsgResult$[ebp+16], eax
  0002a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0002d	89 4d ec	 mov	 DWORD PTR _pMsgResult$[ebp+8], ecx
  00030	8b 4d 1c	 mov	 ecx, DWORD PTR _iNpcMaxHP$[ebp]
  00033	52		 push	 edx
  00034	50		 push	 eax
  00035	c7 45 e4 c1 18
	b2 06		 mov	 DWORD PTR _pMsgResult$[ebp], 112335041 ; 06b218c1H
  0003c	89 4d f8	 mov	 DWORD PTR _pMsgResult$[ebp+20], ecx
  0003f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18308: #endif
; 18309: }

  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	33 cd		 xor	 ecx, ebp
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GCAnsNpcRepair@@YAXHHHHHH@Z ENDP			; GCAnsNpcRepair
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsNpcUpgrade@@YAXHHHHHH@Z			; GCAnsNpcUpgrade
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsNpcUpgrade@@YAXHHHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iNpcUpType$ = 24					; size = 4
_iNpcUpValue$ = 28					; size = 4
?GCAnsNpcUpgrade@@YAXHHHHHH@Z PROC			; GCAnsNpcUpgrade, COMDAT

; 18568: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18569: #if (GS_CASTLE==1)
; 18570: 
; 18571: 	PMSG_ANS_NPCUPGRADE pMsgResult;
; 18572: 
; 18573: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x07,sizeof(pMsgResult));
; 18574: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18575: 	pMsgResult.iNpcNumber = iNpcNumber;
; 18576: 	pMsgResult.iNpcIndex = iNpcIndex;

  00013	8b 55 14	 mov	 edx, DWORD PTR _iNpcIndex$[ebp]
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _iNpcNumber$[ebp]
  00019	88 45 e8	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18577: 	pMsgResult.iNpcUpType = iNpcUpType;

  0001c	8b 45 18	 mov	 eax, DWORD PTR _iNpcUpType$[ebp]
  0001f	89 55 f0	 mov	 DWORD PTR _pMsgResult$[ebp+12], edx

; 18578: 	pMsgResult.iNpcUpValue = iNpcUpValue;
; 18579: 
; 18580: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00022	6a 18		 push	 24			; 00000018H
  00024	8d 55 e4	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00027	89 45 f4	 mov	 DWORD PTR _pMsgResult$[ebp+16], eax
  0002a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0002d	89 4d ec	 mov	 DWORD PTR _pMsgResult$[ebp+8], ecx
  00030	8b 4d 1c	 mov	 ecx, DWORD PTR _iNpcUpValue$[ebp]
  00033	52		 push	 edx
  00034	50		 push	 eax
  00035	c7 45 e4 c1 18
	b2 07		 mov	 DWORD PTR _pMsgResult$[ebp], 129112257 ; 07b218c1H
  0003c	89 4d f8	 mov	 DWORD PTR _pMsgResult$[ebp+20], ecx
  0003f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18581: #endif
; 18582: }

  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	33 cd		 xor	 ecx, ebp
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GCAnsNpcUpgrade@@YAXHHHHHH@Z ENDP			; GCAnsNpcUpgrade
_TEXT	ENDS
PUBLIC	??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ ; `string'
PUBLIC	??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ ; `string'
PUBLIC	?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z ; CGReqTaxMoneyInfo
EXTRN	?GS_GDReqTaxInfo@@YAXHH@Z:PROC			; GS_GDReqTaxInfo
EXTRN	?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z:PROC ; CCastleSiege::CheckGuildOwnCastle
;	COMDAT ??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\mapservermanager.h
CONST	SEGMENT
??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ DB '[Castl'
	DB	'eSiege] CGReqTaxMoneyInfo() ERROR - Authority Fail [%s][%s], '
	DB	'Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
CONST	SEGMENT
??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ DB '[Castl'
	DB	'eSiege] CGReqTaxMoneyInfo() REQ OK - [%s][%s], Guild:(%s)(%d)'
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z PROC ; CGReqTaxMoneyInfo, COMDAT

; 18588: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18589: #if (GS_CASTLE==1)
; 18590: 	if(lpMsg == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	0f 84 e9 00 00
	00		 je	 $LN5@CGReqTaxMo

; 18591: 		return;
; 18592: 
; 18593: 	if(strcmp(gObj[iIndex].GuildName,"")==NULL)

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	53		 push	 ebx
  00013	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00016	56		 push	 esi
  00017	8b f3		 mov	 esi, ebx
  00019	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0001f	57		 push	 edi
  00020	8d bc 06 1c 06
	00 00		 lea	 edi, DWORD PTR [esi+eax+1564]
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002c	8b c7		 mov	 eax, edi
  0002e	8b ff		 npad	 2
$LL10@CGReqTaxMo:
  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00034	75 1a		 jne	 SHORT $LN11@CGReqTaxMo
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN12@CGReqTaxMo
  0003a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00040	75 0e		 jne	 SHORT $LN11@CGReqTaxMo
  00042	83 c0 02	 add	 eax, 2
  00045	83 c1 02	 add	 ecx, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL10@CGReqTaxMo
$LN12@CGReqTaxMo:
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN13@CGReqTaxMo
$LN11@CGReqTaxMo:
  00050	1b c0		 sbb	 eax, eax
  00052	83 d8 ff	 sbb	 eax, -1
$LN13@CGReqTaxMo:
  00055	85 c0		 test	 eax, eax
  00057	0f 84 96 00 00
	00		 je	 $LN14@CGReqTaxMo

; 18594: 		return;
; 18595: 
; 18596: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18597: 		|| gObj[iIndex].GuildStatus != G_MASTER)

  0005d	57		 push	 edi
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00063	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00068	85 c0		 test	 eax, eax
  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	74 58		 je	 SHORT $LN1@CGReqTaxMo
  00071	81 bc 06 28 06
	00 00 80 00 00
	00		 cmp	 DWORD PTR [esi+eax+1576], 128 ; 00000080H
  0007c	75 4b		 jne	 SHORT $LN1@CGReqTaxMo

; 18601: 		return;
; 18602: 	}
; 18603: 
; 18604: 	GS_GDReqTaxInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

  0007e	a1 00 6b 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92928
  00083	85 c0		 test	 eax, eax
  00085	74 06		 je	 SHORT $LN7@CGReqTaxMo
  00087	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  0008b	eb 03		 jmp	 SHORT $LN8@CGReqTaxMo
$LN7@CGReqTaxMo:
  0008d	83 c8 ff	 or	 eax, -1
$LN8@CGReqTaxMo:
  00090	53		 push	 ebx
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?GS_GDReqTaxInfo@@YAXHH@Z ; GS_GDReqTaxInfo

; 18605: 	LogAddTD("[CastleSiege] CGReqTaxMoneyInfo() REQ OK - [%s][%s], Guild:(%s)(%d)",
; 18606: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009c	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  000a3	51		 push	 ecx
  000a4	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  000ab	52		 push	 edx
  000ac	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  000b0	51		 push	 ecx
  000b1	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  000b5	52		 push	 edx
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c1	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx

; 18607: 
; 18608: #endif
; 18609: }

  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
$LN1@CGReqTaxMo:

; 18598: 	{
; 18599: 		LogAddC(2,"[CastleSiege] CGReqTaxMoneyInfo() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",
; 18600: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  000c9	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  000d0	51		 push	 ecx
  000d1	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  000d8	52		 push	 edx
  000d9	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  000dd	51		 push	 ecx
  000de	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  000e2	52		 push	 edx
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
  000e8	6a 02		 push	 2
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000f0	83 c4 18	 add	 esp, 24			; 00000018H
$LN14@CGReqTaxMo:
  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
$LN5@CGReqTaxMo:

; 18607: 
; 18608: #endif
; 18609: }

  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z ENDP ; CGReqTaxMoneyInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z			; GCAnsTaxMoneyInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 15
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_btTaxRateChaos$ = 16					; size = 1
_btTaxRateStore$ = 20					; size = 1
_i64Money$ = 24						; size = 8
?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z PROC			; GCAnsTaxMoneyInfo, COMDAT

; 18629: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18630: #if (GS_CASTLE==1)
; 18631: 	PMSG_ANS_TAXMONEYINFO pMsgResult;
; 18632: 
; 18633: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x08,sizeof(pMsgResult));
; 18634: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18635: 	pMsgResult.btTaxRateChaos = btTaxRateChaos;
; 18636: 	pMsgResult.btTaxRateStore = btTaxRateStore;

  00013	8a 55 14	 mov	 dl, BYTE PTR _btTaxRateStore$[ebp]
  00016	8a 4d 10	 mov	 cl, BYTE PTR _btTaxRateChaos$[ebp]
  00019	88 55 f2	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl
  0001c	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18637: 
; 18638: 	pMsgResult.btMoney1 = DWORD((DWORD(i64Money >> 32) >> 16) & 0xFFFF) >> 8;

  0001f	8b 45 1c	 mov	 eax, DWORD PTR _i64Money$[ebp+4]
  00022	88 4d f1	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  00025	8b d0		 mov	 edx, eax
  00027	c1 ea 18	 shr	 edx, 24			; 00000018H
  0002a	88 55 f3	 mov	 BYTE PTR _pMsgResult$[ebp+7], dl
  0002d	8b c8		 mov	 ecx, eax
  0002f	c1 f9 1f	 sar	 ecx, 31			; 0000001fH

; 18639: 	pMsgResult.btMoney2 = DWORD((DWORD(i64Money >> 32) >> 16) & 0xFFFF) & 0xFF;
; 18640: 	pMsgResult.btMoney3 = DWORD((DWORD(i64Money >> 32) & 0xFFFF) & 0xFFFF) >> 8;

  00032	8b d0		 mov	 edx, eax
  00034	8b c8		 mov	 ecx, eax
  00036	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00039	c1 ea 08	 shr	 edx, 8

; 18641: 	pMsgResult.btMoney4 = DWORD((DWORD(i64Money >> 32) & 0xFFFF) & 0xFFFF) & 0xFF;

  0003c	88 45 f6	 mov	 BYTE PTR _pMsgResult$[ebp+10], al

; 18642: 
; 18643: 	pMsgResult.btMoney5 = DWORD((DWORD(i64Money & 0xFFFFFFFF) >> 16) & 0xFFFF) >> 8;

  0003f	8b 45 18	 mov	 eax, DWORD PTR _i64Money$[ebp]
  00042	88 4d f4	 mov	 BYTE PTR _pMsgResult$[ebp+8], cl
  00045	88 55 f5	 mov	 BYTE PTR _pMsgResult$[ebp+9], dl

; 18644: 	pMsgResult.btMoney6 = DWORD((DWORD(i64Money & 0xFFFFFFFF) >> 16) & 0xFFFF) & 0xFF;

  00048	8b d0		 mov	 edx, eax
  0004a	8b c8		 mov	 ecx, eax
  0004c	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0004f	c1 ea 10	 shr	 edx, 16			; 00000010H
  00052	88 4d f7	 mov	 BYTE PTR _pMsgResult$[ebp+11], cl
  00055	88 55 f8	 mov	 BYTE PTR _pMsgResult$[ebp+12], dl

; 18645: 	pMsgResult.btMoney7 = DWORD((DWORD(i64Money & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) >> 8;

  00058	8b c8		 mov	 ecx, eax

; 18646: 	pMsgResult.btMoney8 = DWORD((DWORD(i64Money & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) & 0xFF;
; 18647: 
; 18648: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0005a	6a 0f		 push	 15			; 0000000fH
  0005c	8d 55 ec	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  0005f	88 45 fa	 mov	 BYTE PTR _pMsgResult$[ebp+14], al
  00062	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00065	52		 push	 edx
  00066	c1 e9 08	 shr	 ecx, 8
  00069	50		 push	 eax
  0006a	c7 45 ec c1 0f
	b2 08		 mov	 DWORD PTR _pMsgResult$[ebp], 145887169 ; 08b20fc1H
  00071	88 4d f9	 mov	 BYTE PTR _pMsgResult$[ebp+13], cl
  00074	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18649: #endif
; 18650: }

  00079	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007c	33 cd		 xor	 ecx, ebp
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z ENDP			; GCAnsTaxMoneyInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsTaxRateChange@@YAXHHEH@Z			; GCAnsTaxRateChange
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsTaxRateChange@@YAXHHEH@Z
_TEXT	SEGMENT
_pMsgResult$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_btTaxType$ = 16					; size = 1
_iTaxRate$ = 20						; size = 4
?GCAnsTaxRateChange@@YAXHHEH@Z PROC			; GCAnsTaxRateChange, COMDAT

; 18717: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18718: #if (GS_CASTLE==1)
; 18719: 	PMSG_ANS_TAXRATECHANGE pMsgResult;
; 18720: 
; 18721: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x09,sizeof(pMsgResult));
; 18722: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18723: 	pMsgResult.btTaxType = btTaxType;

  00013	8a 4d 10	 mov	 cl, BYTE PTR _btTaxType$[ebp]
  00016	88 45 f4	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18724: 	
; 18725: 	pMsgResult.btTaxRate1 = DWORD((DWORD(iTaxRate) >> 16) &0xFFFF) >> 8;

  00019	8b 45 14	 mov	 eax, DWORD PTR _iTaxRate$[ebp]
  0001c	8b d0		 mov	 edx, eax
  0001e	88 4d f5	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  00021	c1 ea 18	 shr	 edx, 24			; 00000018H

; 18726: 	pMsgResult.btTaxRate2 = DWORD((DWORD(iTaxRate) >> 16) &0xFFFF) & 0xFF;

  00024	8b c8		 mov	 ecx, eax
  00026	88 55 f6	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl
  00029	c1 e9 10	 shr	 ecx, 16			; 00000010H

; 18727: 	pMsgResult.btTaxRate3 = DWORD((DWORD(iTaxRate) & 0xFFFF) &0xFFFF) >> 8;

  0002c	8b d0		 mov	 edx, eax

; 18728: 	pMsgResult.btTaxRate4 = DWORD((DWORD(iTaxRate) & 0xFFFF) &0xFFFF) & 0xFF;

  0002e	88 45 f9	 mov	 BYTE PTR _pMsgResult$[ebp+9], al

; 18729: 
; 18730: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00031	6a 0a		 push	 10			; 0000000aH
  00033	8d 45 f0	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00036	88 4d f7	 mov	 BYTE PTR _pMsgResult$[ebp+7], cl
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0003c	50		 push	 eax
  0003d	c1 ea 08	 shr	 edx, 8
  00040	51		 push	 ecx
  00041	c7 45 f0 c1 0a
	b2 09		 mov	 DWORD PTR _pMsgResult$[ebp], 162663105 ; 09b20ac1H
  00048	88 55 f8	 mov	 BYTE PTR _pMsgResult$[ebp+8], dl
  0004b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18731: #endif
; 18732: }

  00050	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00053	33 cd		 xor	 ecx, ebp
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?GCAnsTaxRateChange@@YAXHHEH@Z ENDP			; GCAnsTaxRateChange
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsMoneyDrawOut@@YAXHH_J@Z			; GCAnsMoneyDrawOut
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsMoneyDrawOut@@YAXHH_J@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_i64Money$ = 16						; size = 8
?GCAnsMoneyDrawOut@@YAXHH_J@Z PROC			; GCAnsMoneyDrawOut, COMDAT

; 18803: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18804: #if (GS_CASTLE==1)
; 18805: 	PMSG_ANS_MONEYDRAWOUT pMsgResult;
; 18806: 
; 18807: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x10,sizeof(pMsgResult));
; 18808: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  00013	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18809: 
; 18810: 	pMsgResult.btMoney1 = DWORD((DWORD(i64Money >> 32) >> 16) & 0xFFFF) >> 8;

  00016	8b 45 14	 mov	 eax, DWORD PTR _i64Money$[ebp+4]
  00019	8b d0		 mov	 edx, eax
  0001b	c1 ea 18	 shr	 edx, 24			; 00000018H
  0001e	88 55 f1	 mov	 BYTE PTR _pMsgResult$[ebp+5], dl
  00021	8b c8		 mov	 ecx, eax
  00023	c1 f9 1f	 sar	 ecx, 31			; 0000001fH

; 18811: 	pMsgResult.btMoney2 = DWORD((DWORD(i64Money >> 32) >> 16) & 0xFFFF) & 0xFF;
; 18812: 	pMsgResult.btMoney3 = DWORD((DWORD(i64Money >> 32) & 0xFFFF) & 0xFFFF) >> 8;

  00026	8b d0		 mov	 edx, eax
  00028	8b c8		 mov	 ecx, eax
  0002a	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0002d	c1 ea 08	 shr	 edx, 8

; 18813: 	pMsgResult.btMoney4 = DWORD((DWORD(i64Money >> 32) & 0xFFFF) & 0xFFFF) & 0xFF;

  00030	88 45 f4	 mov	 BYTE PTR _pMsgResult$[ebp+8], al

; 18814: 
; 18815: 	pMsgResult.btMoney5 = DWORD((DWORD(i64Money & 0xFFFFFFFF) >> 16) & 0xFFFF) >> 8;

  00033	8b 45 10	 mov	 eax, DWORD PTR _i64Money$[ebp]
  00036	88 4d f2	 mov	 BYTE PTR _pMsgResult$[ebp+6], cl
  00039	88 55 f3	 mov	 BYTE PTR _pMsgResult$[ebp+7], dl

; 18816: 	pMsgResult.btMoney6 = DWORD((DWORD(i64Money & 0xFFFFFFFF) >> 16) & 0xFFFF) & 0xFF;

  0003c	8b d0		 mov	 edx, eax
  0003e	8b c8		 mov	 ecx, eax
  00040	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00043	c1 ea 10	 shr	 edx, 16			; 00000010H
  00046	88 4d f5	 mov	 BYTE PTR _pMsgResult$[ebp+9], cl
  00049	88 55 f6	 mov	 BYTE PTR _pMsgResult$[ebp+10], dl

; 18817: 	pMsgResult.btMoney7 = DWORD((DWORD(i64Money & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) >> 8;

  0004c	8b c8		 mov	 ecx, eax

; 18818: 	pMsgResult.btMoney8 = DWORD((DWORD(i64Money & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) & 0xFF;
; 18819: 
; 18820: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0004e	6a 0d		 push	 13			; 0000000dH
  00050	8d 55 ec	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00053	88 45 f8	 mov	 BYTE PTR _pMsgResult$[ebp+12], al
  00056	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00059	52		 push	 edx
  0005a	c1 e9 08	 shr	 ecx, 8
  0005d	50		 push	 eax
  0005e	c7 45 ec c1 0d
	b2 10		 mov	 DWORD PTR _pMsgResult$[ebp], 280104385 ; 10b20dc1H
  00065	88 4d f7	 mov	 BYTE PTR _pMsgResult$[ebp+11], cl
  00068	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18821: #endif
; 18822: }

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?GCAnsMoneyDrawOut@@YAXHH_J@Z ENDP			; GCAnsMoneyDrawOut
_TEXT	ENDS
PUBLIC	?GCAnsCsGateState@@YAXHHH@Z			; GCAnsCsGateState
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsGateState@@YAXHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 7
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iGateIndex$ = 16					; size = 4
?GCAnsCsGateState@@YAXHHH@Z PROC			; GCAnsCsGateState, COMDAT

; 18834: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18835: #if (GS_CASTLE==1)
; 18836: 
; 18837: 	PMSG_ANS_CSGATESTATE pMsgResult;
; 18838: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x11,sizeof(pMsgResult));
; 18839: 
; 18840: 	pMsgResult.btResult = iResult;

  00006	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  00009	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18841: 	pMsgResult.btIndex1 = SET_NUMBERH(iGateIndex & 0xFFFF);

  0000c	8b 45 10	 mov	 eax, DWORD PTR _iGateIndex$[ebp]
  0000f	8b c8		 mov	 ecx, eax

; 18842: 	pMsgResult.btIndex2 = SET_NUMBERL(iGateIndex & 0xFFFF);
; 18843: 
; 18844: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00011	6a 07		 push	 7
  00013	8d 55 f8	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00016	88 45 fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], al
  00019	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0001c	52		 push	 edx
  0001d	c1 e9 08	 shr	 ecx, 8
  00020	50		 push	 eax
  00021	c7 45 f8 c1 07
	b2 11		 mov	 DWORD PTR _pMsgResult$[ebp], 296880065 ; 11b207c1H
  00028	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18845: #endif
; 18846: }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCAnsCsGateState@@YAXHHH@Z ENDP			; GCAnsCsGateState
_TEXT	ENDS
PUBLIC	?GCAnsCsGateOperate@@YAXHHHH@Z			; GCAnsCsGateOperate
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsGateOperate@@YAXHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 8
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iGateIndex$ = 16					; size = 4
_iGateOperate$ = 20					; size = 4
?GCAnsCsGateOperate@@YAXHHHH@Z PROC			; GCAnsCsGateOperate, COMDAT

; 18916: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18917: #if (GS_CASTLE==1)
; 18918: 
; 18919: 	PMSG_ANS_CSGATEOPERATE pMsgResult;
; 18920: 
; 18921: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x12,sizeof(pMsgResult));
; 18922: 	pMsgResult.btResult = iResult;

  00006	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18923: 	pMsgResult.btOperate = iGateOperate;

  00009	8a 4d 14	 mov	 cl, BYTE PTR _iGateOperate$[ebp]
  0000c	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18924: 	pMsgResult.btIndex1 = SET_NUMBERH(iGateIndex & 0xFFFF);

  0000f	8b 45 10	 mov	 eax, DWORD PTR _iGateIndex$[ebp]
  00012	8b d0		 mov	 edx, eax

; 18925: 	pMsgResult.btIndex2 = SET_NUMBERL(iGateIndex & 0xFFFF);

  00014	88 45 ff	 mov	 BYTE PTR _pMsgResult$[ebp+7], al

; 18926: 
; 18927: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00017	6a 08		 push	 8
  00019	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0001c	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00022	50		 push	 eax
  00023	c1 ea 08	 shr	 edx, 8
  00026	51		 push	 ecx
  00027	c7 45 f8 c1 08
	b2 12		 mov	 DWORD PTR _pMsgResult$[ebp], 313657537 ; 12b208c1H
  0002e	88 55 fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl
  00031	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18928: #endif
; 18929: }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?GCAnsCsGateOperate@@YAXHHHH@Z ENDP			; GCAnsCsGateOperate
_TEXT	ENDS
PUBLIC	?GCAnsCsGateCurState@@YAXHHH@Z			; GCAnsCsGateCurState
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsGateCurState@@YAXHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 7
_iIndex$ = 8						; size = 4
_iGateIndex$ = 12					; size = 4
_iGateOperate$ = 16					; size = 4
?GCAnsCsGateCurState@@YAXHHH@Z PROC			; GCAnsCsGateCurState, COMDAT

; 18941: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18942: #if (GS_CASTLE==1)
; 18943: 	PMSG_ANS_CSGATECURSTATE pMsgResult;
; 18944: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x13,sizeof(pMsgResult));
; 18945: 
; 18946: 	pMsgResult.btOperate = iGateOperate;

  00006	8a 45 10	 mov	 al, BYTE PTR _iGateOperate$[ebp]
  00009	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18947: 	pMsgResult.btIndex1 = SET_NUMBERH(iGateIndex & 0xFFFF);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _iGateIndex$[ebp]
  0000f	8b c8		 mov	 ecx, eax

; 18948: 	pMsgResult.btIndex2 = SET_NUMBERL(iGateIndex & 0xFFFF);
; 18949: 
; 18950: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00011	6a 07		 push	 7
  00013	8d 55 f8	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00016	88 45 fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], al
  00019	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0001c	52		 push	 edx
  0001d	c1 e9 08	 shr	 ecx, 8
  00020	50		 push	 eax
  00021	c7 45 f8 c1 07
	b2 13		 mov	 DWORD PTR _pMsgResult$[ebp], 330434497 ; 13b207c1H
  00028	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18951: #endif
; 18952: }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCAnsCsGateCurState@@YAXHHH@Z ENDP			; GCAnsCsGateCurState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsCsAccessSwitchState@@YAXHHHE@Z		; GCAnsCsAccessSwitchState
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsAccessSwitchState@@YAXHHHE@Z
_TEXT	SEGMENT
_pMsgResult$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iSwitchIndex$ = 12					; size = 4
_iSwitchUserIndex$ = 16					; size = 4
_btSwitchState$ = 20					; size = 1
?GCAnsCsAccessSwitchState@@YAXHHHE@Z PROC		; GCAnsCsAccessSwitchState, COMDAT

; 18966: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18967: #if (GS_CASTLE==1)
; 18968: 	PMSG_ANS_NOTIFYSWITCHPROC pMsgResult;
; 18969: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x14,sizeof(pMsgResult));
; 18970: 
; 18971: 	pMsgResult.btIndex1 = SET_NUMBERH(iSwitchIndex & 0xFFFF);

  00010	8b 45 0c	 mov	 eax, DWORD PTR _iSwitchIndex$[ebp]
  00013	8b c8		 mov	 ecx, eax

; 18972: 	pMsgResult.btIndex2 = SET_NUMBERL(iSwitchIndex & 0xFFFF);

  00015	88 45 f5	 mov	 BYTE PTR _pMsgResult$[ebp+5], al

; 18973: 
; 18974: 	pMsgResult.btUserIndex1 = SET_NUMBERH(iSwitchUserIndex & 0xFFFF);

  00018	8b 45 10	 mov	 eax, DWORD PTR _iSwitchUserIndex$[ebp]
  0001b	c1 e9 08	 shr	 ecx, 8
  0001e	8b d0		 mov	 edx, eax
  00020	c1 ea 08	 shr	 edx, 8
  00023	88 4d f4	 mov	 BYTE PTR _pMsgResult$[ebp+4], cl

; 18975: 	pMsgResult.btUserIndex2 = SET_NUMBERL(iSwitchUserIndex & 0xFFFF);
; 18976: 
; 18977: 	pMsgResult.btSwitchState = btSwitchState;
; 18978: 
; 18979: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00026	6a 09		 push	 9
  00028	8d 4d f0	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
  0002b	88 55 f6	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl
  0002e	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00031	88 45 f7	 mov	 BYTE PTR _pMsgResult$[ebp+7], al
  00034	8a 45 14	 mov	 al, BYTE PTR _btSwitchState$[ebp]
  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	c7 45 f0 c1 09
	b2 14		 mov	 DWORD PTR _pMsgResult$[ebp], 347212225 ; 14b209c1H
  00040	88 45 f8	 mov	 BYTE PTR _pMsgResult$[ebp+8], al
  00043	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18980: #endif
; 18981: }

  00048	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004b	33 cd		 xor	 ecx, ebp
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?GCAnsCsAccessSwitchState@@YAXHHHE@Z ENDP		; GCAnsCsAccessSwitchState
_TEXT	ENDS
PUBLIC	??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@ ; `string'
PUBLIC	??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@ ; `string'
PUBLIC	??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsCsAccessCrownState@@YAXHE@Z		; GCAnsCsAccessCrownState
EXTRN	?GetCrownAccessTickCount@CCastleSiege@@QAEHXZ:PROC ; CCastleSiege::GetCrownAccessTickCount
;	COMDAT ??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\include\prodef.h
CONST	SEGMENT
??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@ DB '['
	DB	'CastleSiege] [Reg. Fail] Accumulated Crown AccessTime : %d [%'
	DB	's](%s)(%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@
CONST	SEGMENT
??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@ DB '['
	DB	'CastleSiege] [Reg. Success] Accumulated Crown AccessTime : %d'
	DB	' [%s](%s)(%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@
CONST	SEGMENT
??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@ DB '['
	DB	'CastleSiege] [Reg. Attempt] Accumulated Crown AccessTime : %d'
	DB	' [%s](%s)(%s)', 00H				; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?GCAnsCsAccessCrownState@@YAXHE@Z
_TEXT	SEGMENT
_pMsgResult$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_btCrownState$ = 12					; size = 1
?GCAnsCsAccessCrownState@@YAXHE@Z PROC			; GCAnsCsAccessCrownState, COMDAT

; 18992: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18993: #if (GS_CASTLE==1)
; 18994: 	PMSG_ANS_NOTIFYCROWNPROC pMsgResult;
; 18995: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x15,sizeof(pMsgResult));
; 18996: 	pMsgResult.btCrownState = btCrownState;

  00010	8a 45 0c	 mov	 al, BYTE PTR _btCrownState$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00017	c7 45 f0 c1 0c
	b2 15		 mov	 DWORD PTR _pMsgResult$[ebp], 363990209 ; 15b20cc1H
  0001e	88 45 f4	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18997: 
; 18998: 	if(btCrownState == 0)

  00021	84 c0		 test	 al, al
  00023	75 5f		 jne	 SHORT $LN7@GCAnsCsAcc

; 18999: 	{
; 19000: 		if(gObj[iIndex].m_iAccumulatedCrownAccessTime < 0 || gObj[iIndex].m_iAccumulatedCrownAccessTime > 30000)

  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	8b c3		 mov	 eax, ebx
  0002d	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00033	8b 94 08 74 20
	00 00		 mov	 edx, DWORD PTR [eax+ecx+8308]
  0003a	85 d2		 test	 edx, edx
  0003c	78 08		 js	 SHORT $LN5@GCAnsCsAcc
  0003e	81 fa 30 75 00
	00		 cmp	 edx, 30000		; 00007530H
  00044	7e 11		 jle	 SHORT $LN6@GCAnsCsAcc
$LN5@GCAnsCsAcc:

; 19001: 		{
; 19002: 			gObj[iIndex].m_iAccumulatedCrownAccessTime = 0;

  00046	c7 84 08 74 20
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+ecx+8308], 0
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN6@GCAnsCsAcc:

; 19003: 		}
; 19004: 
; 19005: 		LogAddTD("[CastleSiege] [Reg. Attempt] Accumulated Crown AccessTime : %d [%s](%s)(%s)",
; 19006: 			gObj[iIndex].m_iAccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].AccountID,gObj[iIndex].Name);

  00057	8d 54 08 5d	 lea	 edx, DWORD PTR [eax+ecx+93]
  0005b	52		 push	 edx
  0005c	8d 54 08 52	 lea	 edx, DWORD PTR [eax+ecx+82]
  00060	52		 push	 edx
  00061	8d 94 08 1c 06
	00 00		 lea	 edx, DWORD PTR [eax+ecx+1564]
  00068	8b 84 08 74 20
	00 00		 mov	 eax, DWORD PTR [eax+ecx+8308]
  0006f	52		 push	 edx
  00070	50		 push	 eax
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0007c	83 c4 14	 add	 esp, 20			; 00000014H

; 19007: 	}
; 19008: 
; 19009: 	if(btCrownState == 1)

  0007f	e9 dd 00 00 00	 jmp	 $LN3@GCAnsCsAcc
$LN7@GCAnsCsAcc:
  00084	56		 push	 esi
  00085	3c 01		 cmp	 al, 1
  00087	75 47		 jne	 SHORT $LN4@GCAnsCsAcc

; 19010: 	{
; 19011: 		LogAddTD("[CastleSiege] [Reg. Success] Accumulated Crown AccessTime : %d [%s](%s)(%s)",
; 19012: 			gObj[iIndex].m_iAccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].AccountID,gObj[iIndex].Name);

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008e	8b f3		 mov	 esi, ebx
  00090	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00096	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0009a	51		 push	 ecx
  0009b	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  0009f	52		 push	 edx
  000a0	8b 94 06 74 20
	00 00		 mov	 edx, DWORD PTR [esi+eax+8308]
  000a7	8d 8c 06 1c 06
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1564]
  000ae	51		 push	 ecx
  000af	52		 push	 edx
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 19013: 		gObj[iIndex].m_iAccumulatedCrownAccessTime = 0;

  000bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c0	c7 84 06 74 20
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+8308], 0

; 19014: 	}
; 19015: 
; 19016: 	if(btCrownState == 2)

  000cb	e9 8d 00 00 00	 jmp	 $LN13@GCAnsCsAcc
$LN4@GCAnsCsAcc:
  000d0	3c 02		 cmp	 al, 2
  000d2	0f 85 88 00 00
	00		 jne	 $LN12@GCAnsCsAcc

; 19017: 	{
; 19018: 		gObj[iIndex].m_iAccumulatedCrownAccessTime += GetTickCount() - g_CastleSiege.GetCrownAccessTickCount();

  000d8	8b f3		 mov	 esi, ebx
  000da	57		 push	 edi
  000db	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  000e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000e6	e8 00 00 00 00	 call	 ?GetCrownAccessTickCount@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCrownAccessTickCount
  000eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f1	8b bc 0e 74 20
	00 00		 mov	 edi, DWORD PTR [esi+ecx+8308]
  000f8	2b f8		 sub	 edi, eax
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00100	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00106	03 c7		 add	 eax, edi
  00108	89 84 16 74 20
	00 00		 mov	 DWORD PTR [esi+edx+8308], eax

; 19019: 
; 19020: 		if(gObj[iIndex].m_iAccumulatedCrownAccessTime < 0 || gObj[iIndex].m_iAccumulatedCrownAccessTime > 30000)

  0010f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00114	8b 8c 06 74 20
	00 00		 mov	 ecx, DWORD PTR [esi+eax+8308]
  0011b	5f		 pop	 edi
  0011c	85 c9		 test	 ecx, ecx
  0011e	78 08		 js	 SHORT $LN1@GCAnsCsAcc
  00120	81 f9 30 75 00
	00		 cmp	 ecx, 30000		; 00007530H
  00126	7e 10		 jle	 SHORT $LN2@GCAnsCsAcc
$LN1@GCAnsCsAcc:

; 19021: 		{
; 19022: 			gObj[iIndex].m_iAccumulatedCrownAccessTime = 0;

  00128	c7 84 06 74 20
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+8308], 0
  00133	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN2@GCAnsCsAcc:

; 19023: 		}
; 19024: 
; 19025: 		LogAddTD("[CastleSiege] [Reg. Fail] Accumulated Crown AccessTime : %d [%s](%s)(%s)",
; 19026: 			gObj[iIndex].m_iAccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].AccountID,gObj[iIndex].Name);

  00138	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0013c	51		 push	 ecx
  0013d	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00141	52		 push	 edx
  00142	8b 94 06 74 20
	00 00		 mov	 edx, DWORD PTR [esi+eax+8308]
  00149	8d 8c 06 1c 06
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1564]
  00150	51		 push	 ecx
  00151	52		 push	 edx
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
$LN13@GCAnsCsAcc:
  0015d	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@GCAnsCsAcc:
  00160	5e		 pop	 esi
$LN3@GCAnsCsAcc:

; 19027: 	}
; 19028: 
; 19029: 	pMsgResult.dwAccessTime = gObj[iIndex].m_iAccumulatedCrownAccessTime;

  00161	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00167	8b c3		 mov	 eax, ebx
  00169	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0016f	8b 94 08 74 20
	00 00		 mov	 edx, DWORD PTR [eax+ecx+8308]

; 19030: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00176	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsgResult$[ebp+1]
  0017a	50		 push	 eax
  0017b	8d 4d f0	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
  0017e	51		 push	 ecx
  0017f	53		 push	 ebx
  00180	89 55 f8	 mov	 DWORD PTR _pMsgResult$[ebp+8], edx
  00183	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 19031: #endif
; 19032: }

  00188	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018e	33 cd		 xor	 ecx, ebp
  00190	5b		 pop	 ebx
  00191	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c3		 ret	 0
?GCAnsCsAccessCrownState@@YAXHE@Z ENDP			; GCAnsCsAccessCrownState
_TEXT	ENDS
PUBLIC	?GCAnsCsNotifyStart@@YAXHE@Z			; GCAnsCsNotifyStart
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsNotifyStart@@YAXHE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 5
_iIndex$ = 8						; size = 4
_btStartState$ = 12					; size = 1
?GCAnsCsNotifyStart@@YAXHE@Z PROC			; GCAnsCsNotifyStart, COMDAT

; 19042: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19043: #if (GS_CASTLE==1)
; 19044: 	PMSG_ANS_NOTIFYCSSTART pMsgResult;
; 19045: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x17,sizeof(pMsgResult));
; 19046: 	pMsgResult.btStartState = btStartState;
; 19047: 
; 19048: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00006	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00009	8a 45 0c	 mov	 al, BYTE PTR _btStartState$[ebp]
  0000c	6a 05		 push	 5
  0000e	8d 4d f8	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	c7 45 f8 c1 05
	b2 17		 mov	 DWORD PTR _pMsgResult$[ebp], 397542849 ; 17b205c1H
  0001a	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  0001d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19049: #endif
; 19050: }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?GCAnsCsNotifyStart@@YAXHE@Z ENDP			; GCAnsCsNotifyStart
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsCsNotifyProgress@@YAXHEPBD@Z		; GCAnsCsNotifyProgress
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsNotifyProgress@@YAXHEPBD@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_btCastleSiegeState$ = 12				; size = 1
_lpszGuildName$ = 16					; size = 4
?GCAnsCsNotifyProgress@@YAXHEPBD@Z PROC			; GCAnsCsNotifyProgress, COMDAT

; 19063: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _lpszGuildName$[ebp]

; 19064: 	if ( lpszGuildName == NULL )

  00013	85 c9		 test	 ecx, ecx
  00015	74 36		 je	 SHORT $LN2@GCAnsCsNot

; 19065: 		return;
; 19066: 
; 19067: 	PMSG_ANS_NOTIFYCSPROGRESS pMsgResult;
; 19068: 
; 19069: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x18, sizeof(pMsgResult));
; 19070: 	pMsgResult.btCastleSiegeState = btCastleSiegeState;

  00017	8a 45 0c	 mov	 al, BYTE PTR _btCastleSiegeState$[ebp]
  0001a	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 19071: 	memset(pMsgResult.szGuildName, 0, sizeof(pMsgResult.szGuildName));

  0001d	33 c0		 xor	 eax, eax
  0001f	89 45 f1	 mov	 DWORD PTR _pMsgResult$[ebp+5], eax
  00022	89 45 f5	 mov	 DWORD PTR _pMsgResult$[ebp+9], eax

; 19072: 	memcpy(pMsgResult.szGuildName, lpszGuildName, sizeof(pMsgResult.szGuildName));

  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002a	b2 0d		 mov	 dl, 13			; 0000000dH

; 19073: 
; 19074: 	DataSend(iIndex, (UCHAR*)&pMsgResult, pMsgResult.h.size);

  0002c	0f b6 d2	 movzx	 edx, dl
  0002f	89 45 f1	 mov	 DWORD PTR _pMsgResult$[ebp+5], eax
  00032	52		 push	 edx
  00033	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00036	89 4d f5	 mov	 DWORD PTR _pMsgResult$[ebp+9], ecx
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0003c	50		 push	 eax
  0003d	51		 push	 ecx
  0003e	c7 45 ec c1 0d
	b2 18		 mov	 DWORD PTR _pMsgResult$[ebp], 414322113 ; 18b20dc1H
  00045	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCAnsCsNot:

; 19075: }

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00050	33 cd		 xor	 ecx, ebp
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?GCAnsCsNotifyProgress@@YAXHEPBD@Z ENDP			; GCAnsCsNotifyProgress
_TEXT	ENDS
PUBLIC	?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z			; GCAnsCsMapSvrTaxInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_iIndex$ = 8						; size = 4
_btTaxType$ = 12					; size = 1
_btTaxRate$ = 16					; size = 1
?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z PROC			; GCAnsCsMapSvrTaxInfo, COMDAT

; 19087: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19088: 	PMSG_ANS_MAPSVRTAXINFO pMsgResult;
; 19089: 	
; 19090: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1A, sizeof(pMsgResult));
; 19091: 	pMsgResult.btTaxType = btTaxType;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btTaxType$[ebp]

; 19092: 	pMsgResult.btTaxRate = btTaxRate;

  00009	8a 4d 10	 mov	 cl, BYTE PTR _btTaxRate$[ebp]

; 19093: 
; 19094: 	DataSend(iIndex, (UCHAR*)&pMsgResult, pMsgResult.h.size);

  0000c	6a 06		 push	 6
  0000e	8d 55 f8	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00011	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00014	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	c7 45 f8 c1 06
	b2 1a		 mov	 DWORD PTR _pMsgResult$[ebp], 447874753 ; 1ab206c1H
  00020	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  00023	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19095: 
; 19096: }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z ENDP			; GCAnsCsMapSvrTaxInfo
_TEXT	ENDS
PUBLIC	?GCAnsCsMiniMapData@@YAXHE@Z			; GCAnsCsMiniMapData
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsMiniMapData@@YAXHE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 5
_iIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
?GCAnsCsMiniMapData@@YAXHE@Z PROC			; GCAnsCsMiniMapData, COMDAT

; 19133: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19134: 	PMSG_ANS_MINIMAPDATA pMsgResult;
; 19135: 
; 19136: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1B, sizeof(pMsgResult));
; 19137: 	pMsgResult.btResult = btResult;
; 19138: 
; 19139: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00006	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00009	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]
  0000c	6a 05		 push	 5
  0000e	8d 4d f8	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	c7 45 f8 c1 05
	b2 1b		 mov	 DWORD PTR _pMsgResult$[ebp], 464651713 ; 1bb205c1H
  0001a	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  0001d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19140: }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?GCAnsCsMiniMapData@@YAXHE@Z ENDP			; GCAnsCsMiniMapData
_TEXT	ENDS
PUBLIC	?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z ; CGReqStopCsMiniMapData
EXTRN	?DelMiniMapDataReqUser@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::DelMiniMapDataReqUser
; Function compile flags: /Ogtp
;	COMDAT ?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z PROC ; CGReqStopCsMiniMapData, COMDAT

; 19145: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 19146: #if (GS_CASTLE==1)
; 19147: 	if(gObjIsConnected(iIndex) == FALSE)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 0b		 je	 SHORT $LN2@CGReqStopC

; 19148: 		return;
; 19149: 	g_CastleSiege.DelMiniMapDataReqUser(iIndex);

  00014	56		 push	 esi
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0001a	e8 00 00 00 00	 call	 ?DelMiniMapDataReqUser@CCastleSiege@@QAEXH@Z ; CCastleSiege::DelMiniMapDataReqUser
$LN2@CGReqStopC:
  0001f	5e		 pop	 esi

; 19150: #endif
; 19151: }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z ENDP ; CGReqStopCsMiniMapData
_TEXT	ENDS
PUBLIC	?GCAnsCsSendCommand@@YAXHEEEE@Z			; GCAnsCsSendCommand
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsSendCommand@@YAXHEEEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 8
_iCsJoinSize$ = 8					; size = 4
_btTeam$ = 12						; size = 1
_btX$ = 16						; size = 1
_btY$ = 20						; size = 1
_btCommand$ = 24					; size = 1
?GCAnsCsSendCommand@@YAXHEEEE@Z PROC			; GCAnsCsSendCommand, COMDAT

; 19183: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19184: #if (GS_CASTLE==1)
; 19185: 	PMSG_ANS_CSCOMMAND pMsgResult;
; 19186: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1D, sizeof(pMsgResult));
; 19187: 
; 19188: 	pMsgResult.btTeam = btTeam;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btTeam$[ebp]

; 19189: 	pMsgResult.btX = btX;

  00009	8a 4d 10	 mov	 cl, BYTE PTR _btX$[ebp]

; 19190: 	pMsgResult.btY = btY;

  0000c	8a 55 14	 mov	 dl, BYTE PTR _btY$[ebp]
  0000f	53		 push	 ebx
  00010	8b 5d 08	 mov	 ebx, DWORD PTR _iCsJoinSize$[ebp]
  00013	56		 push	 esi
  00014	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 19191: 	pMsgResult.btCommand = btCommand;

  00017	8a 45 18	 mov	 al, BYTE PTR _btCommand$[ebp]
  0001a	57		 push	 edi
  0001b	c7 45 f8 c1 08
	b2 1d		 mov	 DWORD PTR _pMsgResult$[ebp], 498206913 ; 1db208c1H
  00022	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  00025	88 55 fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl
  00028	88 45 ff	 mov	 BYTE PTR _pMsgResult$[ebp+7], al

; 19192: 
; 19193: 	for(int iIndex = OBJ_STARTUSERINDEX; iIndex < OBJMAX; iIndex++)

  0002b	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  00030	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL5@GCAnsCsSen:

; 19194: 	{
; 19195: 		if(gObjIsConnected(iIndex) == FALSE)

  00035	57		 push	 edi
  00036	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003b	83 c4 04	 add	 esp, 4
  0003e	85 c0		 test	 eax, eax
  00040	74 2d		 je	 SHORT $LN4@GCAnsCsSen

; 19196: 			continue;
; 19197: 
; 19198: 		if(gObj[iIndex].m_btCsJoinSide == iCsJoinSize && gObj[iIndex].MapNumber == MAP_INDEX_CASTLESIEGE)

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00047	0f b6 8c 06 5a
	20 00 00	 movzx	 ecx, BYTE PTR [esi+eax+8282]
  0004f	3b cb		 cmp	 ecx, ebx
  00051	75 1c		 jne	 SHORT $LN4@GCAnsCsSen
  00053	80 bc 06 23 01
	00 00 1e	 cmp	 BYTE PTR [esi+eax+291], 30 ; 0000001eH
  0005b	75 12		 jne	 SHORT $LN4@GCAnsCsSen

; 19199: 		{
; 19200: 			DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0005d	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsgResult$[ebp+1]
  00061	52		 push	 edx
  00062	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00065	50		 push	 eax
  00066	57		 push	 edi
  00067	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GCAnsCsSen:

; 19192: 
; 19193: 	for(int iIndex = OBJ_STARTUSERINDEX; iIndex < OBJMAX; iIndex++)

  0006f	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00075	47		 inc	 edi
  00076	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  0007c	7c b7		 jl	 SHORT $LL5@GCAnsCsSen
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx

; 19201: 		}
; 19202: 	}
; 19203: #endif
; 19204: }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?GCAnsCsSendCommand@@YAXHEEEE@Z ENDP			; GCAnsCsSendCommand
_TEXT	ENDS
PUBLIC	?GCAnsCsLeftTimeAlarm@@YAXEE@Z			; GCAnsCsLeftTimeAlarm
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsLeftTimeAlarm@@YAXEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_btHour$ = 8						; size = 1
_btMinute$ = 12						; size = 1
?GCAnsCsLeftTimeAlarm@@YAXEE@Z PROC			; GCAnsCsLeftTimeAlarm, COMDAT

; 19217: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19218: 	PMSG_ANS_CSLEFTTIMEALARM pMsgResult;
; 19219: 
; 19220: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1E, sizeof(pMsgResult));
; 19221: 	pMsgResult.btHour = btHour;

  00006	8a 45 08	 mov	 al, BYTE PTR _btHour$[ebp]

; 19222: 	pMsgResult.btMinute = btMinute;

  00009	8a 4d 0c	 mov	 cl, BYTE PTR _btMinute$[ebp]
  0000c	56		 push	 esi
  0000d	c7 45 f8 c1 06
	b2 1e		 mov	 DWORD PTR _pMsgResult$[ebp], 514983617 ; 1eb206c1H
  00014	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00017	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl

; 19223: 
; 19224: 	for (int iIndex = OBJ_STARTUSERINDEX;iIndex < OBJMAX;iIndex++)

  0001a	be 04 29 00 00	 mov	 esi, 10500		; 00002904H
  0001f	90		 npad	 1
$LL4@GCAnsCsLef:

; 19225: 	{
; 19226: 		if ( !gObjIsConnected(iIndex) )

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	74 12		 je	 SHORT $LN3@GCAnsCsLef

; 19227: 		{
; 19228: 			continue;
; 19229: 		}
; 19230: 
; 19231: 		DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0002d	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsgResult$[ebp+1]
  00031	52		 push	 edx
  00032	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00035	50		 push	 eax
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCAnsCsLef:

; 19223: 
; 19224: 	for (int iIndex = OBJ_STARTUSERINDEX;iIndex < OBJMAX;iIndex++)

  0003f	46		 inc	 esi
  00040	81 fe ec 2c 00
	00		 cmp	 esi, 11500		; 00002cecH
  00046	7c d8		 jl	 SHORT $LL4@GCAnsCsLef
  00048	5e		 pop	 esi

; 19232: 	}
; 19233: 
; 19234: }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?GCAnsCsLeftTimeAlarm@@YAXEE@Z ENDP			; GCAnsCsLeftTimeAlarm
_TEXT	ENDS
PUBLIC	?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z		; GCAnsSelfCsLeftTimeAlarm
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_iIndex$ = 8						; size = 4
_btHour$ = 12						; size = 1
_btMinute$ = 16						; size = 1
?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z PROC		; GCAnsSelfCsLeftTimeAlarm, COMDAT

; 19242: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19243: 	PMSG_ANS_CSLEFTTIMEALARM pMsgResult;
; 19244: 
; 19245: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1E, sizeof(pMsgResult));
; 19246: 	pMsgResult.btHour = btHour;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btHour$[ebp]

; 19247: 	pMsgResult.btMinute = btMinute;

  00009	8a 4d 10	 mov	 cl, BYTE PTR _btMinute$[ebp]
  0000c	56		 push	 esi

; 19248: 
; 19249: 	if ( !gObjIsConnected(iIndex))

  0000d	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00010	56		 push	 esi
  00011	c7 45 f8 c1 06
	b2 1e		 mov	 DWORD PTR _pMsgResult$[ebp], 514983617 ; 1eb206c1H
  00018	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  0001b	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  0001e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	74 12		 je	 SHORT $LN2@GCAnsSelfC

; 19250: 	{
; 19251: 		return;
; 19252: 	}
; 19253: 
; 19254: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0002a	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsgResult$[ebp+1]
  0002e	52		 push	 edx
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00032	50		 push	 eax
  00033	56		 push	 esi
  00034	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCAnsSelfC:
  0003c	5e		 pop	 esi

; 19255: }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z ENDP		; GCAnsSelfCsLeftTimeAlarm
_TEXT	ENDS
PUBLIC	?GCAnsCsSetEnterHuntZone@@YAXHEE@Z		; GCAnsCsSetEnterHuntZone
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_iIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
_btEnterHuntZone$ = 16					; size = 1
?GCAnsCsSetEnterHuntZone@@YAXHEE@Z PROC			; GCAnsCsSetEnterHuntZone, COMDAT

; 19296: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19297: 	PMSG_ANS_CSHUNTZONEENTER pMsgResult;
; 19298: 
; 19299: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1F, sizeof(pMsgResult));
; 19300: 	pMsgResult.btResult = btResult;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]

; 19301: 	pMsgResult.btHuntZoneEnter = btEnterHuntZone;

  00009	8a 4d 10	 mov	 cl, BYTE PTR _btEnterHuntZone$[ebp]

; 19302: 
; 19303: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0000c	6a 06		 push	 6
  0000e	8d 55 f8	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00011	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00014	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	c7 45 f8 c1 06
	b2 1f		 mov	 DWORD PTR _pMsgResult$[ebp], 531760833 ; 1fb206c1H
  00020	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  00023	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19304: }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ENDP			; GCAnsCsSetEnterHuntZone
_TEXT	ENDS
PUBLIC	??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z	; CGReqNpcDbList
EXTRN	?SendNpcStateList@CCastleSiege@@QAEXHH@Z:PROC	; CCastleSiege::SendNpcStateList
;	COMDAT ??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\include\prodef.h
CONST	SEGMENT
??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcDbList() ERROR - Authority Fail [%s][%s],'
	DB	' Guild:(%s)(%d)', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z
_TEXT	SEGMENT
_pMsgResult$224935 = -16				; size = 12
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z PROC	; CGReqNpcDbList, COMDAT

; 19315: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 19316: #if (GS_CASTLE==1)
; 19317: 	if(lpMsg == NULL)

  00010	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00014	53		 push	 ebx
  00015	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00018	0f 84 14 01 00
	00		 je	 $LN3@CGReqNpcDb

; 19318: 		return;
; 19319: 
; 19320: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00023	56		 push	 esi
  00024	8b f3		 mov	 esi, ebx
  00026	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0002c	57		 push	 edi
  0002d	8d bc 06 1c 06
	00 00		 lea	 edi, DWORD PTR [esi+eax+1564]
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00039	8b c7		 mov	 eax, edi
  0003b	eb 03 8d 49 00	 npad	 5
$LL13@CGReqNpcDb:
  00040	8a 10		 mov	 dl, BYTE PTR [eax]
  00042	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00044	75 1a		 jne	 SHORT $LN14@CGReqNpcDb
  00046	84 d2		 test	 dl, dl
  00048	74 12		 je	 SHORT $LN15@CGReqNpcDb
  0004a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0004d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00050	75 0e		 jne	 SHORT $LN14@CGReqNpcDb
  00052	83 c0 02	 add	 eax, 2
  00055	83 c1 02	 add	 ecx, 2
  00058	84 d2		 test	 dl, dl
  0005a	75 e4		 jne	 SHORT $LL13@CGReqNpcDb
$LN15@CGReqNpcDb:
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 05		 jmp	 SHORT $LN16@CGReqNpcDb
$LN14@CGReqNpcDb:
  00060	1b c0		 sbb	 eax, eax
  00062	83 d8 ff	 sbb	 eax, -1
$LN16@CGReqNpcDb:
  00065	85 c0		 test	 eax, eax
  00067	0f 84 c3 00 00
	00		 je	 $LN17@CGReqNpcDb

; 19321: 		return;
; 19322: 
; 19323: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE ||
; 19324: 		(gObj[iIndex].GuildStatus != G_MASTER && gObj[iIndex].GuildStatus != G_SUB_MASTER))

  0006d	57		 push	 edi
  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00073	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00078	85 c0		 test	 eax, eax
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007f	74 67		 je	 SHORT $LN5@CGReqNpcDb
  00081	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  00088	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0008e	74 05		 je	 SHORT $LN6@CGReqNpcDb
  00090	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00093	75 53		 jne	 SHORT $LN5@CGReqNpcDb
$LN6@CGReqNpcDb:

; 19335: 		return;
; 19336: 	}
; 19337: 
; 19338: 	switch(lpMsg->btMonsterCode)

  00095	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00098	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0009c	48		 dec	 eax
  0009d	74 28		 je	 SHORT $LN2@CGReqNpcDb
  0009f	48		 dec	 eax
  000a0	0f 85 8a 00 00
	00		 jne	 $LN17@CGReqNpcDb

; 19342: 		break;
; 19343: 	case 2:
; 19344: 		g_CastleSiege.SendNpcStateList(iIndex,283);

  000a6	68 1b 01 00 00	 push	 283			; 0000011bH
  000ab	53		 push	 ebx
  000ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b1	e8 00 00 00 00	 call	 ?SendNpcStateList@CCastleSiege@@QAEXHH@Z ; CCastleSiege::SendNpcStateList
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx

; 19345: 		break;
; 19346: 	}
; 19347: 
; 19348: #endif
; 19349: }

  000b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bc	33 cd		 xor	 ecx, ebp
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
$LN2@CGReqNpcDb:

; 19339: 	{
; 19340: 	case 1:
; 19341: 		g_CastleSiege.SendNpcStateList(iIndex,277);

  000c7	68 15 01 00 00	 push	 277			; 00000115H
  000cc	53		 push	 ebx
  000cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000d2	e8 00 00 00 00	 call	 ?SendNpcStateList@CCastleSiege@@QAEXHH@Z ; CCastleSiege::SendNpcStateList
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx

; 19345: 		break;
; 19346: 	}
; 19347: 
; 19348: #endif
; 19349: }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	33 cd		 xor	 ecx, ebp
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
$LN5@CGReqNpcDb:

; 19325: 	{
; 19326: 		PMSG_ANS_NPCDBLIST pMsgResult;
; 19327: 
; 19328: 		LogAddC(2,"[CastleSiege] CGReqNpcDbList() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",
; 19329: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  000e8	8b 94 06 28 06
	00 00		 mov	 edx, DWORD PTR [esi+eax+1576]
  000ef	52		 push	 edx
  000f0	8d 8c 06 1c 06
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1564]
  000f7	51		 push	 ecx
  000f8	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  000fc	52		 push	 edx
  000fd	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00101	50		 push	 eax
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@
  00107	6a 02		 push	 2
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 19330: 
; 19331: 		pMsgResult.h.set((PBYTE)&pMsgResult,0xB3,sizeof(pMsgResult));
; 19332: 		pMsgResult.iCount = 0;
; 19333: 		pMsgResult.btResult = 2;
; 19334: 		DataSend(iIndex,(PBYTE)&pMsgResult,sizeof(pMsgResult));

  0010f	6a 0c		 push	 12			; 0000000cH
  00111	8d 4d f0	 lea	 ecx, DWORD PTR _pMsgResult$224935[ebp]
  00114	51		 push	 ecx
  00115	53		 push	 ebx
  00116	c7 45 f0 c2 00
	0c b3		 mov	 DWORD PTR _pMsgResult$224935[ebp], -1291059006 ; b30c00c2H
  0011d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pMsgResult$224935[ebp+8], 0
  00124	c6 45 f4 02	 mov	 BYTE PTR _pMsgResult$224935[ebp+4], 2
  00128	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0012d	83 c4 24	 add	 esp, 36			; 00000024H
$LN17@CGReqNpcDb:
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
$LN3@CGReqNpcDb:

; 19345: 		break;
; 19346: 	}
; 19347: 
; 19348: #endif
; 19349: }

  00132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	5b		 pop	 ebx
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z ENDP	; CGReqNpcDbList
_TEXT	ENDS
PUBLIC	?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z ; CGReqCsRegGuildList
EXTRN	?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z:PROC	; GS_GDReqAllGuildMarkRegInfo
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z PROC ; CGReqCsRegGuildList, COMDAT

; 19354: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19355: #if (GS_CASTLE==1)
; 19356: 	if(lpMsg == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	74 2c		 je	 SHORT $LN2@CGReqCsReg

; 19357: 		return;
; 19358: 
; 19359: 	GS_GDReqAllGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

  00009	a1 00 6b 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92928
  0000e	85 c0		 test	 eax, eax
  00010	74 13		 je	 SHORT $LN4@CGReqCsReg
  00012	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00019	51		 push	 ecx
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqAllGuildMarkRegInfo
  00020	83 c4 08	 add	 esp, 8

; 19360: #endif
; 19361: }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0

; 19357: 		return;
; 19358: 
; 19359: 	GS_GDReqAllGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

$LN4@CGReqCsReg:
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00028	83 c8 ff	 or	 eax, -1
  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqAllGuildMarkRegInfo
  00032	83 c4 08	 add	 esp, 8
$LN2@CGReqCsReg:

; 19360: #endif
; 19361: }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z ENDP ; CGReqCsRegGuildList
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z ; CGReqCsAttkGuildList
EXTRN	?GetCsAttkGuildList@CCastleSiege@@QAEHPAUPMSG_CSATTKGUILDLIST@@PAH@Z:PROC ; CCastleSiege::GetCsAttkGuildList
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z
_TEXT	SEGMENT
_iCount$ = -1032					; size = 4
_cBUFFER$ = -1028					; size = 1022
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z PROC ; CGReqCsAttkGuildList, COMDAT

; 19373: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 19374: #if (GS_CASTLE==1)
; 19375: 
; 19376: 	if(lpMsg == NULL)

  00013	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00017	0f 84 85 00 00
	00		 je	 $LN4@CGReqCsAtt

; 19377: 		return;
; 19378: 
; 19379: 	char cBUFFER[0x3FE];
; 19380: 
; 19381: 	PMSG_ANS_CSATTKGUILDLIST * lpMsgSend = (PMSG_ANS_CSATTKGUILDLIST *)cBUFFER;
; 19382: 	PMSG_CSATTKGUILDLIST * lpMsgSendBody = (PMSG_CSATTKGUILDLIST*)&cBUFFER[sizeof(PMSG_ANS_CSATTKGUILDLIST)];
; 19383: 
; 19384: 	int iCount = 0;
; 19385: 
; 19386: 	lpMsgSend->btResult = g_CastleSiege.GetCsAttkGuildList(lpMsgSendBody,&iCount);

  0001d	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _iCount$[ebp]
  00023	50		 push	 eax
  00024	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _cBUFFER$[ebp+12]
  0002a	51		 push	 ecx
  0002b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00030	c7 85 f8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _iCount$[ebp], 0
  0003a	e8 00 00 00 00	 call	 ?GetCsAttkGuildList@CCastleSiege@@QAEHPAUPMSG_CSATTKGUILDLIST@@PAH@Z ; CCastleSiege::GetCsAttkGuildList
  0003f	88 85 00 fc ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+4], al

; 19387: 	lpMsgSend->iCount = iCount;

  00045	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _iCount$[ebp]
  0004b	89 85 04 fc ff
	ff		 mov	 DWORD PTR _cBUFFER$[ebp+8], eax

; 19388: 
; 19389: 	if(lpMsgSend->iCount < 0)

  00051	85 c0		 test	 eax, eax
  00053	79 04		 jns	 SHORT $LN2@CGReqCsAtt

; 19390: 		lpMsgSend->iCount = 0;

  00055	33 c0		 xor	 eax, eax

; 19391: 
; 19392: 	if(lpMsgSend->iCount > 100)

  00057	eb 0a		 jmp	 SHORT $LN8@CGReqCsAtt
$LN2@CGReqCsAtt:
  00059	83 f8 64	 cmp	 eax, 100		; 00000064H
  0005c	7e 0b		 jle	 SHORT $LN1@CGReqCsAtt

; 19393: 		lpMsgSend->iCount = 100;

  0005e	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
$LN8@CGReqCsAtt:
  00063	89 85 04 fc ff
	ff		 mov	 DWORD PTR _cBUFFER$[ebp+8], eax
$LN1@CGReqCsAtt:

; 19394: 
; 19395: 	lpMsgSend->h.set((PBYTE)lpMsgSend,0xB5,sizeof(PMSG_CSATTKGUILDLIST) * lpMsgSend->iCount + sizeof(PMSG_ANS_CSATTKGUILDLIST));
; 19396: 	DataSend(iIndex,(PBYTE)lpMsgSend,sizeof(PMSG_CSATTKGUILDLIST) * lpMsgSend->iCount + sizeof(PMSG_ANS_CSATTKGUILDLIST));

  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0006c	c1 e0 04	 shl	 eax, 4
  0006f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00072	50		 push	 eax
  00073	8b d0		 mov	 edx, eax
  00075	88 85 fe fb ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+2], al
  0007b	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  00081	50		 push	 eax
  00082	c1 ea 08	 shr	 edx, 8
  00085	51		 push	 ecx
  00086	c6 85 fc fb ff
	ff c2		 mov	 BYTE PTR _cBUFFER$[ebp], 194 ; 000000c2H
  0008d	88 95 fd fb ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+1], dl
  00093	c6 85 ff fb ff
	ff b5		 mov	 BYTE PTR _cBUFFER$[ebp+3], 181 ; 000000b5H
  0009a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@CGReqCsAtt:

; 19397: 
; 19398: #endif
; 19399: }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z ENDP ; CGReqCsAttkGuildList
_TEXT	ENDS
PUBLIC	_iIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z	; CGReqWeaponUse
EXTRN	?SetWeaponCalDamageInfo@CWeapon@@QAEHGEEH@Z:PROC ; CWeapon::SetWeaponCalDamageInfo
EXTRN	?gObjNotifyUseWeaponV1@@YAXPAUOBJECTSTRUCT@@0HH@Z:PROC ; gObjNotifyUseWeaponV1
EXTRN	?GetTargetPointXY@CWeapon@@QAEHHHAAE0H@Z:PROC	; CWeapon::GetTargetPointXY
EXTRN	?g_CsNPC_Weapon@@3VCWeapon@@A:BYTE		; g_CsNPC_Weapon
; Function compile flags: /Ogtp
;	COMDAT ?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z
_TEXT	SEGMENT
_lpOwnerObj$ = -32					; size = 4
_iIndex$GSCopy$ = -28					; size = 4
tv223 = -24						; size = 4
_pMsg$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z PROC	; CGReqWeaponUse, COMDAT

; 19418: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00013	53		 push	 ebx
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 19419: 	WORD wObjIndex = MAKE_NUMBERW(aRecv->btObjIndexH, aRecv->btObjIndexL);

  00018	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0001c	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  00020	66 c1 e0 08	 shl	 ax, 8
  00024	66 0b c2	 or	 ax, dx
  00027	0f b7 d8	 movzx	 ebx, ax

; 19420: 
; 19421: 	if ( !OBJMAX_RANGE(wObjIndex))

  0002a	b8 eb 2c 00 00	 mov	 eax, 11499		; 00002cebH
  0002f	66 3b c3	 cmp	 ax, bx
  00032	1b c0		 sbb	 eax, eax
  00034	40		 inc	 eax

; 19469: 				}
; 19470: 			}
; 19471: 		}
; 19472: 	}
; 19473: 
; 19474: 	gObjNotifyUseWeaponV1(lpOwnerObj, lpWeaponObj, pMsg.btPointX, pMsg.btPointY);

  00035	89 4d e4	 mov	 DWORD PTR _iIndex$GSCopy$[ebp], ecx
  00038	0f 84 45 01 00
	00		 je	 $LN14@CGReqWeapo

; 19422: 		return;
; 19423: 
; 19424: 	if ( !OBJMAX_RANGE(iIndex))

  0003e	85 c9		 test	 ecx, ecx
  00040	0f 88 3d 01 00
	00		 js	 $LN14@CGReqWeapo
  00046	33 c0		 xor	 eax, eax
  00048	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0004e	0f 9e c0	 setle	 al
  00051	85 c0		 test	 eax, eax
  00053	0f 84 2a 01 00
	00		 je	 $LN14@CGReqWeapo

; 19425: 		return;
; 19426: 
; 19427: 	LPOBJ lpOwnerObj = &gObj[iIndex];

  00059	56		 push	 esi
  0005a	8b c1		 mov	 eax, ecx
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00062	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H

; 19428: 	LPOBJ lpWeaponObj = &gObj[wObjIndex];

  00068	8b f3		 mov	 esi, ebx
  0006a	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00070	03 c1		 add	 eax, ecx
  00072	03 f1		 add	 esi, ecx

; 19429: 
; 19430: 	if ( lpOwnerObj->Type != OBJ_USER )

  00074	80 78 50 01	 cmp	 BYTE PTR [eax+80], 1
  00078	89 45 e0	 mov	 DWORD PTR _lpOwnerObj$[ebp], eax
  0007b	0f 85 01 01 00
	00		 jne	 $LN22@CGReqWeapo

; 19431: 		return;
; 19432: 
; 19433: 	if ( lpWeaponObj->Type != OBJ_NPC )

  00081	80 7e 50 03	 cmp	 BYTE PTR [esi+80], 3
  00085	0f 85 f7 00 00
	00		 jne	 $LN22@CGReqWeapo

; 19434: 		return;
; 19435: 
; 19436: 	PMSG_ANS_USEWEAPON pMsg = {0};
; 19437: 
; 19438: 	PHeadSubSetB((LPBYTE)&pMsg, 0xB7, 0x01, sizeof(pMsg));

  0008b	6a 0a		 push	 10			; 0000000aH
  0008d	6a 01		 push	 1
  0008f	33 c0		 xor	 eax, eax
  00091	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00094	68 b7 00 00 00	 push	 183			; 000000b7H
  00099	51		 push	 ecx
  0009a	c6 45 ec 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0009e	89 45 ed	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  000a1	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  000a4	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+9], al
  000a7	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19439: 	pMsg.btResult = 1;

  000ac	c6 45 f0 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 19440: 
; 19441: 	if ( lpWeaponObj->Class == 221 )	// Slingshot attack

  000b0	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  000b7	ba dd 00 00 00	 mov	 edx, 221		; 000000ddH
  000bc	83 c4 10	 add	 esp, 16			; 00000010H
  000bf	66 3b c2	 cmp	 ax, dx
  000c2	75 06		 jne	 SHORT $LN9@CGReqWeapo

; 19442: 	{
; 19443: 		pMsg.btWeaponType = 1;

  000c4	c6 45 f3 01	 mov	 BYTE PTR _pMsg$[ebp+7], 1

; 19444: 		pMsg.btObjIndexH = SET_NUMBERH(wObjIndex);
; 19445: 		pMsg.btObjIndexL = SET_NUMBERL(wObjIndex);
; 19446: 		g_CsNPC_Weapon.GetTargetPointXY(lpWeaponObj->Class, aRecv->btTargetIndex-1, pMsg.btPointX, pMsg.btPointY, TRUE);

  000c8	eb 0e		 jmp	 SHORT $LN23@CGReqWeapo
$LN9@CGReqWeapo:

; 19447: 	}
; 19448: 	else if( lpWeaponObj->Class == 222 )	// Slingshot defense

  000ca	ba de 00 00 00	 mov	 edx, 222		; 000000deH
  000cf	66 3b c2	 cmp	 ax, dx
  000d2	75 31		 jne	 SHORT $LN7@CGReqWeapo

; 19449: 	{
; 19450: 		pMsg.btWeaponType = 2;

  000d4	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+7], 2
$LN23@CGReqWeapo:

; 19451: 		pMsg.btObjIndexH = SET_NUMBERH(wObjIndex);

  000d8	8b c3		 mov	 eax, ebx
  000da	c1 e8 08	 shr	 eax, 8

; 19452: 		pMsg.btObjIndexL = SET_NUMBERL(wObjIndex);
; 19453: 		g_CsNPC_Weapon.GetTargetPointXY(lpWeaponObj->Class, aRecv->btTargetIndex-1, pMsg.btPointX, pMsg.btPointY, TRUE);

  000dd	6a 01		 push	 1
  000df	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al
  000e2	0f b6 47 06	 movzx	 eax, BYTE PTR [edi+6]
  000e6	8d 4d f5	 lea	 ecx, DWORD PTR _pMsg$[ebp+9]
  000e9	51		 push	 ecx
  000ea	8d 55 f4	 lea	 edx, DWORD PTR _pMsg$[ebp+8]
  000ed	52		 push	 edx
  000ee	88 5d f2	 mov	 BYTE PTR _pMsg$[ebp+6], bl
  000f1	0f b7 8e 90 00
	00 00		 movzx	 ecx, WORD PTR [esi+144]
  000f8	48		 dec	 eax
  000f9	50		 push	 eax
  000fa	51		 push	 ecx
  000fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  00100	e8 00 00 00 00	 call	 ?GetTargetPointXY@CWeapon@@QAEHHHAAE0H@Z ; CWeapon::GetTargetPointXY
$LN7@CGReqWeapo:

; 19454: 	}
; 19455: 
; 19456: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00105	8b 45 e4	 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]
  00108	6a 0a		 push	 10			; 0000000aH
  0010a	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0010d	52		 push	 edx
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19457: 
; 19458: 	pMsg.btResult = 2;

  00117	c6 45 f0 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2
  0011b	8d be 4a 0c 00
	00		 lea	 edi, DWORD PTR [esi+3146]
  00121	c7 45 e8 4b 00
	00 00		 mov	 DWORD PTR tv223[ebp], 75 ; 0000004bH
$LL6@CGReqWeapo:

; 19461: 	{
; 19462: 		if ( lpWeaponObj->VpPlayer2[n].type == OBJ_USER )

  00128	80 7f 02 01	 cmp	 BYTE PTR [edi+2], 1
  0012c	75 1d		 jne	 SHORT $LN5@CGReqWeapo

; 19463: 		{
; 19464: 			if ( lpWeaponObj->VpPlayer2[n].state )

  0012e	80 7f fe 00	 cmp	 BYTE PTR [edi-2], 0
  00132	74 17		 je	 SHORT $LN5@CGReqWeapo

; 19465: 			{
; 19466: 				if ( iIndex != lpWeaponObj->VpPlayer2[n].number )

  00134	0f bf 07	 movsx	 eax, WORD PTR [edi]
  00137	39 45 e4	 cmp	 DWORD PTR _iIndex$GSCopy$[ebp], eax
  0013a	74 0f		 je	 SHORT $LN5@CGReqWeapo

; 19467: 				{
; 19468: 					DataSend(lpWeaponObj->VpPlayer2[n].number, (LPBYTE)&pMsg, sizeof(pMsg));

  0013c	6a 0a		 push	 10			; 0000000aH
  0013e	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00141	51		 push	 ecx
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@CGReqWeapo:

; 19459: 
; 19460: 	for ( int n=0;n<MAX_VIEWPORT;n++)

  0014b	83 c7 0c	 add	 edi, 12			; 0000000cH
  0014e	ff 4d e8	 dec	 DWORD PTR tv223[ebp]
  00151	75 d5		 jne	 SHORT $LL6@CGReqWeapo

; 19469: 				}
; 19470: 			}
; 19471: 		}
; 19472: 	}
; 19473: 
; 19474: 	gObjNotifyUseWeaponV1(lpOwnerObj, lpWeaponObj, pMsg.btPointX, pMsg.btPointY);

  00153	0f b6 55 f5	 movzx	 edx, BYTE PTR _pMsg$[ebp+9]
  00157	0f b6 45 f4	 movzx	 eax, BYTE PTR _pMsg$[ebp+8]
  0015b	8b 4d e0	 mov	 ecx, DWORD PTR _lpOwnerObj$[ebp]
  0015e	52		 push	 edx
  0015f	50		 push	 eax
  00160	56		 push	 esi
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 ?gObjNotifyUseWeaponV1@@YAXPAUOBJECTSTRUCT@@0HH@Z ; gObjNotifyUseWeaponV1

; 19475: 	g_CsNPC_Weapon.SetWeaponCalDamageInfo(wObjIndex, pMsg.btPointX, pMsg.btPointY, 10000);

  00167	8b 55 f5	 mov	 edx, DWORD PTR _pMsg$[ebp+9]
  0016a	8b 45 f4	 mov	 eax, DWORD PTR _pMsg$[ebp+8]
  0016d	83 c4 10	 add	 esp, 16			; 00000010H
  00170	68 10 27 00 00	 push	 10000			; 00002710H
  00175	52		 push	 edx
  00176	50		 push	 eax
  00177	53		 push	 ebx
  00178	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  0017d	e8 00 00 00 00	 call	 ?SetWeaponCalDamageInfo@CWeapon@@QAEHGEEH@Z ; CWeapon::SetWeaponCalDamageInfo
$LN22@CGReqWeapo:
  00182	5e		 pop	 esi
$LN14@CGReqWeapo:

; 19476: }

  00183	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00186	5f		 pop	 edi
  00187	33 cd		 xor	 ecx, ebp
  00189	5b		 pop	 ebx
  0018a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c3		 ret	 0
?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z ENDP	; CGReqWeaponUse
_TEXT	ENDS
PUBLIC	?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z ; CGReqWeaponDamageValue
EXTRN	?gObjNotifyUseWeaponDamage@@YAXPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjNotifyUseWeaponDamage
EXTRN	?GetWeaponCalDamageInfo@CWeapon@@QAEHGAAE0@Z:PROC ; CWeapon::GetWeaponCalDamageInfo
; Function compile flags: /Ogtp
;	COMDAT ?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z
_TEXT	SEGMENT
_btTargetX$ = -1					; size = 1
_aRecv$ = 8						; size = 4
_iIndex$ = 12						; size = 4
_btTargetY$ = 15					; size = 1
?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z PROC ; CGReqWeaponDamageValue, COMDAT

; 19483: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 19484: 	if ( !OBJMAX_RANGE(iIndex) )

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b f9		 cmp	 edi, ecx
  0000c	0f 8c 84 00 00
	00		 jl	 $LN1@CGReqWeapo@2
  00012	33 c0		 xor	 eax, eax
  00014	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0001a	0f 9e c0	 setle	 al
  0001d	3b c1		 cmp	 eax, ecx
  0001f	74 75		 je	 SHORT $LN1@CGReqWeapo@2

; 19485: 		return;
; 19486: 
; 19487: 	BYTE btTargetX = 0;
; 19488: 	BYTE btTargetY = 0;
; 19489: 	WORD wObjIndex = MAKE_NUMBERW(aRecv->btObjIndexH, aRecv->btObjIndexL);

  00021	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00024	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  00028	88 4d ff	 mov	 BYTE PTR _btTargetX$[ebp], cl
  0002b	88 4d 0f	 mov	 BYTE PTR _btTargetY$[ebp], cl
  0002e	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00032	66 c1 e1 08	 shl	 cx, 8
  00036	56		 push	 esi
  00037	66 0b ca	 or	 cx, dx
  0003a	0f b7 f1	 movzx	 esi, cx

; 19490: 
; 19491: 	if ( g_CsNPC_Weapon.GetWeaponCalDamageInfo(wObjIndex, btTargetX, btTargetY) == TRUE )

  0003d	8d 45 0f	 lea	 eax, DWORD PTR _btTargetY$[ebp]
  00040	50		 push	 eax
  00041	8d 4d ff	 lea	 ecx, DWORD PTR _btTargetX$[ebp]
  00044	51		 push	 ecx
  00045	56		 push	 esi
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  0004b	e8 00 00 00 00	 call	 ?GetWeaponCalDamageInfo@CWeapon@@QAEHGAAE0@Z ; CWeapon::GetWeaponCalDamageInfo
  00050	83 f8 01	 cmp	 eax, 1
  00053	75 27		 jne	 SHORT $LN2@CGReqWeapo@2

; 19492: 	{
; 19493: 		gObjNotifyUseWeaponDamage(&gObj[wObjIndex], btTargetX, btTargetY);

  00055	0f b6 55 0f	 movzx	 edx, BYTE PTR _btTargetY$[ebp]
  00059	0f b6 45 ff	 movzx	 eax, BYTE PTR _btTargetX$[ebp]
  0005d	8b ce		 mov	 ecx, esi
  0005f	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00065	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006b	52		 push	 edx
  0006c	50		 push	 eax
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 ?gObjNotifyUseWeaponDamage@@YAXPAUOBJECTSTRUCT@@HH@Z ; gObjNotifyUseWeaponDamage
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	5e		 pop	 esi
  00077	5f		 pop	 edi

; 19498: 	}
; 19499: }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN2@CGReqWeapo@2:

; 19494: 	}
; 19495: 	else
; 19496: 	{
; 19497: 		MsgOutput(iIndex, lMsg.Get(MSGGET(6, 112)));

  0007c	68 70 06 00 00	 push	 1648			; 00000670H
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00086	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0008b	50		 push	 eax
  0008c	57		 push	 edi
  0008d	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00092	83 c4 08	 add	 esp, 8
  00095	5e		 pop	 esi
$LN1@CGReqWeapo@2:
  00096	5f		 pop	 edi

; 19498: 	}
; 19499: }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z ENDP ; CGReqWeaponDamageValue
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z ; CGReqGuildMarkOfCastleOwner
; Function compile flags: /Ogtp
;	COMDAT ?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z
_TEXT	SEGMENT
_pMsg$225064 = -52					; size = 36
_szGuildName$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z PROC ; CGReqGuildMarkOfCastleOwner, COMDAT

; 19513: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]

; 19514: 	if ( !OBJMAX_RANGE(iIndex) )

  00014	85 db		 test	 ebx, ebx
  00016	0f 88 97 00 00
	00		 js	 $LN1@CGReqGuild@2
  0001c	33 c0		 xor	 eax, eax
  0001e	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 84 00 00
	00		 je	 $LN1@CGReqGuild@2

; 19515: 		return;
; 19516: 
; 19517: 	LPOBJ lpObj = &gObj[iIndex];
; 19518: 	char szGuildName[MAX_GUILD_LEN+1] = {0};
; 19519: 
; 19520: 	memcpy(szGuildName, g_CastleSiegeSync.GetCastleOwnerGuild(), MAX_GUILD_LEN);

  0002f	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+28
  00035	33 c0		 xor	 eax, eax
  00037	89 45 f1	 mov	 DWORD PTR _szGuildName$[ebp+1], eax
  0003a	89 45 f5	 mov	 DWORD PTR _szGuildName$[ebp+5], eax
  0003d	a1 18 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+24
  00042	56		 push	 esi

; 19521: 
; 19522: 	if ( szGuildName )
; 19523: 	{
; 19524: 		_GUILD_INFO_STRUCT * lpGuild = Guild.SearchGuild(szGuildName);

  00043	8d 55 f0	 lea	 edx, DWORD PTR _szGuildName$[ebp]
  00046	89 4d f4	 mov	 DWORD PTR _szGuildName$[ebp+4], ecx
  00049	52		 push	 edx
  0004a	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  0004f	89 45 f0	 mov	 DWORD PTR _szGuildName$[ebp], eax
  00052	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00057	8b f0		 mov	 esi, eax

; 19525: 
; 19526: 		if ( lpGuild != NULL )

  00059	85 f6		 test	 esi, esi
  0005b	74 55		 je	 SHORT $LN10@CGReqGuild@2

; 19527: 		{
; 19528: 			PMSG_ANS_GUILDMARK_OF_CASTLEOWNER pMsg = {0};

  0005d	33 c0		 xor	 eax, eax
  0005f	57		 push	 edi

; 19529: 
; 19530: 			PHeadSubSetB((LPBYTE)&pMsg, 0xB9, 0x02, sizeof(pMsg));

  00060	6a 24		 push	 36			; 00000024H
  00062	6a 02		 push	 2
  00064	89 45 cd	 mov	 DWORD PTR _pMsg$225064[ebp+1], eax
  00067	89 45 d1	 mov	 DWORD PTR _pMsg$225064[ebp+5], eax
  0006a	89 45 d5	 mov	 DWORD PTR _pMsg$225064[ebp+9], eax
  0006d	89 45 d9	 mov	 DWORD PTR _pMsg$225064[ebp+13], eax
  00070	89 45 dd	 mov	 DWORD PTR _pMsg$225064[ebp+17], eax
  00073	89 45 e1	 mov	 DWORD PTR _pMsg$225064[ebp+21], eax
  00076	89 45 e5	 mov	 DWORD PTR _pMsg$225064[ebp+25], eax
  00079	89 45 e9	 mov	 DWORD PTR _pMsg$225064[ebp+29], eax
  0007c	66 89 45 ed	 mov	 WORD PTR _pMsg$225064[ebp+33], ax
  00080	88 45 ef	 mov	 BYTE PTR _pMsg$225064[ebp+35], al
  00083	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$225064[ebp]
  00086	68 b9 00 00 00	 push	 185			; 000000b9H
  0008b	50		 push	 eax
  0008c	c6 45 cc 00	 mov	 BYTE PTR _pMsg$225064[ebp], 0
  00090	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19531: 			memcpy(pMsg.GuildMarkOfCastleOwner, lpGuild->Mark, sizeof(pMsg.GuildMarkOfCastleOwner));

  00095	83 c6 0d	 add	 esi, 13			; 0000000dH
  00098	b9 08 00 00 00	 mov	 ecx, 8
  0009d	8d 7d d0	 lea	 edi, DWORD PTR _pMsg$225064[ebp+4]
  000a0	f3 a5		 rep movsd

; 19532: 
; 19533: 			DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  000a2	6a 24		 push	 36			; 00000024H
  000a4	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$225064[ebp]
  000a7	51		 push	 ecx
  000a8	53		 push	 ebx
  000a9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ae	83 c4 1c	 add	 esp, 28			; 0000001cH
  000b1	5f		 pop	 edi
$LN10@CGReqGuild@2:
  000b2	5e		 pop	 esi
$LN1@CGReqGuild@2:

; 19534: 		}
; 19535: 	}
; 19536: }

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b6	33 cd		 xor	 ecx, ebp
  000b8	5b		 pop	 ebx
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z ENDP ; CGReqGuildMarkOfCastleOwner
_TEXT	ENDS
PUBLIC	?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z	; CGReqJewelMix
EXTRN	?MixJewel@CJewelMixSystem@@SAHHHH@Z:PROC	; CJewelMixSystem::MixJewel
; Function compile flags: /Ogtp
;	COMDAT ?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z PROC	; CGReqJewelMix, COMDAT

; 19541: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19542: 	if ( lpMsg == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 16		 je	 SHORT $LN2@CGReqJewel

; 19543: 		return;
; 19544: 
; 19545: 	CJewelMixSystem::MixJewel(iIndex, lpMsg->btJewelType, lpMsg->btJewelMix);

  0000a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0000e	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00015	51		 push	 ecx
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?MixJewel@CJewelMixSystem@@SAHHHH@Z ; CJewelMixSystem::MixJewel
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGReqJewel:

; 19546: }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z ENDP	; CGReqJewelMix
_TEXT	ENDS
PUBLIC	?GCAnsJewelMix@@YAXHH@Z				; GCAnsJewelMix
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsJewelMix@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
?GCAnsJewelMix@@YAXHH@Z PROC				; GCAnsJewelMix, COMDAT

; 19557: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19558: 	PMSG_ANS_JEWEL_UNMIX pMsg;
; 19559: 
; 19560: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBC, 0x00, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 00		 push	 0
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 bc 00 00 00	 push	 188			; 000000bcH
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19561: 	pMsg.btResult = iResult;
; 19562: 
; 19563: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00018	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0001b	8a 4d 0c	 mov	 cl, BYTE PTR _iResult$[ebp]
  0001e	6a 05		 push	 5
  00020	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00023	52		 push	 edx
  00024	50		 push	 eax
  00025	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00028	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 19564: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?GCAnsJewelMix@@YAXHH@Z ENDP				; GCAnsJewelMix
_TEXT	ENDS
PUBLIC	?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z ; CGReqJewelUnMix
EXTRN	?UnMixJewel@CJewelMixSystem@@SAHHHHH@Z:PROC	; CJewelMixSystem::UnMixJewel
; Function compile flags: /Ogtp
;	COMDAT ?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z PROC	; CGReqJewelUnMix, COMDAT

; 19569: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19570: 	if ( lpMsg == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1b		 je	 SHORT $LN2@CGReqJewel@2

; 19571: 		return;
; 19572: 
; 19573: 	CJewelMixSystem::UnMixJewel(iIndex, lpMsg->btJewelType, lpMsg->btJewelLevel, lpMsg->btJewelPos);

  0000a	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  0000e	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  00012	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00016	51		 push	 ecx
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0001a	52		 push	 edx
  0001b	50		 push	 eax
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ?UnMixJewel@CJewelMixSystem@@SAHHHHH@Z ; CJewelMixSystem::UnMixJewel
  00022	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@CGReqJewel@2:

; 19574: }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z ENDP	; CGReqJewelUnMix
_TEXT	ENDS
PUBLIC	?GCAnsJewelUnMix@@YAXHH@Z			; GCAnsJewelUnMix
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsJewelUnMix@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
?GCAnsJewelUnMix@@YAXHH@Z PROC				; GCAnsJewelUnMix, COMDAT

; 19580: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19581: 	PMSG_ANS_JEWEL_UNMIX pMsg;
; 19582: 
; 19583: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBC, 0x01, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 bc 00 00 00	 push	 188			; 000000bcH
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19584: 	pMsg.btResult = iResult;
; 19585: 
; 19586: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00018	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0001b	8a 4d 0c	 mov	 cl, BYTE PTR _iResult$[ebp]
  0001e	6a 05		 push	 5
  00020	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00023	52		 push	 edx
  00024	50		 push	 eax
  00025	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00028	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 19587: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?GCAnsJewelUnMix@@YAXHH@Z ENDP				; GCAnsJewelUnMix
_TEXT	ENDS
PUBLIC	?GCAnsCrywolfInfo@@YAXHEE@Z			; GCAnsCrywolfInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCrywolfInfo@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iIndex$ = 8						; size = 4
_btOccupationState$ = 12				; size = 1
_btCrywolfState$ = 16					; size = 1
?GCAnsCrywolfInfo@@YAXHEE@Z PROC			; GCAnsCrywolfInfo, COMDAT

; 19603: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19604: 	PMSG_ANS_CRYWOLF_INFO pMsg={0};

  00006	33 c0		 xor	 eax, eax

; 19605: 
; 19606: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBD, 0x00, sizeof(pMsg));

  00008	6a 06		 push	 6
  0000a	50		 push	 eax
  0000b	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp], al
  0000e	89 45 f9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00011	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00014	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	68 bd 00 00 00	 push	 189			; 000000bdH
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19607: 	pMsg.btOccupationState = btOccupationState;

  00022	8a 4d 0c	 mov	 cl, BYTE PTR _btOccupationState$[ebp]

; 19608: 	pMsg.btCrywolfState = btCrywolfState;

  00025	8a 55 10	 mov	 dl, BYTE PTR _btCrywolfState$[ebp]

; 19609: 	
; 19610: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00028	6a 06		 push	 6
  0002a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002d	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00033	50		 push	 eax
  00034	51		 push	 ecx
  00035	88 55 fd	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  00038	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 19611: }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?GCAnsCrywolfInfo@@YAXHEE@Z ENDP			; GCAnsCrywolfInfo
_TEXT	ENDS
PUBLIC	?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z ; CGReqAlatrContract
EXTRN	?SetAltarUserIndex@CCrywolfAltar@@QAEHHHH@Z:PROC ; CCrywolfAltar::SetAltarUserIndex
EXTRN	?GetAltarState@CCrywolfAltar@@QAEHH@Z:PROC	; CCrywolfAltar::GetAltarState
EXTRN	?g_CrywolfNPC_Altar@@3VCCrywolfAltar@@A:BYTE	; g_CrywolfNPC_Altar
; Function compile flags: /Ogtp
;	COMDAT ?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z PROC ; CGReqAlatrContract, COMDAT

; 19626: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19627: 	int iAltarIndex = MAKE_NUMBERW(lpMsg->btObjIndexH, lpMsg->btObjIndexL);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0000a	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  0000e	83 ec 08	 sub	 esp, 8
  00011	53		 push	 ebx
  00012	66 c1 e1 08	 shl	 cx, 8
  00016	0f b7 d9	 movzx	 ebx, cx
  00019	57		 push	 edi

; 19628: 
; 19629: 	if ( !OBJMAX_RANGE(iIndex))

  0001a	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  0001d	0b da		 or	 ebx, edx
  0001f	85 ff		 test	 edi, edi
  00021	0f 88 3c 01 00
	00		 js	 $LN8@CGReqAlatr
  00027	33 c0		 xor	 eax, eax
  00029	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0002f	0f 9e c0	 setle	 al
  00032	85 c0		 test	 eax, eax
  00034	0f 84 29 01 00
	00		 je	 $LN8@CGReqAlatr

; 19630: 		return;
; 19631: 
; 19632: 	if ( !OBJMAX_RANGE(iAltarIndex))

  0003a	85 db		 test	 ebx, ebx
  0003c	0f 88 21 01 00
	00		 js	 $LN8@CGReqAlatr
  00042	33 c0		 xor	 eax, eax
  00044	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  0004a	0f 9e c0	 setle	 al
  0004d	85 c0		 test	 eax, eax
  0004f	0f 84 0e 01 00
	00		 je	 $LN8@CGReqAlatr

; 19633: 		return;
; 19634: 
; 19635: 	LPOBJ lpObj = &gObj[iIndex];

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005a	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00060	56		 push	 esi

; 19636: 	LPOBJ lpAltarObj = &gObj[iAltarIndex];

  00061	8b f3		 mov	 esi, ebx
  00063	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00069	03 f0		 add	 esi, eax
  0006b	03 f8		 add	 edi, eax

; 19637: 
; 19638: 	if ( !CRYWOLF_ALTAR_CLASS_RANGE(lpAltarObj->Class))

  0006d	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  00074	b9 cd 00 00 00	 mov	 ecx, 205		; 000000cdH
  00079	66 3b c1	 cmp	 ax, cx
  0007c	0f 82 e0 00 00
	00		 jb	 $LN16@CGReqAlatr
  00082	ba d1 00 00 00	 mov	 edx, 209		; 000000d1H
  00087	66 3b d0	 cmp	 dx, ax
  0008a	1b c0		 sbb	 eax, eax
  0008c	40		 inc	 eax
  0008d	0f 84 cf 00 00
	00		 je	 $LN16@CGReqAlatr

; 19639: 		return;
; 19640: 
; 19641: 	if ( !gObjIsConnected(lpObj))

  00093	57		 push	 edi
  00094	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00099	83 c4 04	 add	 esp, 4
  0009c	85 c0		 test	 eax, eax
  0009e	0f 84 be 00 00
	00		 je	 $LN16@CGReqAlatr

; 19642: 		return;
; 19643: 
; 19644: 	PMSG_ANS_CRYWOLF_ALTAR_CONTRACT pMsg={0};

  000a4	33 c0		 xor	 eax, eax

; 19645: 
; 19646: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBD, 0x03, sizeof(pMsg));

  000a6	6a 08		 push	 8
  000a8	6a 03		 push	 3
  000aa	89 45 f9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  000ad	66 89 45 fd	 mov	 WORD PTR _pMsg$[ebp+5], ax
  000b1	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+7], al
  000b4	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000b7	68 bd 00 00 00	 push	 189			; 000000bdH
  000bc	50		 push	 eax
  000bd	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  000c1	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19647: 	pMsg.btResult = 0;

  000c6	c6 45 fc 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0

; 19648: 	pMsg.btAltarState = g_CrywolfNPC_Altar.GetAltarState(lpAltarObj->Class);

  000ca	0f b7 8e 90 00
	00 00		 movzx	 ecx, WORD PTR [esi+144]
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
  000d4	51		 push	 ecx
  000d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfNPC_Altar@@3VCCrywolfAltar@@A ; g_CrywolfNPC_Altar
  000da	e8 00 00 00 00	 call	 ?GetAltarState@CCrywolfAltar@@QAEHH@Z ; CCrywolfAltar::GetAltarState

; 19649: 	pMsg.btObjIndexH = lpMsg->btObjIndexH;

  000df	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000e2	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]

; 19650: 	pMsg.btObjIndexL = lpMsg->btObjIndexL;

  000e5	8a 49 05	 mov	 cl, BYTE PTR [ecx+5]
  000e8	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  000eb	88 55 fe	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  000ee	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 19651: 
; 19652: 	if ( pMsg.btAltarState == 0 && 
; 19653: 		 lpObj->Type == OBJ_USER &&
; 19654: 		 lpObj->Class == CLASS_ELF &&
; 19655: 		 lpObj->Level >= MIN_ELF_LEVEL_ALTAR )

  000f1	84 c0		 test	 al, al
  000f3	75 3f		 jne	 SHORT $LN3@CGReqAlatr
  000f5	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  000f9	75 39		 jne	 SHORT $LN3@CGReqAlatr
  000fb	66 83 bf 90 00
	00 00 02	 cmp	 WORD PTR [edi+144], 2
  00103	75 2f		 jne	 SHORT $LN3@CGReqAlatr
  00105	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  0010a	66 39 97 96 00
	00 00		 cmp	 WORD PTR [edi+150], dx
  00111	7c 21		 jl	 SHORT $LN3@CGReqAlatr

; 19656: 	{
; 19657: 		if ( g_CrywolfNPC_Altar.SetAltarUserIndex(iAltarIndex, lpAltarObj->Class, iIndex) != FALSE )

  00113	0f b7 8e 90 00
	00 00		 movzx	 ecx, WORD PTR [esi+144]
  0011a	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0011d	50		 push	 eax
  0011e	51		 push	 ecx
  0011f	53		 push	 ebx
  00120	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfNPC_Altar@@3VCCrywolfAltar@@A ; g_CrywolfNPC_Altar
  00125	e8 00 00 00 00	 call	 ?SetAltarUserIndex@CCrywolfAltar@@QAEHHHH@Z ; CCrywolfAltar::SetAltarUserIndex
  0012a	85 c0		 test	 eax, eax
  0012c	74 22		 je	 SHORT $LN1@CGReqAlatr

; 19658: 		{
; 19659: 			pMsg.btResult = 1;

  0012e	c6 45 fc 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 19660: 		}
; 19661: 	}
; 19662: 	else

  00132	eb 1c		 jmp	 SHORT $LN1@CGReqAlatr
$LN3@CGReqAlatr:

; 19663: 	{
; 19664: 		MsgOutput(iIndex, lMsg.Get(MSGGET(13, 9)));

  00134	68 09 0d 00 00	 push	 3337			; 00000d09H
  00139	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0013e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00143	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00146	50		 push	 eax
  00147	52		 push	 edx
  00148	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0014d	83 c4 08	 add	 esp, 8
$LN1@CGReqAlatr:

; 19665: 	}
; 19666: 
; 19667: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00150	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00153	6a 08		 push	 8
  00155	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00158	50		 push	 eax
  00159	51		 push	 ecx
  0015a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@CGReqAlatr:
  00162	5e		 pop	 esi
$LN8@CGReqAlatr:
  00163	5f		 pop	 edi
  00164	5b		 pop	 ebx

; 19668: }

  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z ENDP ; CGReqAlatrContract
_TEXT	ENDS
PUBLIC	?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z ; CGReqPlusChaosRate
EXTRN	?GetPlusChaosRate@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetPlusChaosRate
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
; Function compile flags: /Ogtp
;	COMDAT ?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z PROC ; CGReqPlusChaosRate, COMDAT

; 19680: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 19681: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00007	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3b f1		 cmp	 esi, ecx
  0000e	7c 46		 jl	 SHORT $LN2@CGReqPlusC
  00010	33 c0		 xor	 eax, eax
  00012	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00018	0f 9e c0	 setle	 al
  0001b	3b c1		 cmp	 eax, ecx
  0001d	74 37		 je	 SHORT $LN2@CGReqPlusC

; 19682: 		return;
; 19683: 
; 19684: 	PMSG_ANS_CRYWOLF_BENEFIT_PLUS_CHAOSRATE pMsg={0};
; 19685: 
; 19686: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBD, 0x09, sizeof(pMsg));

  0001f	6a 05		 push	 5
  00021	6a 09		 push	 9
  00023	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00026	68 bd 00 00 00	 push	 189			; 000000bdH
  0002b	50		 push	 eax
  0002c	88 4d f8	 mov	 BYTE PTR _pMsg$[ebp], cl
  0002f	89 4d f9	 mov	 DWORD PTR _pMsg$[ebp+1], ecx
  00032	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00037	83 c4 10	 add	 esp, 16			; 00000010H

; 19687: 	pMsg.btPlusChaosRate = g_CrywolfSync.GetPlusChaosRate();

  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0003f	e8 00 00 00 00	 call	 ?GetPlusChaosRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetPlusChaosRate

; 19688: 
; 19689: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00044	6a 05		 push	 5
  00046	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00049	51		 push	 ecx
  0004a	56		 push	 esi
  0004b	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0004e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGReqPlusC:
  00056	5e		 pop	 esi

; 19690: }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z ENDP ; CGReqPlusChaosRate
_TEXT	ENDS
PUBLIC	?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z ; CGReqKanturuStateInfo
EXTRN	?NotifyEntranceInfo@CKanturuEntranceNPC@@QAEXH@Z:PROC ; CKanturuEntranceNPC::NotifyEntranceInfo
EXTRN	?g_KanturuEntranceNPC@@3VCKanturuEntranceNPC@@A:DWORD ; g_KanturuEntranceNPC
; Function compile flags: /Ogtp
;	COMDAT ?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z PROC ; CGReqKanturuStateInfo, COMDAT

; 19694: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19695: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 1a		 js	 SHORT $LN2@CGReqKantu
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $LN2@CGReqKantu

; 19696: 		return;
; 19697: 
; 19698: 	g_KanturuEntranceNPC.NotifyEntranceInfo(iIndex);

  00019	51		 push	 ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KanturuEntranceNPC@@3VCKanturuEntranceNPC@@A ; g_KanturuEntranceNPC
  0001f	e8 00 00 00 00	 call	 ?NotifyEntranceInfo@CKanturuEntranceNPC@@QAEXH@Z ; CKanturuEntranceNPC::NotifyEntranceInfo
$LN2@CGReqKantu:

; 19699: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z ENDP ; CGReqKanturuStateInfo
_TEXT	ENDS
PUBLIC	?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z ; GCReqEnterKanturuBossMap
EXTRN	?NotifyResultEnterKanturuBossMap@CKanturuEntranceNPC@@QAEXH@Z:PROC ; CKanturuEntranceNPC::NotifyResultEnterKanturuBossMap
; Function compile flags: /Ogtp
;	COMDAT ?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z PROC ; GCReqEnterKanturuBossMap, COMDAT

; 19704: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19705: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 1a		 js	 SHORT $LN2@GCReqEnter
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $LN2@GCReqEnter

; 19706: 		return;
; 19707: 
; 19708: 	g_KanturuEntranceNPC.NotifyResultEnterKanturuBossMap(iIndex);

  00019	51		 push	 ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KanturuEntranceNPC@@3VCKanturuEntranceNPC@@A ; g_KanturuEntranceNPC
  0001f	e8 00 00 00 00	 call	 ?NotifyResultEnterKanturuBossMap@CKanturuEntranceNPC@@QAEXH@Z ; CKanturuEntranceNPC::NotifyResultEnterKanturuBossMap
$LN2@GCReqEnter:

; 19709: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z ENDP ; GCReqEnterKanturuBossMap
_TEXT	ENDS
PUBLIC	?GCSendObjectCreationState@@YAXH@Z		; GCSendObjectCreationState
; Function compile flags: /Ogtp
;	COMDAT ?GCSendObjectCreationState@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_iObjectIndex$ = 8					; size = 4
?GCSendObjectCreationState@@YAXH@Z PROC			; GCSendObjectCreationState, COMDAT

; 19720: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 19721: #if (GS_CASTLE == 1)
; 19722: 	if(OBJMAX_RANGE(iObjectIndex) == FALSE)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iObjectIndex$[ebp]
  0000a	85 db		 test	 ebx, ebx
  0000c	78 67		 js	 SHORT $LN1@GCSendObje
  0000e	33 c0		 xor	 eax, eax
  00010	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	74 58		 je	 SHORT $LN1@GCSendObje

; 19723: 		return;
; 19724: 
; 19725: 	LPOBJ lpObj = &gObj[iObjectIndex];

  0001d	56		 push	 esi
  0001e	8b f3		 mov	 esi, ebx
  00020	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00026	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 19726: 	PMSG_NOTIFY_OBJECT_CREATION_STATE pMsg = {0};

  0002c	33 c0		 xor	 eax, eax
  0002e	89 45 f9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00031	66 89 45 fd	 mov	 WORD PTR _pMsg$[ebp+5], ax

; 19727: 
; 19728: 	if(lpObj->Class == 278)

  00035	b8 16 01 00 00	 mov	 eax, 278		; 00000116H
  0003a	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0003e	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  00045	75 2d		 jne	 SHORT $LN7@GCSendObje

; 19729: 	{
; 19730: 		PHeadSubSetB((PBYTE)&pMsg,0xB9,0x01,sizeof(pMsg));

  00047	6a 07		 push	 7
  00049	6a 01		 push	 1
  0004b	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0004e	68 b9 00 00 00	 push	 185			; 000000b9H
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19731: 		pMsg.btObjIndexH = SET_NUMBERH(iObjectIndex);
; 19732: 		pMsg.btObjIndexH = SET_NUMBERL(iObjectIndex);
; 19733: 		pMsg.btCreationState = lpObj->m_btCreationState;
; 19734: 
; 19735: 		MsgSendV2(lpObj,(PBYTE)&pMsg,sizeof(pMsg));

  00059	6a 07		 push	 7
  0005b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0005e	88 5d fc	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  00061	8a 96 6d 20 00
	00		 mov	 dl, BYTE PTR [esi+8301]
  00067	50		 push	 eax
  00068	56		 push	 esi
  00069	88 55 fe	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  0006c	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00071	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN7@GCSendObje:
  00074	5e		 pop	 esi
$LN1@GCSendObje:
  00075	5b		 pop	 ebx

; 19736: 	}
; 19737: #endif
; 19738: }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?GCSendObjectCreationState@@YAXH@Z ENDP			; GCSendObjectCreationState
_TEXT	ENDS
PUBLIC	??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@ ; `string'
PUBLIC	?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z ; CGReqCastleHuntZoneEntrance
EXTRN	?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z:PROC ; CCastleSiege::CheckCastleOwnerMember
EXTRN	?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z:PROC ; CCastleSiege::CheckCastleOwnerUnionMember
EXTRN	?GetHuntZoneEnter@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetHuntZoneEnter
EXTRN	?GetTaxHuntZone@CCastleSiegeSync@@QAEHHH@Z:PROC	; CCastleSiegeSync::GetTaxHuntZone
;	COMDAT ??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@
CONST	SEGMENT
??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@ DB '['
	DB	'Castle HuntZone] [%s][%s] - Entrance TAX : %d - %d = %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_lpMsg$ = 8						; size = 4
_bPermission$ = 12					; size = 4
_iIndex$ = 12						; size = 4
?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z PROC ; CGReqCastleHuntZoneEntrance, COMDAT

; 19741: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 19742: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  00007	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	0f 88 4b 01 00
	00		 js	 $LN13@CGReqCastl@2
  00012	33 c0		 xor	 eax, eax
  00014	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 38 01 00
	00		 je	 $LN13@CGReqCastl@2

; 19743: 		return;
; 19744: 
; 19745: 	LPOBJ lpObj = &gObj[iIndex];

  00025	53		 push	 ebx
  00026	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0002c	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00032	57		 push	 edi

; 19746: 
; 19747: 	PMSG_ANS_MOVE_TO_CASTLE_HUNTZONE pMsg = {0};
; 19748: 
; 19749: 	PHeadSubSetB((LPBYTE)&pMsg,0xB9,5,sizeof( pMsg ));

  00033	6a 05		 push	 5
  00035	6a 05		 push	 5
  00037	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003a	68 b9 00 00 00	 push	 185			; 000000b9H
  0003f	50		 push	 eax
  00040	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00044	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+1], 0
  0004b	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00050	83 c4 10	 add	 esp, 16			; 00000010H

; 19750: 
; 19751: 	pMsg.btResult = FALSE;

  00053	c6 45 fc 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0

; 19752: 
; 19753: 	int iEnterTaxMoney = 0;
; 19754: 	int bPermission;
; 19755: 
; 19756: 	iEnterTaxMoney = g_CastleSiegeSync.GetTaxHuntZone(lpObj->m_Index,TRUE);

  00057	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00059	6a 01		 push	 1
  0005b	51		 push	 ecx
  0005c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00061	e8 00 00 00 00	 call	 ?GetTaxHuntZone@CCastleSiegeSync@@QAEHHH@Z ; CCastleSiegeSync::GetTaxHuntZone
  00066	8b f8		 mov	 edi, eax

; 19757: 
; 19758: 	if(iEnterTaxMoney < 0)

  00068	85 ff		 test	 edi, edi
  0006a	79 02		 jns	 SHORT $LN11@CGReqCastl@2

; 19759: 		iEnterTaxMoney = 0;

  0006c	33 ff		 xor	 edi, edi
$LN11@CGReqCastl@2:

; 19760: 
; 19761: 	if(g_CastleSiege.GetHuntZoneEnter() != FALSE)

  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00073	e8 00 00 00 00	 call	 ?GetHuntZoneEnter@CCastleSiege@@QAEHXZ ; CCastleSiege::GetHuntZoneEnter

; 19762: 		bPermission = TRUE;

  00078	bb 01 00 00 00	 mov	 ebx, 1
  0007d	85 c0		 test	 eax, eax
  0007f	75 03		 jne	 SHORT $LN10@CGReqCastl@2
  00081	8b 5d 0c	 mov	 ebx, DWORD PTR _bPermission$[ebp]
$LN10@CGReqCastl@2:

; 19763: 
; 19764: 	if(lpObj->lpGuild != NULL)

  00084	83 be 18 06 00
	00 00		 cmp	 DWORD PTR [esi+1560], 0

; 19765: 	{
; 19766: 		if(g_CastleSiege.CheckCastleOwnerUnionMember(lpObj->m_Index) != FALSE)

  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00090	74 20		 je	 SHORT $LN9@CGReqCastl@2
  00092	8b 16		 mov	 edx, DWORD PTR [esi]
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
  0009a	85 c0		 test	 eax, eax
  0009c	74 05		 je	 SHORT $LN8@CGReqCastl@2

; 19767: 			bPermission = TRUE;

  0009e	bb 01 00 00 00	 mov	 ebx, 1
$LN8@CGReqCastl@2:

; 19768: 
; 19769: 		if(g_CastleSiege.CheckCastleOwnerMember(lpObj->m_Index) != FALSE) 

  000a3	8b 06		 mov	 eax, DWORD PTR [esi]
  000a5	50		 push	 eax
  000a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000ab	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember

; 19770: 			bPermission = TRUE;
; 19771: 	}

  000b0	eb 05		 jmp	 SHORT $LN20@CGReqCastl@2
$LN9@CGReqCastl@2:

; 19772: 	else if(g_CastleSiege.GetHuntZoneEnter() != FALSE)

  000b2	e8 00 00 00 00	 call	 ?GetHuntZoneEnter@CCastleSiege@@QAEHXZ ; CCastleSiege::GetHuntZoneEnter
$LN20@CGReqCastl@2:
  000b7	85 c0		 test	 eax, eax

; 19773: 	{
; 19774: 		bPermission = TRUE;
; 19775: 	}
; 19776: 
; 19777: 	if(bPermission == TRUE)

  000b9	75 09		 jne	 SHORT $LN17@CGReqCastl@2
  000bb	83 fb 01	 cmp	 ebx, 1
  000be	0f 85 82 00 00
	00		 jne	 $LN2@CGReqCastl@2
$LN17@CGReqCastl@2:

; 19778: 	{
; 19779: 		if( lpObj->Money >= iEnterTaxMoney &&
; 19780: 			lpObj->MapNumber == MAP_INDEX_CASTLESIEGE)

  000c4	39 be cc 00 00
	00		 cmp	 DWORD PTR [esi+204], edi
  000ca	7c 7a		 jl	 SHORT $LN2@CGReqCastl@2
  000cc	80 be 23 01 00
	00 1e		 cmp	 BYTE PTR [esi+291], 30	; 0000001eH
  000d3	75 71		 jne	 SHORT $LN2@CGReqCastl@2

; 19781: 		{
; 19782: 			if(gObjMoveGate(lpObj->m_Index,0x5F) == TRUE)

  000d5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d7	6a 5f		 push	 95			; 0000005fH
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000df	83 c4 08	 add	 esp, 8
  000e2	83 f8 01	 cmp	 eax, 1
  000e5	75 5f		 jne	 SHORT $LN2@CGReqCastl@2

; 19783: 			{
; 19784: 				pMsg.btResult = TRUE;

  000e7	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 19785: 				int iOldMoney = lpObj->Money;

  000ea	8b 9e cc 00 00
	00		 mov	 ebx, DWORD PTR [esi+204]

; 19786: 				lpObj->Money -= iEnterTaxMoney;

  000f0	8b d3		 mov	 edx, ebx
  000f2	2b d7		 sub	 edx, edi

; 19787: 
; 19788: 				g_CastleSiegeSync.AddTributeMoney(iEnterTaxMoney);

  000f4	57		 push	 edi
  000f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  000fa	89 96 cc 00 00
	00		 mov	 DWORD PTR [esi+204], edx
  00100	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 19789: 
; 19790: 				if(lpObj->Money < 0)

  00105	83 be cc 00 00
	00 00		 cmp	 DWORD PTR [esi+204], 0
  0010c	7d 0a		 jge	 SHORT $LN1@CGReqCastl@2

; 19791: 					lpObj->Money = 0;

  0010e	c7 86 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+204], 0
$LN1@CGReqCastl@2:

; 19792: 
; 19793: 				GCMoneySend(lpObj->m_Index,lpObj->Money);

  00118	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  0011e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00120	50		 push	 eax
  00121	51		 push	 ecx
  00122	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 19794: 				LogAddTD("[Castle HuntZone] [%s][%s] - Entrance TAX : %d - %d = %d",
; 19795: 					lpObj->AccountID,lpObj->Name,iOldMoney,iEnterTaxMoney,lpObj->Money);

  00127	8b 96 cc 00 00
	00		 mov	 edx, DWORD PTR [esi+204]
  0012d	52		 push	 edx
  0012e	57		 push	 edi
  0012f	53		 push	 ebx
  00130	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00133	50		 push	 eax
  00134	83 c6 52	 add	 esi, 82			; 00000052H
  00137	56		 push	 esi
  00138	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00143	83 c4 20	 add	 esp, 32			; 00000020H
$LN2@CGReqCastl@2:

; 19796: 			}
; 19797: 		}
; 19798: 	}
; 19799: 
; 19800: 	DataSend(iIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00146	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0014a	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0014d	51		 push	 ecx
  0014e	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00151	52		 push	 edx
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00158	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015b	5f		 pop	 edi
  0015c	5b		 pop	 ebx
$LN13@CGReqCastl@2:
  0015d	5e		 pop	 esi

; 19801: }

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c3		 ret	 0
?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z ENDP ; CGReqCastleHuntZoneEntrance
_TEXT	ENDS
PUBLIC	?GCReqEnterBarracks@@YAXH@Z			; GCReqEnterBarracks
EXTRN	?NotifyResultEnterBarracks@CQuestInfo@@QAEXH@Z:PROC ; CQuestInfo::NotifyResultEnterBarracks
; Function compile flags: /Ogtp
;	COMDAT ?GCReqEnterBarracks@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?GCReqEnterBarracks@@YAXH@Z PROC			; GCReqEnterBarracks, COMDAT

; 19804: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19805: 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 1a		 js	 SHORT $LN2@GCReqEnter@2
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $LN2@GCReqEnter@2

; 19806: 		return;
; 19807: 
; 19808: 	g_QuestInfo.NotifyResultEnterBarracks(aIndex);

  00019	51		 push	 ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0001f	e8 00 00 00 00	 call	 ?NotifyResultEnterBarracks@CQuestInfo@@QAEXH@Z ; CQuestInfo::NotifyResultEnterBarracks
$LN2@GCReqEnter@2:

; 19809: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GCReqEnterBarracks@@YAXH@Z ENDP			; GCReqEnterBarracks
_TEXT	ENDS
PUBLIC	?GCReqEnterBalgassLair@@YAXH@Z			; GCReqEnterBalgassLair
EXTRN	?NotifyResultEnterRefuge@CQuestInfo@@QAEXH@Z:PROC ; CQuestInfo::NotifyResultEnterRefuge
; Function compile flags: /Ogtp
;	COMDAT ?GCReqEnterBalgassLair@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?GCReqEnterBalgassLair@@YAXH@Z PROC			; GCReqEnterBalgassLair, COMDAT

; 19812: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19813: 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 1a		 js	 SHORT $LN2@GCReqEnter@3
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $LN2@GCReqEnter@3

; 19814: 		return;
; 19815: 
; 19816: 	g_QuestInfo.NotifyResultEnterRefuge(aIndex);

  00019	51		 push	 ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0001f	e8 00 00 00 00	 call	 ?NotifyResultEnterRefuge@CQuestInfo@@QAEXH@Z ; CQuestInfo::NotifyResultEnterRefuge
$LN2@GCReqEnter@3:

; 19817: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GCReqEnterBalgassLair@@YAXH@Z ENDP			; GCReqEnterBalgassLair
_TEXT	ENDS
PUBLIC	?GCReqmoveIllusionTemple@@YAXPAUPMSG_REQ_MOVEILLUSIONTEMPLE@@H@Z ; GCReqmoveIllusionTemple
EXTRN	?Enter@CIllusionTempleEvent@@QAEHHEE@Z:PROC	; CIllusionTempleEvent::Enter
; Function compile flags: /Ogtp
;	COMDAT ?GCReqmoveIllusionTemple@@YAXPAUPMSG_REQ_MOVEILLUSIONTEMPLE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?GCReqmoveIllusionTemple@@YAXPAUPMSG_REQ_MOVEILLUSIONTEMPLE@@H@Z PROC ; GCReqmoveIllusionTemple, COMDAT

; 19826: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19827: 	if( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN6@GCReqmoveI
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 1a		 jne	 SHORT $LN1@GCReqmoveI
$LN6@GCReqmoveI:

; 19828: 	{
; 19829: 		LogAdd("return %s %d",__FILE__,__LINE__);

  00018	68 75 4d 00 00	 push	 19829			; 00004d75H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19834: }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN1@GCReqmoveI:

; 19830: 		return;
; 19831: 	}
; 19832: 
; 19833: 	g_IllusionTemple.Enter(iIndex,lpMsg->iTempleNumber - 1,lpMsg->iItemPos);

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00035	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  00039	8a 49 04	 mov	 cl, BYTE PTR [ecx+4]
  0003c	52		 push	 edx
  0003d	fe c9		 dec	 cl
  0003f	0f b6 d1	 movzx	 edx, cl
  00042	52		 push	 edx
  00043	50		 push	 eax
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  00049	e8 00 00 00 00	 call	 ?Enter@CIllusionTempleEvent@@QAEHHEE@Z ; CIllusionTempleEvent::Enter

; 19834: }

  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?GCReqmoveIllusionTemple@@YAXPAUPMSG_REQ_MOVEILLUSIONTEMPLE@@H@Z ENDP ; GCReqmoveIllusionTemple
_TEXT	ENDS
PUBLIC	?GCIllusionSkillUseSend@@YAXPAUPMSG_ILLUSION_REQ_SKILLUSE@@H@Z ; GCIllusionSkillUseSend
EXTRN	?UseSkill@CIllusionTempleEvent@@QAEXHGHE@Z:PROC	; CIllusionTempleEvent::UseSkill
; Function compile flags: /Ogtp
;	COMDAT ?GCIllusionSkillUseSend@@YAXPAUPMSG_ILLUSION_REQ_SKILLUSE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCIllusionSkillUseSend@@YAXPAUPMSG_ILLUSION_REQ_SKILLUSE@@H@Z PROC ; GCIllusionSkillUseSend, COMDAT

; 19837: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19838: 	if( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 0f		 js	 SHORT $LN6@GCIllusion
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	75 1a		 jne	 SHORT $LN1@GCIllusion
$LN6@GCIllusion:

; 19839: 	{
; 19840: 		LogAdd("return %s %d",__FILE__,__LINE__);

  00019	68 80 4d 00 00	 push	 19840			; 00004d80H
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19847: }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN1@GCIllusion:

; 19841: 		return;
; 19842: 	}
; 19843: 
; 19844: 	WORD TargetIndex = MAKE_NUMBERW(lpMsg->tIndexH,lpMsg->tIndexL);
; 19845: 
; 19846: 	g_IllusionTemple.UseSkill(aIndex,MAKE_NUMBERW(lpMsg->MagicH,lpMsg->MagicL),TargetIndex,lpMsg->State);

  00033	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00036	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  0003a	56		 push	 esi
  0003b	0f b6 70 07	 movzx	 esi, BYTE PTR [eax+7]
  0003f	52		 push	 edx
  00040	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  00044	66 c1 e2 08	 shl	 dx, 8
  00048	0f b7 d2	 movzx	 edx, dx
  0004b	0b d6		 or	 edx, esi
  0004d	52		 push	 edx
  0004e	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00052	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00056	66 c1 e2 08	 shl	 dx, 8
  0005a	66 0b d0	 or	 dx, ax
  0005d	0f b7 d2	 movzx	 edx, dx
  00060	52		 push	 edx
  00061	51		 push	 ecx
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  00067	e8 00 00 00 00	 call	 ?UseSkill@CIllusionTempleEvent@@QAEXHGHE@Z ; CIllusionTempleEvent::UseSkill
  0006c	5e		 pop	 esi

; 19847: }

  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?GCIllusionSkillUseSend@@YAXPAUPMSG_ILLUSION_REQ_SKILLUSE@@H@Z ENDP ; GCIllusionSkillUseSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendEffectInfo@@YAXPAUOBJECTSTRUCT@@HHHH@Z	; GCSendEffectInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCSendEffectInfo@@YAXPAUOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_bUseType$ = 12						; size = 4
_iOptionType$ = 16					; size = 4
_iEffectType$ = 20					; size = 4
_iTimeValue$ = 24					; size = 4
?GCSendEffectInfo@@YAXPAUOBJECTSTRUCT@@HHHH@Z PROC	; GCSendEffectInfo, COMDAT

; 19851: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 19852: 	PMSG_SENDEFFECT pMsg;
; 19853: 	PHeadSetB((LPBYTE)&pMsg,0x2D,sizeof(pMsg));

  00014	6a 18		 push	 24			; 00000018H
  00016	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 2d		 push	 45			; 0000002dH
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 19854: 
; 19855: 	pMsg.byEffectOption = bUseType;

  00021	8a 4d 0c	 mov	 cl, BYTE PTR _bUseType$[ebp]

; 19856: 	pMsg.wOptionType = iOptionType;

  00024	66 8b 55 10	 mov	 dx, WORD PTR _iOptionType$[ebp]

; 19857: 	pMsg.wEffectType = iEffectType;

  00028	66 8b 45 14	 mov	 ax, WORD PTR _iEffectType$[ebp]
  0002c	88 4d ec	 mov	 BYTE PTR _pMsg$[ebp+8], cl

; 19858: 	pMsg.iLeftTime = iTimeValue;

  0002f	8b 4d 18	 mov	 ecx, DWORD PTR _iTimeValue$[ebp]
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19859: 	pMsg.iEffect = 0;
; 19860: 
; 19861: 	if( lpObj->Type == OBJ_USER )

  00035	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00039	66 89 55 e8	 mov	 WORD PTR _pMsg$[ebp+4], dx
  0003d	66 89 45 ea	 mov	 WORD PTR _pMsg$[ebp+6], ax
  00041	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+12], ecx
  00044	c6 45 f4 00	 mov	 BYTE PTR _pMsg$[ebp+16], 0
  00048	75 14		 jne	 SHORT $LN1@GCSendEffe@3

; 19862: 	{
; 19863: 		DataSend(lpObj->m_Index,(LPBYTE)&pMsg,pMsg.h.size);

  0004a	0f b6 55 e5	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0004e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00050	52		 push	 edx
  00051	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00054	50		 push	 eax
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCSendEffe@3:

; 19864: 	}
; 19865: }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	33 cd		 xor	 ecx, ebp
  00063	5e		 pop	 esi
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?GCSendEffectInfo@@YAXPAUOBJECTSTRUCT@@HHHH@Z ENDP	; GCSendEffectInfo
_TEXT	ENDS
PUBLIC	?GCIllusionSendPoint@@YAXHE@Z			; GCIllusionSendPoint
; Function compile flags: /Ogtp
;	COMDAT ?GCIllusionSendPoint@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_Point$ = 12						; size = 1
?GCIllusionSendPoint@@YAXHE@Z PROC			; GCIllusionSendPoint, COMDAT

; 19875: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19876: 	PMSG_ILLUSION_POINT_SEND pMsg;
; 19877: 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,6,sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 06		 push	 6
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 bf 00 00 00	 push	 191			; 000000bfH
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19878: 	pMsg.Point = Point;
; 19879: 
; 19880: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001c	8a 4d 0c	 mov	 cl, BYTE PTR _Point$[ebp]
  0001f	52		 push	 edx
  00020	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00023	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00029	50		 push	 eax
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 1c	 add	 esp, 28			; 0000001cH

; 19881: }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCIllusionSendPoint@@YAXHE@Z ENDP			; GCIllusionSendPoint
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendExp@@YAXHH_JHH@Z				; GCSendExp
; Function compile flags: /Ogtp
;	COMDAT ?GCSendExp@@YAXHH_JHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_AttackIndex$ = 12					; size = 4
_Exp$ = 16						; size = 8
_Damage$ = 24						; size = 4
_Type$ = 28						; size = 4
?GCSendExp@@YAXHH_JHH@Z PROC				; GCSendExp, COMDAT

; 19884: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 19885: 	PMSG_KILLPLAYER_EXT pMsg;
; 19886: 	PHeadSetBE((LPBYTE)&pMsg,0x9C,sizeof(pMsg));

  00010	6a 0c		 push	 12			; 0000000cH
  00012	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	68 9c 00 00 00	 push	 156			; 0000009cH
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 19887: 
; 19888: 	pMsg.NumberH = SET_NUMBERH(AttackIndex);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _AttackIndex$[ebp]
  00023	8b c8		 mov	 ecx, eax

; 19889: 	pMsg.NumberL = SET_NUMBERL(AttackIndex);

  00025	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 19890: 	pMsg.ExpH = (DWORD)Exp >> 16;

  00028	8b 45 10	 mov	 eax, DWORD PTR _Exp$[ebp]
  0002b	8b d0		 mov	 edx, eax
  0002d	c1 e9 08	 shr	 ecx, 8
  00030	c1 ea 10	 shr	 edx, 16			; 00000010H

; 19891: 	pMsg.ExpL = (DWORD)Exp & 0xFFFF;

  00033	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+8], ax

; 19892: 
; 19893: #if (CUSTOM_DAMAGE==1)
; 19894: 	pMsg.DamageHW = SET_NUMBERHW(Damage);
; 19895: 	pMsg.DamageLW = SET_NUMBERLW(Damage);
; 19896: #else
; 19897: 	pMsg.DamageH = SET_NUMBERH(Damage);

  00037	8b 45 18	 mov	 eax, DWORD PTR _Damage$[ebp]
  0003a	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0003d	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+6], dx

; 19898: 	pMsg.DamageL = SET_NUMBERL(Damage);
; 19899: #endif
; 19900: 
; 19901: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00041	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00045	8b c8		 mov	 ecx, eax
  00047	c1 e9 08	 shr	 ecx, 8
  0004a	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+11], al
  0004d	52		 push	 edx
  0004e	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00051	88 4d fa	 mov	 BYTE PTR _pMsg$[ebp+10], cl
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00057	50		 push	 eax
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 19902: }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	33 cd		 xor	 ecx, ebp
  00063	83 c4 18	 add	 esp, 24			; 00000018H
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?GCSendExp@@YAXHH_JHH@Z ENDP				; GCSendExp
_TEXT	ENDS
PUBLIC	?CGIllusionTempleReward@@YAXH@Z			; CGIllusionTempleReward
EXTRN	?DropReward@CIllusionTempleEvent@@QAEXH@Z:PROC	; CIllusionTempleEvent::DropReward
; Function compile flags: /Ogtp
;	COMDAT ?CGIllusionTempleReward@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGIllusionTempleReward@@YAXH@Z PROC			; CGIllusionTempleReward, COMDAT

; 19905: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19906: 	if( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 0f		 js	 SHORT $LN6@CGIllusion@2
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	75 1a		 jne	 SHORT $LN1@CGIllusion@2
$LN6@CGIllusion@2:

; 19907: 	{
; 19908: 		LogAdd("return %s %d",__FILE__,__LINE__);

  00019	68 c4 4d 00 00	 push	 19908			; 00004dc4H
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19913: }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN1@CGIllusion@2:

; 19909: 		return;
; 19910: 	}
; 19911: 
; 19912: 	g_IllusionTemple.DropReward(aIndex);

  00033	51		 push	 ecx
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  00039	e8 00 00 00 00	 call	 ?DropReward@CIllusionTempleEvent@@QAEXH@Z ; CIllusionTempleEvent::DropReward

; 19913: }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?CGIllusionTempleReward@@YAXH@Z ENDP			; CGIllusionTempleReward
_TEXT	ENDS
PUBLIC	?CGOpenPCBangShop@@YAXPAEH@Z			; CGOpenPCBangShop
; Function compile flags: /Ogtp
;	COMDAT ?CGOpenPCBangShop@@YAXPAEH@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGOpenPCBangShop@@YAXPAEH@Z PROC			; CGOpenPCBangShop, COMDAT

; 19917: 	if( aRecv == NULL )
; 19918: 		return;
; 19919: 
; 19920: 	if( !OBJMAX_RANGE(aIndex) )
; 19921: 		return;
; 19922: }

  00000	c3		 ret	 0
?CGOpenPCBangShop@@YAXPAEH@Z ENDP			; CGOpenPCBangShop
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGBuyPCBangShop@@YAXPAEH@Z			; CGBuyPCBangShop
; Function compile flags: /Ogtp
;	COMDAT ?CGBuyPCBangShop@@YAXPAEH@Z
_TEXT	SEGMENT
_pMsg$225332 = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGBuyPCBangShop@@YAXPAEH@Z PROC			; CGBuyPCBangShop, COMDAT

; 19933: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 19934: 	if( aRecv == NULL )

  00010	83 7d 08 00	 cmp	 DWORD PTR _aRecv$[ebp], 0
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00018	74 45		 je	 SHORT $LN1@CGBuyPCBan

; 19935: 		return;
; 19936: 
; 19937: 	if( PacketCheckTime(&gObj[aIndex]) == FALSE )

  0001a	8b c6		 mov	 eax, esi
  0001c	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00022	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	75 2a		 jne	 SHORT $LN1@CGBuyPCBan

; 19938: 	{
; 19939: 		PMSB_PCBANG_BUYRESULT pMsg;
; 19940: 
; 19941: 		PHeadSubSetB((LPBYTE)&pMsg,0xD0,0x05,sizeof(pMsg));

  00035	6a 12		 push	 18			; 00000012H
  00037	6a 05		 push	 5
  00039	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$225332[ebp]
  0003c	68 d0 00 00 00	 push	 208			; 000000d0H
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19942: 		pMsg.btResult = 6;
; 19943: 		pMsg.btPos = 0xFF;
; 19944: 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00047	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$225332[ebp+1]
  0004b	52		 push	 edx
  0004c	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$225332[ebp]
  0004f	50		 push	 eax
  00050	56		 push	 esi
  00051	66 c7 45 ec 06
	ff		 mov	 WORD PTR _pMsg$225332[ebp+4], 65286 ; 0000ff06H
  00057	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005c	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@CGBuyPCBan:

; 19945: 		return;
; 19946: 	}
; 19947: }

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	33 cd		 xor	 ecx, ebp
  00064	5e		 pop	 esi
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?CGBuyPCBangShop@@YAXPAEH@Z ENDP			; CGBuyPCBangShop
_TEXT	ENDS
PUBLIC	?CGReqmoveDoubleGoer@@YAXPAEH@Z			; CGReqmoveDoubleGoer
EXTRN	?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z:PROC ; CDoubleGoerEvent::EnterRequest
EXTRN	?gDoubleGoer@@3VCDoubleGoerEvent@@A:BYTE	; gDoubleGoer
; Function compile flags: /Ogtp
;	COMDAT ?CGReqmoveDoubleGoer@@YAXPAEH@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqmoveDoubleGoer@@YAXPAEH@Z PROC			; CGReqmoveDoubleGoer, COMDAT

; 19950: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 19951: 	if( aRecv == NULL || !OBJMAX_RANGE(aIndex) )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]
  00008	85 ff		 test	 edi, edi
  0000a	74 3a		 je	 SHORT $LN2@CGReqmoveD@2
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000f	85 f6		 test	 esi, esi
  00011	78 33		 js	 SHORT $LN2@CGReqmoveD@2
  00013	33 c0		 xor	 eax, eax
  00015	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0001b	0f 9e c0	 setle	 al
  0001e	85 c0		 test	 eax, eax
  00020	74 24		 je	 SHORT $LN2@CGReqmoveD@2

; 19954: 		return;
; 19955: 	}
; 19956: 
; 19957: 	if( !gObjIsConnected(aIndex) )

  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00028	83 c4 04	 add	 esp, 4
  0002b	85 c0		 test	 eax, eax
  0002d	75 07		 jne	 SHORT $LN1@CGReqmoveD@2

; 19958: 	{
; 19959: 		LogAdd("return %s %d",__FILE__,__LINE__);

  0002f	68 f7 4d 00 00	 push	 19959			; 00004df7H

; 19960: 		return;

  00034	eb 15		 jmp	 SHORT $LN8@CGReqmoveD@2
$LN1@CGReqmoveD@2:

; 19961: 	}
; 19962: 
; 19963: 	gDoubleGoer.EnterRequest((PMSG_DOUBLEGOER_REQ_ENTER*)aRecv,aIndex);

  00036	56		 push	 esi
  00037	57		 push	 edi
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDoubleGoer@@3VCDoubleGoerEvent@@A ; gDoubleGoer
  0003d	e8 00 00 00 00	 call	 ?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z ; CDoubleGoerEvent::EnterRequest
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 19964: }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN2@CGReqmoveD@2:

; 19952: 	{
; 19953: 		LogAdd("return %s %d",__FILE__,__LINE__);

  00046	68 f1 4d 00 00	 push	 19953			; 00004df1H
$LN8@CGReqmoveD@2:
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 19964: }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?CGReqmoveDoubleGoer@@YAXPAEH@Z ENDP			; CGReqmoveDoubleGoer
_TEXT	ENDS
PUBLIC	?CGReqEnterZone@@YAXPAUPMSG_REQ_ENTERZONE@@H@Z	; CGReqEnterZone
EXTRN	?CGEnterPortal@CImperialGuardian@@QAEXHH@Z:PROC	; CImperialGuardian::CGEnterPortal
EXTRN	?g_ImperialGuardian@@3VCImperialGuardian@@A:BYTE ; g_ImperialGuardian
; Function compile flags: /Ogtp
;	COMDAT ?CGReqEnterZone@@YAXPAUPMSG_REQ_ENTERZONE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqEnterZone@@YAXPAUPMSG_REQ_ENTERZONE@@H@Z PROC	; CGReqEnterZone, COMDAT

; 19967: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19968: 	if( !OBJMAX_RANGE(aIndex) )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN7@CGReqEnter@4
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 1a		 jne	 SHORT $LN2@CGReqEnter@4
$LN7@CGReqEnter@4:

; 19969: 	{
; 19970: 		LogAdd("return %s %d",__FILE__,__LINE__);

  00018	68 02 4e 00 00	 push	 19970			; 00004e02H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19977: 	}
; 19978: }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN2@CGReqEnter@4:

; 19971: 		return;
; 19972: 	}
; 19973: 
; 19974: 	if( lpMsg->btType == 1 )

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00035	80 79 04 01	 cmp	 BYTE PTR [ecx+4], 1
  00039	75 0d		 jne	 SHORT $LN1@CGReqEnter@4

; 19975: 	{
; 19976: 		g_ImperialGuardian.CGEnterPortal(aIndex,0);

  0003b	6a 00		 push	 0
  0003d	50		 push	 eax
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  00043	e8 00 00 00 00	 call	 ?CGEnterPortal@CImperialGuardian@@QAEXHH@Z ; CImperialGuardian::CGEnterPortal
$LN1@CGReqEnter@4:

; 19977: 	}
; 19978: }

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?CGReqEnterZone@@YAXPAUPMSG_REQ_ENTERZONE@@H@Z ENDP	; CGReqEnterZone
_TEXT	ENDS
PUBLIC	?CGReqmoveLorenMarket@@YAXH@Z			; CGReqmoveLorenMarket
; Function compile flags: /Ogtp
;	COMDAT ?CGReqmoveLorenMarket@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGReqmoveLorenMarket@@YAXH@Z PROC			; CGReqmoveLorenMarket, COMDAT

; 19981: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 19982: 	if( !gObjIsConnected(aIndex) )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 6b		 je	 SHORT $LN3@CGReqmoveL

; 19983: 		return;
; 19984: 
; 19985: 	LPOBJ lpObj = &gObj[aIndex];

  00014	8b c7		 mov	 eax, edi
  00016	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0001c	56		 push	 esi
  0001d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 19986: 
; 19987: 	if( lpObj->m_IfState.use != 1 || lpObj->m_IfState.type != 21 )

  00023	8b 8c 30 b8 11
	00 00		 mov	 ecx, DWORD PTR [eax+esi+4536]
  0002a	8b d1		 mov	 edx, ecx
  0002c	80 e2 03	 and	 dl, 3
  0002f	80 fa 01	 cmp	 dl, 1
  00032	75 4a		 jne	 SHORT $LN8@CGReqmoveL
  00034	8b d1		 mov	 edx, ecx
  00036	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  0003c	81 fa 40 05 00
	00		 cmp	 edx, 1344		; 00000540H
  00042	75 3a		 jne	 SHORT $LN8@CGReqmoveL

; 19988: 		return;
; 19989: 	
; 19990: 	lpObj->m_IfState.use = 0;
; 19991: 	lpObj->m_IfState.type = 0;

  00044	81 e1 3c 00 ff
	ff		 and	 ecx, -65476		; ffff003cH
  0004a	89 8c 30 b8 11
	00 00		 mov	 DWORD PTR [eax+esi+4536], ecx

; 19992: 
; 19993: 
; 19994: 	if( gObj[aIndex].MapNumber == 79 )

  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00057	80 bc 08 23 01
	00 00 4f	 cmp	 BYTE PTR [eax+ecx+291], 79 ; 0000004fH
  0005f	75 0f		 jne	 SHORT $LN2@CGReqmoveL

; 19995: 	{
; 19996: 		gObjMoveGate(aIndex,17);

  00061	6a 11		 push	 17			; 00000011H

; 19997: 	}
; 19998: 	else
; 19999: 	{
; 20000: 		gObjMoveGate(aIndex,333);

  00063	57		 push	 edi
  00064	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00069	83 c4 08	 add	 esp, 8
  0006c	5e		 pop	 esi
  0006d	5f		 pop	 edi

; 20001: 	}
; 20002: }

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN2@CGReqmoveL:

; 19997: 	}
; 19998: 	else
; 19999: 	{
; 20000: 		gObjMoveGate(aIndex,333);

  00070	68 4d 01 00 00	 push	 333			; 0000014dH
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0007b	83 c4 08	 add	 esp, 8
$LN8@CGReqmoveL:
  0007e	5e		 pop	 esi
$LN3@CGReqmoveL:
  0007f	5f		 pop	 edi

; 20001: 	}
; 20002: }

  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?CGReqmoveLorenMarket@@YAXH@Z ENDP			; CGReqmoveLorenMarket
_TEXT	ENDS
PUBLIC	?CGReqMoveAcheron@@YAXH@Z			; CGReqMoveAcheron
; Function compile flags: /Ogtp
;	COMDAT ?CGReqMoveAcheron@@YAXH@Z
_TEXT	SEGMENT
_pMsg$225382 = -8					; size = 5
_aIndex$ = 8						; size = 4
?CGReqMoveAcheron@@YAXH@Z PROC				; CGReqMoveAcheron, COMDAT

; 20011: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 20012: 	if( !gObjIsConnected(aIndex) )

  00007	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	0f 84 fa 00 00
	00		 je	 $LN6@CGReqMoveA

; 20013: 		return;
; 20014: 
; 20015: 	LPOBJ lpObj = &gObj[aIndex];

  0001b	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00021	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 20016: 
; 20017: 	if( lpObj->m_IfState.use != 1 || lpObj->m_IfState.type != 21 )

  00027	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  0002d	8b c8		 mov	 ecx, eax
  0002f	80 e1 03	 and	 cl, 3
  00032	80 f9 01	 cmp	 cl, 1
  00035	0f 85 da 00 00
	00		 jne	 $LN6@CGReqMoveA
  0003b	8b d0		 mov	 edx, eax
  0003d	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00043	81 fa 40 05 00
	00		 cmp	 edx, 1344		; 00000540H
  00049	0f 85 c6 00 00
	00		 jne	 $LN6@CGReqMoveA

; 20018: 		return;
; 20019: 	
; 20020: 	lpObj->m_IfState.use = 0;
; 20021: 	lpObj->m_IfState.type = 0;

  0004f	53		 push	 ebx
  00050	25 3c 00 ff ff	 and	 eax, -65476		; ffff003cH
  00055	57		 push	 edi
  00056	89 86 b8 11 00
	00		 mov	 DWORD PTR [esi+4536], eax

; 20022: 
; 20023: 	int bSpiritMap = FALSE;
; 20024: 
; 20025: 	for(int i = INVETORY_WEAR_SIZE; i < MAIN_INVENTORY_SIZE; i++)	{

  0005c	bb 0c 00 00 00	 mov	 ebx, 12			; 0000000cH
  00061	bf f0 09 00 00	 mov	 edi, 2544		; 000009f0H
  00066	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL5@CGReqMoveA:

; 20026: 		if( lpObj->pInventory[i].IsItem() &&
; 20027: 			lpObj->pInventory[i].m_Type == ITEMGET(13,146) )

  00070	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00076	03 cf		 add	 ecx, edi
  00078	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0007d	85 c0		 test	 eax, eax
  0007f	74 12		 je	 SHORT $LN4@CGReqMoveA
  00081	8b 86 c0 11 00
	00		 mov	 eax, DWORD PTR [esi+4544]
  00087	b9 92 1a 00 00	 mov	 ecx, 6802		; 00001a92H
  0008c	66 39 4c 38 06	 cmp	 WORD PTR [eax+edi+6], cx
  00091	74 41		 je	 SHORT $LN12@CGReqMoveA
$LN4@CGReqMoveA:

; 20022: 
; 20023: 	int bSpiritMap = FALSE;
; 20024: 
; 20025: 	for(int i = INVETORY_WEAR_SIZE; i < MAIN_INVENTORY_SIZE; i++)	{

  00093	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00099	43		 inc	 ebx
  0009a	81 ff f0 a8 00
	00		 cmp	 edi, 43248		; 0000a8f0H
  000a0	7c ce		 jl	 SHORT $LL5@CGReqMoveA

; 20034: 			break;
; 20035: 		}
; 20036: 	}
; 20037: 
; 20038: 
; 20039: 	if( !bSpiritMap )
; 20040: 	{
; 20041: 		PMSG_ANS_MOVEACHERON pMsg;
; 20042: 		PHeadSubSetB((LPBYTE)&pMsg,0xF8,0x21,sizeof(pMsg));

  000a2	6a 05		 push	 5
  000a4	6a 21		 push	 33			; 00000021H
  000a6	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$225382[ebp]
  000a9	68 f8 00 00 00	 push	 248			; 000000f8H
  000ae	52		 push	 edx
  000af	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 20043: 		pMsg.btResult = 1;
; 20044: 
; 20045: 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  000b4	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$225382[ebp+1]
  000b8	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000bb	50		 push	 eax
  000bc	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$225382[ebp]
  000bf	51		 push	 ecx
  000c0	52		 push	 edx
  000c1	c6 45 fc 01	 mov	 BYTE PTR _pMsg$225382[ebp+4], 1
  000c5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ca	83 c4 1c	 add	 esp, 28			; 0000001cH
  000cd	5f		 pop	 edi
  000ce	5b		 pop	 ebx
  000cf	5e		 pop	 esi

; 20050: 
; 20051: 
; 20052: 	/*if( gObj[aIndex].MapNumber == 79 )
; 20053: 	{
; 20054: 		gObjMoveGate(aIndex,17);
; 20055: 	}
; 20056: 	else
; 20057: 	{
; 20058: 		gObjMoveGate(aIndex,333);
; 20059: 	}*/
; 20060: }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN12@CGReqMoveA:

; 20028: 		{
; 20029: 			bSpiritMap = TRUE;
; 20030: 
; 20031: 			gObjInventoryItemSet(aIndex,i,(BYTE)-1);

  000d4	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  000d7	68 ff 00 00 00	 push	 255			; 000000ffH
  000dc	53		 push	 ebx
  000dd	57		 push	 edi
  000de	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 20032: 			lpObj->pInventory[i].Clear();

  000e3	8b cb		 mov	 ecx, ebx
  000e5	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  000eb	03 8e c0 11 00
	00		 add	 ecx, DWORD PTR [esi+4544]
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 20033: 			GCInventoryItemDeleteSend(aIndex,i,1);

  000f9	6a 01		 push	 1
  000fb	53		 push	 ebx
  000fc	57		 push	 edi
  000fd	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20046: 		return;
; 20047: 	}
; 20048: 
; 20049: 	gObjMoveGate(aIndex,417);

  00105	68 a1 01 00 00	 push	 417			; 000001a1H
  0010a	57		 push	 edi
  0010b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00110	83 c4 08	 add	 esp, 8
  00113	5f		 pop	 edi
  00114	5b		 pop	 ebx
$LN6@CGReqMoveA:
  00115	5e		 pop	 esi

; 20050: 
; 20051: 
; 20052: 	/*if( gObj[aIndex].MapNumber == 79 )
; 20053: 	{
; 20054: 		gObjMoveGate(aIndex,17);
; 20055: 	}
; 20056: 	else
; 20057: 	{
; 20058: 		gObjMoveGate(aIndex,333);
; 20059: 	}*/
; 20060: }

  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
?CGReqMoveAcheron@@YAXH@Z ENDP				; CGReqMoveAcheron
_TEXT	ENDS
PUBLIC	?CGWindowReqMove@@YAXPAUPMSG_MOVE_REQUEST@@H@Z	; CGWindowReqMove
EXTRN	?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMoveCommand::Move
EXTRN	?gMoveCommand@@3VCMoveCommand@@A:BYTE		; gMoveCommand
EXTRN	?g_SelfDefenseTime@@3HA:DWORD			; g_SelfDefenseTime
EXTRN	?g_SelfDefenseOn@@3_NA:BYTE			; g_SelfDefenseOn
; Function compile flags: /Ogtp
;	COMDAT ?CGWindowReqMove@@YAXPAUPMSG_MOVE_REQUEST@@H@Z
_TEXT	SEGMENT
_pMsg$ = -12						; size = 8
_movereq$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGWindowReqMove@@YAXPAUPMSG_MOVE_REQUEST@@H@Z PROC	; CGWindowReqMove, COMDAT

; 20063: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	57		 push	 edi

; 20064: 	if ( !OBJMAX_RANGE(aIndex))

  00007	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000a	85 ff		 test	 edi, edi
  0000c	0f 88 65 01 00
	00		 js	 $LN11@CGWindowRe
  00012	33 c0		 xor	 eax, eax
  00014	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 52 01 00
	00		 je	 $LN11@CGWindowRe

; 20065: 	{
; 20066: 		return;
; 20067: 	}
; 20068: 
; 20069: 	if( !gObjIsConnected(aIndex) )

  00025	57		 push	 edi
  00026	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002b	83 c4 04	 add	 esp, 4
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 41 01 00
	00		 je	 $LN11@CGWindowRe

; 20070: 		return;
; 20071: 
; 20072: 
; 20073: 	if (g_SelfDefenseOn)

  00036	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_SelfDefenseOn@@3_NA, 0 ; g_SelfDefenseOn
  0003d	74 4b		 je	 SHORT $LN15@CGWindowRe

; 20074: 	{
; 20075: 		if ((GetTickCount() - gObj[aIndex].MySelfDefenseTime) < g_SelfDefenseTime * 1000) 

  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00045	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004b	8b cf		 mov	 ecx, edi
  0004d	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00053	2b 84 11 fc 05
	00 00		 sub	 eax, DWORD PTR [ecx+edx+1532]
  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_SelfDefenseTime@@3HA ; g_SelfDefenseTime
  00060	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  00066	3b c1		 cmp	 eax, ecx
  00068	73 20		 jae	 SHORT $LN15@CGWindowRe

; 20076: 		{
; 20077: 			GCServerMsgStringSend(lMsg.Get(1133),aIndex,1);

  0006a	6a 01		 push	 1
  0006c	57		 push	 edi
  0006d	68 6d 04 00 00	 push	 1133			; 0000046dH
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00077	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	5f		 pop	 edi

; 20126: }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN15@CGWindowRe:

; 20078: 			return;
; 20079: 		}
; 20080: 	}
; 20081: 
; 20082: 	LPOBJ lpObj = &gObj[aIndex];

  0008a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00090	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00096	53		 push	 ebx

; 20083: 	int movereq = lpMsg->wMoveNumber;

  00097	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  0009a	0f b7 43 08	 movzx	 eax, WORD PTR [ebx+8]
  0009e	56		 push	 esi

; 20084: 
; 20085: 	PMSG_MOVE_ANSWER pMsg;
; 20086: 	PHeadSetB((LPBYTE) &pMsg,0x8E,sizeof(pMsg));

  0009f	6a 08		 push	 8
  000a1	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000a4	68 8e 00 00 00	 push	 142			; 0000008eH
  000a9	51		 push	 ecx
  000aa	8d 34 17	 lea	 esi, DWORD PTR [edi+edx]
  000ad	89 45 fc	 mov	 DWORD PTR _movereq$[ebp], eax
  000b0	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 20087: 	pMsg.CHECK = lpMsg->CHECK;

  000b5	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+4], edx

; 20088: 
; 20089: 	if ( lpObj->Teleport != 0 )

  000be	80 be 88 05 00
	00 00		 cmp	 BYTE PTR [esi+1416], 0
  000c5	74 24		 je	 SHORT $LN6@CGWindowRe
$LN18@CGWindowRe:

; 20090: 	{
; 20091: 		GCServerMsgStringSend(lMsg.Get(MSGGET(6, 68)), lpObj->m_Index, 1);

  000c7	8b 06		 mov	 eax, DWORD PTR [esi]
  000c9	6a 01		 push	 1
  000cb	50		 push	 eax
$LN19@CGWindowRe:
  000cc	68 44 06 00 00	 push	 1604			; 00000644H
$LN20@CGWindowRe:
  000d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000d6	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 20125: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e4	5e		 pop	 esi
  000e5	5b		 pop	 ebx
  000e6	5f		 pop	 edi

; 20126: }

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
$LN6@CGWindowRe:

; 20092: 		return;
; 20093: 	}
; 20094: 
; 20095: 
; 20096: 	if ( (lpObj->m_IfState.use) != 0 )

  000eb	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  000f1	a8 03		 test	 al, 3
  000f3	74 25		 je	 SHORT $LN4@CGWindowRe

; 20097: 	{
; 20098: 		if ( lpObj->m_IfState.type  == 3 )

  000f5	8b c8		 mov	 ecx, eax
  000f7	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  000fd	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  00103	75 15		 jne	 SHORT $LN4@CGWindowRe

; 20099: 		{
; 20100: 			lpObj->TargetShopNumber = -1;

  00105	83 ca ff	 or	 edx, -1

; 20101: 			lpObj->m_IfState.type = 0;
; 20102: 			lpObj->m_IfState.use = 0;

  00108	25 3c 00 ff ff	 and	 eax, -65476		; ffff003cH
  0010d	66 89 96 3a 06
	00 00		 mov	 WORD PTR [esi+1594], dx
  00114	89 86 b8 11 00
	00		 mov	 DWORD PTR [esi+4536], eax
$LN4@CGWindowRe:

; 20103: 		}
; 20104: 	}
; 20105: 
; 20106: 	if ( lpObj->m_IfState.use > 0 )

  0011a	f6 86 b8 11 00
	00 03		 test	 BYTE PTR [esi+4536], 3

; 20107: 	{
; 20108: 		GCServerMsgStringSend(lMsg.Get(MSGGET(6, 68)), lpObj->m_Index, 1);
; 20109: 		return;

  00121	77 a4		 ja	 SHORT $LN18@CGWindowRe

; 20110: 	}
; 20111: 			
; 20112: 	if ( lpObj->IsInBattleGround != false )

  00123	80 be de 13 00
	00 00		 cmp	 BYTE PTR [esi+5086], 0
  0012a	74 07		 je	 SHORT $LN2@CGWindowRe

; 20113: 	{
; 20114: 		GCServerMsgStringSend(lMsg.Get(MSGGET(6, 68)), lpObj->m_Index, 1);

  0012c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012e	6a 01		 push	 1
  00130	51		 push	 ecx

; 20115: 		return;

  00131	eb 99		 jmp	 SHORT $LN19@CGWindowRe
$LN2@CGWindowRe:

; 20116: 	}
; 20117: 
; 20118: 	if ( lpObj->m_PK_Level >= 6)

  00133	80 be 19 01 00
	00 06		 cmp	 BYTE PTR [esi+281], 6
  0013a	7c 0c		 jl	 SHORT $LN1@CGWindowRe

; 20119: 	{
; 20120: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 101)), lpObj->m_Index, 1);

  0013c	8b 16		 mov	 edx, DWORD PTR [esi]
  0013e	6a 01		 push	 1
  00140	52		 push	 edx
  00141	68 65 04 00 00	 push	 1125			; 00000465H

; 20121: 		return;

  00146	eb 89		 jmp	 SHORT $LN20@CGWindowRe
$LN1@CGWindowRe:

; 20122: 	}
; 20123: 
; 20124: 	pMsg.btResult = gMoveCommand.Move(&gObj[aIndex], movereq);

  00148	8b 45 fc	 mov	 eax, DWORD PTR _movereq$[ebp]
  0014b	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00151	50		 push	 eax
  00152	57		 push	 edi
  00153	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00158	e8 00 00 00 00	 call	 ?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::Move

; 20125: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0015d	0f b6 55 f5	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00161	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00164	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00167	52		 push	 edx
  00168	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0016b	50		 push	 eax
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH
  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx
$LN11@CGWindowRe:
  00177	5f		 pop	 edi

; 20126: }

  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
?CGWindowReqMove@@YAXPAUPMSG_MOVE_REQUEST@@H@Z ENDP	; CGWindowReqMove
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z ; GCMonkMagicAttackNumberSend
; Function compile flags: /Ogtp
;	COMDAT ?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_pAttack$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_MagicNumber$ = 12					; size = 4
_usernumber$ = 16					; size = 4
_skillsuccess$ = 20					; size = 4
?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z PROC ; GCMonkMagicAttackNumberSend, COMDAT

; 20129: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 20130: 	PMSG_MAGICATTACK_RESULT pAttack;
; 20131: 	PHeadSetBE((LPBYTE)&pAttack, 0x4A, sizeof(pAttack));

  00014	6a 09		 push	 9
  00016	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  00019	6a 4a		 push	 74			; 0000004aH
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 20132: 
; 20133: 	pAttack.MagicNumberH = SET_NUMBERH(MagicNumber);

  00021	8b 45 0c	 mov	 eax, DWORD PTR _MagicNumber$[ebp]
  00024	8b c8		 mov	 ecx, eax
  00026	c1 e9 08	 shr	 ecx, 8
  00029	88 4d f5	 mov	 BYTE PTR _pAttack$[ebp+5], cl

; 20134: 	pAttack.MagicNumberL = SET_NUMBERL(MagicNumber);
; 20135: 
; 20136: 	pAttack.SourceNumberH = SET_NUMBERH(lpObj->m_Index);

  0002c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002e	88 45 f6	 mov	 BYTE PTR _pAttack$[ebp+6], al
  00031	8b d1		 mov	 edx, ecx
  00033	c1 ea 08	 shr	 edx, 8

; 20137: 	pAttack.SourceNumberL = SET_NUMBERL(lpObj->m_Index);

  00036	8a c1		 mov	 al, cl
  00038	88 55 f3	 mov	 BYTE PTR _pAttack$[ebp+3], dl

; 20138: 	pAttack.TargetNumberH = SET_NUMBERH(usernumber);

  0003b	8b 55 10	 mov	 edx, DWORD PTR _usernumber$[ebp]
  0003e	88 45 f4	 mov	 BYTE PTR _pAttack$[ebp+4], al
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 08	 shr	 eax, 8

; 20139: 	pAttack.TargetNumberL = SET_NUMBERL(usernumber);
; 20140: 	pAttack.TargetNumberH &= 0x7F;

  00046	24 7f		 and	 al, 127			; 0000007fH
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20141: 
; 20142: 	if ( skillsuccess )

  0004b	83 7d 14 00	 cmp	 DWORD PTR _skillsuccess$[ebp], 0
  0004f	88 55 f8	 mov	 BYTE PTR _pAttack$[ebp+8], dl
  00052	88 45 f7	 mov	 BYTE PTR _pAttack$[ebp+7], al
  00055	74 05		 je	 SHORT $LN2@GCMonkMagi

; 20143: 		pAttack.TargetNumberH |= 0x80;

  00057	0c 80		 or	 al, 128			; 00000080H
  00059	88 45 f7	 mov	 BYTE PTR _pAttack$[ebp+7], al
$LN2@GCMonkMagi:

; 20144: 
; 20145: 	if ( lpObj->Type == OBJ_USER )

  0005c	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00060	75 12		 jne	 SHORT $LN1@GCMonkMagi

; 20146: 		DataSend(lpObj->m_Index, (LPBYTE)&pAttack, pAttack.h.size);

  00062	0f b6 55 f1	 movzx	 edx, BYTE PTR _pAttack$[ebp+1]
  00066	52		 push	 edx
  00067	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  0006a	50		 push	 eax
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCMonkMagi:

; 20147: 	
; 20148: 	MsgSendV2(lpObj, (LPBYTE)&pAttack, pAttack.h.size);

  00074	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pAttack$[ebp+1]
  00078	51		 push	 ecx
  00079	8d 55 f0	 lea	 edx, DWORD PTR _pAttack$[ebp]
  0007c	52		 push	 edx
  0007d	56		 push	 esi
  0007e	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 20149: }

  00083	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	33 cd		 xor	 ecx, ebp
  0008b	5e		 pop	 esi
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z ENDP ; GCMonkMagicAttackNumberSend
_TEXT	ENDS
PUBLIC	??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ ; `string'
PUBLIC	??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ ; `string'
PUBLIC	??_C@_0EM@GKLOHMBB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ ; `string'
PUBLIC	?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z	; GCMonkMagicAttack
EXTRN	?g_iSkillDistanceKick@@3HA:DWORD		; g_iSkillDistanceKick
EXTRN	?g_iSkillDistanceKickCount@@3HA:DWORD		; g_iSkillDistanceKickCount
EXTRN	?g_iSkillDiatanceKickCheckTime@@3KA:DWORD	; g_iSkillDiatanceKickCheckTime
EXTRN	?gCheckSkillDistance@@YAHHHH@Z:PROC		; gCheckSkillDistance
EXTRN	?gObjCheckAttackArea@@YAHHH@Z:PROC		; gObjCheckAttackArea
;	COMDAT ??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@ DB 'error :%s %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'SKILL DISTANCE CHECK] [%s][%s] Kick Invalid Skill Area User. '
	DB	'count(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
CONST	SEGMENT
??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ DB '['
	DB	'0x4A] CGRageAttack() - Invalid KillCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
CONST	SEGMENT
??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ DB '['
	DB	'0x4A] CGRageAttack() - Invalid Status', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@GKLOHMBB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
CONST	SEGMENT
??_C@_0EM@GKLOHMBB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ DB '['
	DB	'%s][%s] Try Attack In Not Attack Area [Protocol] (%d:%d,%d) e'
	DB	'rrortype = %d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z
_TEXT	SEGMENT
tv331 = -4						; size = 4
_usernumber$ = 8					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z PROC	; GCMonkMagicAttack, COMDAT

; 20152: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 20153: 	LPOBJ lpObj;
; 20154: 	LPOBJ lpTargetObj;
; 20155: 	int usernumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00004	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00007	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0000b	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  0000f	66 c1 e1 08	 shl	 cx, 8
  00013	0f b7 c9	 movzx	 ecx, cx
  00016	0b ca		 or	 ecx, edx

; 20156: 	CMagicInf* lpMagic;
; 20157: 
; 20158: 
; 20159: 	if( gObj[aIndex].CloseCount >= 0 )

  00018	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0001b	56		 push	 esi
  0001c	8b f2		 mov	 esi, edx
  0001e	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00024	89 75 fc	 mov	 DWORD PTR tv331[ebp], esi
  00027	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002d	57		 push	 edi
  0002e	80 7e 0c 00	 cmp	 BYTE PTR [esi+12], 0
  00032	89 4d 08	 mov	 DWORD PTR _usernumber$[ebp], ecx
  00035	0f 8d 2c 01 00
	00		 jge	 $LN22@GCMonkMagi@2

; 20160: 		return;
; 20161: 
; 20162: 	WORD MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH, lpMsg->MagicNumberL);

  0003b	0f b6 78 04	 movzx	 edi, BYTE PTR [eax+4]
  0003f	0f b6 40 06	 movzx	 eax, BYTE PTR [eax+6]
  00043	66 c1 e7 08	 shl	 di, 8
  00047	66 0b f8	 or	 di, ax
  0004a	0f b7 ff	 movzx	 edi, di

; 20163: 
; 20164: 	if( MagicNumber == AT_SKILL_RAGEFIGHTER_DARKSIDE ||
; 20165: 		MagicNumber == AT_MSKILL_RF_DARKSIDE1 ||
; 20166: 		MagicNumber == AT_MSKILL_RF_DARKSIDE2 )

  0004d	b8 07 01 00 00	 mov	 eax, 263		; 00000107H
  00052	66 3b f8	 cmp	 di, ax
  00055	0f 84 31 02 00
	00		 je	 $LN19@GCMonkMagi@2
  0005b	b8 2f 02 00 00	 mov	 eax, 559		; 0000022fH
  00060	66 3b f8	 cmp	 di, ax
  00063	0f 84 23 02 00
	00		 je	 $LN19@GCMonkMagi@2
  00069	b8 33 02 00 00	 mov	 eax, 563		; 00000233H
  0006e	66 3b f8	 cmp	 di, ax
  00071	0f 84 15 02 00
	00		 je	 $LN19@GCMonkMagi@2

; 20169: 		return;
; 20170: 	}
; 20171: 
; 20172: 	if( usernumber < 0 || usernumber > OBJMAX-1 )

  00077	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0007d	0f 87 ea 01 00
	00		 ja	 $LN17@GCMonkMagi@2

; 20175: 		return;
; 20176: 	}
; 20177: 
; 20178: 	if( gObj[aIndex].Live == FALSE || 
; 20179: 		gObj[aIndex].Connected <= PLAYER_LOGGED )

  00083	80 7e 51 00	 cmp	 BYTE PTR [esi+81], 0
  00087	0f 84 da 00 00
	00		 je	 $LN22@GCMonkMagi@2
  0008d	83 7e 04 02	 cmp	 DWORD PTR [esi+4], 2
  00091	0f 8e d0 00 00
	00		 jle	 $LN22@GCMonkMagi@2

; 20180: 	{
; 20181: 		return;
; 20182: 	}
; 20183: 
; 20184: 	lpObj = &gObj[aIndex];
; 20185: 	lpTargetObj = &gObj[usernumber];
; 20186: 
; 20187: 	int attackret = gObjCheckAttackArea(aIndex,usernumber);

  00097	51		 push	 ecx
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 ?gObjCheckAttackArea@@YAHHH@Z ; gObjCheckAttackArea
  0009e	83 c4 08	 add	 esp, 8

; 20188: 
; 20189: 	if( attackret != 0 )

  000a1	85 c0		 test	 eax, eax
  000a3	74 50		 je	 SHORT $LN12@GCMonkMagi@2

; 20190: 	{
; 20191: 		LogAddTD("[%s][%s] Try Attack In Not Attack Area [Protocol] (%d:%d,%d) errortype = %d",
; 20192: 			lpObj->AccountID,lpObj->Name,lpObj->MapNumber,lpObj->X,lpObj->Y,attackret);

  000a5	0f b6 8e 21 01
	00 00		 movzx	 ecx, BYTE PTR [esi+289]
  000ac	0f b6 96 20 01
	00 00		 movzx	 edx, BYTE PTR [esi+288]
  000b3	50		 push	 eax
  000b4	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  000bb	51		 push	 ecx
  000bc	52		 push	 edx
  000bd	50		 push	 eax
  000be	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  000c1	51		 push	 ecx
  000c2	8d 56 52	 lea	 edx, DWORD PTR [esi+82]
  000c5	52		 push	 edx
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@GKLOHMBB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 20193: 
; 20194: 		if( lpObj->Class == 275 )

  000d1	b8 13 01 00 00	 mov	 eax, 275		; 00000113H
  000d6	83 c4 1c	 add	 esp, 28			; 0000001cH
  000d9	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  000e0	75 0a		 jne	 SHORT $LN13@GCMonkMagi@2

; 20195: 			lpObj->TargetNumber = -1;

  000e2	83 c9 ff	 or	 ecx, -1
  000e5	66 89 8e 38 06
	00 00		 mov	 WORD PTR [esi+1592], cx
$LN13@GCMonkMagi@2:

; 20196: 		if( bIsIgnorePacketSpeedHackDetect != 0 )

  000ec	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  000f3	75 72		 jne	 SHORT $LN22@GCMonkMagi@2
$LN12@GCMonkMagi@2:

; 20197: 			return;
; 20198: 	}
; 20199: 
; 20200: 	if ( lpObj->Type == OBJ_USER )

  000f5	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  000f9	53		 push	 ebx

; 20201: 	{
; 20202: 		lpMagic = gObjGetMagicSearch(lpObj, MagicNumber);

  000fa	8b df		 mov	 ebx, edi
  000fc	53		 push	 ebx
  000fd	56		 push	 esi
  000fe	0f 85 9a 00 00
	00		 jne	 $LN11@GCMonkMagi@2
  00104	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00109	8b f8		 mov	 edi, eax
  0010b	83 c4 08	 add	 esp, 8

; 20203: 
; 20204: 		if ( !lpMagic )

  0010e	85 ff		 test	 edi, edi
  00110	74 54		 je	 SHORT $LN25@GCMonkMagi@2

; 20205: 			return;
; 20206: 
; 20207: 		if ( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, lpObj->ChangeUP2 , lpMagic->m_Skill) < 1 )

  00112	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00115	0f b6 86 94 00
	00 00		 movzx	 eax, BYTE PTR [esi+148]
  0011c	0f b6 8e 93 00
	00 00		 movzx	 ecx, BYTE PTR [esi+147]
  00123	52		 push	 edx
  00124	0f b7 96 90 00
	00 00		 movzx	 edx, WORD PTR [esi+144]
  0012b	50		 push	 eax
  0012c	51		 push	 ecx
  0012d	52		 push	 edx
  0012e	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00133	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z ; CMagicDamage::SkillGetRequireClass
  00138	83 f8 01	 cmp	 eax, 1
  0013b	7c 29		 jl	 SHORT $LN25@GCMonkMagi@2

; 20208: 			return;
; 20209: 
; 20210: 		if ( MagicDamageC.CheckStatus(lpMagic->m_Skill, lpObj->GuildStatus) == 0 )

  0013d	8b 86 28 06 00
	00		 mov	 eax, DWORD PTR [esi+1576]
  00143	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00146	50		 push	 eax
  00147	51		 push	 ecx
  00148	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0014d	e8 00 00 00 00	 call	 ?CheckStatus@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckStatus
  00152	85 c0		 test	 eax, eax
  00154	75 17		 jne	 SHORT $LN8@GCMonkMagi@2

; 20211: 		{
; 20212: 			LogAddC(2, "[0x4A] CGRageAttack() - Invalid Status");

  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
  0015b	6a 02		 push	 2
  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00163	83 c4 08	 add	 esp, 8
$LN25@GCMonkMagi@2:
  00166	5b		 pop	 ebx
$LN22@GCMonkMagi@2:
  00167	5f		 pop	 edi
  00168	5e		 pop	 esi

; 20259: }

  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
$LN8@GCMonkMagi@2:

; 20213: 			return;
; 20214: 		}
; 20215: 
; 20216: 		if ( MagicDamageC.CheckKillCount(lpMagic->m_Skill, lpObj->m_btKillCount) < 0 )

  0016d	0f b6 96 64 20
	00 00		 movzx	 edx, BYTE PTR [esi+8292]
  00174	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00177	52		 push	 edx
  00178	50		 push	 eax
  00179	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0017e	e8 00 00 00 00	 call	 ?CheckKillCount@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckKillCount
  00183	85 c0		 test	 eax, eax
  00185	79 25		 jns	 SHORT $LN5@GCMonkMagi@2

; 20217: 		{
; 20218: 			LogAddC(2, "[0x4A] CGRageAttack() - Invalid KillCount");

  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
  0018c	6a 02		 push	 2
  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00194	83 c4 08	 add	 esp, 8
  00197	5b		 pop	 ebx
  00198	5f		 pop	 edi
  00199	5e		 pop	 esi

; 20259: }

  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c3		 ret	 0
$LN11@GCMonkMagi@2:

; 20219: 			return;
; 20220: 		}
; 20221: 	}
; 20222: 	else
; 20223: 	{
; 20224: 		lpMagic = gObjGetMagic(lpObj, MagicNumber);

  0019e	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
  001a3	8b f8		 mov	 edi, eax
  001a5	83 c4 08	 add	 esp, 8

; 20225: 
; 20226: 		if ( !lpMagic )

  001a8	85 ff		 test	 edi, edi
  001aa	74 ba		 je	 SHORT $LN25@GCMonkMagi@2
$LN5@GCMonkMagi@2:

; 20227: 			return;
; 20228: 	}
; 20229: 
; 20230: 	if ( !gCheckSkillDistance(aIndex, usernumber, lpMagic->m_Skill))

  001ac	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  001af	8b 7d 08	 mov	 edi, DWORD PTR _usernumber$[ebp]
  001b2	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001b5	51		 push	 ecx
  001b6	57		 push	 edi
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  001bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c0	85 c0		 test	 eax, eax
  001c2	0f 85 88 00 00
	00		 jne	 $LN4@GCMonkMagi@2

; 20231: 	{
; 20232: 		DWORD dwTick = GetTickCount() - lpObj->m_dwSkillDistanceErrorTick;

  001c8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  001ce	ff d7		 call	 edi

; 20233: 		
; 20234: 		if ( dwTick > (g_iSkillDiatanceKickCheckTime*1000) )

  001d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_iSkillDiatanceKickCheckTime@@3KA ; g_iSkillDiatanceKickCheckTime
  001d6	2b 86 28 24 00
	00		 sub	 eax, DWORD PTR [esi+9256]
  001dc	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  001e2	3b c1		 cmp	 eax, ecx
  001e4	76 12		 jbe	 SHORT $LN24@GCMonkMagi@2

; 20235: 		{
; 20236: 			lpObj->m_iSkillDistanceErrorCount = 0;

  001e6	c7 86 24 24 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9252], 0

; 20237: 			lpObj->m_dwSkillDistanceErrorTick = GetTickCount();

  001f0	ff d7		 call	 edi
  001f2	89 86 28 24 00
	00		 mov	 DWORD PTR [esi+9256], eax
$LN24@GCMonkMagi@2:

; 20238: 		}
; 20239: 
; 20240: 		lpObj->m_iSkillDistanceErrorCount++;

  001f8	ff 86 24 24 00
	00		 inc	 DWORD PTR [esi+9252]
  001fe	8b 86 24 24 00
	00		 mov	 eax, DWORD PTR [esi+9252]

; 20241: 
; 20242: 		if ( lpObj->m_iSkillDistanceErrorCount > g_iSkillDistanceKickCount )

  00204	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iSkillDistanceKickCount@@3HA ; g_iSkillDistanceKickCount
  0020a	0f 8e 56 ff ff
	ff		 jle	 $LN25@GCMonkMagi@2

; 20243: 		{
; 20244: 			if ( g_iSkillDistanceKick )

  00210	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iSkillDistanceKick@@3HA, 0 ; g_iSkillDistanceKick
  00217	74 26		 je	 SHORT $LN1@GCMonkMagi@2

; 20245: 			{
; 20246: 				LogAddTD("[SKILL DISTANCE CHECK] [%s][%s] Kick Invalid Skill Area User. count(%d)",
; 20247: 					lpObj->AccountID, lpObj->Name, lpObj->m_iSkillDistanceErrorCount);

  00219	50		 push	 eax
  0021a	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  0021d	52		 push	 edx
  0021e	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00221	50		 push	 eax
  00222	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  00227	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 20248: 
; 20249: 				CloseClient(lpObj->m_Index);

  0022d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00235	83 c4 14	 add	 esp, 20			; 00000014H
  00238	5b		 pop	 ebx
  00239	5f		 pop	 edi
  0023a	5e		 pop	 esi

; 20259: }

  0023b	8b e5		 mov	 esp, ebp
  0023d	5d		 pop	 ebp
  0023e	c3		 ret	 0
$LN1@GCMonkMagi@2:
  0023f	5b		 pop	 ebx
  00240	5f		 pop	 edi

; 20250: 				return;
; 20251: 			}
; 20252: 
; 20253: 			lpObj->m_iSkillDistanceErrorCount=0;

  00241	c7 86 24 24 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9252], 0
  0024b	5e		 pop	 esi

; 20259: }

  0024c	8b e5		 mov	 esp, ebp
  0024e	5d		 pop	 ebp
  0024f	c3		 ret	 0
$LN4@GCMonkMagi@2:

; 20254: 		}
; 20255: 
; 20256: 		return;
; 20257: 	}
; 20258: 	GCMonkMagicAttackNumberSend(&gObj[aIndex],MagicNumber,usernumber,TRUE);

  00250	8b 45 fc	 mov	 eax, DWORD PTR tv331[ebp]
  00253	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00259	6a 01		 push	 1
  0025b	57		 push	 edi
  0025c	53		 push	 ebx
  0025d	50		 push	 eax
  0025e	e8 00 00 00 00	 call	 ?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z ; GCMonkMagicAttackNumberSend
  00263	83 c4 10	 add	 esp, 16			; 00000010H
  00266	5b		 pop	 ebx
  00267	5f		 pop	 edi
  00268	5e		 pop	 esi

; 20259: }

  00269	8b e5		 mov	 esp, ebp
  0026b	5d		 pop	 ebp
  0026c	c3		 ret	 0
$LN17@GCMonkMagi@2:

; 20173: 	{
; 20174: 		LogAdd("error :%s %d %d",__FILE__,__LINE__,usernumber);

  0026d	51		 push	 ecx
  0026e	68 ce 4e 00 00	 push	 20174			; 00004eceH
  00273	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00278	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@
  0027d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00283	83 c4 10	 add	 esp, 16			; 00000010H
  00286	5f		 pop	 edi
  00287	5e		 pop	 esi

; 20259: }

  00288	8b e5		 mov	 esp, ebp
  0028a	5d		 pop	 ebp
  0028b	c3		 ret	 0
$LN19@GCMonkMagi@2:

; 20167: 	{
; 20168: 		GCMonkMagicAttackNumberSend(&gObj[aIndex],MagicNumber,gObj[aIndex].m_wDarkSideTarget[0],TRUE);

  0028c	0f bf 8e c2 26
	00 00		 movsx	 ecx, WORD PTR [esi+9922]
  00293	6a 01		 push	 1
  00295	51		 push	 ecx
  00296	57		 push	 edi
  00297	56		 push	 esi
  00298	e8 00 00 00 00	 call	 ?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z ; GCMonkMagicAttackNumberSend
  0029d	83 c4 10	 add	 esp, 16			; 00000010H
  002a0	5f		 pop	 edi
  002a1	5e		 pop	 esi

; 20259: }

  002a2	8b e5		 mov	 esp, ebp
  002a4	5d		 pop	 ebp
  002a5	c3		 ret	 0
?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ENDP	; GCMonkMagicAttack
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z ; GCMonkDarkSideTargetSelect
EXTRN	?SkillMonkDarkSideGetTargetIndex@CObjUseSkill@@QAEHHHPAVCMagicInf@@PAG@Z:PROC ; CObjUseSkill::SkillMonkDarkSideGetTargetIndex
; Function compile flags: /Ogtp
;	COMDAT ?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z
_TEXT	SEGMENT
_wTargetIndex$ = -36					; size = 2
_pDarkSideTargetList$ = -32				; size = 16
_wTargetList$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z PROC ; GCMonkDarkSideTargetSelect, COMDAT

; 20262: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]

; 20263: 	WORD wMagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH,lpMsg->MagicNumberL);

  00013	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00017	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  0001b	66 c1 e1 08	 shl	 cx, 8
  0001f	66 0b ca	 or	 cx, dx

; 20264: 	WORD wTargetIndex = MAKE_NUMBERW(lpMsg->NumberH,lpMsg->NumberL);

  00022	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  00026	53		 push	 ebx
  00027	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	0f b7 f9	 movzx	 edi, cx
  0002f	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00033	66 c1 e1 08	 shl	 cx, 8
  00037	66 0b ca	 or	 cx, dx
  0003a	0f b7 c1	 movzx	 eax, cx
  0003d	89 45 dc	 mov	 DWORD PTR _wTargetIndex$[ebp], eax

; 20265: 	WORD wTargetList[5];
; 20266: 
; 20267: 	int i;
; 20268: 	for(i = 0; i < 5; i++)
; 20269: 	{
; 20270: 		wTargetList[i] = 10000;

  00040	b8 10 27 00 00	 mov	 eax, 10000		; 00002710H
  00045	0f b7 d0	 movzx	 edx, ax

; 20271: 	}
; 20272: 
; 20273: 	if( gObj[aIndex].CloseCount >= 0 )

  00048	8b f3		 mov	 esi, ebx
  0004a	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00050	8b c2		 mov	 eax, edx
  00052	c1 e2 10	 shl	 edx, 16			; 00000010H
  00055	0b c2		 or	 eax, edx
  00057	89 45 f0	 mov	 DWORD PTR _wTargetList$[ebp], eax
  0005a	89 45 f4	 mov	 DWORD PTR _wTargetList$[ebp+4], eax
  0005d	66 89 45 f8	 mov	 WORD PTR _wTargetList$[ebp+8], ax
  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	03 c6		 add	 eax, esi
  00068	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0006c	0f 8d 0f 01 00
	00		 jge	 $LN11@GCMonkDark

; 20274: 		return;
; 20275: 
; 20276: 	CMagicInf* lpMagic = NULL;
; 20277: 	lpMagic = gObjGetMagicSearch(&gObj[aIndex],wMagicNumber);

  00072	57		 push	 edi
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00079	83 c4 08	 add	 esp, 8

; 20278: 
; 20279: 	if( lpMagic == NULL )

  0007c	85 c0		 test	 eax, eax
  0007e	0f 84 fd 00 00
	00		 je	 $LN11@GCMonkDark

; 20280: 		return;
; 20281: 
; 20282: 	if( !gObjUseSkill.SkillMonkDarkSideGetTargetIndex(aIndex,wTargetIndex,lpMagic,&wTargetList[0]) )

  00084	8d 55 f0	 lea	 edx, DWORD PTR _wTargetList$[ebp]
  00087	52		 push	 edx
  00088	50		 push	 eax
  00089	0f b7 45 dc	 movzx	 eax, WORD PTR _wTargetIndex$[ebp]
  0008d	50		 push	 eax
  0008e	53		 push	 ebx
  0008f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00094	e8 00 00 00 00	 call	 ?SkillMonkDarkSideGetTargetIndex@CObjUseSkill@@QAEHHHPAVCMagicInf@@PAG@Z ; CObjUseSkill::SkillMonkDarkSideGetTargetIndex
  00099	85 c0		 test	 eax, eax
  0009b	0f 84 e0 00 00
	00		 je	 $LN11@GCMonkDark

; 20283: 		return;
; 20284: 
; 20285: 	PMSG_MONK_DARKSIDE_ANS pDarkSideTargetList;
; 20286: 	memset(&pDarkSideTargetList,0,sizeof(pDarkSideTargetList));

  000a1	33 c0		 xor	 eax, eax

; 20287: 	PHeadSetB((LPBYTE)&pDarkSideTargetList,0x4B,sizeof(pDarkSideTargetList));

  000a3	6a 10		 push	 16			; 00000010H
  000a5	8d 4d e0	 lea	 ecx, DWORD PTR _pDarkSideTargetList$[ebp]
  000a8	6a 4b		 push	 75			; 0000004bH
  000aa	51		 push	 ecx
  000ab	89 45 e0	 mov	 DWORD PTR _pDarkSideTargetList$[ebp], eax
  000ae	89 45 e4	 mov	 DWORD PTR _pDarkSideTargetList$[ebp+4], eax
  000b1	89 45 e8	 mov	 DWORD PTR _pDarkSideTargetList$[ebp+8], eax
  000b4	89 45 ec	 mov	 DWORD PTR _pDarkSideTargetList$[ebp+12], eax
  000b7	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 20288: 	memcpy(pDarkSideTargetList.Target,wTargetList,sizeof(wTargetList));

  000bc	8b 55 f0	 mov	 edx, DWORD PTR _wTargetList$[ebp]
  000bf	8b 45 f4	 mov	 eax, DWORD PTR _wTargetList$[ebp+4]
  000c2	66 8b 4d f8	 mov	 cx, WORD PTR _wTargetList$[ebp+8]
  000c6	89 55 e6	 mov	 DWORD PTR _pDarkSideTargetList$[ebp+6], edx

; 20289: 	pDarkSideTargetList.MagicNumber = wMagicNumber;
; 20290: 	gObj[aIndex].m_btDarkSideTargetCount = 0;

  000c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cf	89 45 ea	 mov	 DWORD PTR _pDarkSideTargetList$[ebp+10], eax
  000d2	66 89 4d ee	 mov	 WORD PTR _pDarkSideTargetList$[ebp+14], cx
  000d6	66 89 7d e4	 mov	 WORD PTR _pDarkSideTargetList$[ebp+4], di

; 20291: 
; 20292: 	for(i = 0; i < 5; i++)
; 20293: 	{
; 20294: 		if( wTargetList[i] != 10000 )

  000da	b8 10 27 00 00	 mov	 eax, 10000		; 00002710H
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e2	c6 84 16 c0 26
	00 00 00	 mov	 BYTE PTR [esi+edx+9920], 0
  000ea	b1 01		 mov	 cl, 1
  000ec	66 39 45 f0	 cmp	 WORD PTR _wTargetList$[ebp], ax
  000f0	74 0c		 je	 SHORT $LN3@GCMonkDark

; 20295: 		{
; 20296: 			gObj[aIndex].m_btDarkSideTargetCount++;

  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f7	00 8c 06 c0 26
	00 00		 add	 BYTE PTR [esi+eax+9920], cl
$LN3@GCMonkDark:

; 20291: 
; 20292: 	for(i = 0; i < 5; i++)
; 20293: 	{
; 20294: 		if( wTargetList[i] != 10000 )

  000fe	ba 10 27 00 00	 mov	 edx, 10000		; 00002710H
  00103	66 39 55 f2	 cmp	 WORD PTR _wTargetList$[ebp+2], dx
  00107	74 0c		 je	 SHORT $LN21@GCMonkDark

; 20295: 		{
; 20296: 			gObj[aIndex].m_btDarkSideTargetCount++;

  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010e	00 8c 06 c0 26
	00 00		 add	 BYTE PTR [esi+eax+9920], cl
$LN21@GCMonkDark:

; 20291: 
; 20292: 	for(i = 0; i < 5; i++)
; 20293: 	{
; 20294: 		if( wTargetList[i] != 10000 )

  00115	8b c2		 mov	 eax, edx
  00117	66 39 45 f4	 cmp	 WORD PTR _wTargetList$[ebp+4], ax
  0011b	74 0c		 je	 SHORT $LN23@GCMonkDark

; 20295: 		{
; 20296: 			gObj[aIndex].m_btDarkSideTargetCount++;

  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00122	00 8c 06 c0 26
	00 00		 add	 BYTE PTR [esi+eax+9920], cl
$LN23@GCMonkDark:

; 20291: 
; 20292: 	for(i = 0; i < 5; i++)
; 20293: 	{
; 20294: 		if( wTargetList[i] != 10000 )

  00129	66 39 55 f6	 cmp	 WORD PTR _wTargetList$[ebp+6], dx
  0012d	74 0c		 je	 SHORT $LN25@GCMonkDark

; 20295: 		{
; 20296: 			gObj[aIndex].m_btDarkSideTargetCount++;

  0012f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00134	00 8c 06 c0 26
	00 00		 add	 BYTE PTR [esi+eax+9920], cl
$LN25@GCMonkDark:

; 20291: 
; 20292: 	for(i = 0; i < 5; i++)
; 20293: 	{
; 20294: 		if( wTargetList[i] != 10000 )

  0013b	8b c2		 mov	 eax, edx
  0013d	66 39 45 f8	 cmp	 WORD PTR _wTargetList$[ebp+8], ax
  00141	74 0c		 je	 SHORT $LN27@GCMonkDark

; 20295: 		{
; 20296: 			gObj[aIndex].m_btDarkSideTargetCount++;

  00143	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00148	00 8c 06 c0 26
	00 00		 add	 BYTE PTR [esi+eax+9920], cl
$LN27@GCMonkDark:

; 20297: 		}
; 20298: 	}
; 20299: 
; 20300: 	memcpy(gObj[aIndex].m_wDarkSideTarget,wTargetList,sizeof(wTargetList));

  0014f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00155	8b 55 f0	 mov	 edx, DWORD PTR _wTargetList$[ebp]
  00158	8d 84 0e c2 26
	00 00		 lea	 eax, DWORD PTR [esi+ecx+9922]
  0015f	89 10		 mov	 DWORD PTR [eax], edx
  00161	8b 4d f4	 mov	 ecx, DWORD PTR _wTargetList$[ebp+4]
  00164	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00167	66 8b 55 f8	 mov	 dx, WORD PTR _wTargetList$[ebp+8]
  0016b	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 20301: 	DataSend(aIndex,(LPBYTE)&pDarkSideTargetList,pDarkSideTargetList.h.size);

  0016f	0f b6 45 e1	 movzx	 eax, BYTE PTR _pDarkSideTargetList$[ebp+1]
  00173	50		 push	 eax
  00174	8d 4d e0	 lea	 ecx, DWORD PTR _pDarkSideTargetList$[ebp]
  00177	51		 push	 ecx
  00178	53		 push	 ebx
  00179	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0017e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@GCMonkDark:

; 20302: }

  00181	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	33 cd		 xor	 ecx, ebp
  00188	5b		 pop	 ebx
  00189	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z ENDP ; GCMonkDarkSideTargetSelect
_TEXT	ENDS
PUBLIC	??_C@_0BN@JLEKNDOL@?$FLMuBot?$FN?5Option?5Save?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	?CGSaveMuBotSettings@@YAXPAUPMSG_MUBOT_SETTINGS_RECV@@H@Z ; CGSaveMuBotSettings
EXTRN	?DGMuBotSettingsSend@@YAXHPADPAE@Z:PROC		; DGMuBotSettingsSend
;	COMDAT ??_C@_0BN@JLEKNDOL@?$FLMuBot?$FN?5Option?5Save?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BN@JLEKNDOL@?$FLMuBot?$FN?5Option?5Save?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ DB '['
	DB	'MuBot] Option Save [%s][%s]', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGSaveMuBotSettings@@YAXPAUPMSG_MUBOT_SETTINGS_RECV@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGSaveMuBotSettings@@YAXPAUPMSG_MUBOT_SETTINGS_RECV@@H@Z PROC ; CGSaveMuBotSettings, COMDAT

; 20305: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 20306: 	if( !gObjIsConnectedGP(aIndex) )

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 3f		 je	 SHORT $LN2@CGSaveMuBo

; 20307: 		return;
; 20308: 
; 20309: 	DGMuBotSettingsSend(aIndex,gObj[aIndex].Name,&lpMsg->btDATA[0]);

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00017	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001d	56		 push	 esi
  0001e	8b f7		 mov	 esi, edi
  00020	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00026	83 c0 05	 add	 eax, 5
  00029	50		 push	 eax
  0002a	8d 54 0e 5d	 lea	 edx, DWORD PTR [esi+ecx+93]
  0002e	52		 push	 edx
  0002f	57		 push	 edi
  00030	e8 00 00 00 00	 call	 ?DGMuBotSettingsSend@@YAXHPADPAE@Z ; DGMuBotSettingsSend

; 20310: 
; 20311: 	LogAddL("[MuBot] Option Save [%s][%s]",
; 20312: 		gObj[aIndex].AccountID,gObj[aIndex].Name);

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003a	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0003e	51		 push	 ecx
  0003f	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00043	52		 push	 edx
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JLEKNDOL@?$FLMuBot?$FN?5Option?5Save?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  0004f	83 c4 18	 add	 esp, 24			; 00000018H
  00052	5e		 pop	 esi
$LN2@CGSaveMuBo:
  00053	5f		 pop	 edi

; 20313: }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?CGSaveMuBotSettings@@YAXPAUPMSG_MUBOT_SETTINGS_RECV@@H@Z ENDP ; CGSaveMuBotSettings
_TEXT	ENDS
PUBLIC	??_C@_0BN@JAGJPNLP@?$FLMuBot?$FN?5Option?5Send?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendMuBotSettings@@YAXHPAE@Z			; GCSendMuBotSettings
;	COMDAT ??_C@_0BN@JAGJPNLP@?$FLMuBot?$FN?5Option?5Send?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BN@JAGJPNLP@?$FLMuBot?$FN?5Option?5Send?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ DB '['
	DB	'MuBot] Option Send [%s][%s]', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCSendMuBotSettings@@YAXHPAE@Z
_TEXT	SEGMENT
_pMsg$ = -268						; size = 262
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpData$ = 12						; size = 4
?GCSendMuBotSettings@@YAXHPAE@Z PROC			; GCSendMuBotSettings, COMDAT

; 20316: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _lpData$[ebp]

; 20317: 	if( !gObjIsConnected(aIndex) )

  0001b	53		 push	 ebx
  0001c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	74 64		 je	 SHORT $LN2@GCSendMuBo

; 20318: 		return;
; 20319: 
; 20320: 	PMSG_MUBOT_SETTINGS_RECV pMsg;
; 20321: 	PHeadSetW((LPBYTE)&pMsg,0xAE,sizeof(pMsg));

  00028	57		 push	 edi
  00029	68 06 01 00 00	 push	 262			; 00000106H
  0002e	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00034	68 ae 00 00 00	 push	 174			; 000000aeH
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 20322: 
; 20323: 	pMsg.btType = 0;

  0003f	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+4], 0

; 20324: 	memcpy(pMsg.btDATA,lpData,sizeof(pMsg.btDATA));

  00046	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0004b	8d bd f9 fe ff
	ff		 lea	 edi, DWORD PTR _pMsg$[ebp+5]
  00051	f3 a5		 rep movsd

; 20325: 
; 20326: 	DataSend(aIndex,(LPBYTE)&pMsg,sizeof(pMsg));

  00053	68 06 01 00 00	 push	 262			; 00000106H
  00058	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0005e	51		 push	 ecx
  0005f	53		 push	 ebx
  00060	a4		 movsb
  00061	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20327: 
; 20328: 	LogAddL("[MuBot] Option Send [%s][%s]",
; 20329: 		gObj[aIndex].AccountID,gObj[aIndex].Name);

  00066	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  0006c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00072	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00075	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  00078	51		 push	 ecx
  00079	83 c0 52	 add	 eax, 82			; 00000052H
  0007c	50		 push	 eax
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JAGJPNLP@?$FLMuBot?$FN?5Option?5Send?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  00088	83 c4 24	 add	 esp, 36			; 00000024H
  0008b	5f		 pop	 edi
$LN2@GCSendMuBo:

; 20330: }

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008f	5e		 pop	 esi
  00090	33 cd		 xor	 ecx, ebp
  00092	5b		 pop	 ebx
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?GCSendMuBotSettings@@YAXHPAE@Z ENDP			; GCSendMuBotSettings
_TEXT	ENDS
PUBLIC	??_C@_0CE@IHDJCCIO@MU?5Helper?5cant?5run?5on?5this?5locat@ ; `string'
PUBLIC	??_C@_0DB@OKKAKFII@Only?5characters?5above?5?$CFd?5level?5c@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGRequestStartMuBot@@YAXPAUPMSG_MUBOT_REQ_START@@H@Z ; CGRequestStartMuBot
EXTRN	?g_iMuBotStage1Zen@@3HA:DWORD			; g_iMuBotStage1Zen
EXTRN	?g_iMuBotSystemUserLevel@@3HA:DWORD		; g_iMuBotSystemUserLevel
EXTRN	?g_bMuBotSystemOn@@3HA:DWORD			; g_bMuBotSystemOn
;	COMDAT ??_C@_0CE@IHDJCCIO@MU?5Helper?5cant?5run?5on?5this?5locat@
CONST	SEGMENT
??_C@_0CE@IHDJCCIO@MU?5Helper?5cant?5run?5on?5this?5locat@ DB 'MU Helper '
	DB	'cant run on this location', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OKKAKFII@Only?5characters?5above?5?$CFd?5level?5c@
CONST	SEGMENT
??_C@_0DB@OKKAKFII@Only?5characters?5above?5?$CFd?5level?5c@ DB 'Only cha'
	DB	'racters above %d level can run MU Helper', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGRequestStartMuBot@@YAXPAUPMSG_MUBOT_REQ_START@@H@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestStartMuBot@@YAXPAUPMSG_MUBOT_REQ_START@@H@Z PROC ; CGRequestStartMuBot, COMDAT

; 20333: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx

; 20334: 	if (g_bMuBotSystemOn == FALSE) {

  00011	33 db		 xor	 ebx, ebx
  00013	57		 push	 edi
  00014	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00017	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?g_bMuBotSystemOn@@3HA, ebx ; g_bMuBotSystemOn
  0001d	0f 84 55 01 00
	00		 je	 $LN11@CGRequestS

; 20335: 		return;
; 20336: 	}
; 20337: 
; 20338: 	if (!gObjIsConnectedGP(aIndex)) {

  00023	57		 push	 edi
  00024	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00029	83 c4 04	 add	 esp, 4
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 44 01 00
	00		 je	 $LN11@CGRequestS

; 20339: 		return;
; 20340: 	}
; 20341: 
; 20342: 	PMSG_MUBOT_USE pMsg;
; 20343: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x51, sizeof(pMsg));

  00034	56		 push	 esi
  00035	6a 10		 push	 16			; 00000010H
  00037	6a 51		 push	 81			; 00000051H
  00039	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003c	68 bf 00 00 00	 push	 191			; 000000bfH
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 20344: 	pMsg.Money = 0;
; 20345: 	pMsg.Time = 0;
; 20346: 	pMsg.Status = 1;
; 20347: 
; 20348: 	LPOBJ lpObj = &gObj[aIndex];

  00047	8b f7		 mov	 esi, edi
  00049	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0004f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	33 c9		 xor	 ecx, ecx
  00057	89 5d f4	 mov	 DWORD PTR _pMsg$[ebp+8], ebx
  0005a	66 89 4d f0	 mov	 WORD PTR _pMsg$[ebp+4], cx
  0005e	c6 45 f8 01	 mov	 BYTE PTR _pMsg$[ebp+12], 1

; 20349: 
; 20350: 	if (lpObj->m_IfState.use == TRUE) {

  00062	8b 96 b8 11 00
	00		 mov	 edx, DWORD PTR [esi+4536]
  00068	80 e2 03	 and	 dl, 3
  0006b	83 c4 10	 add	 esp, 16			; 00000010H
  0006e	80 fa 01	 cmp	 dl, 1
  00071	0f 84 00 01 00
	00		 je	 $LN13@CGRequestS

; 20351: 		return;
; 20352: 	}
; 20353: 
; 20354: 	if (lpObj->Level < g_iMuBotSystemUserLevel) {

  00077	0f bf 8e 96 00
	00 00		 movsx	 ecx, WORD PTR [esi+150]
  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_iMuBotSystemUserLevel@@3HA ; g_iMuBotSystemUserLevel
  00083	3b c8		 cmp	 ecx, eax
  00085	7d 2f		 jge	 SHORT $LN7@CGRequestS

; 20355: 		MsgOutput(aIndex, "Only characters above %d level can run MU Helper", g_iMuBotSystemUserLevel);

  00087	50		 push	 eax
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@OKKAKFII@Only?5characters?5above?5?$CFd?5level?5c@
  0008d	57		 push	 edi
  0008e	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 20356: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00093	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00097	52		 push	 edx
  00098	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009b	50		 push	 eax
  0009c	57		 push	 edi
  0009d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20363: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000a2	83 c4 18	 add	 esp, 24			; 00000018H
  000a5	5e		 pop	 esi
  000a6	5f		 pop	 edi
  000a7	5b		 pop	 ebx

; 20387: }

  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ab	33 cd		 xor	 ecx, ebp
  000ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
$LN7@CGRequestS:

; 20357: 		return;
; 20358: 	}
; 20359: 	
; 20360: 	if (lpObj->MapNumber == MAP_INDEX_CASTLESIEGE
; 20361: 		|| lpObj->MapNumber == MAP_INDEX_PKFIELD) {

  000b6	8a 8e 23 01 00
	00		 mov	 cl, BYTE PTR [esi+291]
  000bc	80 f9 1e	 cmp	 cl, 30			; 0000001eH
  000bf	0f 84 8e 00 00
	00		 je	 $LN5@CGRequestS
  000c5	80 f9 40	 cmp	 cl, 64			; 00000040H
  000c8	0f 84 85 00 00
	00		 je	 $LN5@CGRequestS

; 20365: 		return;
; 20366: 	}
; 20367: 
; 20368: 	if (lpMsg->btType == 0) {

  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000d1	38 59 04	 cmp	 BYTE PTR [ecx+4], bl
  000d4	75 48		 jne	 SHORT $LN4@CGRequestS

; 20369: 		if (lpObj->Money < g_iMuBotStage1Zen) {

  000d6	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_iMuBotStage1Zen@@3HA ; g_iMuBotStage1Zen
  000e2	3b c1		 cmp	 eax, ecx
  000e4	7d 06		 jge	 SHORT $LN3@CGRequestS

; 20370: 			pMsg.Status = 2;

  000e6	c6 45 f8 02	 mov	 BYTE PTR _pMsg$[ebp+12], 2

; 20371: 		}
; 20372: 		else {

  000ea	eb 38		 jmp	 SHORT $LN1@CGRequestS
$LN3@CGRequestS:

; 20373: 			lpObj->Money -= g_iMuBotStage1Zen;
; 20374: 			GCMoneySend(lpObj->m_Index,lpObj->Money);

  000ec	8b 16		 mov	 edx, DWORD PTR [esi]
  000ee	2b c1		 sub	 eax, ecx
  000f0	50		 push	 eax
  000f1	52		 push	 edx
  000f2	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  000f8	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 20375: 			pMsg.Status = 0;
; 20376: 			pMsg.Time = 0;
; 20377: 			pMsg.Money = g_iMuBotStage1Zen;

  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_iMuBotStage1Zen@@3HA ; g_iMuBotStage1Zen
  00103	83 c4 08	 add	 esp, 8
  00106	33 c0		 xor	 eax, eax
  00108	88 5d f8	 mov	 BYTE PTR _pMsg$[ebp+12], bl
  0010b	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax
  0010f	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx

; 20378: 			lpObj->m_bMUBOT = TRUE;

  00112	c7 86 d0 26 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+9936], 1

; 20379: 		}
; 20380: 	} else {

  0011c	eb 06		 jmp	 SHORT $LN1@CGRequestS
$LN4@CGRequestS:

; 20381: 		lpObj->m_bMUBOT = FALSE;

  0011e	89 9e d0 26 00
	00		 mov	 DWORD PTR [esi+9936], ebx
$LN1@CGRequestS:

; 20382: 	}
; 20383: 
; 20384: 	lpObj->m_iMUBOT_TIME = 0;

  00124	89 9e d8 26 00
	00		 mov	 DWORD PTR [esi+9944], ebx

; 20385: 	lpObj->m_iMUBOT_STAGE = 0;

  0012a	89 9e d4 26 00
	00		 mov	 DWORD PTR [esi+9940], ebx

; 20386: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00130	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00134	52		 push	 edx
  00135	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00138	50		 push	 eax
  00139	57		 push	 edi
  0013a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00142	5e		 pop	 esi
  00143	5f		 pop	 edi
  00144	5b		 pop	 ebx

; 20387: }

  00145	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00148	33 cd		 xor	 ecx, ebp
  0014a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c3		 ret	 0
$LN5@CGRequestS:

; 20362: 		MsgOutput(aIndex, "MU Helper cant run on this location", g_iMuBotSystemUserLevel);

  00153	50		 push	 eax
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IHDJCCIO@MU?5Helper?5cant?5run?5on?5this?5locat@
  00159	57		 push	 edi
  0015a	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 20363: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0015f	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00163	51		 push	 ecx
  00164	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00167	52		 push	 edx
  00168	57		 push	 edi
  00169	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20364: 		lpObj->m_bMUBOT = FALSE;

  0016e	89 9e d0 26 00
	00		 mov	 DWORD PTR [esi+9936], ebx
  00174	83 c4 18	 add	 esp, 24			; 00000018H
$LN13@CGRequestS:
  00177	5e		 pop	 esi
$LN11@CGRequestS:

; 20387: }

  00178	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017b	5f		 pop	 edi
  0017c	33 cd		 xor	 ecx, ebp
  0017e	5b		 pop	 ebx
  0017f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c3		 ret	 0
?CGRequestStartMuBot@@YAXPAUPMSG_MUBOT_REQ_START@@H@Z ENDP ; CGRequestStartMuBot
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAttackSpeedSend@@YAXH@Z			; GCAttackSpeedSend
; Function compile flags: /Ogtp
;	COMDAT ?GCAttackSpeedSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCAttackSpeedSend@@YAXH@Z PROC				; GCAttackSpeedSend, COMDAT

; 20397: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 20398: 	if( !gObjIsConnected(aIndex) )

  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	74 46		 je	 SHORT $LN2@GCAttackSp

; 20399: 		return;
; 20400: 
; 20401: 	PMSG_ATTACKSPEED pMsg;
; 20402: 	PHeadSubSetB((LPBYTE)&pMsg,0xEC,0x30,sizeof(pMsg));

  00021	6a 0c		 push	 12			; 0000000cH
  00023	6a 30		 push	 48			; 00000030H
  00025	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00028	68 ec 00 00 00	 push	 236			; 000000ecH
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 20403: 
; 20404: 	pMsg.iAttackSpeed = gObj[aIndex].m_AttackSpeed;

  00033	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00039	8b c6		 mov	 eax, esi
  0003b	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00041	8b 8c 10 6c 06
	00 00		 mov	 ecx, DWORD PTR [eax+edx+1644]
  00048	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+4], ecx

; 20405: 	pMsg.iMagicSpeed = gObj[aIndex].m_MagicSpeed;

  0004b	8b 94 10 70 06
	00 00		 mov	 edx, DWORD PTR [eax+edx+1648]

; 20406: 
; 20407: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00052	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00056	50		 push	 eax
  00057	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0005a	51		 push	 ecx
  0005b	56		 push	 esi
  0005c	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  0005f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00064	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@GCAttackSp:

; 20408: }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	33 cd		 xor	 ecx, ebp
  0006c	5e		 pop	 esi
  0006d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?GCAttackSpeedSend@@YAXH@Z ENDP				; GCAttackSpeedSend
_TEXT	ENDS
PUBLIC	??_C@_0GN@LMFACHAA@?$FLUseCahngeSkinState?$FN?$FLCGEnableUse@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGEnableUsePolymorphSkinrRecv@@YAXPAUPMSG_REQ_USE_POLYMORPH_SKIN@@H@Z ; CGEnableUsePolymorphSkinrRecv
EXTRN	?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolCreate
EXTRN	?IsTransformCharcterSkin@@YA_NH@Z:PROC		; IsTransformCharcterSkin
;	COMDAT ??_C@_0GN@LMFACHAA@?$FLUseCahngeSkinState?$FN?$FLCGEnableUse@
CONST	SEGMENT
??_C@_0GN@LMFACHAA@?$FLUseCahngeSkinState?$FN?$FLCGEnableUse@ DB '[UseCah'
	DB	'ngeSkinState][CGEnableUsePolymorphSkinrRecv] [ChaageEanbleSta'
	DB	'te : %d] On(Use): 0 / Off: 1(Don''t Use) ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGEnableUsePolymorphSkinrRecv@@YAXPAUPMSG_REQ_USE_POLYMORPH_SKIN@@H@Z
_TEXT	SEGMENT
_pMove$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGEnableUsePolymorphSkinrRecv@@YAXPAUPMSG_REQ_USE_POLYMORPH_SKIN@@H@Z PROC ; CGEnableUsePolymorphSkinrRecv, COMDAT

; 20411: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 20412: 	PMSG_MOVE pMove = { 0 };
; 20413: 	// ---
; 20414: 	if( lpMsg->EnableUsePolymorphSkin == 1 )

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]

; 20415: 	{
; 20416: 		if( IsTransformCharcterSkin(gObj[aIndex].m_Change) )

  00013	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	56		 push	 esi
  0001a	33 c0		 xor	 eax, eax
  0001c	57		 push	 edi
  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00020	89 45 ed	 mov	 DWORD PTR _pMove$[ebp+1], eax
  00023	89 45 f1	 mov	 DWORD PTR _pMove$[ebp+5], eax
  00026	89 45 f5	 mov	 DWORD PTR _pMove$[ebp+9], eax
  00029	8b f7		 mov	 esi, edi
  0002b	b0 01		 mov	 al, 1
  0002d	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00033	38 41 04	 cmp	 BYTE PTR [ecx+4], al
  00036	75 24		 jne	 SHORT $LN3@CGEnableUs
  00038	8b 84 16 34 06
	00 00		 mov	 eax, DWORD PTR [esi+edx+1588]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?IsTransformCharcterSkin@@YA_NH@Z ; IsTransformCharcterSkin
  00045	83 c4 04	 add	 esp, 4
  00048	84 c0		 test	 al, al
  0004a	74 17		 je	 SHORT $LN1@CGEnableUs

; 20417: 		{
; 20418: 		  gObj[aIndex].m_EnableUseChangeSkin = 0;

  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	c6 84 0e 12 27
	00 00 00	 mov	 BYTE PTR [esi+ecx+10002], 0

; 20419: 		}
; 20420: 	 }
; 20421: 	 else

  0005a	eb 07		 jmp	 SHORT $LN1@CGEnableUs
$LN3@CGEnableUs:

; 20422: 	 {
; 20423: 		gObj[aIndex].m_EnableUseChangeSkin = 1;

  0005c	88 84 16 12 27
	00 00		 mov	 BYTE PTR [esi+edx+10002], al
$LN1@CGEnableUs:

; 20424: 	 }
; 20425: 	 // ----
; 20426: 	 pMove.h.c			= 0xC1;
; 20427: 	 pMove.h.headcode	= 0xD7;
; 20428: 	 pMove.h.size		= 0xD;
; 20429: 	 pMove.X			= gObj[aIndex].X;

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00068	8a 8c 06 20 01
	00 00		 mov	 cl, BYTE PTR [esi+eax+288]

; 20430: 	 pMove.Y			= gObj[aIndex].Y;

  0006f	8a 94 06 21 01
	00 00		 mov	 dl, BYTE PTR [esi+eax+289]

; 20431: 	 PMoveProc(&pMove, aIndex);

  00076	8d 45 ec	 lea	 eax, DWORD PTR _pMove$[ebp]
  00079	57		 push	 edi
  0007a	50		 push	 eax
  0007b	c6 45 ec c1	 mov	 BYTE PTR _pMove$[ebp], 193 ; 000000c1H
  0007f	66 c7 45 ed 0d
	d7		 mov	 WORD PTR _pMove$[ebp+1], 55053 ; 0000d70dH
  00085	88 4d ef	 mov	 BYTE PTR _pMove$[ebp+3], cl
  00088	88 55 f0	 mov	 BYTE PTR _pMove$[ebp+4], dl
  0008b	e8 00 00 00 00	 call	 ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ; PMoveProc

; 20432: 	 LogAddTD("[UseCahngeSkinState][CGEnableUsePolymorphSkinrRecv] [ChaageEanbleState : %d] On(Use): 0 / Off: 1(Don't Use) ",
; 20433: 		gObj[aIndex].m_EnableUseChangeSkin, gObj[aIndex].AccountID, gObj[aIndex].Name);

  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00095	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00099	51		 push	 ecx
  0009a	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  0009e	0f be 84 06 12
	27 00 00	 movsx	 eax, BYTE PTR [esi+eax+10002]
  000a6	52		 push	 edx
  000a7	50		 push	 eax
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0GN@LMFACHAA@?$FLUseCahngeSkinState?$FN?$FLCGEnableUse@
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 20434: 	 gObjViewportListProtocolCreate(&gObj[aIndex]);

  000b3	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b9	56		 push	 esi
  000ba	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate

; 20435: }

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c2	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c5	5f		 pop	 edi
  000c6	33 cd		 xor	 ecx, ebp
  000c8	5e		 pop	 esi
  000c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
?CGEnableUsePolymorphSkinrRecv@@YAXPAUPMSG_REQ_USE_POLYMORPH_SKIN@@H@Z ENDP ; CGEnableUsePolymorphSkinrRecv
_TEXT	ENDS
PUBLIC	__real@437f0000
PUBLIC	__real@406fc00000000000
PUBLIC	__real@437e0000
PUBLIC	__real@406fe00000000000
PUBLIC	?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z ; CGInventoryEquipment
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@406fc00000000000
CONST	SEGMENT
__real@406fc00000000000 DQ 0406fc00000000000r	; 254
CONST	ENDS
;	COMDAT __real@437e0000
CONST	SEGMENT
__real@437e0000 DD 0437e0000r			; 254
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z PROC ; CGInventoryEquipment, COMDAT

; 20439: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 20440: 	if( !OBJMAX_RANGE(iIndex) )

  00007	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  0000a	85 ff		 test	 edi, edi
  0000c	0f 88 ff 01 00
	00		 js	 $LN30@CGInventor@2
  00012	33 c0		 xor	 eax, eax
  00014	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 ec 01 00
	00		 je	 $LN30@CGInventor@2

; 20441: 	{
; 20442: 		return;
; 20443: 	}
; 20444: 	// ----
; 20445: 	LPOBJ lpObj = &gObj[iIndex];

  00025	56		 push	 esi
  00026	8b f7		 mov	 esi, edi
  00028	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0002e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 20446: 	// ----
; 20447: 	if( !gObjIsConnected(iIndex) )

  00034	57		 push	 edi
  00035	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003a	83 c4 04	 add	 esp, 4
  0003d	85 c0		 test	 eax, eax
  0003f	0f 84 cb 01 00
	00		 je	 $LN35@CGInventor@2

; 20448: 	{
; 20449: 		return;
; 20450: 	}
; 20451: 	// ----
; 20452: 	_tagPMSG_ANS_INVENTORY_EQUIPMENT_ITEM pMsg = { 0 };

  00045	33 c0		 xor	 eax, eax

; 20453: 	pMsg.btResult = 0;
; 20454: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x20, sizeof(_tagPMSG_ANS_INVENTORY_EQUIPMENT_ITEM));

  00047	6a 06		 push	 6
  00049	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0004c	6a 20		 push	 32			; 00000020H
  0004e	89 45 f9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00051	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00054	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00057	68 bf 00 00 00	 push	 191			; 000000bfH
  0005c	50		 push	 eax
  0005d	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00061	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 20455: 	pMsg.btItemPos = lpMsg->btItemPos;

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00069	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  0006c	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 20456: 	// ----
; 20457: 	if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 0.0 )

  0006f	8b 96 c0 11 00
	00		 mov	 edx, DWORD PTR [esi+4544]
  00075	0f b6 c0	 movzx	 eax, al
  00078	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0007e	83 c4 10	 add	 esp, 16			; 00000010H
  00081	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  00085	d9 ee		 fldz
  00087	da e9		 fucompp
  00089	df e0		 fnstsw	 ax
  0008b	f6 c4 44	 test	 ah, 68			; 00000044H
  0008e	7a 1c		 jp	 SHORT $LN27@CGInventor@2

; 20458: 	{
; 20459: 		pMsg.btResult = -1;
; 20460: 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00090	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00094	51		 push	 ecx
  00095	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00098	52		 push	 edx
  00099	57		 push	 edi
  0009a	c6 45 fd ff	 mov	 BYTE PTR _pMsg$[ebp+5], 255 ; 000000ffH
  0009e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	5e		 pop	 esi
  000a7	5f		 pop	 edi

; 20587: }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
$LN27@CGInventor@2:
  000ac	53		 push	 ebx

; 20461: 		return;
; 20462: 	}
; 20463: 	// ----
; 20464: 	switch( lpObj->pInventory[lpMsg->btItemPos].m_Type )

  000ad	8a 59 04	 mov	 bl, BYTE PTR [ecx+4]
  000b0	0f b6 fb	 movzx	 edi, bl
  000b3	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  000b9	0f bf 44 17 06	 movsx	 eax, WORD PTR [edi+edx+6]
  000be	03 fa		 add	 edi, edx
  000c0	05 80 e5 ff ff	 add	 eax, -6784		; ffffe580H
  000c5	83 f8 06	 cmp	 eax, 6
  000c8	0f 87 26 01 00
	00		 ja	 $LN34@CGInventor@2
  000ce	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN42@CGInventor@2[eax*4]
$LN24@CGInventor@2:

; 20465: 	{
; 20466: 	case ITEMGET(13, 128):
; 20467: 	case ITEMGET(13, 129):
; 20468: 		{
; 20469: 			if( !lpObj->m_btSculptPos )

  000d5	8a 86 9c 25 00
	00		 mov	 al, BYTE PTR [esi+9628]
  000db	84 c0		 test	 al, al
  000dd	0f 85 af 00 00
	00		 jne	 $LN7@CGInventor@2

; 20470: 			{
; 20471: 				if( lpMsg->btValue == 254 )

  000e3	b3 fe		 mov	 bl, 254			; 000000feH
  000e5	38 59 05	 cmp	 BYTE PTR [ecx+5], bl
  000e8	0f 85 06 01 00
	00		 jne	 $LN34@CGInventor@2

; 20472: 				{
; 20473: 					if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 255.0 )

  000ee	d9 47 24	 fld	 DWORD PTR [edi+36]
  000f1	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fe00000000000
  000f7	da e9		 fucompp
  000f9	df e0		 fnstsw	 ax
  000fb	f6 c4 44	 test	 ah, 68			; 00000044H
  000fe	0f 8a f0 00 00
	00		 jp	 $LN34@CGInventor@2

; 20474: 					{
; 20475: 						lpObj->m_btSculptPos = lpMsg->btItemPos;

  00104	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00107	88 86 9c 25 00
	00		 mov	 BYTE PTR [esi+9628], al

; 20476: 						lpObj->pInventory[lpMsg->btItemPos].m_Durability = 254.0;
; 20477: 						pMsg.btResult = -2;
; 20478: 					}
; 20479: 				}
; 20480: 				break;
; 20481: 			}
; 20482: 			// ----
; 20483: 			if(		lpObj->m_btSculptPos < INVETORY_WEAR_SIZE 
; 20484: 				||	lpObj->m_btSculptPos >= MAIN_INVENTORY_SIZE )
; 20485: 			{
; 20486: 				break;
; 20487: 			}
; 20488: 			// ----
; 20489: 			if(		lpMsg->btValue			== 255
; 20490: 				&&	lpObj->m_btSculptPos	== lpMsg->btItemPos )
; 20491: 			{
; 20492: 				if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 254.0 )
; 20493: 				{
; 20494: 					lpObj->pInventory[lpMsg->btItemPos].m_Durability = 255.0;
; 20495: 					pMsg.btResult = -1;
; 20496: 				}
; 20497: 				break;
; 20498: 			}
; 20499: 			// ----
; 20500: 			GCServerMsgStringSend(lMsg.Get(3480), lpObj->m_Index, 1);
; 20501:             DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 20502: 		}
; 20503: 		break;

  0010d	eb 6a		 jmp	 SHORT $LN41@CGInventor@2
$LN16@CGInventor@2:

; 20504: 		// --
; 20505: 	case ITEMGET(13, 130):
; 20506: 	case ITEMGET(13, 131):
; 20507: 	case ITEMGET(13, 132):
; 20508: 	case ITEMGET(13, 133):
; 20509: 		{
; 20510: 			if( !lpObj->m_btCharmPos )

  0010f	8a 86 9d 25 00
	00		 mov	 al, BYTE PTR [esi+9629]
  00115	84 c0		 test	 al, al
  00117	75 79		 jne	 SHORT $LN7@CGInventor@2

; 20511: 			{
; 20512: 				if( lpMsg->btValue == 254 )

  00119	b3 fe		 mov	 bl, 254			; 000000feH
  0011b	38 59 05	 cmp	 BYTE PTR [ecx+5], bl
  0011e	0f 85 d0 00 00
	00		 jne	 $LN34@CGInventor@2

; 20513: 				{
; 20514: 					if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 255.0 )

  00124	d9 47 24	 fld	 DWORD PTR [edi+36]
  00127	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fe00000000000
  0012d	da e9		 fucompp
  0012f	df e0		 fnstsw	 ax
  00131	f6 c4 44	 test	 ah, 68			; 00000044H
  00134	0f 8a ba 00 00
	00		 jp	 $LN34@CGInventor@2

; 20515: 					{
; 20516: 						lpObj->m_btCharmPos = lpMsg->btItemPos;

  0013a	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  0013d	88 86 9d 25 00
	00		 mov	 BYTE PTR [esi+9629], al

; 20517: 						lpObj->pInventory[lpMsg->btItemPos].m_Durability = 254.0;
; 20518: 						pMsg.btResult = -2;
; 20519: 					}
; 20520: 				}
; 20521: 				break;
; 20522: 			}
; 20523: 			// ----
; 20524: 			if(		lpObj->m_btCharmPos < INVETORY_WEAR_SIZE 
; 20525: 				||	lpObj->m_btCharmPos >= MAIN_INVENTORY_SIZE )
; 20526: 			{
; 20527: 				break;
; 20528: 			}
; 20529: 			// ----
; 20530: 			if(		lpMsg->btValue		== 255
; 20531: 				&&	lpObj->m_btCharmPos == lpMsg->btItemPos )
; 20532: 			{
; 20533: 				if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 254.0 )
; 20534: 				{
; 20535: 					lpObj->pInventory[lpMsg->btItemPos].m_Durability = 255.0;
; 20536: 					pMsg.btResult = -1;
; 20537: 				}
; 20538: 				break;
; 20539: 			}
; 20540: 			// ----
; 20541: 			GCServerMsgStringSend(lMsg.Get(3480), lpObj->m_Index, 1);
; 20542:             DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 20543: 		}
; 20544: 		break;

  00143	eb 34		 jmp	 SHORT $LN41@CGInventor@2
$LN8@CGInventor@2:

; 20545: 		// --
; 20546: 	case ITEMGET(13, 134):
; 20547: 		{
; 20548: 			if( !lpObj->m_btArtifactPos )

  00145	8a 86 9e 25 00
	00		 mov	 al, BYTE PTR [esi+9630]
  0014b	84 c0		 test	 al, al
  0014d	75 43		 jne	 SHORT $LN7@CGInventor@2

; 20549: 			{
; 20550: 				if( lpMsg->btValue == 254 )

  0014f	b3 fe		 mov	 bl, 254			; 000000feH
  00151	38 59 05	 cmp	 BYTE PTR [ecx+5], bl
  00154	0f 85 9a 00 00
	00		 jne	 $LN34@CGInventor@2

; 20551: 				{
; 20552: 					if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 255.0 )

  0015a	d9 47 24	 fld	 DWORD PTR [edi+36]
  0015d	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fe00000000000
  00163	da e9		 fucompp
  00165	df e0		 fnstsw	 ax
  00167	f6 c4 44	 test	 ah, 68			; 00000044H
  0016a	0f 8a 84 00 00
	00		 jp	 $LN34@CGInventor@2

; 20553: 					{
; 20554: 						lpObj->m_btArtifactPos = lpMsg->btItemPos;

  00170	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00173	88 86 9e 25 00
	00		 mov	 BYTE PTR [esi+9630], al
$LN41@CGInventor@2:

; 20555: 						lpObj->pInventory[lpMsg->btItemPos].m_Durability = 254.0;

  00179	0f b6 49 04	 movzx	 ecx, BYTE PTR [ecx+4]
  0017d	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@437e0000
  00183	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00189	d9 5c 11 24	 fstp	 DWORD PTR [ecx+edx+36]

; 20556: 						pMsg.btResult = -2;

  0018d	88 5d fd	 mov	 BYTE PTR _pMsg$[ebp+5], bl

; 20557: 					}
; 20558: 				}
; 20559: 				break;

  00190	eb 62		 jmp	 SHORT $LN34@CGInventor@2
$LN7@CGInventor@2:

; 20560: 			}
; 20561: 			// ----
; 20562: 			if(		lpObj->m_btArtifactPos < INVETORY_WEAR_SIZE 
; 20563: 				||	lpObj->m_btArtifactPos >= MAIN_INVENTORY_SIZE )

  00192	3c 0c		 cmp	 al, 12			; 0000000cH
  00194	72 5e		 jb	 SHORT $LN34@CGInventor@2
  00196	3c cc		 cmp	 al, 204			; 000000ccH
  00198	73 5a		 jae	 SHORT $LN34@CGInventor@2

; 20564: 			{
; 20565: 				break;
; 20566: 			}
; 20567: 			// ----
; 20568: 			if(		lpMsg->btValue			== 255
; 20569: 				&&	lpObj->m_btArtifactPos	== lpMsg->btItemPos )

  0019a	b2 ff		 mov	 dl, 255			; 000000ffH
  0019c	38 51 05	 cmp	 BYTE PTR [ecx+5], dl
  0019f	75 24		 jne	 SHORT $LN2@CGInventor@2
  001a1	3a c3		 cmp	 al, bl
  001a3	75 20		 jne	 SHORT $LN2@CGInventor@2

; 20570: 			{
; 20571: 				if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 254.0 )

  001a5	d9 47 24	 fld	 DWORD PTR [edi+36]
  001a8	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fc00000000000
  001ae	da e9		 fucompp
  001b0	df e0		 fnstsw	 ax
  001b2	f6 c4 44	 test	 ah, 68			; 00000044H
  001b5	7a 3d		 jp	 SHORT $LN34@CGInventor@2

; 20572: 				{
; 20573: 					lpObj->pInventory[lpMsg->btItemPos].m_Durability = 255.0;

  001b7	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@437f0000
  001bd	d9 5f 24	 fstp	 DWORD PTR [edi+36]

; 20574: 					pMsg.btResult = -1;

  001c0	88 55 fd	 mov	 BYTE PTR _pMsg$[ebp+5], dl

; 20575: 				}
; 20576: 				break;

  001c3	eb 2f		 jmp	 SHORT $LN34@CGInventor@2
$LN2@CGInventor@2:

; 20577: 			}
; 20578: 			// ----
; 20579: 			GCServerMsgStringSend(lMsg.Get(3480), lpObj->m_Index, 1);

  001c5	8b 16		 mov	 edx, DWORD PTR [esi]
  001c7	6a 01		 push	 1
  001c9	52		 push	 edx
  001ca	68 98 0d 00 00	 push	 3480			; 00000d98H
  001cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001d4	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001d9	50		 push	 eax
  001da	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 20580:             DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  001df	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001e3	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  001e6	50		 push	 eax
  001e7	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  001ea	51		 push	 ecx
  001eb	52		 push	 edx
  001ec	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f1	83 c4 18	 add	 esp, 24			; 00000018H
$LN34@CGInventor@2:

; 20581: 		}
; 20582: 		break;
; 20583: 	}
; 20584: 	// ----
; 20585: 	gObjCalCharacter(iIndex);

  001f4	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  001f7	56		 push	 esi
  001f8	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 20586: 	DataSend(iIndex,(LPBYTE)&pMsg, pMsg.h.size);

  001fd	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00201	50		 push	 eax
  00202	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00205	51		 push	 ecx
  00206	56		 push	 esi
  00207	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0020c	83 c4 10	 add	 esp, 16			; 00000010H
  0020f	5b		 pop	 ebx
$LN35@CGInventor@2:
  00210	5e		 pop	 esi
$LN30@CGInventor@2:
  00211	5f		 pop	 edi

; 20587: }

  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c3		 ret	 0
  00216	8b ff		 npad	 2
$LN42@CGInventor@2:
  00218	00 00 00 00	 DD	 $LN24@CGInventor@2
  0021c	00 00 00 00	 DD	 $LN24@CGInventor@2
  00220	00 00 00 00	 DD	 $LN16@CGInventor@2
  00224	00 00 00 00	 DD	 $LN16@CGInventor@2
  00228	00 00 00 00	 DD	 $LN16@CGInventor@2
  0022c	00 00 00 00	 DD	 $LN16@CGInventor@2
  00230	00 00 00 00	 DD	 $LN8@CGInventor@2
?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z ENDP ; CGInventoryEquipment
_TEXT	ENDS
PUBLIC	??_C@_0BM@JGJDNBPL@?$FLDEBUG?$FN?5Text?3?5?$CFs?0?5Value?3?5?$CFd?$AA@ ; `string'
PUBLIC	?ClientTestSend@@YAXHPAUClientTest@@@Z		; ClientTestSend
;	COMDAT ??_C@_0BM@JGJDNBPL@?$FLDEBUG?$FN?5Text?3?5?$CFs?0?5Value?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BM@JGJDNBPL@?$FLDEBUG?$FN?5Text?3?5?$CFs?0?5Value?3?5?$CFd?$AA@ DB '['
	DB	'DEBUG] Text: %s, Value: %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ClientTestSend@@YAXHPAUClientTest@@@Z
_TEXT	SEGMENT
_UserIndex$ = 8						; size = 4
_lpResult$ = 12						; size = 4
?ClientTestSend@@YAXHPAUClientTest@@@Z PROC		; ClientTestSend, COMDAT

; 20590: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 20591: 	LogAddC(2, "[DEBUG] Text: %s, Value: %d",
; 20592: 		lpResult->Text, lpResult->Value);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _lpResult$[ebp]
  00006	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00009	51		 push	 ecx
  0000a	83 c0 04	 add	 eax, 4
  0000d	50		 push	 eax
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JGJDNBPL@?$FLDEBUG?$FN?5Text?3?5?$CFs?0?5Value?3?5?$CFd?$AA@
  00013	6a 02		 push	 2
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 20593: }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?ClientTestSend@@YAXHPAUClientTest@@@Z ENDP		; ClientTestSend
_TEXT	ENDS
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
EXTRN	_vsprintf_s:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 323  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, _Deref_post_z_ char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Dest$[ebp]
  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	68 00 01 00 00	 push	 256			; 00000100H
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _vsprintf_s
  00019	83 c4 10	 add	 esp, 16			; 00000010H
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
_TEXT	ENDS
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_EOBJECTSTRUCT@@QAEPAXI@Z$0
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_EOBJECTSTRUCT@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8a 5d 08	 mov	 bl, BYTE PTR ___flags$[ebp]
  0002e	f6 c3 02	 test	 bl, 2
  00031	74 3b		 je	 SHORT $LN3@vector@2
  00033	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00036	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  0003b	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003e	50		 push	 eax
  0003f	68 40 27 00 00	 push	 10048			; 00002740H
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0004a	f6 c3 01	 test	 bl, 1
  0004d	74 09		 je	 SHORT $LN2@vector@2
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00055	83 c4 04	 add	 esp, 4
$LN2@vector@2:
  00058	8b c7		 mov	 eax, edi
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
$LN3@vector@2:
  0006e	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007b	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  00080	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00086	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008d	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00092	f6 c3 01	 test	 bl, 1
  00095	74 09		 je	 SHORT $LN1@vector@2
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009d	83 c4 04	 add	 esp, 4
$LN1@vector@2:
  000a0	8b c6		 mov	 eax, esi
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_EOBJECTSTRUCT@@QAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	??0_CS_NPC_DATA@@QAE@XZ				; _CS_NPC_DATA::_CS_NPC_DATA
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\castlesiege.h
;	COMDAT ??0_CS_NPC_DATA@@QAE@XZ
_TEXT	SEGMENT
??0_CS_NPC_DATA@@QAE@XZ PROC				; _CS_NPC_DATA::_CS_NPC_DATA, COMDAT
; _this$ = ecx

; 68   : 	_CS_NPC_DATA()

  00000	8b c1		 mov	 eax, ecx

; 69   : 	{
; 70   : 		Clear();

  00002	83 c9 ff	 or	 ecx, -1
  00005	33 d2		 xor	 edx, edx
  00007	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_CS_NPC_DATA@@6B@
  0000d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00010	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00013	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00016	89 50 68	 mov	 DWORD PTR [eax+104], edx
  00019	89 48 6c	 mov	 DWORD PTR [eax+108], ecx
  0001c	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0001f	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00022	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00025	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  00028	89 50 20	 mov	 DWORD PTR [eax+32], edx
  0002b	89 50 24	 mov	 DWORD PTR [eax+36], edx
  0002e	89 50 28	 mov	 DWORD PTR [eax+40], edx
  00031	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
  00034	89 48 30	 mov	 DWORD PTR [eax+48], ecx
  00037	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  0003a	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  0003d	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  00040	89 50 40	 mov	 DWORD PTR [eax+64], edx
  00043	89 50 44	 mov	 DWORD PTR [eax+68], edx
  00046	89 50 48	 mov	 DWORD PTR [eax+72], edx
  00049	89 50 4c	 mov	 DWORD PTR [eax+76], edx
  0004c	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  0004f	89 48 54	 mov	 DWORD PTR [eax+84], ecx
  00052	89 48 58	 mov	 DWORD PTR [eax+88], ecx
  00055	89 48 5c	 mov	 DWORD PTR [eax+92], ecx
  00058	89 48 60	 mov	 DWORD PTR [eax+96], ecx
  0005b	89 50 70	 mov	 DWORD PTR [eax+112], edx

; 71   : 		m_iCS_GATE_LEVER_INDEX = -1;

  0005e	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 72   : 	};

  00061	c3		 ret	 0
??0_CS_NPC_DATA@@QAE@XZ ENDP				; _CS_NPC_DATA::_CS_NPC_DATA
_TEXT	ENDS
PUBLIC	?GCCheckMainExeKeySend@@YAXH@Z			; GCCheckMainExeKeySend
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
;	COMDAT ?GCCheckMainExeKeySend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
?GCCheckMainExeKeySend@@YAXH@Z PROC			; GCCheckMainExeKeySend, COMDAT

; 1454 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1455 : 	PMSG_CHECK_MAINEXE pMsg;
; 1456 : 
; 1457 : 	gObj[aIndex].CheckSumTableNum = rand() % MAX_CHECKSUM_KEY;

  00008	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000b	8b f7		 mov	 esi, edi
  0000d	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00013	e8 00 00 00 00	 call	 _rand
  00018	25 ff 03 00 80	 and	 eax, -2147482625	; 800003ffH
  0001d	79 07		 jns	 SHORT $LN3@GCCheckMai
  0001f	48		 dec	 eax
  00020	0d 00 fc ff ff	 or	 eax, -1024		; fffffc00H
  00025	40		 inc	 eax
$LN3@GCCheckMai:
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	66 89 44 0e 48	 mov	 WORD PTR [esi+ecx+72], ax

; 1458 : 	gObj[aIndex].CheckSumTime = GetTickCount();

  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1459 : 	PHeadSetB((LPBYTE)&pMsg, 0x03, sizeof(pMsg));

  0003d	6a 06		 push	 6
  0003f	89 44 16 4c	 mov	 DWORD PTR [esi+edx+76], eax
  00043	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00046	6a 03		 push	 3
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1460 : 	pMsg.m_wKey = EncryptCheckSumKey(gObj[aIndex].CheckSumTableNum);

  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00054	0f b7 54 0e 48	 movzx	 edx, WORD PTR [esi+ecx+72]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?EncryptCheckSumKey@@YAGG@Z ; EncryptCheckSumKey
  0005f	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 1461 : 
; 1462 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00063	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00067	50		 push	 eax
  00068	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0006b	51		 push	 ecx
  0006c	57		 push	 edi
  0006d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00072	83 c4 1c	 add	 esp, 28			; 0000001cH
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 1463 : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?GCCheckMainExeKeySend@@YAXH@Z ENDP			; GCCheckMainExeKeySend
_TEXT	ENDS
PUBLIC	??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z	; CSPJoinIdPassRequest
EXTRN	?IsMember@CConMember@@QAEHPAD@Z:PROC		; CConMember::IsMember
EXTRN	?ConMember@@3VCConMember@@A:BYTE		; ConMember
EXTRN	?g_ConnectMemberLoad@@3_NA:BYTE			; g_ConnectMemberLoad
EXTRN	?szGameServerExeSerial@@3PADA:BYTE		; szGameServerExeSerial
;	COMDAT ??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@ DB 'join send '
	DB	': (%d)%s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@ DB 'error : %d %s '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@ DB 'e'
	DB	'rror-L1: Serial error [%s] [%s]', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -96					; size = 4
_spMsg$ = -92						; size = 54
_serial$ = -36						; size = 17
_id$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z PROC	; CSPJoinIdPassRequest, COMDAT

; 2196 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2197 : 	char serial[17];
; 2198 : 	char id[11];
; 2199 : 
; 2200 : 	if ( lpMsg->CliVersion[0] != szClientVersion[0] ||
; 2201 : 		 lpMsg->CliVersion[1] != szClientVersion[1] ||
; 2202 : 		 lpMsg->CliVersion[2] != szClientVersion[2] ||
; 2203 : 		 lpMsg->CliVersion[3] != szClientVersion[3] ||
; 2204 : 		 lpMsg->CliVersion[4] != szClientVersion[4] )

  00010	0f be 0d 00 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001f	0f b6 47 26	 movzx	 eax, BYTE PTR [edi+38]

; 2271 : 
; 2272 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();

  00023	89 75 a0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  00026	3b c1		 cmp	 eax, ecx
  00028	0f 85 17 03 00
	00		 jne	 $LN9@CSPJoinIdP@2

; 2197 : 	char serial[17];
; 2198 : 	char id[11];
; 2199 : 
; 2200 : 	if ( lpMsg->CliVersion[0] != szClientVersion[0] ||
; 2201 : 		 lpMsg->CliVersion[1] != szClientVersion[1] ||
; 2202 : 		 lpMsg->CliVersion[2] != szClientVersion[2] ||
; 2203 : 		 lpMsg->CliVersion[3] != szClientVersion[3] ||
; 2204 : 		 lpMsg->CliVersion[4] != szClientVersion[4] )

  0002e	0f b6 57 27	 movzx	 edx, BYTE PTR [edi+39]
  00032	0f be 05 01 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+1
  00039	3b d0		 cmp	 edx, eax
  0003b	0f 85 04 03 00
	00		 jne	 $LN9@CSPJoinIdP@2
  00041	0f b6 4f 28	 movzx	 ecx, BYTE PTR [edi+40]
  00045	0f be 15 02 00
	00 00		 movsx	 edx, BYTE PTR ?szClientVersion@@3PADA+2
  0004c	3b ca		 cmp	 ecx, edx
  0004e	0f 85 f1 02 00
	00		 jne	 $LN9@CSPJoinIdP@2
  00054	0f b6 47 29	 movzx	 eax, BYTE PTR [edi+41]
  00058	0f be 0d 03 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA+3
  0005f	3b c1		 cmp	 eax, ecx
  00061	0f 85 de 02 00
	00		 jne	 $LN9@CSPJoinIdP@2
  00067	0f b6 57 2a	 movzx	 edx, BYTE PTR [edi+42]
  0006b	0f be 05 04 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+4
  00072	3b d0		 cmp	 edx, eax
  00074	0f 85 cb 02 00
	00		 jne	 $LN9@CSPJoinIdP@2

; 2208 : 		return;
; 2209 : 	}
; 2210 : 
; 2211 : 	serial[16] = 0;
; 2212 : 	memcpy(serial, lpMsg->CliSerial, sizeof(lpMsg->CliSerial));

  0007a	8b 57 2f	 mov	 edx, DWORD PTR [edi+47]
  0007d	8b 4f 2b	 mov	 ecx, DWORD PTR [edi+43]
  00080	8b 47 33	 mov	 eax, DWORD PTR [edi+51]
  00083	89 55 e0	 mov	 DWORD PTR _serial$[ebp+4], edx

; 2213 : 	id[10]=0;
; 2214 : 	memcpy(id, lpMsg->Id, sizeof(lpMsg->Id));

  00086	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00089	89 4d dc	 mov	 DWORD PTR _serial$[ebp], ecx
  0008c	8b 4f 37	 mov	 ecx, DWORD PTR [edi+55]
  0008f	89 55 f0	 mov	 DWORD PTR _id$[ebp], edx
  00092	89 45 e4	 mov	 DWORD PTR _serial$[ebp+8], eax
  00095	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00098	89 4d e8	 mov	 DWORD PTR _serial$[ebp+12], ecx
  0009b	66 8b 4f 0c	 mov	 cx, WORD PTR [edi+12]

; 2215 : 	BuxConvert(id, MAX_ACCOUNT_LEN);

  0009f	8d 55 f0	 lea	 edx, DWORD PTR _id$[ebp]
  000a2	6a 0a		 push	 10			; 0000000aH
  000a4	52		 push	 edx
  000a5	c6 45 ec 00	 mov	 BYTE PTR _serial$[ebp+16], 0
  000a9	c6 45 fa 00	 mov	 BYTE PTR _id$[ebp+10], 0
  000ad	89 45 f4	 mov	 DWORD PTR _id$[ebp+4], eax
  000b0	66 89 4d f8	 mov	 WORD PTR _id$[ebp+8], cx
  000b4	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  000b9	83 c4 08	 add	 esp, 8

; 2216 : 
; 2217 : 	if ( strcmp(serial, szGameServerExeSerial) != 0 )

  000bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?szGameServerExeSerial@@3PADA ; szGameServerExeSerial
  000c1	8d 45 dc	 lea	 eax, DWORD PTR _serial$[ebp]
$LL15@CSPJoinIdP@2:
  000c4	8a 10		 mov	 dl, BYTE PTR [eax]
  000c6	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000c8	75 1a		 jne	 SHORT $LN16@CSPJoinIdP@2
  000ca	84 d2		 test	 dl, dl
  000cc	74 12		 je	 SHORT $LN17@CSPJoinIdP@2
  000ce	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000d1	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000d4	75 0e		 jne	 SHORT $LN16@CSPJoinIdP@2
  000d6	83 c0 02	 add	 eax, 2
  000d9	83 c1 02	 add	 ecx, 2
  000dc	84 d2		 test	 dl, dl
  000de	75 e4		 jne	 SHORT $LL15@CSPJoinIdP@2
$LN17@CSPJoinIdP@2:
  000e0	33 c0		 xor	 eax, eax
  000e2	eb 05		 jmp	 SHORT $LN18@CSPJoinIdP@2
$LN16@CSPJoinIdP@2:
  000e4	1b c0		 sbb	 eax, eax
  000e6	83 d8 ff	 sbb	 eax, -1
$LN18@CSPJoinIdP@2:
  000e9	85 c0		 test	 eax, eax
  000eb	74 36		 je	 SHORT $LN8@CSPJoinIdP@2

; 2218 : 	{
; 2219 : 		LogAddC(2, "error-L1: Serial error [%s] [%s]", id, serial);

  000ed	8d 45 dc	 lea	 eax, DWORD PTR _serial$[ebp]
  000f0	50		 push	 eax
  000f1	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  000f4	51		 push	 ecx
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@
  000fa	6a 02		 push	 2
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 2220 : 		GCJoinResult(JS_BAD_CLIENT_VERSION, aIndex);

  00102	56		 push	 esi
  00103	6a 06		 push	 6
  00105	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult

; 2221 : 		CloseClient(aIndex);

  0010a	56		 push	 esi
  0010b	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00110	83 c4 1c	 add	 esp, 28			; 0000001cH
  00113	5f		 pop	 edi
  00114	5e		 pop	 esi

; 2286 : 	lpObj->m_btDestY = 0;
; 2287 : }

  00115	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00118	33 cd		 xor	 ecx, ebp
  0011a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN8@CSPJoinIdP@2:

; 2222 : 		return;
; 2223 : 	}
; 2224 : 	
; 2225 : 	if ( g_ConnectMemberLoad == TRUE )

  00123	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR ?g_ConnectMemberLoad@@3_NA, 1 ; g_ConnectMemberLoad
  0012a	75 2d		 jne	 SHORT $LN6@CSPJoinIdP@2

; 2226 : 	{
; 2227 : 		if ( ConMember.IsMember(id) == FALSE )

  0012c	8d 55 f0	 lea	 edx, DWORD PTR _id$[ebp]
  0012f	52		 push	 edx
  00130	b9 00 00 00 00	 mov	 ecx, OFFSET ?ConMember@@3VCConMember@@A ; ConMember
  00135	e8 00 00 00 00	 call	 ?IsMember@CConMember@@QAEHPAD@Z ; CConMember::IsMember
  0013a	85 c0		 test	 eax, eax
  0013c	75 1b		 jne	 SHORT $LN6@CSPJoinIdP@2

; 2228 : 		{
; 2229 : 			GCJoinResult(JS_ONLY_VIP_MEMBERS, aIndex);

  0013e	56		 push	 esi
  0013f	6a 02		 push	 2
  00141	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult
  00146	83 c4 08	 add	 esp, 8
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi

; 2286 : 	lpObj->m_btDestY = 0;
; 2287 : }

  0014b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014e	33 cd		 xor	 ecx, ebp
  00150	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
$LN6@CSPJoinIdP@2:

; 2230 : 			return;
; 2231 : 		}
; 2232 : 	}
; 2233 : 
; 2234 : 	LPOBJ lpObj = &gObj[aIndex];

  00159	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015e	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00164	53		 push	 ebx
  00165	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]

; 2235 : 
; 2236 : 	if (PacketCheckTime(lpObj) == FALSE )

  00168	53		 push	 ebx
  00169	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0016e	83 c4 04	 add	 esp, 4
  00171	85 c0		 test	 eax, eax
  00173	75 0f		 jne	 SHORT $LN5@CSPJoinIdP@2

; 2237 : 	{
; 2238 : 		LogAdd(lMsg.Get(MSGGET(1, 217)), aIndex, id);

  00175	8b 75 a0	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00178	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  0017b	51		 push	 ecx
  0017c	56		 push	 esi
  0017d	68 d9 01 00 00	 push	 473			; 000001d9H

; 2239 : 		CloseClient(aIndex);
; 2240 : 		return;

  00182	eb 1a		 jmp	 SHORT $LN20@CSPJoinIdP@2
$LN5@CSPJoinIdP@2:

; 2241 : 	}
; 2242 : 
; 2243 : 	if ( gObj[aIndex].Connected != PLAYER_CONNECTED )

  00184	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018a	83 7c 0e 04 01	 cmp	 DWORD PTR [esi+ecx+4], 1
  0018f	74 38		 je	 SHORT $LN4@CSPJoinIdP@2

; 2244 : 	{
; 2245 : 		LogAdd(lMsg.Get(MSGGET(1, 218)), aIndex, id);

  00191	8b 75 a0	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00194	8d 55 f0	 lea	 edx, DWORD PTR _id$[ebp]
  00197	52		 push	 edx
  00198	56		 push	 esi
  00199	68 da 01 00 00	 push	 474			; 000001daH
$LN20@CSPJoinIdP@2:
  0019e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001a3	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001a8	50		 push	 eax
  001a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2246 : 		CloseClient(aIndex);

  001af	56		 push	 esi
  001b0	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 2253 : 		{
; 2254 : 			LogAdd(lMsg.Get(MSGGET(1, 219)), aIndex, id, gObj[aIndex].Ip_addr );

  001b5	83 c4 10	 add	 esp, 16			; 00000010H
  001b8	5b		 pop	 ebx
  001b9	5f		 pop	 edi
  001ba	5e		 pop	 esi

; 2286 : 	lpObj->m_btDestY = 0;
; 2287 : }

  001bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001be	33 cd		 xor	 ecx, ebp
  001c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c5	8b e5		 mov	 esp, ebp
  001c7	5d		 pop	 ebp
  001c8	c3		 ret	 0
$LN4@CSPJoinIdP@2:

; 2247 : 		return;
; 2248 : 	}
; 2249 : 
; 2250 : 	if ( gObj[aIndex].LoginMsgSnd != FALSE )

  001c9	8a 44 0e 0a	 mov	 al, BYTE PTR [esi+ecx+10]
  001cd	84 c0		 test	 al, al
  001cf	74 50		 je	 SHORT $LN3@CSPJoinIdP@2

; 2251 : 	{
; 2252 : 		if ( gObj[aIndex].LoginMsgSnd == TRUE )

  001d1	3c 01		 cmp	 al, 1
  001d3	75 37		 jne	 SHORT $LN2@CSPJoinIdP@2

; 2253 : 		{
; 2254 : 			LogAdd(lMsg.Get(MSGGET(1, 219)), aIndex, id, gObj[aIndex].Ip_addr );

  001d5	8b 55 a0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  001d8	8d 44 0e 1c	 lea	 eax, DWORD PTR [esi+ecx+28]
  001dc	50		 push	 eax
  001dd	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  001e0	51		 push	 ecx
  001e1	52		 push	 edx
  001e2	68 db 01 00 00	 push	 475			; 000001dbH
  001e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001ec	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001f1	50		 push	 eax
$LN21@CSPJoinIdP@2:
  001f2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001f8	83 c4 10	 add	 esp, 16			; 00000010H
  001fb	5b		 pop	 ebx
  001fc	5f		 pop	 edi
  001fd	5e		 pop	 esi

; 2286 : 	lpObj->m_btDestY = 0;
; 2287 : }

  001fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00201	33 cd		 xor	 ecx, ebp
  00203	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c3		 ret	 0
$LN2@CSPJoinIdP@2:

; 2255 : 		}
; 2256 : 		else
; 2257 : 		{
; 2258 : 			LogAdd("error : %d %s %d", gObj[aIndex].LoginMsgSnd, __FILE__, __LINE__);

  0020c	68 d2 08 00 00	 push	 2258			; 000008d2H
  00211	0f be c0	 movsx	 eax, al
  00214	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00219	50		 push	 eax
  0021a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@

; 2259 : 		}
; 2260 : 
; 2261 : 		return;

  0021f	eb d1		 jmp	 SHORT $LN21@CSPJoinIdP@2
$LN3@CSPJoinIdP@2:

; 2262 : 	}
; 2263 : 
; 2264 : 	SDHP_IDPASS spMsg;
; 2265 : 
; 2266 : 	PHeadSetB((LPBYTE)&spMsg, 0x01, sizeof(spMsg));

  00221	6a 36		 push	 54			; 00000036H
  00223	8d 4d a4	 lea	 ecx, DWORD PTR _spMsg$[ebp]
  00226	6a 01		 push	 1
  00228	51		 push	 ecx
  00229	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2267 : 	spMsg.Number = aIndex;

  0022e	0f b7 55 a0	 movzx	 edx, WORD PTR _aIndex$GSCopy$[ebp]

; 2268 : 	memcpy(spMsg.Id, lpMsg->Id, sizeof(spMsg.Id));

  00232	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00235	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00238	66 89 55 c6	 mov	 WORD PTR _spMsg$[ebp+34], dx
  0023c	0f b7 57 0c	 movzx	 edx, WORD PTR [edi+12]
  00240	89 45 a7	 mov	 DWORD PTR _spMsg$[ebp+3], eax

; 2269 : 	memcpy(spMsg.Pass, lpMsg->Pass, sizeof(spMsg.Pass));

  00243	8b 47 0e	 mov	 eax, DWORD PTR [edi+14]
  00246	66 89 55 af	 mov	 WORD PTR _spMsg$[ebp+11], dx
  0024a	8b 57 16	 mov	 edx, DWORD PTR [edi+22]
  0024d	89 45 b1	 mov	 DWORD PTR _spMsg$[ebp+13], eax
  00250	8b 47 1a	 mov	 eax, DWORD PTR [edi+26]
  00253	89 55 b9	 mov	 DWORD PTR _spMsg$[ebp+21], edx

; 2270 : 	strcpy(spMsg.IpAddress, gObj[aIndex].Ip_addr);

  00256	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0025c	89 4d ab	 mov	 DWORD PTR _spMsg$[ebp+7], ecx
  0025f	8b 4f 12	 mov	 ecx, DWORD PTR [edi+18]
  00262	89 45 bd	 mov	 DWORD PTR _spMsg$[ebp+25], eax
  00265	8d 44 16 1c	 lea	 eax, DWORD PTR [esi+edx+28]
  00269	89 4d b5	 mov	 DWORD PTR _spMsg$[ebp+17], ecx
  0026c	8b 4f 1e	 mov	 ecx, DWORD PTR [edi+30]
  0026f	8d 55 c8	 lea	 edx, DWORD PTR _spMsg$[ebp+36]
  00272	83 c4 0c	 add	 esp, 12			; 0000000cH
  00275	89 4d c1	 mov	 DWORD PTR _spMsg$[ebp+29], ecx
  00278	2b d0		 sub	 edx, eax
  0027a	8d 9b 00 00 00
	00		 npad	 6
$LL13@CSPJoinIdP@2:
  00280	8a 08		 mov	 cl, BYTE PTR [eax]
  00282	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00285	40		 inc	 eax
  00286	84 c9		 test	 cl, cl
  00288	75 f6		 jne	 SHORT $LL13@CSPJoinIdP@2

; 2271 : 
; 2272 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();

  0028a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00290	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00296	89 44 0e 3c	 mov	 DWORD PTR [esi+ecx+60], eax

; 2273 : 
; 2274 : 	gObj[aIndex].LoginMsgSnd = 1;

  0029a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a0	c6 44 16 0a 01	 mov	 BYTE PTR [esi+edx+10], 1

; 2275 : 	gObj[aIndex].LoginMsgCount++;

  002a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002aa	fe 44 06 0b	 inc	 BYTE PTR [esi+eax+11]

; 2276 : 	gObj[aIndex].AccountID[MAX_ACCOUNT_LEN] = 0;

  002ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b3	c6 44 06 5c 00	 mov	 BYTE PTR [esi+eax+92], 0

; 2277 : 	memcpy(gObj[aIndex].AccountID, id, MAX_ACCOUNT_LEN);

  002b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002be	8b 55 f0	 mov	 edx, DWORD PTR _id$[ebp]
  002c1	8d 44 0e 52	 lea	 eax, DWORD PTR [esi+ecx+82]
  002c5	89 10		 mov	 DWORD PTR [eax], edx
  002c7	8b 4d f4	 mov	 ecx, DWORD PTR _id$[ebp+4]
  002ca	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  002cd	66 8b 55 f8	 mov	 dx, WORD PTR _id$[ebp+8]
  002d1	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 2278 : 	gObj[aIndex].m_cAccountItemBlock = 0;

  002d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002da	c6 84 06 c4 01
	00 00 00	 mov	 BYTE PTR [esi+eax+452], 0

; 2279 : 
; 2280 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  002e2	0f b6 4d a5	 movzx	 ecx, BYTE PTR _spMsg$[ebp+1]
  002e6	51		 push	 ecx
  002e7	8d 55 a4	 lea	 edx, DWORD PTR _spMsg$[ebp]
  002ea	52		 push	 edx
  002eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  002f0	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 2281 : 	LogAddTD("join send : (%d)%s", aIndex, gObj[aIndex].AccountID);

  002f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002fa	8b 55 a0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  002fd	8d 4c 06 52	 lea	 ecx, DWORD PTR [esi+eax+82]
  00301	51		 push	 ecx
  00302	52		 push	 edx
  00303	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@
  00308	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0030e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2282 : 	lpObj->m_bMapSvrMoveReq = false;
; 2283 : 	lpObj->m_sPrevMapSvrCode = -1; 

  00311	83 c8 ff	 or	 eax, -1

; 2284 : 	lpObj->m_sDestMapNumber = -1;

  00314	0b c8		 or	 ecx, eax
  00316	c6 83 3d 20 00
	00 00		 mov	 BYTE PTR [ebx+8253], 0
  0031d	66 89 83 44 20
	00 00		 mov	 WORD PTR [ebx+8260], ax
  00324	66 89 8b 46 20
	00 00		 mov	 WORD PTR [ebx+8262], cx

; 2285 : 	lpObj->m_btDestX = 0;

  0032b	66 c7 83 48 20
	00 00 00 00	 mov	 WORD PTR [ebx+8264], 0
  00334	5b		 pop	 ebx
  00335	5f		 pop	 edi
  00336	5e		 pop	 esi

; 2286 : 	lpObj->m_btDestY = 0;
; 2287 : }

  00337	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033a	33 cd		 xor	 ecx, ebp
  0033c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00341	8b e5		 mov	 esp, ebp
  00343	5d		 pop	 ebp
  00344	c3		 ret	 0
$LN9@CSPJoinIdP@2:

; 2205 : 	{
; 2206 : 		GCJoinResult(JS_BAD_CLIENT_VERSION, aIndex);

  00345	56		 push	 esi
  00346	6a 06		 push	 6
  00348	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult

; 2207 : 		CloseClient(aIndex);

  0034d	56		 push	 esi
  0034e	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 2286 : 	lpObj->m_btDestY = 0;
; 2287 : }

  00353	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00356	83 c4 0c	 add	 esp, 12			; 0000000cH
  00359	5f		 pop	 edi
  0035a	33 cd		 xor	 ecx, ebp
  0035c	5e		 pop	 esi
  0035d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00362	8b e5		 mov	 esp, ebp
  00364	5d		 pop	 ebp
  00365	c3		 ret	 0
?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z ENDP	; CSPJoinIdPassRequest
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCLevelUpMsgSend@@YAXHH@Z			; GCLevelUpMsgSend
EXTRN	?gObjGetStatPointState@@YAXHAAF000@Z:PROC	; gObjGetStatPointState
; Function compile flags: /Ogtp
;	COMDAT ?GCLevelUpMsgSend@@YAXHH@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -72					; size = 4
tv317 = -68						; size = 4
_AddPoint$ = -64					; size = 2
_MinusPoint$ = -60					; size = 2
_MaxAddPoint$ = -56					; size = 2
_MaxMinusPoint$ = -52					; size = 2
tv338 = -48						; size = 4
tv336 = -48						; size = 4
tv330 = -48						; size = 4
tv327 = -48						; size = 4
tv325 = -48						; size = 4
tv341 = -42						; size = 2
tv332 = -42						; size = 2
_pMsg$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_iSendEffect$ = 12					; size = 4
?GCLevelUpMsgSend@@YAXHH@Z PROC				; GCLevelUpMsgSend, COMDAT

; 2824 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 2825 : 	if ( !OBJMAX_RANGE(aIndex))

  00014	33 c0		 xor	 eax, eax

; 2826 : 		return;
; 2827 : 
; 2828 : 	short AddPoint=0;

  00016	89 75 b8	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  00019	3b f0		 cmp	 esi, eax
  0001b	0f 8c 83 01 00
	00		 jl	 $LN1@GCLevelUpM

; 2825 : 	if ( !OBJMAX_RANGE(aIndex))

  00021	33 c9		 xor	 ecx, ecx
  00023	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00029	0f 9e c1	 setle	 cl
  0002c	3b c8		 cmp	 ecx, eax
  0002e	0f 84 70 01 00
	00		 je	 $LN1@GCLevelUpM

; 2829 : 	short MaxAddPoint=0;
; 2830 : 	short MinusPoint=0;
; 2831 : 	short MaxMinusPoint=0;
; 2832 : 
; 2833 : 	gObjGetStatPointState(gObj[aIndex].m_Index, AddPoint, MaxAddPoint, MinusPoint, MaxMinusPoint);

  00034	53		 push	 ebx
  00035	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0003b	57		 push	 edi
  0003c	89 45 c0	 mov	 DWORD PTR _AddPoint$[ebp], eax
  0003f	89 45 c8	 mov	 DWORD PTR _MaxAddPoint$[ebp], eax
  00042	89 45 c4	 mov	 DWORD PTR _MinusPoint$[ebp], eax
  00045	89 45 cc	 mov	 DWORD PTR _MaxMinusPoint$[ebp], eax
  00048	8d 45 cc	 lea	 eax, DWORD PTR _MaxMinusPoint$[ebp]
  0004b	50		 push	 eax
  0004c	8d 4d c4	 lea	 ecx, DWORD PTR _MinusPoint$[ebp]
  0004f	51		 push	 ecx
  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	8d 55 c8	 lea	 edx, DWORD PTR _MaxAddPoint$[ebp]
  00059	52		 push	 edx
  0005a	8b 14 0e	 mov	 edx, DWORD PTR [esi+ecx]
  0005d	8d 45 c0	 lea	 eax, DWORD PTR _AddPoint$[ebp]
  00060	50		 push	 eax
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF000@Z ; gObjGetStatPointState

; 2834 : 	
; 2835 : 	PMSG_LEVELUP pMsg;
; 2836 : 
; 2837 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x05, sizeof(pMsg));

  00067	6a 24		 push	 36			; 00000024H
  00069	6a 05		 push	 5
  0006b	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006e	68 f3 00 00 00	 push	 243			; 000000f3H
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2838 : 	pMsg.Level = gObj[aIndex].Level;

  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2839 : 	pMsg.LevelUpPoint = gObj[aIndex].LevelUpPoint;
; 2840 : 	pMsg.MaxLife = (WORD)(gObj[aIndex].MaxLife+gObj[aIndex].AddLife);

  0007f	d9 7d d6	 fnstcw	 WORD PTR tv341[ebp]
  00082	66 8b 94 0e 96
	00 00 00	 mov	 dx, WORD PTR [esi+ecx+150]
  0008a	66 89 55 dc	 mov	 WORD PTR _pMsg$[ebp+4], dx
  0008e	0f b7 84 0e 98
	00 00 00	 movzx	 eax, WORD PTR [esi+ecx+152]
  00096	66 89 45 de	 mov	 WORD PTR _pMsg$[ebp+6], ax
  0009a	0f b7 45 d6	 movzx	 eax, WORD PTR tv341[ebp]
  0009e	db 84 0e 24 01
	00 00		 fild	 DWORD PTR [esi+ecx+292]
  000a5	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000aa	d8 84 0e dc 00
	00 00		 fadd	 DWORD PTR [esi+ecx+220]
  000b1	89 45 d0	 mov	 DWORD PTR tv338[ebp], eax
  000b4	8d 94 0e 24 01
	00 00		 lea	 edx, DWORD PTR [esi+ecx+292]
  000bb	8d bc 0e dc 00
	00 00		 lea	 edi, DWORD PTR [esi+ecx+220]
  000c2	d9 6d d0	 fldcw	 WORD PTR tv338[ebp]

; 2841 : 	pMsg.MaxMana = (WORD)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana);

  000c5	8d 9c 0e 28 01
	00 00		 lea	 ebx, DWORD PTR [esi+ecx+296]
  000cc	db 5d d0	 fistp	 DWORD PTR tv336[ebp]
  000cf	0f b7 45 d0	 movzx	 eax, WORD PTR tv336[ebp]
  000d3	66 89 45 e0	 mov	 WORD PTR _pMsg$[ebp+8], ax
  000d7	8d 84 0e f0 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+240]
  000de	d9 6d d6	 fldcw	 WORD PTR tv341[ebp]
  000e1	89 45 bc	 mov	 DWORD PTR tv317[ebp], eax
  000e4	db 03		 fild	 DWORD PTR [ebx]
  000e6	d9 7d d6	 fnstcw	 WORD PTR tv332[ebp]
  000e9	d8 00		 fadd	 DWORD PTR [eax]
  000eb	0f b7 45 d6	 movzx	 eax, WORD PTR tv332[ebp]
  000ef	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000f4	89 45 d0	 mov	 DWORD PTR tv327[ebp], eax
  000f7	d9 6d d0	 fldcw	 WORD PTR tv327[ebp]
  000fa	db 5d d0	 fistp	 DWORD PTR tv325[ebp]
  000fd	0f b7 45 d0	 movzx	 eax, WORD PTR tv325[ebp]
  00101	66 89 45 e2	 mov	 WORD PTR _pMsg$[ebp+10], ax

; 2842 : 	pMsg.MaxBP = gObj[aIndex].MaxBP + gObj[aIndex].AddBP;

  00105	0f b7 84 0e 0c
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+268]
  0010d	d9 6d d6	 fldcw	 WORD PTR tv332[ebp]
  00110	66 03 84 0e 08
	01 00 00	 add	 ax, WORD PTR [esi+ecx+264]
  00118	66 89 45 e6	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 2843 : 	pMsg.wMaxShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  0011c	8d 84 0e 34 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+308]
  00123	8d b4 0e 30 01
	00 00		 lea	 esi, DWORD PTR [esi+ecx+304]
  0012a	0f b7 0e	 movzx	 ecx, WORD PTR [esi]
  0012d	66 03 08	 add	 cx, WORD PTR [eax]
  00130	89 45 d0	 mov	 DWORD PTR tv330[ebp], eax

; 2844 : 	pMsg.AddPoint = AddPoint;

  00133	0f b7 45 c0	 movzx	 eax, WORD PTR _AddPoint$[ebp]
  00137	66 89 4d e4	 mov	 WORD PTR _pMsg$[ebp+12], cx

; 2845 : 	pMsg.MaxAddPoint = MaxAddPoint;

  0013b	0f b7 4d c8	 movzx	 ecx, WORD PTR _MaxAddPoint$[ebp]
  0013f	66 89 45 e8	 mov	 WORD PTR _pMsg$[ebp+16], ax

; 2846 : 	pMsg.MinusPoint = MinusPoint;

  00143	0f b7 45 c4	 movzx	 eax, WORD PTR _MinusPoint$[ebp]
  00147	66 89 4d ea	 mov	 WORD PTR _pMsg$[ebp+18], cx

; 2847 : 	pMsg.MaxMinusPoint = MaxMinusPoint;

  0014b	0f b7 4d cc	 movzx	 ecx, WORD PTR _MaxMinusPoint$[ebp]
  0014f	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+20], ax
  00153	66 89 4d ee	 mov	 WORD PTR _pMsg$[ebp+22], cx

; 2848 : 
; 2849 : #if (FIX_HP==1)
; 2850 : 	pMsg.MAXHP = (int)(gObj[aIndex].AddLife + gObj[aIndex].MaxLife);

  00157	db 02		 fild	 DWORD PTR [edx]
  00159	d8 07		 fadd	 DWORD PTR [edi]
  0015b	e8 00 00 00 00	 call	 __ftol2_sse

; 2851 : 	pMsg.MAXMP = (int)(gObj[aIndex].AddMana + gObj[aIndex].MaxMana);

  00160	8b 55 bc	 mov	 edx, DWORD PTR tv317[ebp]
  00163	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  00166	db 03		 fild	 DWORD PTR [ebx]
  00168	d8 02		 fadd	 DWORD PTR [edx]
  0016a	e8 00 00 00 00	 call	 __ftol2_sse

; 2852 : 	pMsg.MAXSD = gObj[aIndex].iAddShield+gObj[aIndex].iMaxShield;

  0016f	8b 4d d0	 mov	 ecx, DWORD PTR tv330[ebp]

; 2853 : #endif
; 2854 : 
; 2855 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00172	0f b6 55 d9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00176	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+28], eax
  00179	8b 06		 mov	 eax, DWORD PTR [esi]
  0017b	03 01		 add	 eax, DWORD PTR [ecx]
  0017d	8b 75 b8	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00180	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+32], eax
  00183	52		 push	 edx
  00184	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00187	50		 push	 eax
  00188	56		 push	 esi
  00189	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0018e	83 c4 30	 add	 esp, 48			; 00000030H

; 2856 : 
; 2857 : 	if ( iSendEffect == 1 )

  00191	83 7d 0c 01	 cmp	 DWORD PTR _iSendEffect$[ebp], 1
  00195	5f		 pop	 edi
  00196	5b		 pop	 ebx
  00197	75 0b		 jne	 SHORT $LN1@GCLevelUpM

; 2858 : 		GCSendEffectInfo(aIndex, 0x10);

  00199	6a 10		 push	 16			; 00000010H
  0019b	56		 push	 esi
  0019c	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo
  001a1	83 c4 08	 add	 esp, 8
$LN1@GCLevelUpM:

; 2859 : }

  001a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a7	33 cd		 xor	 ecx, ebp
  001a9	5e		 pop	 esi
  001aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
?GCLevelUpMsgSend@@YAXHH@Z ENDP				; GCLevelUpMsgSend
_TEXT	ENDS
PUBLIC	??_C@_0EO@IHPJKMLA@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@ ; `string'
PUBLIC	??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	??_C@_0DF@EMLONCAM@?$FLAcheron?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Spirit?5M@ ; `string'
PUBLIC	??_C@_0EJ@KBMFDFFG@?$FLImperialGuardianFort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0EH@MPCKANHC@?$FLDoppelganger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dim@ ; `string'
PUBLIC	??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@ ; `string'
PUBLIC	__real@4014000000000000
PUBLIC	__real@40a00000
PUBLIC	??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@ ; `string'
PUBLIC	??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@ ; `string'
PUBLIC	??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@ ; `string'
PUBLIC	??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ; CGItemGetRequest
EXTRN	?PickupRelicSend@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CIllusionTempleEvent::PickupRelicSend
EXTRN	?PickupRelic@CIllusionTempleEvent@@QAEXEHE@Z:PROC ; CIllusionTempleEvent::PickupRelic
EXTRN	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z:PROC ; CBloodCastle::SendNoticeMessage
EXTRN	?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z:PROC ; CBloodCastle::CheckQuestItemSerial
EXTRN	?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z:PROC ; gObjInventoryInsertItem
EXTRN	?ItemByteConvert@@YAXPAEHEEEEEEEEE0E@Z:PROC	; ItemByteConvert
EXTRN	?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z:PROC ; gObjInventoryInsertItemTemp
EXTRN	?CheckOverlapMysteriousPaper@CImperialGuardian@@QAEHHH@Z:PROC ; CImperialGuardian::CheckOverlapMysteriousPaper
EXTRN	?gObjCheckOverlapItemUsingDur@@YAHHHHH@Z:PROC	; gObjCheckOverlapItemUsingDur
EXTRN	?CheckOverlapCsMarks@CCastleSiegeSync@@QAEHH@Z:PROC ; CCastleSiegeSync::CheckOverlapCsMarks
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z:PROC ; CKalimaGate::CheckOverlapKundunMark
EXTRN	?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z:PROC ; gObjOverlapItemUsingDur
EXTRN	?ItemGive@MapClass@@QAEHHH_N@Z:PROC		; MapClass::ItemGive
EXTRN	?CheckItemCount@CQuestInfo@@QAEHHFF@Z:PROC	; CQuestInfo::CheckItemCount
;	COMDAT ??_C@_0EO@IHPJKMLA@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@
CONST	SEGMENT
??_C@_0EO@IHPJKMLA@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@ DB '['
	DB	'Illusion Temple] (%d) (Account:%s, Name:%s) picked up Relics '
	DB	'Item(serial:%u)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) picked up Angel King'
	DB	'''s Weapon (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EMLONCAM@?$FLAcheron?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Spirit?5M@
CONST	SEGMENT
??_C@_0DF@EMLONCAM@?$FLAcheron?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Spirit?5M@ DB '['
	DB	'Acheron] [%s][%s] Make Spirit Map (Left Old Map:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@KBMFDFFG@?$FLImperialGuardianFort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0EJ@KBMFDFFG@?$FLImperialGuardianFort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'ImperialGuardianFort] [%s][%s] Make Imperial Letter (Left Old'
	DB	' Paper:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@MPCKANHC@?$FLDoppelganger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dim@
CONST	SEGMENT
??_C@_0EH@MPCKANHC@?$FLDoppelganger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dim@ DB '['
	DB	'Doppelganger] [%s][%s] Make Dimension Mirror (Left Dimension '
	DB	'Mark:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@
CONST	SEGMENT
??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@ DB '['
	DB	'Kalima] [%s][%s] Make Lost Kalima Map (Left Kundun Mark:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT ??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@
CONST	SEGMENT
??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@ DB '[ Ch'
	DB	'angeRing ] Too many have ChangeRing [%s][%s] ( Name:%s, Count'
	DB	':%d )', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@
CONST	SEGMENT
??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@ DB '[ Moon'
	DB	'StonePendant ] Too many have MoonStonePendant [%s][%s] ( Name'
	DB	':%s, Count:%d )', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@
CONST	SEGMENT
??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@ DB '[Ring'
	DB	' Event] Too many have Magician''s Ring [%s][%s] (Name:%s, Cou'
	DB	'nt:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ DB 'error-L3 : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@
CONST	SEGMENT
??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@ DB '['
	DB	'%s][%s] CGItemGetRequest() Failed : Transaction == 1, IF_TYPE'
	DB	' : %d', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z
_TEXT	SEGMENT
_level$ = -248						; size = 4
_type$ = -244						; size = 4
tv3281 = -240						; size = 4
_item_num$ = -236					; size = 4
_map_num$ = -232					; size = 4
tv4157 = -228						; size = 4
tv3736 = -228						; size = 4
_Bridge$218557 = -228					; size = 4
_NewDur$218501 = -228					; size = 4
_NewDur$218478 = -228					; size = 4
_pos$218450 = -228					; size = 4
_NewDur$218437 = -228					; size = 4
tv3285 = -224						; size = 4
tv3234 = -220						; size = 4
_Bridge$218555 = -220					; size = 4
_NewDur$218532 = -220					; size = 4
_i$218515 = -220					; size = 4
_n$218487 = -220					; size = 4
_n$218464 = -220					; size = 4
_n$218446 = -220					; size = 4
_n$218423 = -220					; size = 4
_pos$218417 = -220					; size = 4
_pos$218399 = -220					; size = 4
_pos$218392 = -220					; size = 4
_pos$218386 = -220					; size = 4
_pos$218380 = -220					; size = 4
tv3558 = -216						; size = 4
_pos$218514 = -216					; size = 4
_pos$218491 = -216					; size = 4
_pos$218468 = -216					; size = 4
_pos$218427 = -216					; size = 4
tv3711 = -214						; size = 2
tv3696 = -214						; size = 2
tv3681 = -214						; size = 2
tv3664 = -214						; size = 2
tv3648 = -214						; size = 2
tv3599 = -214						; size = 2
tv3580 = -214						; size = 2
tv3567 = -214						; size = 2
tv3512 = -214						; size = 2
tv3463 = -214						; size = 2
tv3408 = -214						; size = 2
tv3395 = -214						; size = 2
tv3708 = -212						; size = 4
tv3706 = -212						; size = 4
tv3693 = -212						; size = 4
tv3691 = -212						; size = 4
tv3678 = -212						; size = 4
tv3675 = -212						; size = 4
tv3663 = -212						; size = 4
tv3660 = -212						; size = 4
tv3658 = -212						; size = 4
tv3645 = -212						; size = 4
tv3643 = -212						; size = 4
tv3611 = -212						; size = 4
tv3596 = -212						; size = 4
tv3594 = -212						; size = 4
tv3583 = -212						; size = 4
tv3576 = -212						; size = 4
tv3574 = -212						; size = 4
tv3564 = -212						; size = 4
tv3562 = -212						; size = 4
tv3519 = -212						; size = 4
tv3509 = -212						; size = 4
tv3506 = -212						; size = 4
tv3460 = -212						; size = 4
tv3458 = -212						; size = 4
tv3405 = -212						; size = 4
tv3402 = -212						; size = 4
tv3392 = -212						; size = 4
tv3390 = -212						; size = 4
_pos$218544 = -212					; size = 1
_lpMsg$GSCopy$ = -212					; size = 4
_n$218510 = -212					; size = 4
_pResult$ = -208					; size = 16
_szTempMsg$218558 = -192				; size = 128
_szItemName$ = -64					; size = 50
_NewOption$218549 = -12					; size = 8
_NewOption$218525 = -12					; size = 8
_NewOption$218494 = -12					; size = 8
_NewOption$218471 = -12					; size = 8
_NewOption$218430 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z PROC	; CGItemGetRequest, COMDAT

; 3283 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 3284 : 	int item_num, map_num;
; 3285 : 	PMSG_ITEMGETRESULT pResult;
; 3286 : 	int type;
; 3287 : 	int level;
; 3288 : 	int special;
; 3289 : 	int NOption;
; 3290 : 	char szItemName[50];
; 3291 : 	CMapItem * lpItem;
; 3292 : 
; 3293 : 	pResult.h.c = 0xC3;
; 3294 : 	pResult.h.headcode = 0x22;
; 3295 : 	pResult.h.size = sizeof(pResult);
; 3296 : 	pResult.result = -1;
; 3297 : 
; 3298 : 	if ( !gObjIsConnected(aIndex))

  0001a	53		 push	 ebx

; 3341 : 
; 3342 : 	if ( MAX_ITEM_TYPE_RANGE(item_num) == FALSE )

  0001b	89 85 2c ff ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax
  00021	c6 85 30 ff ff
	ff c3		 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H
  00028	66 c7 85 31 ff
	ff ff 10 22	 mov	 WORD PTR _pResult$[ebp+1], 8720 ; 00002210H
  00031	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00038	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003d	83 c4 04	 add	 esp, 4
  00040	85 c0		 test	 eax, eax
  00042	75 18		 jne	 SHORT $LN120@CGItemGetR

; 3299 : 	{
; 3300 : 		CloseClient(aIndex);

  00044	53		 push	 ebx
  00045	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0004a	83 c4 04	 add	 esp, 4
  0004d	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00051	33 cd		 xor	 ecx, ebp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN120@CGItemGetR:

; 3301 : 		return;
; 3302 : 	}
; 3303 : 
; 3304 : 	if ( gObj[aIndex].CloseType != -1 )

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00061	56		 push	 esi
  00062	8b f3		 mov	 esi, ebx
  00064	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0006a	80 7c 06 0d ff	 cmp	 BYTE PTR [esi+eax+13], -1
  0006f	0f 85 5c 1f 00
	00		 jne	 $LN230@CGItemGetR

; 3305 : 		return;
; 3306 : 
; 3307 : 	if ( gObj[aIndex].DieRegen != 0 )

  00075	80 bc 06 8a 05
	00 00 00	 cmp	 BYTE PTR [esi+eax+1418], 0
  0007d	74 39		 je	 SHORT $LN118@CGItemGetR

; 3308 : 	{
; 3309 : 		pResult.result = -1;
; 3310 : 		pResult.h.size -= sizeof(pResult.Data);

  0007f	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00085	04 f4		 add	 al, 244			; 000000f4H

; 3311 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  00087	0f b6 c8	 movzx	 ecx, al
  0008a	51		 push	 ecx
  0008b	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00091	52		 push	 edx
  00092	53		 push	 ebx
  00093	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  0009a	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  000a0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ad	33 cd		 xor	 ecx, ebp
  000af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
$LN118@CGItemGetR:

; 3312 : 
; 3313 : 		return;
; 3314 : 	}
; 3315 : 
; 3316 : 	if ( gObj[aIndex].m_IfState.use != 0 )

  000b8	8b 84 06 b8 11
	00 00		 mov	 eax, DWORD PTR [esi+eax+4536]
  000bf	a8 03		 test	 al, 3
  000c1	74 5d		 je	 SHORT $LN116@CGItemGetR

; 3317 : 	{
; 3318 : 		if ( gObj[aIndex].m_IfState.type != 3 )

  000c3	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000c8	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000cd	74 51		 je	 SHORT $LN116@CGItemGetR

; 3319 : 		{
; 3320 : 			::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 94)), aIndex, 1);

  000cf	6a 01		 push	 1
  000d1	53		 push	 ebx
  000d2	68 5e 04 00 00	 push	 1118			; 0000045eH
  000d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000dc	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 3321 : 			pResult.result = -1;
; 3322 : 			pResult.h.size -= sizeof(pResult.Data);

  000e7	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  000ed	04 f4		 add	 al, 244			; 000000f4H
  000ef	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 3323 : 			DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  000f5	0f b6 c0	 movzx	 eax, al
  000f8	50		 push	 eax
  000f9	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  000ff	51		 push	 ecx
  00100	53		 push	 ebx
  00101	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00108	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0010d	83 c4 18	 add	 esp, 24			; 00000018H
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  00112	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	33 cd		 xor	 ecx, ebp
  00117	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN116@CGItemGetR:

; 3324 : 
; 3325 : 			return;
; 3326 : 		}
; 3327 : 	}
; 3328 : 
; 3329 : 	if ( !::gObjFixInventoryPointer(aIndex))

  00120	53		 push	 ebx
  00121	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00126	83 c4 04	 add	 esp, 4
  00129	84 c0		 test	 al, al
  0012b	75 18		 jne	 SHORT $LN115@CGItemGetR

; 3330 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0012d	68 02 0d 00 00	 push	 3330			; 00000d02H
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00142	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN115@CGItemGetR:

; 3331 : 
; 3332 : 	if ( gObj[aIndex].pTransaction == TRUE )

  00145	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014a	80 bc 06 cc 11
	00 00 01	 cmp	 BYTE PTR [esi+eax+4556], 1
  00152	75 39		 jne	 SHORT $LN114@CGItemGetR

; 3333 : 	{
; 3334 : 		LogAddTD("[%s][%s] CGItemGetRequest() Failed : Transaction == 1, IF_TYPE : %d",
; 3335 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  00154	8b 94 06 b8 11
	00 00		 mov	 edx, DWORD PTR [esi+eax+4536]
  0015b	c1 ea 06	 shr	 edx, 6
  0015e	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00164	52		 push	 edx
  00165	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00169	51		 push	 ecx
  0016a	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  0016e	52		 push	 edx
  0016f	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0017a	83 c4 10	 add	 esp, 16			; 00000010H
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  0017f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00182	33 cd		 xor	 ecx, ebp
  00184	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c3		 ret	 0
$LN114@CGItemGetR:

; 3336 : 		return;
; 3337 : 
; 3338 : 	}
; 3339 : 
; 3340 : 	item_num = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  0018d	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00193	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00197	0f b6 49 04	 movzx	 ecx, BYTE PTR [ecx+4]
  0019b	66 c1 e2 08	 shl	 dx, 8
  0019f	57		 push	 edi
  001a0	0f b7 fa	 movzx	 edi, dx
  001a3	0b f9		 or	 edi, ecx
  001a5	89 bd 14 ff ff
	ff		 mov	 DWORD PTR _item_num$[ebp], edi

; 3341 : 
; 3342 : 	if ( MAX_ITEM_TYPE_RANGE(item_num) == FALSE )

  001ab	7c 0f		 jl	 SHORT $LN210@CGItemGetR
  001ad	33 c9		 xor	 ecx, ecx
  001af	81 ff 2b 01 00
	00		 cmp	 edi, 299		; 0000012bH
  001b5	0f 9e c1	 setle	 cl
  001b8	85 c9		 test	 ecx, ecx
  001ba	75 4f		 jne	 SHORT $LN113@CGItemGetR
$LN210@CGItemGetR:

; 3343 : 	{
; 3344 : 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  001bc	68 10 0d 00 00	 push	 3344			; 00000d10H
  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 3345 : 		pResult.result = -1;
; 3346 : 		pResult.h.size -= sizeof(pResult.Data);

  001d1	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  001d7	04 f4		 add	 al, 244			; 000000f4H

; 3347 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  001d9	0f b6 d0	 movzx	 edx, al
  001dc	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  001e2	52		 push	 edx
  001e3	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  001e9	50		 push	 eax
  001ea	53		 push	 ebx
  001eb	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  001f2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f7	83 c4 18	 add	 esp, 24			; 00000018H
  001fa	5f		 pop	 edi
  001fb	5e		 pop	 esi
  001fc	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  001fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00200	33 cd		 xor	 ecx, ebp
  00202	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c3		 ret	 0
$LN113@CGItemGetR:

; 3348 : 
; 3349 : 		return;
; 3350 : 	}
; 3351 : 
; 3352 : 	map_num = gObj[aIndex].MapNumber;

  0020b	0f b6 84 06 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+291]
  00213	89 85 18 ff ff
	ff		 mov	 DWORD PTR _map_num$[ebp], eax

; 3353 : 
; 3354 : 	if ( MAX_MAP_RANGE(map_num) == FALSE )

  00219	85 c0		 test	 eax, eax
  0021b	78 0e		 js	 SHORT $LN211@CGItemGetR
  0021d	33 c9		 xor	 ecx, ecx
  0021f	83 f8 63	 cmp	 eax, 99			; 00000063H
  00222	0f 9e c1	 setle	 cl
  00225	8b c1		 mov	 eax, ecx
  00227	85 c0		 test	 eax, eax
  00229	75 4f		 jne	 SHORT $LN112@CGItemGetR
$LN211@CGItemGetR:

; 3355 : 	{
; 3356 : 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  0022b	68 1c 0d 00 00	 push	 3356			; 00000d1cH
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  0023a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 3357 : 		pResult.result = -1;
; 3358 : 		pResult.h.size -= sizeof(pResult.Data);

  00240	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00246	04 f4		 add	 al, 244			; 000000f4H

; 3359 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  00248	0f b6 d0	 movzx	 edx, al
  0024b	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  00251	52		 push	 edx
  00252	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00258	50		 push	 eax
  00259	53		 push	 ebx
  0025a	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00261	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00266	83 c4 18	 add	 esp, 24			; 00000018H
  00269	5f		 pop	 edi
  0026a	5e		 pop	 esi
  0026b	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  0026c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026f	33 cd		 xor	 ecx, ebp
  00271	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00276	8b e5		 mov	 esp, ebp
  00278	5d		 pop	 ebp
  00279	c3		 ret	 0
$LN112@CGItemGetR:

; 3360 : 
; 3361 : 		return;
; 3362 : 	}
; 3363 : 
; 3364 : 	lpItem = &MapC[map_num].m_cItem[item_num];

  0027a	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _map_num$[ebp]
  00280	8b cf		 mov	 ecx, edi
  00282	69 c0 28 38 05
	00		 imul	 eax, 342056		; 00053828H
  00288	69 c9 74 04 00
	00		 imul	 ecx, 1140		; 00000474H
  0028e	8d bc 01 20 00
	00 00		 lea	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+eax+32]

; 3365 : 
; 3366 : 	if ( lpItem->IsItem() == TRUE && lpItem->Give == false && lpItem->live == true)

  00295	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00298	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv3281[ebp], eax
  0029e	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv3285[ebp], ecx
  002a4	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002a9	83 f8 01	 cmp	 eax, 1
  002ac	0f 85 fc 1c 00
	00		 jne	 $LN111@CGItemGetR
  002b2	80 bf db 00 00
	00 00		 cmp	 BYTE PTR [edi+219], 0
  002b9	0f 85 ef 1c 00
	00		 jne	 $LN111@CGItemGetR
  002bf	38 87 da 00 00
	00		 cmp	 BYTE PTR [edi+218], al
  002c5	0f 85 e3 1c 00
	00		 jne	 $LN111@CGItemGetR

; 3367 : 	{
; 3368 : 		if ( lpItem->m_QuestItem != false )

  002cb	80 bf ad 00 00
	00 00		 cmp	 BYTE PTR [edi+173], 0
  002d2	74 19		 je	 SHORT $LN109@CGItemGetR

; 3369 : 		{
; 3370 : 			int bResult = g_QuestInfo.CheckItemCount(aIndex,lpItem->m_Type,lpItem->m_Level);

  002d4	0f b7 57 0c	 movzx	 edx, WORD PTR [edi+12]
  002d8	0f b7 47 0a	 movzx	 eax, WORD PTR [edi+10]
  002dc	52		 push	 edx
  002dd	50		 push	 eax
  002de	53		 push	 ebx
  002df	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  002e4	e8 00 00 00 00	 call	 ?CheckItemCount@CQuestInfo@@QAEHHFF@Z ; CQuestInfo::CheckItemCount

; 3371 : 
; 3372 : 			if ( bResult == FALSE )

  002e9	85 c0		 test	 eax, eax

; 3373 : 			{
; 3374 : 				pResult.result = -1;
; 3375 : 				pResult.h.size -= sizeof(pResult.Data);
; 3376 : 
; 3377 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3378 : 				return;

  002eb	74 1f		 je	 SHORT $LN236@CGItemGetR
$LN109@CGItemGetR:

; 3379 : 			}
; 3380 : 		}
; 3381 : 
; 3382 : 		if ( lpItem->m_Type == ITEMGET(13,20) )	// Wizard Ring

  002ed	b8 14 1a 00 00	 mov	 eax, 6676		; 00001a14H
  002f2	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  002f6	0f 85 c3 00 00
	00		 jne	 $LN227@CGItemGetR

; 3383 : 		{
; 3384 : 			switch ( lpItem->m_Level )

  002fc	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]
  00300	83 e8 00	 sub	 eax, 0
  00303	74 2c		 je	 SHORT $LN105@CGItemGetR
  00305	48		 dec	 eax
  00306	0f 85 b3 00 00
	00		 jne	 $LN227@CGItemGetR
$LN236@CGItemGetR:

; 3400 : 
; 3401 : 						return;
; 3402 : 					}
; 3403 : 					break;
; 3404 : 				}
; 3405 : 				case 1:
; 3406 : 
; 3407 : 					pResult.result = -1;
; 3408 : 					pResult.h.size -= sizeof(pResult.Data);

  0030c	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00312	04 f4		 add	 al, 244			; 000000f4H

; 3409 : 
; 3410 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00314	0f b6 c8	 movzx	 ecx, al
  00317	51		 push	 ecx
  00318	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  0031e	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00325	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  0032b	52		 push	 edx

; 3411 : 					return;

  0032c	e9 96 1c 00 00	 jmp	 $LN232@CGItemGetR
$LN105@CGItemGetR:

; 3385 : 			{
; 3386 : 				case 0:
; 3387 : 				{
; 3388 : 					int iWRCount = gObjGetItemCountInIventory(aIndex, lpItem->m_Type/MAX_SUBTYPE_ITEMS, lpItem->m_Type%MAX_SUBTYPE_ITEMS, lpItem->m_Level);

  00331	6a 00		 push	 0
  00333	6a 14		 push	 20			; 00000014H
  00335	6a 0d		 push	 13			; 0000000dH
  00337	53		 push	 ebx
  00338	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  0033d	83 c4 10	 add	 esp, 16			; 00000010H

; 3389 : 
; 3390 : 					if ( iWRCount > 0 )

  00340	85 c0		 test	 eax, eax
  00342	7e 7b		 jle	 SHORT $LN227@CGItemGetR

; 3391 : 					{
; 3392 : 						LogAdd("[Ring Event] Too many have Magician's Ring [%s][%s] (Name:%s, Count:%d)",
; 3393 : 							gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), iWRCount);

  00344	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  0034a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00350	50		 push	 eax
  00351	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00356	50		 push	 eax
  00357	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  0035a	52		 push	 edx
  0035b	83 c6 52	 add	 esi, 82			; 00000052H
  0035e	56		 push	 esi
  0035f	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@
  00364	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 3394 : 
; 3395 : 						pResult.result = -1;
; 3396 : 						pResult.h.size -= sizeof(pResult.Data);

  0036a	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00370	04 f4		 add	 al, 244			; 000000f4H
  00372	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 3397 : 
; 3398 : 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00378	0f b6 c0	 movzx	 eax, al
  0037b	50		 push	 eax
  0037c	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00382	51		 push	 ecx
  00383	53		 push	 ebx
  00384	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  0038b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00390	83 c4 20	 add	 esp, 32			; 00000020H

; 3399 : 						::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 186)), aIndex, 1);

  00393	6a 01		 push	 1
  00395	53		 push	 ebx
  00396	68 ba 04 00 00	 push	 1210			; 000004baH
$LN237@CGItemGetR:
  0039b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003a0	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003a5	50		 push	 eax
  003a6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 4038 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  003ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ae	5f		 pop	 edi
  003af	5e		 pop	 esi
  003b0	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  003b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b4	33 cd		 xor	 ecx, ebp
  003b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003bb	8b e5		 mov	 esp, ebp
  003bd	5d		 pop	 ebp
  003be	c3		 ret	 0
$LN227@CGItemGetR:

; 3412 : 				
; 3413 : 			}
; 3414 : 		}
; 3415 : 
; 3416 : 		if ( lpItem->m_Type == ITEMGET(13,20) && lpItem->m_Level == 2 )	// Wizard Ring

  003bf	0f b7 47 0a	 movzx	 eax, WORD PTR [edi+10]
  003c3	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  003c8	66 3b c2	 cmp	 ax, dx
  003cb	75 2c		 jne	 SHORT $LN102@CGItemGetR
  003cd	66 83 7f 0c 02	 cmp	 WORD PTR [edi+12], 2
  003d2	75 25		 jne	 SHORT $LN102@CGItemGetR
$LN94@CGItemGetR:

; 3417 : 		{
; 3418 : 			pResult.result = -1;
; 3419 : 			pResult.h.size -= sizeof(pResult.Data);

  003d4	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  003da	04 f4		 add	 al, 244			; 000000f4H
  003dc	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 3420 : 
; 3421 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  003e2	0f b6 c0	 movzx	 eax, al
  003e5	50		 push	 eax
  003e6	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  003ec	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  003f3	51		 push	 ecx

; 3422 : 
; 3423 : 			return;

  003f4	e9 ce 1b 00 00	 jmp	 $LN232@CGItemGetR
$LN102@CGItemGetR:

; 3424 : 		}
; 3425 : 
; 3426 : 		if ( lpItem->m_Type == ITEMGET(13,38) )	// MoonStonePendant

  003f9	ba 26 1a 00 00	 mov	 edx, 6694		; 00001a26H
  003fe	66 3b c2	 cmp	 ax, dx
  00401	75 72		 jne	 SHORT $LN100@CGItemGetR

; 3427 : 		{
; 3428 : 			int count = gObjGetItemCountInIventory(aIndex, lpItem->m_Type/MAX_SUBTYPE_ITEMS,
; 3429 : 				lpItem->m_Type % MAX_SUBTYPE_ITEMS, lpItem->m_Level);

  00403	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]
  00407	50		 push	 eax
  00408	6a 26		 push	 38			; 00000026H
  0040a	6a 0d		 push	 13			; 0000000dH
  0040c	53		 push	 ebx
  0040d	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  00412	83 c4 10	 add	 esp, 16			; 00000010H

; 3430 : 
; 3431 : 			if ( count > 0 )

  00415	85 c0		 test	 eax, eax
  00417	7e 5c		 jle	 SHORT $LN100@CGItemGetR

; 3432 : 			{
; 3433 : 				LogAdd("[ MoonStonePendant ] Too many have MoonStonePendant [%s][%s] ( Name:%s, Count:%d )",
; 3434 : 					gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), count);

  00419	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  0041f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00425	50		 push	 eax
  00426	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0042b	50		 push	 eax
  0042c	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  0042f	52		 push	 edx
  00430	83 c6 52	 add	 esi, 82			; 00000052H
  00433	56		 push	 esi
  00434	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@
  00439	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 3435 : 
; 3436 : 				pResult.result = -1;
; 3437 : 				pResult.h.size -= sizeof(pResult.Data);

  0043f	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00445	04 f4		 add	 al, 244			; 000000f4H
  00447	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 3438 : 
; 3439 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);	

  0044d	0f b6 c0	 movzx	 eax, al
  00450	50		 push	 eax
  00451	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00457	51		 push	 ecx
  00458	53		 push	 ebx
  00459	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00460	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00465	83 c4 20	 add	 esp, 32			; 00000020H

; 3440 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(13, 56)), aIndex, 1);

  00468	6a 01		 push	 1
  0046a	53		 push	 ebx
  0046b	68 38 0d 00 00	 push	 3384			; 00000d38H

; 3441 : 
; 3442 : 				return;

  00470	e9 26 ff ff ff	 jmp	 $LN237@CGItemGetR
$LN100@CGItemGetR:

; 3443 : 			}
; 3444 : 		}
; 3445 : 
; 3446 : 		if ( lpItem->m_Type == ITEMGET(13,39) )	// ChangeRing

  00475	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  0047a	66 39 57 0a	 cmp	 WORD PTR [edi+10], dx
  0047e	75 72		 jne	 SHORT $LN98@CGItemGetR

; 3447 : 		{
; 3448 : 			int count = gObjGetItemCountInIventory(aIndex, lpItem->m_Type/MAX_SUBTYPE_ITEMS,
; 3449 : 				lpItem->m_Type % MAX_SUBTYPE_ITEMS, lpItem->m_Level);

  00480	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]
  00484	50		 push	 eax
  00485	6a 27		 push	 39			; 00000027H
  00487	6a 0d		 push	 13			; 0000000dH
  00489	53		 push	 ebx
  0048a	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  0048f	83 c4 10	 add	 esp, 16			; 00000010H

; 3450 : 
; 3451 : 			if ( count > 0 )

  00492	85 c0		 test	 eax, eax
  00494	7e 5c		 jle	 SHORT $LN98@CGItemGetR

; 3452 : 			{
; 3453 : 				LogAdd("[ ChangeRing ] Too many have ChangeRing [%s][%s] ( Name:%s, Count:%d )",
; 3454 : 					gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), count);

  00496	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  0049c	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004a2	50		 push	 eax
  004a3	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  004a8	50		 push	 eax
  004a9	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  004ac	52		 push	 edx
  004ad	83 c6 52	 add	 esi, 82			; 00000052H
  004b0	56		 push	 esi
  004b1	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@
  004b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 3455 : 
; 3456 : 				pResult.result = -1;
; 3457 : 				pResult.h.size -= sizeof(pResult.Data);

  004bc	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  004c2	04 f4		 add	 al, 244			; 000000f4H
  004c4	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 3458 : 
; 3459 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);	

  004ca	0f b6 c0	 movzx	 eax, al
  004cd	50		 push	 eax
  004ce	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  004d4	51		 push	 ecx
  004d5	53		 push	 ebx
  004d6	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  004dd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004e2	83 c4 20	 add	 esp, 32			; 00000020H

; 3460 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(13, 63)), aIndex, 1);

  004e5	6a 01		 push	 1
  004e7	53		 push	 ebx
  004e8	68 3f 0d 00 00	 push	 3391			; 00000d3fH

; 3461 : 
; 3462 : 				return;

  004ed	e9 a9 fe ff ff	 jmp	 $LN237@CGItemGetR
$LN98@CGItemGetR:

; 3463 : 			}
; 3464 : 		}
; 3465 : 
; 3466 : 		type = lpItem->m_Type;

  004f2	0f bf 57 0a	 movsx	 edx, WORD PTR [edi+10]

; 3467 : 		level = lpItem->m_Level;

  004f6	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]

; 3468 : 		special = lpItem->m_Special[0];
; 3469 : 		NOption = lpItem->m_NewOption;
; 3470 : 		strcpy(szItemName, lpItem->GetName());

  004fa	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  00500	89 95 0c ff ff
	ff		 mov	 DWORD PTR _type$[ebp], edx
  00506	89 85 08 ff ff
	ff		 mov	 DWORD PTR _level$[ebp], eax
  0050c	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00511	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$[ebp]
  00514	2b d0		 sub	 edx, eax
$LL127@CGItemGetR:
  00516	8a 08		 mov	 cl, BYTE PTR [eax]
  00518	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  0051b	40		 inc	 eax
  0051c	84 c9		 test	 cl, cl
  0051e	75 f6		 jne	 SHORT $LL127@CGItemGetR

; 3471 : 
; 3472 : 		if ( lpItem->m_Type == ITEMGET(14,15) ) // Zen

  00520	0f b7 47 0a	 movzx	 eax, WORD PTR [edi+10]
  00524	b9 0f 1c 00 00	 mov	 ecx, 7183		; 00001c0fH
  00529	66 3b c1	 cmp	 ax, cx
  0052c	0f 85 0a 01 00
	00		 jne	 $LN97@CGItemGetR

; 3473 : 		{
; 3474 : 			if ( MapC[map_num].ItemGive(aIndex, item_num, false) == TRUE )

  00532	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _item_num$[ebp]
  00538	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv3281[ebp]
  0053e	6a 00		 push	 0
  00540	52		 push	 edx
  00541	53		 push	 ebx
  00542	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  00548	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  0054d	83 f8 01	 cmp	 eax, 1
  00550	0f 85 d2 00 00
	00		 jne	 $LN223@CGItemGetR

; 3475 : 			{
; 3476 : 				if ( !gObjCheckMaxZen(aIndex, lpItem->m_BuyMoney))

  00556	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
  00559	50		 push	 eax
  0055a	53		 push	 ebx
  0055b	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  00560	83 c4 08	 add	 esp, 8
  00563	85 c0		 test	 eax, eax

; 3477 : 				{
; 3478 : 					if ( gObj[aIndex].Money < MAX_ZEN )

  00565	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0056a	75 6c		 jne	 SHORT $LN95@CGItemGetR
  0056c	b9 00 94 35 77	 mov	 ecx, 2000000000		; 77359400H
  00571	39 8c 06 cc 00
	00 00		 cmp	 DWORD PTR [esi+eax+204], ecx
  00578	0f 8d 56 fe ff
	ff		 jge	 $LN94@CGItemGetR

; 3479 : 					{
; 3480 : 						gObj[aIndex].Money = MAX_ZEN;

  0057e	89 8c 06 cc 00
	00 00		 mov	 DWORD PTR [esi+eax+204], ecx

; 3481 : 						pResult.result = -2;
; 3482 : 						WORD hiWord = SET_NUMBERHW(gObj[aIndex].Money);

  00585	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0058b	c6 85 33 ff ff
	ff fe		 mov	 BYTE PTR _pResult$[ebp+3], 254 ; 000000feH
  00592	0f b7 84 0e ce
	00 00 00	 movzx	 eax, WORD PTR [esi+ecx+206]

; 3483 : 						WORD loWord = SET_NUMBERLW(gObj[aIndex].Money);

  0059a	0f b7 8c 0e cc
	00 00 00	 movzx	 ecx, WORD PTR [esi+ecx+204]

; 3484 : 						pResult.Data[0] = SET_NUMBERH(hiWord);

  005a2	8b d0		 mov	 edx, eax

; 3485 : 						pResult.Data[1] = SET_NUMBERL(hiWord);

  005a4	88 85 35 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+5], al

; 3486 : 						pResult.Data[2] = SET_NUMBERH(loWord);

  005aa	8b c1		 mov	 eax, ecx
  005ac	c1 ea 08	 shr	 edx, 8

; 3487 : 						pResult.Data[3] = SET_NUMBERL(loWord);

  005af	88 8d 37 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+7], cl

; 3488 : 
; 3489 : 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  005b5	0f b6 8d 31 ff
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  005bc	88 95 34 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+4], dl
  005c2	c1 e8 08	 shr	 eax, 8
  005c5	51		 push	 ecx
  005c6	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  005cc	88 85 36 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+6], al
  005d2	52		 push	 edx

; 3490 : 
; 3491 : 						return;

  005d3	e9 ef 19 00 00	 jmp	 $LN232@CGItemGetR
$LN95@CGItemGetR:

; 3492 : 					}
; 3493 : 
; 3494 : 					pResult.result = -1;
; 3495 : 					pResult.h.size -= sizeof(pResult.Data);
; 3496 : 
; 3497 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			
; 3498 : 
; 3499 : 					return;
; 3500 : 				}
; 3501 : 
; 3502 : 				gObj[aIndex].Money += lpItem->m_BuyMoney;

  005d8	8b 57 7c	 mov	 edx, DWORD PTR [edi+124]
  005db	01 94 06 cc 00
	00 00		 add	 DWORD PTR [esi+eax+204], edx

; 3503 : 				pResult.result = -2;
; 3504 : 
; 3505 : 				WORD hiWord = SET_NUMBERHW(gObj[aIndex].Money);

  005e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005e8	c6 85 33 ff ff
	ff fe		 mov	 BYTE PTR _pResult$[ebp+3], 254 ; 000000feH
  005ef	0f b7 84 0e ce
	00 00 00	 movzx	 eax, WORD PTR [esi+ecx+206]

; 3506 : 				WORD loWord = SET_NUMBERLW(gObj[aIndex].Money);

  005f7	0f b7 8c 0e cc
	00 00 00	 movzx	 ecx, WORD PTR [esi+ecx+204]

; 3507 : 				pResult.Data[0] = SET_NUMBERH(hiWord);

  005ff	8b d0		 mov	 edx, eax

; 3508 : 				pResult.Data[1] = SET_NUMBERL(hiWord);

  00601	88 85 35 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+5], al

; 3509 : 				pResult.Data[2] = SET_NUMBERH(loWord);

  00607	8b c1		 mov	 eax, ecx
  00609	c1 ea 08	 shr	 edx, 8
  0060c	c1 e8 08	 shr	 eax, 8

; 3510 : 				pResult.Data[3] = SET_NUMBERL(loWord);
; 3511 : 				pResult.h.size -= 3;

  0060f	80 85 31 ff ff
	ff fd		 add	 BYTE PTR _pResult$[ebp+1], 253 ; 000000fdH
  00616	88 95 34 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+4], dl
  0061c	88 85 36 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+6], al
  00622	88 8d 37 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+7], cl
$LN223@CGItemGetR:

; 3512 : 			}
; 3513 : 
; 3514 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00628	0f b6 8d 31 ff
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  0062f	51		 push	 ecx
  00630	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00636	52		 push	 edx

; 3515 : 
; 3516 : 		}
; 3517 : 		else

  00637	e9 8b 19 00 00	 jmp	 $LN232@CGItemGetR
$LN97@CGItemGetR:

; 3518 : 		{
; 3519 : 			if ( lpItem->m_Type == ITEMGET(13,32) )

  0063c	b9 20 1a 00 00	 mov	 ecx, 6688		; 00001a20H
  00641	66 3b c1	 cmp	 ax, cx
  00644	0f 85 f0 00 00
	00		 jne	 $LN91@CGItemGetR

; 3520 : 			{
; 3521 : 
; 3522 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 20, ITEMGET(13,32), 0);

  0064a	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _item_num$[ebp]
  00650	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _map_num$[ebp]
  00656	6a 00		 push	 0
  00658	51		 push	 ecx
  00659	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  0065f	6a 14		 push	 20			; 00000014H
  00661	53		 push	 ebx
  00662	52		 push	 edx
  00663	50		 push	 eax
  00664	51		 push	 ecx
  00665	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  0066a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0066d	89 85 24 ff ff
	ff		 mov	 DWORD PTR _pos$218380[ebp], eax

; 3523 : 
; 3524 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  00673	85 c0		 test	 eax, eax
  00675	0f 88 bf 00 00
	00		 js	 $LN91@CGItemGetR
  0067b	33 c0		 xor	 eax, eax
  0067d	81 bd 24 ff ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$218380[ebp], 203 ; 000000cbH
  00687	0f 9e c0	 setle	 al
  0068a	85 c0		 test	 eax, eax
  0068c	0f 84 a8 00 00
	00		 je	 $LN91@CGItemGetR

; 3525 : 				{
; 3526 : 					pResult.result = -3;
; 3527 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00692	0f b6 95 31 ff
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00699	52		 push	 edx
  0069a	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  006a0	50		 push	 eax
  006a1	53		 push	 ebx
  006a2	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  006a9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3528 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  006ae	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _pos$218380[ebp]
  006b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006ba	d9 47 28	 fld	 DWORD PTR [edi+40]
  006bd	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]

; 3529 : 					GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  006c4	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3711[ebp]
  006ca	8b c2		 mov	 eax, edx
  006cc	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  006d2	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  006d6	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  006da	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  006de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006e4	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  006eb	6a 00		 push	 0
  006ed	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  006f1	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3711[ebp]
  006f8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  006fd	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3708[ebp], eax
  00703	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3708[ebp]
  00709	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3706[ebp]
  0070f	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv3706[ebp]
  00715	0f b6 c8	 movzx	 ecx, al
  00718	51		 push	 ecx
  00719	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3711[ebp]
  0071f	52		 push	 edx
  00720	53		 push	 ebx
  00721	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00726	83 c4 1c	 add	 esp, 28			; 0000001cH
  00729	5f		 pop	 edi
  0072a	5e		 pop	 esi
  0072b	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  0072c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0072f	33 cd		 xor	 ecx, ebp
  00731	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00736	8b e5		 mov	 esp, ebp
  00738	5d		 pop	 ebp
  00739	c3		 ret	 0
$LN91@CGItemGetR:

; 3530 : 
; 3531 : 					return;
; 3532 : 				}
; 3533 : 			}
; 3534 : 
; 3535 : 			if ( lpItem->m_Type == ITEMGET(13,33) )

  0073a	ba 21 1a 00 00	 mov	 edx, 6689		; 00001a21H
  0073f	66 39 57 0a	 cmp	 WORD PTR [edi+10], dx
  00743	0f 85 f0 00 00
	00		 jne	 $LN89@CGItemGetR

; 3536 : 			{
; 3537 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 20, ITEMGET(13,33), 0);

  00749	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _item_num$[ebp]
  0074f	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _map_num$[ebp]
  00755	6a 00		 push	 0
  00757	52		 push	 edx
  00758	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv3285[ebp]
  0075e	6a 14		 push	 20			; 00000014H
  00760	53		 push	 ebx
  00761	50		 push	 eax
  00762	51		 push	 ecx
  00763	52		 push	 edx
  00764	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  00769	83 c4 1c	 add	 esp, 28			; 0000001cH
  0076c	89 85 24 ff ff
	ff		 mov	 DWORD PTR _pos$218386[ebp], eax

; 3538 : 
; 3539 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  00772	85 c0		 test	 eax, eax
  00774	0f 88 bf 00 00
	00		 js	 $LN89@CGItemGetR
  0077a	33 c0		 xor	 eax, eax
  0077c	81 bd 24 ff ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$218386[ebp], 203 ; 000000cbH
  00786	0f 9e c0	 setle	 al
  00789	85 c0		 test	 eax, eax
  0078b	0f 84 a8 00 00
	00		 je	 $LN89@CGItemGetR

; 3540 : 				{
; 3541 : 					pResult.result = -3;
; 3542 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00791	0f b6 85 31 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00798	50		 push	 eax
  00799	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  0079f	51		 push	 ecx
  007a0	53		 push	 ebx
  007a1	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  007a8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3543 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  007ad	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _pos$218386[ebp]
  007b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007b9	d9 47 28	 fld	 DWORD PTR [edi+40]
  007bc	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]

; 3544 : 					GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  007c3	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3696[ebp]
  007c9	8b c2		 mov	 eax, edx
  007cb	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  007d1	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  007d5	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  007d9	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  007dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007e3	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  007ea	6a 00		 push	 0
  007ec	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  007f0	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3696[ebp]
  007f7	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  007fc	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3693[ebp], eax
  00802	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3693[ebp]
  00808	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3691[ebp]
  0080e	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv3691[ebp]
  00814	0f b6 c8	 movzx	 ecx, al
  00817	51		 push	 ecx
  00818	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3696[ebp]
  0081e	52		 push	 edx
  0081f	53		 push	 ebx
  00820	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00825	83 c4 1c	 add	 esp, 28			; 0000001cH
  00828	5f		 pop	 edi
  00829	5e		 pop	 esi
  0082a	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  0082b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0082e	33 cd		 xor	 ecx, ebp
  00830	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00835	8b e5		 mov	 esp, ebp
  00837	5d		 pop	 ebp
  00838	c3		 ret	 0
$LN89@CGItemGetR:

; 3545 : 
; 3546 : 					return;
; 3547 : 				}
; 3548 : 			}
; 3549 : 
; 3550 : 			if ( lpItem->m_Type == ITEMGET(13,34) )

  00839	ba 22 1a 00 00	 mov	 edx, 6690		; 00001a22H
  0083e	66 39 57 0a	 cmp	 WORD PTR [edi+10], dx
  00842	0f 85 f0 00 00
	00		 jne	 $LN87@CGItemGetR

; 3551 : 			{
; 3552 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 10, ITEMGET(13,34), 0);

  00848	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _item_num$[ebp]
  0084e	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _map_num$[ebp]
  00854	6a 00		 push	 0
  00856	52		 push	 edx
  00857	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv3285[ebp]
  0085d	6a 0a		 push	 10			; 0000000aH
  0085f	53		 push	 ebx
  00860	50		 push	 eax
  00861	51		 push	 ecx
  00862	52		 push	 edx
  00863	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  00868	83 c4 1c	 add	 esp, 28			; 0000001cH
  0086b	89 85 24 ff ff
	ff		 mov	 DWORD PTR _pos$218392[ebp], eax

; 3553 : 
; 3554 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  00871	85 c0		 test	 eax, eax
  00873	0f 88 bf 00 00
	00		 js	 $LN87@CGItemGetR
  00879	33 c0		 xor	 eax, eax
  0087b	81 bd 24 ff ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$218392[ebp], 203 ; 000000cbH
  00885	0f 9e c0	 setle	 al
  00888	85 c0		 test	 eax, eax
  0088a	0f 84 a8 00 00
	00		 je	 $LN87@CGItemGetR

; 3555 : 				{
; 3556 : 					pResult.result = -3;
; 3557 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00890	0f b6 85 31 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00897	50		 push	 eax
  00898	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  0089e	51		 push	 ecx
  0089f	53		 push	 ebx
  008a0	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  008a7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3558 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  008ac	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _pos$218392[ebp]
  008b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008b8	d9 47 28	 fld	 DWORD PTR [edi+40]
  008bb	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]

; 3559 : 					GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  008c2	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3681[ebp]
  008c8	8b c2		 mov	 eax, edx
  008ca	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  008d0	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  008d4	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  008d8	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  008dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008e2	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  008e9	6a 00		 push	 0
  008eb	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  008ef	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3681[ebp]
  008f6	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  008fb	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3678[ebp], eax
  00901	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3678[ebp]
  00907	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3675[ebp]
  0090d	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv3675[ebp]
  00913	0f b6 c8	 movzx	 ecx, al
  00916	51		 push	 ecx
  00917	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3681[ebp]
  0091d	52		 push	 edx
  0091e	53		 push	 ebx
  0091f	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00924	83 c4 1c	 add	 esp, 28			; 0000001cH
  00927	5f		 pop	 edi
  00928	5e		 pop	 esi
  00929	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  0092a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0092d	33 cd		 xor	 ecx, ebp
  0092f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00934	8b e5		 mov	 esp, ebp
  00936	5d		 pop	 ebp
  00937	c3		 ret	 0
$LN87@CGItemGetR:

; 3560 : 
; 3561 : 					return;
; 3562 : 				}
; 3563 : 			}
; 3564 : 
; 3565 : 			if ( lpItem->m_Type == ITEMGET(14,70) ||
; 3566 : 				 lpItem->m_Type == ITEMGET(14,71) ||
; 3567 : 				 lpItem->m_Type == ITEMGET(14,94) )

  00938	0f b7 47 0a	 movzx	 eax, WORD PTR [edi+10]
  0093c	ba 46 1c 00 00	 mov	 edx, 7238		; 00001c46H
  00941	66 3b c2	 cmp	 ax, dx
  00944	74 18		 je	 SHORT $LN85@CGItemGetR
  00946	b9 47 1c 00 00	 mov	 ecx, 7239		; 00001c47H
  0094b	66 3b c1	 cmp	 ax, cx
  0094e	74 0e		 je	 SHORT $LN85@CGItemGetR
  00950	ba 5e 1c 00 00	 mov	 edx, 7262		; 00001c5eH
  00955	66 3b c2	 cmp	 ax, dx
  00958	0f 85 f1 00 00
	00		 jne	 $LN84@CGItemGetR
$LN85@CGItemGetR:

; 3568 : 			{
; 3569 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 50, lpItem->m_Type, 0);

  0095e	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _item_num$[ebp]
  00964	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  0096a	6a 00		 push	 0
  0096c	98		 cwde
  0096d	50		 push	 eax
  0096e	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv3285[ebp]
  00974	6a 32		 push	 50			; 00000032H
  00976	53		 push	 ebx
  00977	51		 push	 ecx
  00978	52		 push	 edx
  00979	50		 push	 eax
  0097a	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  0097f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00982	89 85 24 ff ff
	ff		 mov	 DWORD PTR _pos$218399[ebp], eax

; 3570 : 
; 3571 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  00988	85 c0		 test	 eax, eax
  0098a	0f 88 bf 00 00
	00		 js	 $LN84@CGItemGetR
  00990	33 c0		 xor	 eax, eax
  00992	81 bd 24 ff ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$218399[ebp], 203 ; 000000cbH
  0099c	0f 9e c0	 setle	 al
  0099f	85 c0		 test	 eax, eax
  009a1	0f 84 a8 00 00
	00		 je	 $LN84@CGItemGetR

; 3572 : 				{
; 3573 : 					pResult.result = -3;
; 3574 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  009a7	0f b6 8d 31 ff
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  009ae	51		 push	 ecx
  009af	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  009b5	52		 push	 edx
  009b6	53		 push	 ebx
  009b7	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  009be	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3575 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  009c3	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _pos$218399[ebp]
  009c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009cf	d9 47 28	 fld	 DWORD PTR [edi+40]
  009d2	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]

; 3576 : 					GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  009d9	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3664[ebp]
  009df	8b c2		 mov	 eax, edx
  009e1	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  009e7	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  009eb	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  009ef	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  009f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009f9	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  00a00	6a 00		 push	 0
  00a02	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  00a06	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3664[ebp]
  00a0d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00a12	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3660[ebp], eax
  00a18	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3660[ebp]
  00a1e	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3658[ebp]
  00a24	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv3658[ebp]
  00a2a	0f b6 c8	 movzx	 ecx, al
  00a2d	51		 push	 ecx
  00a2e	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3664[ebp]
  00a34	52		 push	 edx
  00a35	53		 push	 ebx
  00a36	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00a3b	83 c4 1c	 add	 esp, 28			; 0000001cH
  00a3e	5f		 pop	 edi
  00a3f	5e		 pop	 esi
  00a40	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  00a41	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a44	33 cd		 xor	 ecx, ebp
  00a46	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a4b	8b e5		 mov	 esp, ebp
  00a4d	5d		 pop	 ebp
  00a4e	c3		 ret	 0
$LN84@CGItemGetR:

; 3577 : 
; 3578 : 					return;
; 3579 : 				}
; 3580 : 			}
; 3581 : 
; 3582 : 			if ( lpItem->m_Type == ITEMGET(14,88) ||
; 3583 : 				 lpItem->m_Type == ITEMGET(14,89) ||
; 3584 : 				 lpItem->m_Type == ITEMGET(14,90) ||
; 3585 : 				 lpItem->m_Type == ITEMGET(14,85) ||
; 3586 : 				 lpItem->m_Type == ITEMGET(14,86) ||
; 3587 : 				 lpItem->m_Type == ITEMGET(14,87) )

  00a4f	0f b7 4f 0a	 movzx	 ecx, WORD PTR [edi+10]
  00a53	ba 58 1c 00 00	 mov	 edx, 7256		; 00001c58H
  00a58	66 3b ca	 cmp	 cx, dx
  00a5b	74 36		 je	 SHORT $LN82@CGItemGetR
  00a5d	b8 59 1c 00 00	 mov	 eax, 7257		; 00001c59H
  00a62	66 3b c8	 cmp	 cx, ax
  00a65	74 2c		 je	 SHORT $LN82@CGItemGetR
  00a67	ba 5a 1c 00 00	 mov	 edx, 7258		; 00001c5aH
  00a6c	66 3b ca	 cmp	 cx, dx
  00a6f	74 22		 je	 SHORT $LN82@CGItemGetR
  00a71	b8 55 1c 00 00	 mov	 eax, 7253		; 00001c55H
  00a76	66 3b c8	 cmp	 cx, ax
  00a79	74 18		 je	 SHORT $LN82@CGItemGetR
  00a7b	ba 56 1c 00 00	 mov	 edx, 7254		; 00001c56H
  00a80	66 3b ca	 cmp	 cx, dx
  00a83	74 0e		 je	 SHORT $LN82@CGItemGetR
  00a85	b8 57 1c 00 00	 mov	 eax, 7255		; 00001c57H
  00a8a	66 3b c8	 cmp	 cx, ax
  00a8d	0f 85 23 01 00
	00		 jne	 $LN73@CGItemGetR
$LN82@CGItemGetR:

; 3588 : 			{
; 3589 : 				int Dur = 1;
; 3590 : 
; 3591 : 				switch( lpItem->m_Type )

  00a93	0f bf c9	 movsx	 ecx, cx
  00a96	8d 91 ab e3 ff
	ff		 lea	 edx, DWORD PTR [ecx-7253]
  00a9c	b8 01 00 00 00	 mov	 eax, 1
  00aa1	83 fa 05	 cmp	 edx, 5
  00aa4	77 21		 ja	 SHORT $LN80@CGItemGetR
  00aa6	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN238@CGItemGetR[edx*4]
$LN79@CGItemGetR:

; 3592 : 				{
; 3593 : 				case ITEMGET(14,88):
; 3594 : 					Dur = 10;

  00aad	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH

; 3595 : 					break;

  00ab2	eb 13		 jmp	 SHORT $LN80@CGItemGetR
$LN78@CGItemGetR:

; 3596 : 				case ITEMGET(14,89):
; 3597 : 					Dur = 30;

  00ab4	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH

; 3598 : 					break;

  00ab9	eb 0c		 jmp	 SHORT $LN80@CGItemGetR
$LN77@CGItemGetR:

; 3599 : 				case ITEMGET(14,90):
; 3600 : 					Dur = 255;

  00abb	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH

; 3601 : 					break;
; 3602 : 				case ITEMGET(14,85):
; 3603 : 					Dur = 3;
; 3604 : 					break;

  00ac0	eb 05		 jmp	 SHORT $LN80@CGItemGetR
$LN74@CGItemGetR:

; 3605 : 				case ITEMGET(14,86):
; 3606 : 					Dur = 3;
; 3607 : 					break;
; 3608 : 				case ITEMGET(14,87):
; 3609 : 					Dur = 3;

  00ac2	b8 03 00 00 00	 mov	 eax, 3
$LN80@CGItemGetR:

; 3610 : 					break;
; 3611 : 				}
; 3612 : 
; 3613 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, Dur, lpItem->m_Type, 0);

  00ac7	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  00acd	6a 00		 push	 0
  00acf	51		 push	 ecx
  00ad0	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _item_num$[ebp]
  00ad6	50		 push	 eax
  00ad7	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv3285[ebp]
  00add	53		 push	 ebx
  00ade	51		 push	 ecx
  00adf	52		 push	 edx
  00ae0	50		 push	 eax
  00ae1	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  00ae6	83 c4 1c	 add	 esp, 28			; 0000001cH
  00ae9	89 85 24 ff ff
	ff		 mov	 DWORD PTR _pos$218417[ebp], eax

; 3614 : 
; 3615 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  00aef	85 c0		 test	 eax, eax
  00af1	0f 88 bf 00 00
	00		 js	 $LN73@CGItemGetR
  00af7	33 c0		 xor	 eax, eax
  00af9	81 bd 24 ff ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$218417[ebp], 203 ; 000000cbH
  00b03	0f 9e c0	 setle	 al
  00b06	85 c0		 test	 eax, eax
  00b08	0f 84 a8 00 00
	00		 je	 $LN73@CGItemGetR

; 3616 : 				{
; 3617 : 					pResult.result = -3;
; 3618 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00b0e	0f b6 8d 31 ff
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00b15	51		 push	 ecx
  00b16	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00b1c	52		 push	 edx
  00b1d	53		 push	 ebx
  00b1e	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  00b25	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3619 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  00b2a	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _pos$218417[ebp]
  00b30	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b36	d9 47 28	 fld	 DWORD PTR [edi+40]
  00b39	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]

; 3620 : 					GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  00b40	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3648[ebp]
  00b46	8b c2		 mov	 eax, edx
  00b48	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00b4e	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  00b52	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  00b56	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  00b5a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b60	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  00b67	6a 00		 push	 0
  00b69	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  00b6d	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3648[ebp]
  00b74	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00b79	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3645[ebp], eax
  00b7f	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3645[ebp]
  00b85	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3643[ebp]
  00b8b	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv3643[ebp]
  00b91	0f b6 c8	 movzx	 ecx, al
  00b94	51		 push	 ecx
  00b95	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3648[ebp]
  00b9b	52		 push	 edx
  00b9c	53		 push	 ebx
  00b9d	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00ba2	83 c4 1c	 add	 esp, 28			; 0000001cH
  00ba5	5f		 pop	 edi
  00ba6	5e		 pop	 esi
  00ba7	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  00ba8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bab	33 cd		 xor	 ecx, ebp
  00bad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bb2	8b e5		 mov	 esp, ebp
  00bb4	5d		 pop	 ebp
  00bb5	c3		 ret	 0
$LN73@CGItemGetR:

; 3621 : 
; 3622 : 					return;
; 3623 : 				}
; 3624 : 			}
; 3625 : 			
; 3626 : 			if ( lpItem->m_Type == ITEMGET(14,29) ) // Symbol of Kundun

  00bb6	ba 1d 1c 00 00	 mov	 edx, 7197		; 00001c1dH
  00bbb	66 39 57 0a	 cmp	 WORD PTR [edi+10], dx
  00bbf	0f 85 bd 02 00
	00		 jne	 $LN225@CGItemGetR

; 3627 : 			{
; 3628 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00bc5	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$218423[ebp], 0
  00bcf	90		 npad	 1
$LL71@CGItemGetR:

; 3629 : 				{
; 3630 : 					int pos = ::g_KalimaGate.CheckOverlapKundunMark(aIndex, lpItem->m_Level);

  00bd0	0f b6 47 0c	 movzx	 eax, BYTE PTR [edi+12]
  00bd4	50		 push	 eax
  00bd5	53		 push	 ebx
  00bd6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  00bdb	e8 00 00 00 00	 call	 ?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z ; CKalimaGate::CheckOverlapKundunMark
  00be0	89 85 28 ff ff
	ff		 mov	 DWORD PTR _pos$218427[ebp], eax

; 3631 : 
; 3632 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  00be6	85 c0		 test	 eax, eax
  00be8	0f 88 94 02 00
	00		 js	 $LN225@CGItemGetR
  00bee	33 c0		 xor	 eax, eax
  00bf0	81 bd 28 ff ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$218427[ebp], 203 ; 000000cbH
  00bfa	0f 9e c0	 setle	 al
  00bfd	85 c0		 test	 eax, eax
  00bff	0f 84 7d 02 00
	00		 je	 $LN225@CGItemGetR

; 3633 : 					{
; 3634 : 						if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  00c05	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _item_num$[ebp]
  00c0b	6a 01		 push	 1
  00c0d	51		 push	 ecx
  00c0e	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv3281[ebp]
  00c14	53		 push	 ebx
  00c15	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  00c1b	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00c20	83 f8 01	 cmp	 eax, 1
  00c23	0f 85 41 02 00
	00		 jne	 $LN70@CGItemGetR

; 3635 : 						{
; 3636 : 							BYTE NewOption[MAX_EXOPTION_SIZE];
; 3637 : 
; 3638 : 							::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  00c29	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv3285[ebp]
  00c2f	52		 push	 edx
  00c30	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$218430[ebp]
  00c33	50		 push	 eax
  00c34	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 3639 : 
; 3640 : 							LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num,
; 3641 : 								gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type,
; 3642 : 								level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (int)lpItem->m_Durability,
; 3643 : 								NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5],
; 3644 : 								NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7,
; 3645 : 								g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));

  00c39	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  00c3f	83 c4 08	 add	 esp, 8
  00c42	51		 push	 ecx
  00c43	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00c48	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  00c4d	0f b6 d0	 movzx	 edx, al
  00c50	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv3285[ebp]
  00c56	52		 push	 edx
  00c57	50		 push	 eax
  00c58	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00c5d	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  00c62	0f b6 97 ca 00
	00 00		 movzx	 edx, BYTE PTR [edi+202]
  00c69	d9 47 28	 fld	 DWORD PTR [edi+40]
  00c6c	0f b6 c8	 movzx	 ecx, al
  00c6f	0f b6 87 ae 00
	00 00		 movzx	 eax, BYTE PTR [edi+174]
  00c76	51		 push	 ecx
  00c77	0f b6 4d fa	 movzx	 ecx, BYTE PTR _NewOption$218430[ebp+6]
  00c7b	c1 ea 07	 shr	 edx, 7
  00c7e	52		 push	 edx
  00c7f	0f b6 55 f9	 movzx	 edx, BYTE PTR _NewOption$218430[ebp+5]
  00c83	50		 push	 eax
  00c84	0f b6 45 f8	 movzx	 eax, BYTE PTR _NewOption$218430[ebp+4]
  00c88	51		 push	 ecx
  00c89	0f b6 4d f7	 movzx	 ecx, BYTE PTR _NewOption$218430[ebp+3]
  00c8d	52		 push	 edx
  00c8e	0f b6 55 f6	 movzx	 edx, BYTE PTR _NewOption$218430[ebp+2]
  00c92	50		 push	 eax
  00c93	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$218430[ebp+1]
  00c97	51		 push	 ecx
  00c98	0f b6 4d f4	 movzx	 ecx, BYTE PTR _NewOption$218430[ebp]
  00c9c	52		 push	 edx
  00c9d	50		 push	 eax
  00c9e	51		 push	 ecx
  00c9f	e8 00 00 00 00	 call	 __ftol2_sse
  00ca4	0f b6 97 96 00
	00 00		 movzx	 edx, BYTE PTR [edi+150]
  00cab	0f b6 8f 94 00
	00 00		 movzx	 ecx, BYTE PTR [edi+148]
  00cb2	50		 push	 eax
  00cb3	0f b6 87 95 00
	00 00		 movzx	 eax, BYTE PTR [edi+149]
  00cba	52		 push	 edx
  00cbb	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _level$[ebp]
  00cc1	50		 push	 eax
  00cc2	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _type$[ebp]
  00cc8	51		 push	 ecx
  00cc9	52		 push	 edx
  00cca	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv3285[ebp]
  00cd0	50		 push	 eax
  00cd1	8b 02		 mov	 eax, DWORD PTR [edx]
  00cd3	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$[ebp]
  00cd6	51		 push	 ecx
  00cd7	50		 push	 eax
  00cd8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cdd	0f b6 8c 06 21
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+289]
  00ce5	0f b6 94 06 20
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+288]
  00ced	51		 push	 ecx
  00cee	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _map_num$[ebp]
  00cf4	52		 push	 edx
  00cf5	51		 push	 ecx
  00cf6	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  00cfa	52		 push	 edx
  00cfb	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00cff	50		 push	 eax
  00d00	68 dd 01 00 00	 push	 477			; 000001ddH
  00d05	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00d0a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00d0f	50		 push	 eax
  00d10	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3646 : 
; 3647 : 							pResult.result = -3;
; 3648 : 
; 3649 : 							DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  00d16	0f b6 8d 31 ff
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00d1d	51		 push	 ecx
  00d1e	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00d24	52		 push	 edx
  00d25	53		 push	 ebx
  00d26	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  00d2d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3650 : 
; 3651 : 							gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  00d32	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218427[ebp]
  00d38	83 c4 70	 add	 esp, 112		; 00000070H
  00d3b	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00d41	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d46	8b 94 06 c0 11
	00 00		 mov	 edx, DWORD PTR [esi+eax+4544]
  00d4d	d9 44 0a 24	 fld	 DWORD PTR [edx+ecx+36]
  00d51	8d 44 0a 24	 lea	 eax, DWORD PTR [edx+ecx+36]
  00d55	d8 47 28	 fadd	 DWORD PTR [edi+40]
  00d58	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv3519[ebp], ecx
  00d5e	d9 18		 fstp	 DWORD PTR [eax]

; 3652 : 
; 3653 : 							if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )

  00d60	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d66	8b 84 16 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+edx+4544]
  00d6d	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40a00000
  00d73	d8 5c 08 24	 fcomp	 DWORD PTR [eax+ecx+36]
  00d77	8d 4c 08 24	 lea	 ecx, DWORD PTR [eax+ecx+36]
  00d7b	df e0		 fnstsw	 ax
  00d7d	f6 c4 41	 test	 ah, 65			; 00000041H
  00d80	0f 8a 5c 02 00
	00		 jp	 $LN66@CGItemGetR

; 3654 : 							{
; 3655 : 								int NewDur = (int)(gObj[aIndex].pInventory[pos].m_Durability - 5.0f);

  00d86	d9 01		 fld	 DWORD PTR [ecx]
  00d88	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@4014000000000000
  00d8e	e8 00 00 00 00	 call	 __ftol2_sse

; 3656 : 								::gObjInventoryItemSet(aIndex, pos, -1);

  00d93	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218427[ebp]
  00d99	68 ff 00 00 00	 push	 255			; 000000ffH
  00d9e	51		 push	 ecx
  00d9f	53		 push	 ebx
  00da0	89 85 1c ff ff
	ff		 mov	 DWORD PTR _NewDur$218437[ebp], eax
  00da6	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 3657 : 								gObj[aIndex].pInventory[pos].Clear();

  00dab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00db1	8b 8c 16 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4544]
  00db8	03 8d 2c ff ff
	ff		 add	 ecx, DWORD PTR tv3519[ebp]
  00dbe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dc1	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 3658 : 								::GCInventoryItemDeleteSend(aIndex, pos, 1);

  00dc6	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _pos$218427[ebp]
  00dcc	6a 01		 push	 1
  00dce	50		 push	 eax
  00dcf	53		 push	 ebx
  00dd0	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 3659 : 								::ItemSerialCreateSend(aIndex, 235, gObj[aIndex].X, gObj[aIndex].Y, ItemGetNumberMake(14, 28),
; 3660 : 									lpItem->m_Level, 0, 0, 0, 0, aIndex, 0, 0);

  00dd5	0f b6 4f 0c	 movzx	 ecx, BYTE PTR [edi+12]
  00dd9	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ddc	6a 00		 push	 0
  00dde	6a 00		 push	 0
  00de0	6a 00		 push	 0
  00de2	6a 00		 push	 0
  00de4	53		 push	 ebx
  00de5	6a 00		 push	 0
  00de7	6a 00		 push	 0
  00de9	6a 00		 push	 0
  00deb	6a 00		 push	 0
  00ded	51		 push	 ecx
  00dee	6a 1c		 push	 28			; 0000001cH
  00df0	6a 0e		 push	 14			; 0000000eH
  00df2	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00df7	83 c4 08	 add	 esp, 8
  00dfa	50		 push	 eax
  00dfb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e00	0f b6 94 06 21
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+289]
  00e08	0f b6 84 06 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+288]
  00e10	52		 push	 edx
  00e11	50		 push	 eax
  00e12	68 eb 00 00 00	 push	 235			; 000000ebH
  00e17	53		 push	 ebx
  00e18	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 3661 : 
; 3662 : 								LogAddTD("[Kalima] [%s][%s] Make Lost Kalima Map (Left Kundun Mark:%d)",
; 3663 : 									gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);

  00e1d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e22	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _NewDur$218437[ebp]
  00e28	51		 push	 ecx
  00e29	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  00e2d	52		 push	 edx
  00e2e	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00e32	50		 push	 eax
  00e33	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@
  00e38	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00e3e	83 c4 4c	 add	 esp, 76			; 0000004cH

; 3664 : 
; 3665 : 								if ( NewDur > 0 )

  00e41	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR _NewDur$218437[ebp], 0
  00e48	0f 8e 82 11 00
	00		 jle	 $LN231@CGItemGetR

; 3666 : 								{
; 3667 : 									lpItem->m_State = 2;
; 3668 : 									lpItem->Give = false;
; 3669 : 									lpItem->live = true;
; 3670 : 									lpItem->m_Durability = (float)NewDur;

  00e4e	db 85 1c ff ff
	ff		 fild	 DWORD PTR _NewDur$218437[ebp]
  00e54	c7 87 dc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+220], 2
  00e5e	66 c7 87 da 00
	00 00 01 00	 mov	 WORD PTR [edi+218], 1
  00e67	d9 5f 28	 fstp	 DWORD PTR [edi+40]
$LN70@CGItemGetR:

; 3627 : 			{
; 3628 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00e6a	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$218423[ebp]
  00e70	40		 inc	 eax
  00e71	89 85 24 ff ff
	ff		 mov	 DWORD PTR _n$218423[ebp], eax
  00e77	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  00e7c	0f 8c 4e fd ff
	ff		 jl	 $LL71@CGItemGetR
$LN225@CGItemGetR:

; 3678 : 								
; 3679 : 							}
; 3680 : 							return;
; 3681 : 						}
; 3682 : 					}
; 3683 : 					else
; 3684 : 					{
; 3685 : 						break;
; 3686 : 					}
; 3687 : 				}
; 3688 : 			}
; 3689 : 
; 3690 : 			if ( lpItem->m_Type == ITEMGET(14,21) && lpItem->m_Level == 3) // Sign of Lord

  00e82	b8 15 1c 00 00	 mov	 eax, 7189		; 00001c15H
  00e87	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  00e8b	0f 85 5b 02 00
	00		 jne	 $LN226@CGItemGetR
  00e91	66 83 7f 0c 03	 cmp	 WORD PTR [edi+12], 3
  00e96	0f 85 50 02 00
	00		 jne	 $LN226@CGItemGetR

; 3691 : 			{	
; 3692 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00e9c	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$218446[ebp], 0
  00ea6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL61@CGItemGetR:

; 3693 : 				{
; 3694 : 					int pos = ::g_CastleSiegeSync.CheckOverlapCsMarks(aIndex);

  00eb0	53		 push	 ebx
  00eb1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00eb6	e8 00 00 00 00	 call	 ?CheckOverlapCsMarks@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::CheckOverlapCsMarks
  00ebb	89 85 1c ff ff
	ff		 mov	 DWORD PTR _pos$218450[ebp], eax

; 3695 : 
; 3696 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  00ec1	85 c0		 test	 eax, eax
  00ec3	0f 88 23 02 00
	00		 js	 $LN226@CGItemGetR
  00ec9	33 c0		 xor	 eax, eax
  00ecb	81 bd 1c ff ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$218450[ebp], 203 ; 000000cbH
  00ed5	0f 9e c0	 setle	 al
  00ed8	85 c0		 test	 eax, eax
  00eda	0f 84 0c 02 00
	00		 je	 $LN226@CGItemGetR

; 3697 : 					{
; 3698 : 						int Dur = (int)(gObj[aIndex].pInventory[pos].m_Durability + lpItem->m_Durability);

  00ee0	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _pos$218450[ebp]
  00ee6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00eec	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00ef2	8b 94 0e c0 11
	00 00		 mov	 edx, DWORD PTR [esi+ecx+4544]
  00ef9	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv3558[ebp], eax
  00eff	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  00f03	d8 47 28	 fadd	 DWORD PTR [edi+40]
  00f06	e8 00 00 00 00	 call	 __ftol2_sse

; 3699 : 
; 3700 : 						if ( Dur <= 255 )

  00f0b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00f10	0f 8f 36 01 00
	00		 jg	 $LN57@CGItemGetR

; 3701 : 						{
; 3702 : 							if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  00f16	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _item_num$[ebp]
  00f1c	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv3281[ebp]
  00f22	6a 01		 push	 1
  00f24	50		 push	 eax
  00f25	53		 push	 ebx
  00f26	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  00f2c	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00f31	83 f8 01	 cmp	 eax, 1
  00f34	0f 85 9a 01 00
	00		 jne	 $LN60@CGItemGetR

; 3703 : 							{
; 3704 : 								pResult.result = -3;
; 3705 : 								DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00f3a	0f b6 85 31 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00f41	50		 push	 eax
  00f42	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00f48	51		 push	 ecx
  00f49	53		 push	 ebx
  00f4a	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  00f51	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3706 : 								gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  00f56	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _pos$218450[ebp]
  00f5c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f62	d9 47 28	 fld	 DWORD PTR [edi+40]
  00f65	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]

; 3707 : 								GCItemDurSend( aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability,0);

  00f6c	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3567[ebp]
  00f72	8b c2		 mov	 eax, edx
  00f74	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00f7a	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  00f7e	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  00f82	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  00f86	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f8c	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  00f93	6a 00		 push	 0
  00f95	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  00f99	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3567[ebp]
  00fa0	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00fa5	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3564[ebp], eax
  00fab	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3564[ebp]
  00fb1	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3562[ebp]
  00fb7	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv3562[ebp]
  00fbd	0f b6 c8	 movzx	 ecx, al
  00fc0	51		 push	 ecx
  00fc1	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3567[ebp]
  00fc7	52		 push	 edx
  00fc8	53		 push	 ebx
  00fc9	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00fce	83 c4 1c	 add	 esp, 28			; 0000001cH
  00fd1	5f		 pop	 edi
  00fd2	5e		 pop	 esi
  00fd3	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  00fd4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00fd7	33 cd		 xor	 ecx, ebp
  00fd9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fde	8b e5		 mov	 esp, ebp
  00fe0	5d		 pop	 ebp
  00fe1	c3		 ret	 0
$LN66@CGItemGetR:

; 3671 : 									continue;
; 3672 : 
; 3673 : 								}
; 3674 : 							}
; 3675 : 							else
; 3676 : 							{
; 3677 : 								GCItemDurSend(aIndex,pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  00fe2	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218427[ebp]
  00fe8	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3599[ebp]
  00fee	8b 94 16 c0 11
	00 00		 mov	 edx, DWORD PTR [esi+edx+4544]
  00ff5	8b c1		 mov	 eax, ecx
  00ff7	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00ffd	6a 00		 push	 0
  00fff	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  01003	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3599[ebp]
  0100a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0100f	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3596[ebp], eax
  01015	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3596[ebp]
  0101b	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3594[ebp]
  01021	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv3594[ebp]
  01027	0f b6 d0	 movzx	 edx, al
  0102a	52		 push	 edx
  0102b	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3599[ebp]
  01031	51		 push	 ecx
  01032	53		 push	 ebx
  01033	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  01038	83 c4 10	 add	 esp, 16			; 00000010H
  0103b	5f		 pop	 edi
  0103c	5e		 pop	 esi
  0103d	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  0103e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01041	33 cd		 xor	 ecx, ebp
  01043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01048	8b e5		 mov	 esp, ebp
  0104a	5d		 pop	 ebp
  0104b	c3		 ret	 0
$LN57@CGItemGetR:

; 3708 : 								return;
; 3709 : 							}
; 3710 : 						}
; 3711 : 						else
; 3712 : 						{
; 3713 : 							lpItem->m_Durability = (float)(Dur - 255);
; 3714 : 							gObj[aIndex].pInventory[pos].m_Durability = 255.0f;

  0104c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01052	05 01 ff ff ff	 add	 eax, -255		; ffffff01H
  01057	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3583[ebp], eax
  0105d	db 85 2c ff ff
	ff		 fild	 DWORD PTR tv3583[ebp]
  01063	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR tv3558[ebp]

; 3715 : 							GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  01069	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3580[ebp]
  0106f	6a 00		 push	 0
  01071	d9 5f 28	 fstp	 DWORD PTR [edi+40]
  01074	8b 94 0e c0 11
	00 00		 mov	 edx, DWORD PTR [esi+ecx+4544]
  0107b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@437f0000
  01081	d9 5c 02 24	 fstp	 DWORD PTR [edx+eax+36]
  01085	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0108b	8b 94 0e c0 11
	00 00		 mov	 edx, DWORD PTR [esi+ecx+4544]
  01092	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  01096	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3580[ebp]
  0109d	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _pos$218450[ebp]
  010a3	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  010a8	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3576[ebp], eax
  010ae	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3576[ebp]
  010b4	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3574[ebp]
  010ba	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv3574[ebp]
  010c0	0f b6 c8	 movzx	 ecx, al
  010c3	51		 push	 ecx
  010c4	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3580[ebp]
  010ca	52		 push	 edx
  010cb	53		 push	 ebx
  010cc	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  010d1	83 c4 10	 add	 esp, 16			; 00000010H
$LN60@CGItemGetR:

; 3691 : 			{	
; 3692 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  010d4	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$218446[ebp]
  010da	40		 inc	 eax
  010db	89 85 24 ff ff
	ff		 mov	 DWORD PTR _n$218446[ebp], eax
  010e1	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  010e6	0f 8c c4 fd ff
	ff		 jl	 $LL61@CGItemGetR
$LN226@CGItemGetR:

; 3716 : 						}
; 3717 : 
; 3718 : 					}
; 3719 : 					else
; 3720 : 					{
; 3721 : 						break;
; 3722 : 					}
; 3723 : 				}
; 3724 : 			}
; 3725 : 
; 3726 : 
; 3727 : 			if ( lpItem->m_Type == ITEMGET(14,110) ) // Dimension Mark

  010ec	ba 6e 1c 00 00	 mov	 edx, 7278		; 00001c6eH
  010f1	66 39 57 0a	 cmp	 WORD PTR [edi+10], dx
  010f5	0f 85 d6 02 00
	00		 jne	 $LN48@CGItemGetR

; 3728 : 			{
; 3729 : 				if( lpItem->m_Durability > 5 )

  010fb	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40a00000
  01101	d8 5f 28	 fcomp	 DWORD PTR [edi+40]
  01104	df e0		 fnstsw	 ax
  01106	f6 c4 05	 test	 ah, 5
  01109	7a 05		 jp	 SHORT $LN52@CGItemGetR

; 3730 : 					lpItem->m_Durability = 1;

  0110b	d9 e8		 fld1
  0110d	d9 5f 28	 fstp	 DWORD PTR [edi+40]
$LN52@CGItemGetR:

; 3731 : 
; 3732 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  01110	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$218464[ebp], 0
  0111a	8d 9b 00 00 00
	00		 npad	 6
$LL51@CGItemGetR:

; 3733 : 				{
; 3734 : 					int pos = ::gObjCheckOverlapItemUsingDur(aIndex,5,lpItem->m_Type,0);

  01120	0f bf 47 0a	 movsx	 eax, WORD PTR [edi+10]
  01124	6a 00		 push	 0
  01126	50		 push	 eax
  01127	6a 05		 push	 5
  01129	53		 push	 ebx
  0112a	e8 00 00 00 00	 call	 ?gObjCheckOverlapItemUsingDur@@YAHHHHH@Z ; gObjCheckOverlapItemUsingDur
  0112f	83 c4 10	 add	 esp, 16			; 00000010H
  01132	89 85 28 ff ff
	ff		 mov	 DWORD PTR _pos$218468[ebp], eax

; 3735 : 
; 3736 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  01138	85 c0		 test	 eax, eax
  0113a	0f 88 91 02 00
	00		 js	 $LN48@CGItemGetR
  01140	33 c0		 xor	 eax, eax
  01142	81 bd 28 ff ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$218468[ebp], 203 ; 000000cbH
  0114c	0f 9e c0	 setle	 al
  0114f	85 c0		 test	 eax, eax
  01151	0f 84 7a 02 00
	00		 je	 $LN48@CGItemGetR

; 3737 : 					{
; 3738 : 						if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  01157	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _item_num$[ebp]
  0115d	6a 01		 push	 1
  0115f	51		 push	 ecx
  01160	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv3281[ebp]
  01166	53		 push	 ebx
  01167	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  0116d	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  01172	83 f8 01	 cmp	 eax, 1
  01175	0f 85 3e 02 00
	00		 jne	 $LN50@CGItemGetR

; 3739 : 						{
; 3740 : 							BYTE NewOption[MAX_EXOPTION_SIZE];
; 3741 : 
; 3742 : 							::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  0117b	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv3285[ebp]
  01181	52		 push	 edx
  01182	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$218471[ebp]
  01185	50		 push	 eax
  01186	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 3743 : 
; 3744 : 							LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num,
; 3745 : 								gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type,
; 3746 : 								level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (int)lpItem->m_Durability,
; 3747 : 								NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5],
; 3748 : 								NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7,
; 3749 : 								g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));

  0118b	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  01191	83 c4 08	 add	 esp, 8
  01194	51		 push	 ecx
  01195	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0119a	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  0119f	0f b6 d0	 movzx	 edx, al
  011a2	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv3285[ebp]
  011a8	52		 push	 edx
  011a9	50		 push	 eax
  011aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  011af	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  011b4	0f b6 97 ca 00
	00 00		 movzx	 edx, BYTE PTR [edi+202]
  011bb	d9 47 28	 fld	 DWORD PTR [edi+40]
  011be	0f b6 c8	 movzx	 ecx, al
  011c1	0f b6 87 ae 00
	00 00		 movzx	 eax, BYTE PTR [edi+174]
  011c8	51		 push	 ecx
  011c9	0f b6 4d fa	 movzx	 ecx, BYTE PTR _NewOption$218471[ebp+6]
  011cd	c1 ea 07	 shr	 edx, 7
  011d0	52		 push	 edx
  011d1	0f b6 55 f9	 movzx	 edx, BYTE PTR _NewOption$218471[ebp+5]
  011d5	50		 push	 eax
  011d6	0f b6 45 f8	 movzx	 eax, BYTE PTR _NewOption$218471[ebp+4]
  011da	51		 push	 ecx
  011db	0f b6 4d f7	 movzx	 ecx, BYTE PTR _NewOption$218471[ebp+3]
  011df	52		 push	 edx
  011e0	0f b6 55 f6	 movzx	 edx, BYTE PTR _NewOption$218471[ebp+2]
  011e4	50		 push	 eax
  011e5	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$218471[ebp+1]
  011e9	51		 push	 ecx
  011ea	0f b6 4d f4	 movzx	 ecx, BYTE PTR _NewOption$218471[ebp]
  011ee	52		 push	 edx
  011ef	50		 push	 eax
  011f0	51		 push	 ecx
  011f1	e8 00 00 00 00	 call	 __ftol2_sse
  011f6	0f b6 97 96 00
	00 00		 movzx	 edx, BYTE PTR [edi+150]
  011fd	0f b6 8f 94 00
	00 00		 movzx	 ecx, BYTE PTR [edi+148]
  01204	50		 push	 eax
  01205	0f b6 87 95 00
	00 00		 movzx	 eax, BYTE PTR [edi+149]
  0120c	52		 push	 edx
  0120d	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _level$[ebp]
  01213	50		 push	 eax
  01214	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _type$[ebp]
  0121a	51		 push	 ecx
  0121b	52		 push	 edx
  0121c	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv3285[ebp]
  01222	50		 push	 eax
  01223	8b 02		 mov	 eax, DWORD PTR [edx]
  01225	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$[ebp]
  01228	51		 push	 ecx
  01229	50		 push	 eax
  0122a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0122f	0f b6 8c 06 21
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+289]
  01237	0f b6 94 06 20
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+288]
  0123f	51		 push	 ecx
  01240	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _map_num$[ebp]
  01246	52		 push	 edx
  01247	51		 push	 ecx
  01248	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  0124c	52		 push	 edx
  0124d	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  01251	50		 push	 eax
  01252	68 dd 01 00 00	 push	 477			; 000001ddH
  01257	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0125c	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01261	50		 push	 eax
  01262	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3750 : 
; 3751 : 							pResult.result = -3;
; 3752 : 							DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  01268	0f b6 8d 31 ff
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  0126f	51		 push	 ecx
  01270	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  01276	52		 push	 edx
  01277	53		 push	 ebx
  01278	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  0127f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3753 : 
; 3754 : 							gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  01284	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218468[ebp]
  0128a	83 c4 70	 add	 esp, 112		; 00000070H
  0128d	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  01293	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01298	8b 94 06 c0 11
	00 00		 mov	 edx, DWORD PTR [esi+eax+4544]
  0129f	d9 44 0a 24	 fld	 DWORD PTR [edx+ecx+36]
  012a3	8d 44 0a 24	 lea	 eax, DWORD PTR [edx+ecx+36]
  012a7	d8 47 28	 fadd	 DWORD PTR [edi+40]
  012aa	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv3611[ebp], ecx
  012b0	d9 18		 fstp	 DWORD PTR [eax]

; 3755 : 
; 3756 : 							if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )

  012b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  012b8	8b 84 16 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+edx+4544]
  012bf	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40a00000
  012c5	d8 5c 08 24	 fcomp	 DWORD PTR [eax+ecx+36]
  012c9	8d 4c 08 24	 lea	 ecx, DWORD PTR [eax+ecx+36]
  012cd	df e0		 fnstsw	 ax
  012cf	f6 c4 41	 test	 ah, 65			; 00000041H
  012d2	0f 8a 69 08 00
	00		 jp	 $LN46@CGItemGetR

; 3757 : 							{
; 3758 : 								int NewDur = (int)(gObj[aIndex].pInventory[pos].m_Durability - 5.0f);

  012d8	d9 01		 fld	 DWORD PTR [ecx]
  012da	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@4014000000000000
  012e0	e8 00 00 00 00	 call	 __ftol2_sse

; 3759 : 								::gObjInventoryItemSet(aIndex, pos, -1);

  012e5	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218468[ebp]
  012eb	68 ff 00 00 00	 push	 255			; 000000ffH
  012f0	51		 push	 ecx
  012f1	53		 push	 ebx
  012f2	89 85 1c ff ff
	ff		 mov	 DWORD PTR _NewDur$218478[ebp], eax
  012f8	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 3760 : 								gObj[aIndex].pInventory[pos].Clear();

  012fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01303	8b 8c 16 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4544]
  0130a	03 8d 2c ff ff
	ff		 add	 ecx, DWORD PTR tv3611[ebp]
  01310	83 c4 0c	 add	 esp, 12			; 0000000cH
  01313	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 3761 : 								::GCInventoryItemDeleteSend(aIndex, pos, 1);

  01318	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _pos$218468[ebp]
  0131e	6a 01		 push	 1
  01320	50		 push	 eax
  01321	53		 push	 ebx
  01322	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01327	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3762 : 								::ItemSerialCreateSend(aIndex, 235, gObj[aIndex].X, gObj[aIndex].Y, ItemGetNumberMake(14, 111),
; 3763 : 									0, 0, 0, 0, 0, aIndex, 0, 0);

  0132a	6a 00		 push	 0
  0132c	6a 00		 push	 0
  0132e	6a 00		 push	 0
  01330	6a 00		 push	 0
  01332	53		 push	 ebx
  01333	6a 00		 push	 0
  01335	6a 00		 push	 0
  01337	6a 00		 push	 0
  01339	6a 00		 push	 0
  0133b	6a 00		 push	 0
  0133d	6a 6f		 push	 111			; 0000006fH
  0133f	6a 0e		 push	 14			; 0000000eH
  01341	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01346	83 c4 08	 add	 esp, 8
  01349	50		 push	 eax
  0134a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0134f	0f b6 8c 06 21
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+289]
  01357	0f b6 94 06 20
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+288]
  0135f	51		 push	 ecx
  01360	52		 push	 edx
  01361	68 eb 00 00 00	 push	 235			; 000000ebH
  01366	53		 push	 ebx
  01367	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 3764 : 
; 3765 : 								LogAddTD("[Doppelganger] [%s][%s] Make Dimension Mirror (Left Dimension Mark:%d)",
; 3766 : 									gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);

  0136c	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _NewDur$218478[ebp]
  01372	50		 push	 eax
  01373	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01378	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0137c	51		 push	 ecx
  0137d	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  01381	52		 push	 edx
  01382	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@MPCKANHC@?$FLDoppelganger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dim@
  01387	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0138d	83 c4 4c	 add	 esp, 76			; 0000004cH

; 3767 : 
; 3768 : 								if ( NewDur > 0 )

  01390	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR _NewDur$218478[ebp], 0
  01397	0f 8e 33 0c 00
	00		 jle	 $LN231@CGItemGetR

; 3769 : 								{
; 3770 : 									lpItem->m_State = 2;
; 3771 : 									lpItem->Give = false;
; 3772 : 									lpItem->live = true;
; 3773 : 									lpItem->m_Durability = (float)NewDur;

  0139d	db 85 1c ff ff
	ff		 fild	 DWORD PTR _NewDur$218478[ebp]
  013a3	c7 87 dc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+220], 2
  013ad	66 c7 87 da 00
	00 00 01 00	 mov	 WORD PTR [edi+218], 1
  013b6	d9 5f 28	 fstp	 DWORD PTR [edi+40]
$LN50@CGItemGetR:

; 3731 : 
; 3732 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  013b9	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$218464[ebp]
  013bf	40		 inc	 eax
  013c0	89 85 24 ff ff
	ff		 mov	 DWORD PTR _n$218464[ebp], eax
  013c6	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  013cb	0f 8c 4f fd ff
	ff		 jl	 $LL51@CGItemGetR
$LN48@CGItemGetR:

; 3781 : 								
; 3782 : 							}
; 3783 : 							return;
; 3784 : 						}
; 3785 : 					}
; 3786 : 					else
; 3787 : 					{
; 3788 : 						break;
; 3789 : 					}
; 3790 : 				}
; 3791 : 			}
; 3792 : 
; 3793 : 			if ( lpItem->m_Type == ITEMGET(14,101) ) // Old Paper

  013d1	b8 65 1c 00 00	 mov	 eax, 7269		; 00001c65H
  013d6	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  013da	0f 85 c0 02 00
	00		 jne	 $LN38@CGItemGetR

; 3794 : 			{
; 3795 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  013e0	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$218487[ebp], 0
  013ea	8d 9b 00 00 00
	00		 npad	 6
$LL41@CGItemGetR:

; 3796 : 				{
; 3797 : 					int pos = ::g_ImperialGuardian.CheckOverlapMysteriousPaper(aIndex, lpItem->m_Level);

  013f0	0f bf 4f 0c	 movsx	 ecx, WORD PTR [edi+12]
  013f4	51		 push	 ecx
  013f5	53		 push	 ebx
  013f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  013fb	e8 00 00 00 00	 call	 ?CheckOverlapMysteriousPaper@CImperialGuardian@@QAEHHH@Z ; CImperialGuardian::CheckOverlapMysteriousPaper
  01400	89 85 28 ff ff
	ff		 mov	 DWORD PTR _pos$218491[ebp], eax

; 3798 : 
; 3799 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  01406	85 c0		 test	 eax, eax
  01408	0f 88 92 02 00
	00		 js	 $LN38@CGItemGetR
  0140e	33 c0		 xor	 eax, eax
  01410	81 bd 28 ff ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$218491[ebp], 203 ; 000000cbH
  0141a	0f 9e c0	 setle	 al
  0141d	85 c0		 test	 eax, eax
  0141f	0f 84 7b 02 00
	00		 je	 $LN38@CGItemGetR

; 3800 : 					{
; 3801 : 						if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  01425	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _item_num$[ebp]
  0142b	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv3281[ebp]
  01431	6a 01		 push	 1
  01433	52		 push	 edx
  01434	53		 push	 ebx
  01435	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  0143b	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  01440	83 f8 01	 cmp	 eax, 1
  01443	0f 85 3f 02 00
	00		 jne	 $LN40@CGItemGetR

; 3802 : 						{
; 3803 : 							BYTE NewOption[MAX_EXOPTION_SIZE];
; 3804 : 
; 3805 : 							::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  01449	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv3285[ebp]
  0144f	50		 push	 eax
  01450	8d 4d f4	 lea	 ecx, DWORD PTR _NewOption$218494[ebp]
  01453	51		 push	 ecx
  01454	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 3806 : 
; 3807 : 							LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num,
; 3808 : 								gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type,
; 3809 : 								level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (int)lpItem->m_Durability,
; 3810 : 								NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5],
; 3811 : 								NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7,
; 3812 : 								g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));

  01459	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv3285[ebp]
  0145f	83 c4 08	 add	 esp, 8
  01462	52		 push	 edx
  01463	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  01468	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  0146d	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  01473	0f b6 c0	 movzx	 eax, al
  01476	50		 push	 eax
  01477	51		 push	 ecx
  01478	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0147d	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  01482	0f b6 8f ae 00
	00 00		 movzx	 ecx, BYTE PTR [edi+174]
  01489	d9 47 28	 fld	 DWORD PTR [edi+40]
  0148c	0f b6 d0	 movzx	 edx, al
  0148f	0f b6 87 ca 00
	00 00		 movzx	 eax, BYTE PTR [edi+202]
  01496	52		 push	 edx
  01497	0f b6 55 fa	 movzx	 edx, BYTE PTR _NewOption$218494[ebp+6]
  0149b	c1 e8 07	 shr	 eax, 7
  0149e	50		 push	 eax
  0149f	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$218494[ebp+5]
  014a3	51		 push	 ecx
  014a4	0f b6 4d f8	 movzx	 ecx, BYTE PTR _NewOption$218494[ebp+4]
  014a8	52		 push	 edx
  014a9	0f b6 55 f7	 movzx	 edx, BYTE PTR _NewOption$218494[ebp+3]
  014ad	50		 push	 eax
  014ae	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$218494[ebp+2]
  014b2	51		 push	 ecx
  014b3	0f b6 4d f5	 movzx	 ecx, BYTE PTR _NewOption$218494[ebp+1]
  014b7	52		 push	 edx
  014b8	0f b6 55 f4	 movzx	 edx, BYTE PTR _NewOption$218494[ebp]
  014bc	50		 push	 eax
  014bd	51		 push	 ecx
  014be	52		 push	 edx
  014bf	e8 00 00 00 00	 call	 __ftol2_sse
  014c4	0f b6 8f 95 00
	00 00		 movzx	 ecx, BYTE PTR [edi+149]
  014cb	0f b6 97 94 00
	00 00		 movzx	 edx, BYTE PTR [edi+148]
  014d2	50		 push	 eax
  014d3	0f b6 87 96 00
	00 00		 movzx	 eax, BYTE PTR [edi+150]
  014da	50		 push	 eax
  014db	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _level$[ebp]
  014e1	51		 push	 ecx
  014e2	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _type$[ebp]
  014e8	52		 push	 edx
  014e9	50		 push	 eax
  014ea	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv3285[ebp]
  014f0	51		 push	 ecx
  014f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  014f3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014f8	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$[ebp]
  014fb	52		 push	 edx
  014fc	0f b6 94 06 21
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+289]
  01504	51		 push	 ecx
  01505	0f b6 8c 06 20
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+288]
  0150d	52		 push	 edx
  0150e	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  01514	51		 push	 ecx
  01515	52		 push	 edx
  01516	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0151a	51		 push	 ecx
  0151b	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  0151f	52		 push	 edx
  01520	68 dd 01 00 00	 push	 477			; 000001ddH
  01525	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0152a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0152f	50		 push	 eax
  01530	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3813 : 
; 3814 : 							pResult.result = -3;
; 3815 : 							DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  01536	0f b6 85 31 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0153d	50		 push	 eax
  0153e	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  01544	51		 push	 ecx
  01545	53		 push	 ebx
  01546	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  0154d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3816 : 
; 3817 : 							gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  01552	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218491[ebp]
  01558	83 c4 70	 add	 esp, 112		; 00000070H
  0155b	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  01561	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01567	8b 84 16 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+edx+4544]
  0156e	d9 44 08 24	 fld	 DWORD PTR [eax+ecx+36]
  01572	8d 44 08 24	 lea	 eax, DWORD PTR [eax+ecx+36]
  01576	d8 47 28	 fadd	 DWORD PTR [edi+40]
  01579	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv3663[ebp], ecx
  0157f	d9 18		 fstp	 DWORD PTR [eax]

; 3818 : 
; 3819 : 							if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )

  01581	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01587	8b 84 16 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+edx+4544]
  0158e	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40a00000
  01594	d8 5c 08 24	 fcomp	 DWORD PTR [eax+ecx+36]
  01598	8d 4c 08 24	 lea	 ecx, DWORD PTR [eax+ecx+36]
  0159c	df e0		 fnstsw	 ax
  0159e	f6 c4 41	 test	 ah, 65			; 00000041H
  015a1	0f 8a 04 06 00
	00		 jp	 $LN36@CGItemGetR

; 3820 : 							{
; 3821 : 								int NewDur = (int)(gObj[aIndex].pInventory[pos].m_Durability - 5.0f);

  015a7	d9 01		 fld	 DWORD PTR [ecx]
  015a9	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@4014000000000000
  015af	e8 00 00 00 00	 call	 __ftol2_sse

; 3822 : 								::gObjInventoryItemSet(aIndex, pos, -1);

  015b4	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218491[ebp]
  015ba	68 ff 00 00 00	 push	 255			; 000000ffH
  015bf	51		 push	 ecx
  015c0	53		 push	 ebx
  015c1	89 85 1c ff ff
	ff		 mov	 DWORD PTR _NewDur$218501[ebp], eax
  015c7	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 3823 : 								gObj[aIndex].pInventory[pos].Clear();

  015cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  015d2	8b 8c 16 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4544]
  015d9	03 8d 2c ff ff
	ff		 add	 ecx, DWORD PTR tv3663[ebp]
  015df	83 c4 0c	 add	 esp, 12			; 0000000cH
  015e2	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 3824 : 								::GCInventoryItemDeleteSend(aIndex, pos, 1);

  015e7	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _pos$218491[ebp]
  015ed	6a 01		 push	 1
  015ef	50		 push	 eax
  015f0	53		 push	 ebx
  015f1	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  015f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3825 : 								::ItemSerialCreateSend(aIndex, 235, gObj[aIndex].X, gObj[aIndex].Y, ItemGetNumberMake(14, 102),
; 3826 : 									0, 0, 0, 0, 0, aIndex, 0, 0);

  015f9	6a 00		 push	 0
  015fb	6a 00		 push	 0
  015fd	6a 00		 push	 0
  015ff	6a 00		 push	 0
  01601	53		 push	 ebx
  01602	6a 00		 push	 0
  01604	6a 00		 push	 0
  01606	6a 00		 push	 0
  01608	6a 00		 push	 0
  0160a	6a 00		 push	 0
  0160c	6a 66		 push	 102			; 00000066H
  0160e	6a 0e		 push	 14			; 0000000eH
  01610	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01615	83 c4 08	 add	 esp, 8
  01618	50		 push	 eax
  01619	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0161e	0f b6 8c 06 21
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+289]
  01626	0f b6 94 06 20
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+288]
  0162e	51		 push	 ecx
  0162f	52		 push	 edx
  01630	68 eb 00 00 00	 push	 235			; 000000ebH
  01635	53		 push	 ebx
  01636	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 3827 : 
; 3828 : 								LogAddTD("[ImperialGuardianFort] [%s][%s] Make Imperial Letter (Left Old Paper:%d)",
; 3829 : 									gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);

  0163b	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _NewDur$218501[ebp]
  01641	50		 push	 eax
  01642	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01647	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0164b	51		 push	 ecx
  0164c	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  01650	52		 push	 edx
  01651	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@KBMFDFFG@?$FLImperialGuardianFort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  01656	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0165c	83 c4 4c	 add	 esp, 76			; 0000004cH

; 3830 : 
; 3831 : 								if ( NewDur > 0 )

  0165f	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR _NewDur$218501[ebp], 0
  01666	0f 8e 64 09 00
	00		 jle	 $LN231@CGItemGetR

; 3832 : 								{
; 3833 : 									lpItem->m_State = 2;
; 3834 : 									lpItem->Give = false;
; 3835 : 									lpItem->live = true;
; 3836 : 									lpItem->m_Durability = (float)NewDur;

  0166c	db 85 1c ff ff
	ff		 fild	 DWORD PTR _NewDur$218501[ebp]
  01672	c7 87 dc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+220], 2
  0167c	66 c7 87 da 00
	00 00 01 00	 mov	 WORD PTR [edi+218], 1
  01685	d9 5f 28	 fstp	 DWORD PTR [edi+40]
$LN40@CGItemGetR:

; 3794 : 			{
; 3795 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  01688	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$218487[ebp]
  0168e	40		 inc	 eax
  0168f	89 85 24 ff ff
	ff		 mov	 DWORD PTR _n$218487[ebp], eax
  01695	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  0169a	0f 8c 50 fd ff
	ff		 jl	 $LL41@CGItemGetR
$LN38@CGItemGetR:

; 3844 : 								
; 3845 : 							}
; 3846 : 							return;
; 3847 : 						}
; 3848 : 					}
; 3849 : 					else
; 3850 : 					{
; 3851 : 						break;
; 3852 : 					}
; 3853 : 				}
; 3854 : 			}
; 3855 : 
; 3856 : 			if ( lpItem->m_Type == ITEMGET(13, 145) ) // Old Paper

  016a0	b8 91 1a 00 00	 mov	 eax, 6801		; 00001a91H
  016a5	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  016a9	0f 85 5e 03 00
	00		 jne	 $LN224@CGItemGetR

; 3857 : 			{
; 3858 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  016af	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$218510[ebp], 0
  016b9	8d a4 24 00 00
	00 00		 npad	 7
$LL31@CGItemGetR:

; 3859 : 				{
; 3860 : 					int pos = -1;

  016c0	c7 85 28 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _pos$218514[ebp], -1

; 3861 : 					for(int i = INVETORY_WEAR_SIZE; i < 204; i++)

  016ca	c7 85 24 ff ff
	ff 0c 00 00 00	 mov	 DWORD PTR _i$218515[ebp], 12 ; 0000000cH
  016d4	c7 85 1c ff ff
	ff f0 09 00 00	 mov	 DWORD PTR tv4157[ebp], 2544 ; 000009f0H
  016de	8b ff		 npad	 2
$LL28@CGItemGetR:

; 3862 : 					{
; 3863 : 						if( gObj[aIndex].pInventory[i].IsItem() == TRUE &&
; 3864 : 							gObj[aIndex].pInventory[i].m_Type == ITEMGET(13, 145) &&
; 3865 : 							gObj[aIndex].pInventory[i].m_Level == lpItem->m_Level )

  016e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016e6	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  016ed	03 8d 1c ff ff
	ff		 add	 ecx, DWORD PTR tv4157[ebp]
  016f3	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  016f8	83 f8 01	 cmp	 eax, 1
  016fb	75 4e		 jne	 SHORT $LN27@CGItemGetR
  016fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01703	8b 84 16 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+edx+4544]
  0170a	03 85 1c ff ff
	ff		 add	 eax, DWORD PTR tv4157[ebp]
  01710	ba 91 1a 00 00	 mov	 edx, 6801		; 00001a91H
  01715	66 39 50 06	 cmp	 WORD PTR [eax+6], dx
  01719	75 30		 jne	 SHORT $LN27@CGItemGetR
  0171b	66 8b 48 08	 mov	 cx, WORD PTR [eax+8]
  0171f	66 3b 4f 0c	 cmp	 cx, WORD PTR [edi+12]
  01723	75 26		 jne	 SHORT $LN27@CGItemGetR

; 3866 : 						{
; 3867 : 							int nItemDur = (int)gObj[aIndex].pInventory[i].m_Durability;

  01725	d9 40 24	 fld	 DWORD PTR [eax+36]
  01728	e8 00 00 00 00	 call	 __ftol2_sse

; 3868 : 
; 3869 : 							if( ((nItemDur < 0) ? FALSE : (nItemDur <= 4)) != 0 )

  0172d	85 c0		 test	 eax, eax
  0172f	78 1a		 js	 SHORT $LN27@CGItemGetR
  01731	33 d2		 xor	 edx, edx
  01733	83 f8 04	 cmp	 eax, 4
  01736	0f 9e c2	 setle	 dl
  01739	8b c2		 mov	 eax, edx
  0173b	85 c0		 test	 eax, eax
  0173d	74 0c		 je	 SHORT $LN27@CGItemGetR

; 3870 : 								pos = i;

  0173f	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _i$218515[ebp]
  01745	89 85 28 ff ff
	ff		 mov	 DWORD PTR _pos$218514[ebp], eax
$LN27@CGItemGetR:

; 3861 : 					for(int i = INVETORY_WEAR_SIZE; i < 204; i++)

  0174b	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR tv4157[ebp]
  01751	ff 85 24 ff ff
	ff		 inc	 DWORD PTR _i$218515[ebp]
  01757	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  0175c	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv4157[ebp], eax
  01762	3d f0 a8 00 00	 cmp	 eax, 43248		; 0000a8f0H
  01767	0f 8c 73 ff ff
	ff		 jl	 $LL28@CGItemGetR

; 3871 : 						}
; 3872 : 					}
; 3873 : 
; 3874 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  0176d	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _pos$218514[ebp]
  01773	85 c0		 test	 eax, eax
  01775	0f 88 92 02 00
	00		 js	 $LN224@CGItemGetR
  0177b	33 c9		 xor	 ecx, ecx
  0177d	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  01782	0f 9e c1	 setle	 cl
  01785	8b c1		 mov	 eax, ecx
  01787	85 c0		 test	 eax, eax
  01789	0f 84 7e 02 00
	00		 je	 $LN224@CGItemGetR

; 3875 : 					{
; 3876 : 						if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  0178f	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _item_num$[ebp]
  01795	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv3281[ebp]
  0179b	6a 01		 push	 1
  0179d	52		 push	 edx
  0179e	53		 push	 ebx
  0179f	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  017a5	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  017aa	83 f8 01	 cmp	 eax, 1
  017ad	0f 85 42 02 00
	00		 jne	 $LN30@CGItemGetR

; 3877 : 						{
; 3878 : 							BYTE NewOption[MAX_EXOPTION_SIZE];
; 3879 : 
; 3880 : 							::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  017b3	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv3285[ebp]
  017b9	50		 push	 eax
  017ba	8d 4d f4	 lea	 ecx, DWORD PTR _NewOption$218525[ebp]
  017bd	51		 push	 ecx
  017be	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 3881 : 
; 3882 : 							LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num,
; 3883 : 								gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type,
; 3884 : 								level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (int)lpItem->m_Durability,
; 3885 : 								NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5],
; 3886 : 								NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7,
; 3887 : 								g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));

  017c3	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv3285[ebp]
  017c9	83 c4 08	 add	 esp, 8
  017cc	52		 push	 edx
  017cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  017d2	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  017d7	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  017dd	0f b6 c0	 movzx	 eax, al
  017e0	50		 push	 eax
  017e1	51		 push	 ecx
  017e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  017e7	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  017ec	0f b6 8f ae 00
	00 00		 movzx	 ecx, BYTE PTR [edi+174]
  017f3	d9 47 28	 fld	 DWORD PTR [edi+40]
  017f6	0f b6 d0	 movzx	 edx, al
  017f9	0f b6 87 ca 00
	00 00		 movzx	 eax, BYTE PTR [edi+202]
  01800	52		 push	 edx
  01801	0f b6 55 fa	 movzx	 edx, BYTE PTR _NewOption$218525[ebp+6]
  01805	c1 e8 07	 shr	 eax, 7
  01808	50		 push	 eax
  01809	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$218525[ebp+5]
  0180d	51		 push	 ecx
  0180e	0f b6 4d f8	 movzx	 ecx, BYTE PTR _NewOption$218525[ebp+4]
  01812	52		 push	 edx
  01813	0f b6 55 f7	 movzx	 edx, BYTE PTR _NewOption$218525[ebp+3]
  01817	50		 push	 eax
  01818	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$218525[ebp+2]
  0181c	51		 push	 ecx
  0181d	0f b6 4d f5	 movzx	 ecx, BYTE PTR _NewOption$218525[ebp+1]
  01821	52		 push	 edx
  01822	0f b6 55 f4	 movzx	 edx, BYTE PTR _NewOption$218525[ebp]
  01826	50		 push	 eax
  01827	51		 push	 ecx
  01828	52		 push	 edx
  01829	e8 00 00 00 00	 call	 __ftol2_sse
  0182e	0f b6 8f 95 00
	00 00		 movzx	 ecx, BYTE PTR [edi+149]
  01835	0f b6 97 94 00
	00 00		 movzx	 edx, BYTE PTR [edi+148]
  0183c	50		 push	 eax
  0183d	0f b6 87 96 00
	00 00		 movzx	 eax, BYTE PTR [edi+150]
  01844	50		 push	 eax
  01845	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _level$[ebp]
  0184b	51		 push	 ecx
  0184c	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _type$[ebp]
  01852	52		 push	 edx
  01853	50		 push	 eax
  01854	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv3285[ebp]
  0185a	51		 push	 ecx
  0185b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0185d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01862	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$[ebp]
  01865	52		 push	 edx
  01866	0f b6 94 06 21
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+289]
  0186e	51		 push	 ecx
  0186f	0f b6 8c 06 20
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+288]
  01877	52		 push	 edx
  01878	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  0187e	51		 push	 ecx
  0187f	52		 push	 edx
  01880	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  01884	51		 push	 ecx
  01885	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  01889	52		 push	 edx
  0188a	68 dd 01 00 00	 push	 477			; 000001ddH
  0188f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  01894	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01899	50		 push	 eax
  0189a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3888 : 
; 3889 : 							pResult.result = -3;
; 3890 : 							DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  018a0	0f b6 85 31 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  018a7	50		 push	 eax
  018a8	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  018ae	51		 push	 ecx
  018af	53		 push	 ebx
  018b0	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  018b7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3891 : 
; 3892 : 							gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  018bc	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218514[ebp]
  018c2	83 c4 70	 add	 esp, 112		; 00000070H
  018c5	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  018cb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018d1	8b 84 16 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+edx+4544]
  018d8	d9 44 08 24	 fld	 DWORD PTR [eax+ecx+36]
  018dc	8d 44 08 24	 lea	 eax, DWORD PTR [eax+ecx+36]
  018e0	d8 47 28	 fadd	 DWORD PTR [edi+40]
  018e3	89 8d 1c ff ff
	ff		 mov	 DWORD PTR tv3736[ebp], ecx
  018e9	d9 18		 fstp	 DWORD PTR [eax]

; 3893 : 
; 3894 : 							if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )

  018eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018f1	8b 84 16 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+edx+4544]
  018f8	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40a00000
  018fe	d8 5c 08 24	 fcomp	 DWORD PTR [eax+ecx+36]
  01902	8d 4c 08 24	 lea	 ecx, DWORD PTR [eax+ecx+36]
  01906	df e0		 fnstsw	 ax
  01908	f6 c4 41	 test	 ah, 65			; 00000041H
  0190b	0f 8a 04 03 00
	00		 jp	 $LN21@CGItemGetR

; 3895 : 							{
; 3896 : 								int NewDur = (int)(gObj[aIndex].pInventory[pos].m_Durability - 5.0f);

  01911	d9 01		 fld	 DWORD PTR [ecx]
  01913	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@4014000000000000
  01919	e8 00 00 00 00	 call	 __ftol2_sse

; 3897 : 								::gObjInventoryItemSet(aIndex, pos, -1);

  0191e	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218514[ebp]
  01924	68 ff 00 00 00	 push	 255			; 000000ffH
  01929	51		 push	 ecx
  0192a	53		 push	 ebx
  0192b	89 85 24 ff ff
	ff		 mov	 DWORD PTR _NewDur$218532[ebp], eax
  01931	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 3898 : 								gObj[aIndex].pInventory[pos].Clear();

  01936	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0193c	8b 8c 16 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4544]
  01943	03 8d 1c ff ff
	ff		 add	 ecx, DWORD PTR tv3736[ebp]
  01949	83 c4 0c	 add	 esp, 12			; 0000000cH
  0194c	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 3899 : 								::GCInventoryItemDeleteSend(aIndex, pos, 1);

  01951	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _pos$218514[ebp]
  01957	6a 01		 push	 1
  01959	50		 push	 eax
  0195a	53		 push	 ebx
  0195b	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01960	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3900 : 								::ItemSerialCreateSend(aIndex, 235, gObj[aIndex].X, gObj[aIndex].Y, ItemGetNumberMake(13, 146),
; 3901 : 									0, 0, 0, 0, 0, aIndex, 0, 0);

  01963	6a 00		 push	 0
  01965	6a 00		 push	 0
  01967	6a 00		 push	 0
  01969	6a 00		 push	 0
  0196b	53		 push	 ebx
  0196c	6a 00		 push	 0
  0196e	6a 00		 push	 0
  01970	6a 00		 push	 0
  01972	6a 00		 push	 0
  01974	6a 00		 push	 0
  01976	68 92 00 00 00	 push	 146			; 00000092H
  0197b	6a 0d		 push	 13			; 0000000dH
  0197d	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01982	83 c4 08	 add	 esp, 8
  01985	50		 push	 eax
  01986	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0198b	0f b6 8c 06 21
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+289]
  01993	0f b6 94 06 20
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+288]
  0199b	51		 push	 ecx
  0199c	52		 push	 edx
  0199d	68 eb 00 00 00	 push	 235			; 000000ebH
  019a2	53		 push	 ebx
  019a3	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 3902 : 
; 3903 : 								LogAddTD("[Acheron] [%s][%s] Make Spirit Map (Left Old Map:%d)",
; 3904 : 									gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);

  019a8	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _NewDur$218532[ebp]
  019ae	50		 push	 eax
  019af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  019b4	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  019b8	51		 push	 ecx
  019b9	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  019bd	52		 push	 edx
  019be	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@EMLONCAM@?$FLAcheron?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Spirit?5M@
  019c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  019c9	83 c4 4c	 add	 esp, 76			; 0000004cH

; 3905 : 
; 3906 : 								if ( NewDur > 0 )

  019cc	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR _NewDur$218532[ebp], 0
  019d3	0f 8e f7 05 00
	00		 jle	 $LN231@CGItemGetR

; 3907 : 								{
; 3908 : 									lpItem->m_State = 2;
; 3909 : 									lpItem->Give = false;
; 3910 : 									lpItem->live = true;
; 3911 : 									lpItem->m_Durability = (float)NewDur;

  019d9	db 85 24 ff ff
	ff		 fild	 DWORD PTR _NewDur$218532[ebp]
  019df	c7 87 dc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+220], 2
  019e9	66 c7 87 da 00
	00 00 01 00	 mov	 WORD PTR [edi+218], 1
  019f2	d9 5f 28	 fstp	 DWORD PTR [edi+40]
$LN30@CGItemGetR:

; 3857 : 			{
; 3858 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  019f5	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _n$218510[ebp]
  019fb	40		 inc	 eax
  019fc	89 85 2c ff ff
	ff		 mov	 DWORD PTR _n$218510[ebp], eax
  01a02	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  01a07	0f 8c b3 fc ff
	ff		 jl	 $LL31@CGItemGetR
$LN224@CGItemGetR:

; 3919 : 								
; 3920 : 							}
; 3921 : 							return;
; 3922 : 						}
; 3923 : 					}
; 3924 : 					else
; 3925 : 					{
; 3926 : 						break;
; 3927 : 					}
; 3928 : 				}
; 3929 : 			}
; 3930 : 
; 3931 : 			pResult.result = ::gObjInventoryInsertItemTemp(&gObj[aIndex], lpItem);

  01a0d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a12	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  01a15	57		 push	 edi
  01a16	51		 push	 ecx
  01a17	e8 00 00 00 00	 call	 ?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z ; gObjInventoryInsertItemTemp
  01a1c	83 c4 08	 add	 esp, 8
  01a1f	88 85 33 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al

; 3932 : 
; 3933 : 			if ( pResult.result != 0xFF )

  01a25	3c ff		 cmp	 al, 255			; 000000ffH
  01a27	0f 84 a7 e9 ff
	ff		 je	 $LN94@CGItemGetR

; 3934 : 			{
; 3935 : 				ItemByteConvert((LPBYTE)&pResult.Data[0], lpItem->m_Type, lpItem->m_Option1, lpItem->m_Option2,
; 3936 : 					lpItem->m_Option3, lpItem->m_Level, (BYTE)lpItem->m_Durability, lpItem->m_NewOption,
; 3937 : 					lpItem->m_SetOption, lpItem->m_JewelOfHarmonyOption, lpItem->m_ItemOptionEx,
; 3938 : 					lpItem->m_SocketOption,lpItem->m_SocketBonus);

  01a2d	0f b6 97 cb 00
	00 00		 movzx	 edx, BYTE PTR [edi+203]
  01a34	d9 47 28	 fld	 DWORD PTR [edi+40]
  01a37	0f b6 8f ca 00
	00 00		 movzx	 ecx, BYTE PTR [edi+202]
  01a3e	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3395[ebp]
  01a44	52		 push	 edx
  01a45	0f b6 97 c4 00
	00 00		 movzx	 edx, BYTE PTR [edi+196]
  01a4c	8d 87 cc 00 00
	00		 lea	 eax, DWORD PTR [edi+204]
  01a52	50		 push	 eax
  01a53	0f b6 87 ae 00
	00 00		 movzx	 eax, BYTE PTR [edi+174]
  01a5a	51		 push	 ecx
  01a5b	0f b6 8f 97 00
	00 00		 movzx	 ecx, BYTE PTR [edi+151]
  01a62	52		 push	 edx
  01a63	50		 push	 eax
  01a64	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3395[ebp]
  01a6b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01a70	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3392[ebp], eax
  01a76	51		 push	 ecx
  01a77	0f b6 4f 0c	 movzx	 ecx, BYTE PTR [edi+12]
  01a7b	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3392[ebp]
  01a81	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3390[ebp]
  01a87	8a 95 2c ff ff
	ff		 mov	 dl, BYTE PTR tv3390[ebp]
  01a8d	0f b6 c2	 movzx	 eax, dl
  01a90	0f b6 97 96 00
	00 00		 movzx	 edx, BYTE PTR [edi+150]
  01a97	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3395[ebp]
  01a9d	50		 push	 eax
  01a9e	0f b6 87 95 00
	00 00		 movzx	 eax, BYTE PTR [edi+149]
  01aa5	51		 push	 ecx
  01aa6	0f b6 8f 94 00
	00 00		 movzx	 ecx, BYTE PTR [edi+148]
  01aad	52		 push	 edx
  01aae	0f bf 57 0a	 movsx	 edx, WORD PTR [edi+10]
  01ab2	50		 push	 eax
  01ab3	51		 push	 ecx
  01ab4	52		 push	 edx
  01ab5	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp+4]
  01abb	50		 push	 eax
  01abc	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEHEEEEEEEEE0E@Z ; ItemByteConvert

; 3939 : 
; 3940 : 				if ( MapC[map_num].ItemGive(aIndex, item_num, false) == TRUE )

  01ac1	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _item_num$[ebp]
  01ac7	83 c4 34	 add	 esp, 52			; 00000034H
  01aca	6a 00		 push	 0
  01acc	51		 push	 ecx
  01acd	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv3281[ebp]
  01ad3	53		 push	 ebx
  01ad4	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  01ada	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  01adf	83 f8 01	 cmp	 eax, 1
  01ae2	0f 85 24 e8 ff
	ff		 jne	 $LN236@CGItemGetR

; 3941 : 				{
; 3942 : 					BYTE pos = ::gObjInventoryInsertItem(aIndex, lpItem);

  01ae8	57		 push	 edi
  01ae9	53		 push	 ebx
  01aea	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z ; gObjInventoryInsertItem
  01aef	83 c4 08	 add	 esp, 8
  01af2	88 85 2c ff ff
	ff		 mov	 BYTE PTR _pos$218544[ebp], al

; 3943 : 
; 3944 : 					if ( pos == 0xFF )

  01af8	3c ff		 cmp	 al, 255			; 000000ffH
  01afa	75 06		 jne	 SHORT $LN15@CGItemGetR

; 3945 : 						pResult.result = -1;

  01afc	88 85 33 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al
$LN15@CGItemGetR:

; 3946 : 
; 3947 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01b02	0f b6 95 31 ff
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  01b09	52		 push	 edx
  01b0a	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  01b10	50		 push	 eax
  01b11	53		 push	 ebx
  01b12	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01b17	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3948 : 
; 3949 : 					if ( pos == 0xFF )

  01b1a	80 bd 2c ff ff
	ff ff		 cmp	 BYTE PTR _pos$218544[ebp], 255 ; 000000ffH
  01b21	0f 85 58 01 00
	00		 jne	 $LN14@CGItemGetR

; 3950 : 					{
; 3951 : 						::GCItemListSend(aIndex);

  01b27	53		 push	 ebx
  01b28	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  01b2d	83 c4 04	 add	 esp, 4
  01b30	5f		 pop	 edi
  01b31	5e		 pop	 esi
  01b32	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  01b33	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b36	33 cd		 xor	 ecx, ebp
  01b38	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01b3d	8b e5		 mov	 esp, ebp
  01b3f	5d		 pop	 ebp
  01b40	c3		 ret	 0
$LN46@CGItemGetR:

; 3774 : 									continue;
; 3775 : 
; 3776 : 								}
; 3777 : 							}
; 3778 : 							else
; 3779 : 							{
; 3780 : 								GCItemDurSend(aIndex,pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  01b41	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218468[ebp]
  01b47	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3512[ebp]
  01b4d	8b 94 16 c0 11
	00 00		 mov	 edx, DWORD PTR [esi+edx+4544]
  01b54	8b c1		 mov	 eax, ecx
  01b56	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  01b5c	6a 00		 push	 0
  01b5e	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  01b62	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3512[ebp]
  01b69	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01b6e	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3509[ebp], eax
  01b74	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3509[ebp]
  01b7a	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3506[ebp]
  01b80	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv3506[ebp]
  01b86	0f b6 d0	 movzx	 edx, al
  01b89	52		 push	 edx
  01b8a	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3512[ebp]
  01b90	51		 push	 ecx
  01b91	53		 push	 ebx
  01b92	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  01b97	83 c4 10	 add	 esp, 16			; 00000010H
  01b9a	5f		 pop	 edi
  01b9b	5e		 pop	 esi
  01b9c	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  01b9d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ba0	33 cd		 xor	 ecx, ebp
  01ba2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01ba7	8b e5		 mov	 esp, ebp
  01ba9	5d		 pop	 ebp
  01baa	c3		 ret	 0
$LN36@CGItemGetR:

; 3837 : 									continue;
; 3838 : 
; 3839 : 								}
; 3840 : 							}
; 3841 : 							else
; 3842 : 							{
; 3843 : 								GCItemDurSend(aIndex,pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  01bab	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218491[ebp]
  01bb1	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3463[ebp]
  01bb7	8b 94 16 c0 11
	00 00		 mov	 edx, DWORD PTR [esi+edx+4544]
  01bbe	8b c1		 mov	 eax, ecx
  01bc0	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  01bc6	6a 00		 push	 0
  01bc8	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  01bcc	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3463[ebp]
  01bd3	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01bd8	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3460[ebp], eax
  01bde	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3460[ebp]
  01be4	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3458[ebp]
  01bea	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv3458[ebp]
  01bf0	0f b6 d0	 movzx	 edx, al
  01bf3	52		 push	 edx
  01bf4	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3463[ebp]
  01bfa	51		 push	 ecx
  01bfb	53		 push	 ebx
  01bfc	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  01c01	83 c4 10	 add	 esp, 16			; 00000010H
  01c04	5f		 pop	 edi
  01c05	5e		 pop	 esi
  01c06	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  01c07	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c0a	33 cd		 xor	 ecx, ebp
  01c0c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c11	8b e5		 mov	 esp, ebp
  01c13	5d		 pop	 ebp
  01c14	c3		 ret	 0
$LN21@CGItemGetR:

; 3912 : 									continue;
; 3913 : 
; 3914 : 								}
; 3915 : 							}
; 3916 : 							else
; 3917 : 							{
; 3918 : 								GCItemDurSend(aIndex,pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  01c15	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218514[ebp]
  01c1b	d9 bd 2a ff ff
	ff		 fnstcw	 WORD PTR tv3408[ebp]
  01c21	8b 94 16 c0 11
	00 00		 mov	 edx, DWORD PTR [esi+edx+4544]
  01c28	8b c1		 mov	 eax, ecx
  01c2a	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  01c30	6a 00		 push	 0
  01c32	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  01c36	0f b7 85 2a ff
	ff ff		 movzx	 eax, WORD PTR tv3408[ebp]
  01c3d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01c42	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv3405[ebp], eax
  01c48	d9 ad 2c ff ff
	ff		 fldcw	 WORD PTR tv3405[ebp]
  01c4e	db 9d 2c ff ff
	ff		 fistp	 DWORD PTR tv3402[ebp]
  01c54	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv3402[ebp]
  01c5a	0f b6 d0	 movzx	 edx, al
  01c5d	52		 push	 edx
  01c5e	d9 ad 2a ff ff
	ff		 fldcw	 WORD PTR tv3408[ebp]
  01c64	51		 push	 ecx
  01c65	53		 push	 ebx
  01c66	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  01c6b	83 c4 10	 add	 esp, 16			; 00000010H
  01c6e	5f		 pop	 edi
  01c6f	5e		 pop	 esi
  01c70	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  01c71	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c74	33 cd		 xor	 ecx, ebp
  01c76	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c7b	8b e5		 mov	 esp, ebp
  01c7d	5d		 pop	 ebp
  01c7e	c3		 ret	 0
$LN14@CGItemGetR:

; 3952 : 					}
; 3953 : 					else
; 3954 : 					{
; 3955 : 						BYTE NewOption[MAX_EXOPTION_SIZE];
; 3956 : 
; 3957 : 						::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  01c7f	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  01c85	51		 push	 ecx
  01c86	8d 55 f4	 lea	 edx, DWORD PTR _NewOption$218549[ebp]
  01c89	52		 push	 edx
  01c8a	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 3958 : 
; 3959 : 						LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num,
; 3960 : 							gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type,
; 3961 : 							level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (INT)lpItem->m_Durability,
; 3962 : 							NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5],
; 3963 : 							NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7,
; 3964 : 							g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));

  01c8f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c94	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv3285[ebp]
  01c9a	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  01c9d	83 c4 08	 add	 esp, 8
  01ca0	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv3234[ebp], ecx
  01ca6	52		 push	 edx
  01ca7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  01cac	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  01cb1	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  01cb7	0f b6 c0	 movzx	 eax, al
  01cba	50		 push	 eax
  01cbb	51		 push	 ecx
  01cbc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  01cc1	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  01cc6	0f b6 8f ae 00
	00 00		 movzx	 ecx, BYTE PTR [edi+174]
  01ccd	d9 47 28	 fld	 DWORD PTR [edi+40]
  01cd0	0f b6 d0	 movzx	 edx, al
  01cd3	0f b6 87 ca 00
	00 00		 movzx	 eax, BYTE PTR [edi+202]
  01cda	52		 push	 edx
  01cdb	0f b6 55 fa	 movzx	 edx, BYTE PTR _NewOption$218549[ebp+6]
  01cdf	c1 e8 07	 shr	 eax, 7
  01ce2	50		 push	 eax
  01ce3	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$218549[ebp+5]
  01ce7	51		 push	 ecx
  01ce8	0f b6 4d f8	 movzx	 ecx, BYTE PTR _NewOption$218549[ebp+4]
  01cec	52		 push	 edx
  01ced	0f b6 55 f7	 movzx	 edx, BYTE PTR _NewOption$218549[ebp+3]
  01cf1	50		 push	 eax
  01cf2	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$218549[ebp+2]
  01cf6	51		 push	 ecx
  01cf7	0f b6 4d f5	 movzx	 ecx, BYTE PTR _NewOption$218549[ebp+1]
  01cfb	52		 push	 edx
  01cfc	0f b6 55 f4	 movzx	 edx, BYTE PTR _NewOption$218549[ebp]
  01d00	50		 push	 eax
  01d01	51		 push	 ecx
  01d02	52		 push	 edx
  01d03	e8 00 00 00 00	 call	 __ftol2_sse
  01d08	0f b6 8f 95 00
	00 00		 movzx	 ecx, BYTE PTR [edi+149]
  01d0f	0f b6 97 94 00
	00 00		 movzx	 edx, BYTE PTR [edi+148]
  01d16	50		 push	 eax
  01d17	0f b6 87 96 00
	00 00		 movzx	 eax, BYTE PTR [edi+150]
  01d1e	50		 push	 eax
  01d1f	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _level$[ebp]
  01d25	51		 push	 ecx
  01d26	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _type$[ebp]
  01d2c	52		 push	 edx
  01d2d	50		 push	 eax
  01d2e	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv3285[ebp]
  01d34	51		 push	 ecx
  01d35	8b 08		 mov	 ecx, DWORD PTR [eax]
  01d37	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv3234[ebp]
  01d3d	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$[ebp]
  01d40	52		 push	 edx
  01d41	0f b6 90 21 01
	00 00		 movzx	 edx, BYTE PTR [eax+289]
  01d48	51		 push	 ecx
  01d49	0f b6 88 20 01
	00 00		 movzx	 ecx, BYTE PTR [eax+288]
  01d50	52		 push	 edx
  01d51	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  01d57	51		 push	 ecx
  01d58	52		 push	 edx
  01d59	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  01d5c	51		 push	 ecx
  01d5d	83 c0 52	 add	 eax, 82			; 00000052H
  01d60	50		 push	 eax
  01d61	68 dd 01 00 00	 push	 477			; 000001ddH
  01d66	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  01d6b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01d70	50		 push	 eax
  01d71	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3965 : 						::GCSendGetItemInfoForParty(aIndex, lpItem);

  01d77	57		 push	 edi
  01d78	53		 push	 ebx
  01d79	e8 00 00 00 00	 call	 ?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z ; GCSendGetItemInfoForParty
  01d7e	83 c4 6c	 add	 esp, 108		; 0000006cH

; 3966 : 
; 3967 : 						if ( BC_MAP_RANGE(map_num) )

  01d81	83 bd 18 ff ff
	ff 34		 cmp	 DWORD PTR _map_num$[ebp], 52 ; 00000034H
  01d88	74 1f		 je	 SHORT $LN212@CGItemGetR
  01d8a	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _map_num$[ebp]
  01d90	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  01d93	0f 8c 75 01 00
	00		 jl	 $LN229@CGItemGetR
  01d99	33 c9		 xor	 ecx, ecx
  01d9b	83 f8 11	 cmp	 eax, 17			; 00000011H
  01d9e	0f 9e c1	 setle	 cl
  01da1	85 c9		 test	 ecx, ecx
  01da3	0f 84 65 01 00
	00		 je	 $LN229@CGItemGetR
$LN212@CGItemGetR:

; 3968 : 						{
; 3969 : 							int Bridge = g_BloodCastle.GetBridgeLevel(map_num);

  01da9	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  01daf	52		 push	 edx
  01db0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01db5	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel

; 3970 : 							if ( g_BloodCastle.CheckQuestItemSerial(Bridge, lpItem) )

  01dba	57		 push	 edi
  01dbb	50		 push	 eax
  01dbc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01dc1	89 85 24 ff ff
	ff		 mov	 DWORD PTR _Bridge$218555[ebp], eax
  01dc7	e8 00 00 00 00	 call	 ?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ; CBloodCastle::CheckQuestItemSerial
  01dcc	84 c0		 test	 al, al
  01dce	0f 84 34 01 00
	00		 je	 $LN228@CGItemGetR

; 3971 : 							{
; 3972 : 								g_BloodCastle.m_BridgeData[Bridge].m_iBC_QUEST_ITEM_USER_INDEX = gObj[aIndex].m_Index;

  01dd4	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _Bridge$218555[ebp]
  01dda	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ddf	69 c9 0c 02 00
	00		 imul	 ecx, 524		; 0000020cH
  01de5	8b 14 06	 mov	 edx, DWORD PTR [esi+eax]
  01de8	89 91 94 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+404], edx

; 3973 : 								int Bridge = g_BloodCastle.GetBridgeLevel(gObj[aIndex].MapNumber);

  01dee	0f b6 84 06 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+291]
  01df6	50		 push	 eax
  01df7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01dfc	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  01e01	89 85 1c ff ff
	ff		 mov	 DWORD PTR _Bridge$218557[ebp], eax

; 3974 : 
; 3975 : 								char szTempMsg[128];
; 3976 : 
; 3977 : 								switch ( lpItem->m_Level )

  01e07	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]
  01e0b	83 e8 00	 sub	 eax, 0
  01e0e	0f 84 87 00 00
	00		 je	 $LN8@CGItemGetR
  01e14	48		 dec	 eax
  01e15	74 4a		 je	 SHORT $LN7@CGItemGetR
  01e17	48		 dec	 eax
  01e18	74 0c		 je	 SHORT $LN6@CGItemGetR

; 3993 : 
; 3994 : 									default:
; 3995 : 										szTempMsg[0] = 0;

  01e1a	c6 85 40 ff ff
	ff 00		 mov	 BYTE PTR _szTempMsg$218558[ebp], 0
  01e21	e9 b8 00 00 00	 jmp	 $LN9@CGItemGetR
$LN6@CGItemGetR:

; 3988 : 
; 3989 : 									case 2:	// Crossbow of Archangel
; 3990 : 										wsprintf(szTempMsg, lMsg.Get(MSGGET(4, 152)), gObj[aIndex].Name);

  01e26	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e2c	8d 54 0e 5d	 lea	 edx, DWORD PTR [esi+ecx+93]
  01e30	52		 push	 edx
  01e31	68 98 04 00 00	 push	 1176			; 00000498H
  01e36	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  01e3b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01e40	50		 push	 eax
  01e41	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _szTempMsg$218558[ebp]
  01e47	50		 push	 eax
  01e48	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 3991 : 										g_BloodCastle.SendNoticeMessage(Bridge, szTempMsg);

  01e4e	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _Bridge$218557[ebp]
  01e54	83 c4 0c	 add	 esp, 12			; 0000000cH
  01e57	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _szTempMsg$218558[ebp]
  01e5d	51		 push	 ecx
  01e5e	52		 push	 edx

; 3992 : 										break;

  01e5f	eb 73		 jmp	 SHORT $LN235@CGItemGetR
$LN7@CGItemGetR:

; 3982 : 										break;
; 3983 : 
; 3984 : 									case 1:	// Sword of Archangel
; 3985 : 										wsprintf(szTempMsg, lMsg.Get(MSGGET(4, 151)), gObj[aIndex].Name);

  01e61	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e66	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  01e6a	51		 push	 ecx
  01e6b	68 97 04 00 00	 push	 1175			; 00000497H
  01e70	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  01e75	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01e7a	50		 push	 eax
  01e7b	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _szTempMsg$218558[ebp]
  01e81	52		 push	 edx
  01e82	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 3986 : 										g_BloodCastle.SendNoticeMessage(Bridge, szTempMsg);

  01e88	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _Bridge$218557[ebp]
  01e8e	83 c4 0c	 add	 esp, 12			; 0000000cH
  01e91	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _szTempMsg$218558[ebp]
  01e97	50		 push	 eax
  01e98	51		 push	 ecx

; 3987 : 										break;

  01e99	eb 39		 jmp	 SHORT $LN235@CGItemGetR
$LN8@CGItemGetR:

; 3978 : 								{
; 3979 : 									case 0:	// Staff of Archangel
; 3980 : 										wsprintf(szTempMsg, lMsg.Get(MSGGET(4, 150)), gObj[aIndex].Name);

  01e9b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ea1	8d 44 16 5d	 lea	 eax, DWORD PTR [esi+edx+93]
  01ea5	50		 push	 eax
  01ea6	68 96 04 00 00	 push	 1174			; 00000496H
  01eab	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  01eb0	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01eb5	50		 push	 eax
  01eb6	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _szTempMsg$218558[ebp]
  01ebc	51		 push	 ecx
  01ebd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 3981 : 										g_BloodCastle.SendNoticeMessage(Bridge, szTempMsg);

  01ec3	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _Bridge$218557[ebp]
  01ec9	83 c4 0c	 add	 esp, 12			; 0000000cH
  01ecc	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _szTempMsg$218558[ebp]
  01ed2	52		 push	 edx
  01ed3	50		 push	 eax
$LN235@CGItemGetR:
  01ed4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01ed9	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage
$LN9@CGItemGetR:

; 3996 : 								}
; 3997 : 
; 3998 : 								LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) picked up Angel King's Weapon (%d)",
; 3999 : 									Bridge+1, gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->m_Level);

  01ede	0f bf 4f 0c	 movsx	 ecx, WORD PTR [edi+12]
  01ee2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ee7	51		 push	 ecx
  01ee8	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _Bridge$218557[ebp]
  01eee	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  01ef2	52		 push	 edx
  01ef3	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  01ef7	50		 push	 eax
  01ef8	41		 inc	 ecx
  01ef9	51		 push	 ecx
  01efa	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  01eff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01f05	83 c4 14	 add	 esp, 20			; 00000014H
$LN228@CGItemGetR:
  01f08	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _map_num$[ebp]
$LN229@CGItemGetR:

; 4000 : 							}
; 4001 : 						}
; 4002 : 						
; 4003 : 						if ( IT_MAP_RANGE(map_num) && lpItem->m_Type == ITEMGET(14,64) )

  01f0e	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  01f11	0f 8c b9 00 00
	00		 jl	 $LN231@CGItemGetR
  01f17	33 d2		 xor	 edx, edx
  01f19	83 f8 32	 cmp	 eax, 50			; 00000032H
  01f1c	0f 9e c2	 setle	 dl
  01f1f	8b c2		 mov	 eax, edx
  01f21	85 c0		 test	 eax, eax
  01f23	0f 84 a7 00 00
	00		 je	 $LN231@CGItemGetR
  01f29	b8 40 1c 00 00	 mov	 eax, 7232		; 00001c40H
  01f2e	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  01f32	0f 85 98 00 00
	00		 jne	 $LN231@CGItemGetR

; 4004 : 						{
; 4005 : 							g_IllusionTemple.PickupRelic(gObj[aIndex].MapNumber,aIndex,pos);

  01f38	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _pos$218544[ebp]
  01f3e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f44	0f b6 84 16 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+edx+291]
  01f4c	51		 push	 ecx
  01f4d	53		 push	 ebx
  01f4e	50		 push	 eax
  01f4f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  01f54	e8 00 00 00 00	 call	 ?PickupRelic@CIllusionTempleEvent@@QAEXEHE@Z ; CIllusionTempleEvent::PickupRelic

; 4006 : 							g_IllusionTemple.PickupRelicSend(&gObj[aIndex]);

  01f59	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f5f	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  01f62	52		 push	 edx
  01f63	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  01f68	e8 00 00 00 00	 call	 ?PickupRelicSend@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::PickupRelicSend

; 4007 : 							LogAddTD("[Illusion Temple] (%d) (Account:%s, Name:%s) picked up Relics Item(serial:%u)",
; 4008 : 								map_num - (MAP_INDEX_ILLUSIONTEMPLE1 - 1),gObj[aIndex].AccountID,gObj[aIndex].Name,lpItem->m_Number);

  01f6d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f72	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv3285[ebp]
  01f78	8b 11		 mov	 edx, DWORD PTR [ecx]
  01f7a	52		 push	 edx
  01f7b	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  01f7f	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  01f83	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _map_num$[ebp]
  01f89	51		 push	 ecx
  01f8a	52		 push	 edx
  01f8b	83 c0 d4	 add	 eax, -44		; ffffffd4H
  01f8e	50		 push	 eax
  01f8f	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@IHPJKMLA@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@
  01f94	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01f9a	83 c4 14	 add	 esp, 20			; 00000014H
  01f9d	5f		 pop	 edi
  01f9e	5e		 pop	 esi
  01f9f	5b		 pop	 ebx

; 4039 : 	}
; 4040 : }

  01fa0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01fa3	33 cd		 xor	 ecx, ebp
  01fa5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01faa	8b e5		 mov	 esp, ebp
  01fac	5d		 pop	 ebp
  01fad	c3		 ret	 0
$LN111@CGItemGetR:

; 4009 : 						}
; 4010 : #if (ENABLETEST_ARCA == 1)
; 4011 : 						if( g_ArcaBattle.IsArcaBattleServer() && lpItem->m_Type == AB_REW_KILL_TROPHY )
; 4012 : 						{
; 4013 : 							g_ArcaBattle.BootyItemGetCnt(gObj[aIndex]);
; 4014 : 						}
; 4015 : #endif
; 4016 : 					}
; 4017 : 				}
; 4018 : 				else
; 4019 : 				{
; 4020 : 					pResult.result = -1;
; 4021 : 					pResult.h.size -= sizeof(pResult.Data);
; 4022 : 
; 4023 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4024 : 				}
; 4025 : 			}
; 4026 : 			else
; 4027 : 			{
; 4028 : 				pResult.result = -1;
; 4029 : 				pResult.h.size -= sizeof(pResult.Data);
; 4030 : 
; 4031 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4032 : 			}
; 4033 : 		}
; 4034 : 	}
; 4035 : 	else
; 4036 : 	{
; 4037 : 		pResult.h.size -= sizeof(pResult.Data);

  01fae	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  01fb4	04 f4		 add	 al, 244			; 000000f4H

; 4038 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  01fb6	0f b6 d0	 movzx	 edx, al
  01fb9	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  01fbf	52		 push	 edx
  01fc0	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  01fc6	50		 push	 eax
$LN232@CGItemGetR:
  01fc7	53		 push	 ebx
  01fc8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01fcd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN231@CGItemGetR:
  01fd0	5f		 pop	 edi
$LN230@CGItemGetR:

; 4039 : 	}
; 4040 : }

  01fd1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01fd4	5e		 pop	 esi
  01fd5	33 cd		 xor	 ecx, ebp
  01fd7	5b		 pop	 ebx
  01fd8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01fdd	8b e5		 mov	 esp, ebp
  01fdf	5d		 pop	 ebp
  01fe0	c3		 ret	 0
  01fe1	8d 49 00	 npad	 3
$LN238@CGItemGetR:
  01fe4	00 00 00 00	 DD	 $LN74@CGItemGetR
  01fe8	00 00 00 00	 DD	 $LN74@CGItemGetR
  01fec	00 00 00 00	 DD	 $LN74@CGItemGetR
  01ff0	00 00 00 00	 DD	 $LN79@CGItemGetR
  01ff4	00 00 00 00	 DD	 $LN78@CGItemGetR
  01ff8	00 00 00 00	 DD	 $LN77@CGItemGetR
?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ENDP	; CGItemGetRequest
_TEXT	ENDS
PUBLIC	??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@ ; `string'
PUBLIC	??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z	; CGTalkRequestRecv
EXTRN	?SendPrice@ItemPrice@@QAEXHH@Z:PROC		; ItemPrice::SendPrice
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjWarehouseTextSave
EXTRN	?gObjInventoryTrans@@YAHH@Z:PROC		; gObjInventoryTrans
EXTRN	?gDQChaosSuccessRateLevel7@@3HA:DWORD		; gDQChaosSuccessRateLevel7
EXTRN	?gDQChaosSuccessRateLevel6@@3HA:DWORD		; gDQChaosSuccessRateLevel6
EXTRN	?gDQChaosSuccessRateLevel5@@3HA:DWORD		; gDQChaosSuccessRateLevel5
EXTRN	?gDQChaosSuccessRateLevel4@@3HA:DWORD		; gDQChaosSuccessRateLevel4
EXTRN	?gDQChaosSuccessRateLevel3@@3HA:DWORD		; gDQChaosSuccessRateLevel3
EXTRN	?gDQChaosSuccessRateLevel1@@3HA:DWORD		; gDQChaosSuccessRateLevel1
EXTRN	?gDQChaosSuccessRateLevel2@@3HA:DWORD		; gDQChaosSuccessRateLevel2
EXTRN	?bCanChaosBox@@3HA:DWORD			; bCanChaosBox
EXTRN	?GDGetWarehouseList@@YAXHPAD@Z:PROC		; GDGetWarehouseList
EXTRN	?gHappyNewYearNpcEvent@@3HA:DWORD		; gHappyNewYearNpcEvent
EXTRN	?gMerryXMasNpcEvent@@3HA:DWORD			; gMerryXMasNpcEvent
EXTRN	?NpcTalk@@YAHPAUOBJECTSTRUCT@@0@Z:PROC		; NpcTalk
;	COMDAT ??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@
CONST	SEGMENT
??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@ DB '['
	DB	'%s][%s] Open Chaos Box', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@
CONST	SEGMENT
??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@ DB '['
	DB	'ANTI-HACK][NPC Talk] Couldn''t talk.. (%s)(%s)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z
_TEXT	SEGMENT
tv512 = -2084						; size = 4
_pShopItemCount$ = -2080				; size = 6
_lpMsg$GSCopy$ = -2072					; size = 4
_ShopNum$ = -2072					; size = 4
_aIndex$GSCopy$ = -2068					; size = 4
_pResult$ = -2064					; size = 11
_SendByte$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z PROC	; CGTalkRequestRecv, COMDAT

; 5172 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 08 00
	00		 sub	 esp, 2084		; 00000824H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 5173 : 	LPOBJ lpObj = &gObj[aIndex];

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0001c	53		 push	 ebx
  0001d	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	8b fb		 mov	 edi, ebx
  00024	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  0002a	8d 34 0f	 lea	 esi, DWORD PTR [edi+ecx]

; 5174 : 	int DealerNumber ;
; 5175 : 	PMSG_TALKRESULT pResult;
; 5176 : 	PMSG_SHOPITEMCOUNT pShopItemCount;
; 5177 : 
; 5178 : 	if ( !PacketCheckTime(lpObj))

  0002d	56		 push	 esi

; 5182 : 		return;
; 5183 : 
; 5184 : 	if ( !gObjIsConnectedGP(aIndex) )

  0002e	89 85 e8 f7 ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax
  00034	89 9d ec f7 ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0003a	89 bd dc f7 ff
	ff		 mov	 DWORD PTR tv512[ebp], edi
  00040	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00045	83 c4 04	 add	 esp, 4
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 b8 05 00
	00		 je	 $LN31@CGTalkRequ

; 5179 : 		return;
; 5180 : 
; 5181 : 	if ( gObj[aIndex].CloseType != -1 )

  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	80 7c 17 0d ff	 cmp	 BYTE PTR [edi+edx+13], -1
  0005b	0f 85 a7 05 00
	00		 jne	 $LN31@CGTalkRequ

; 5182 : 		return;
; 5183 : 
; 5184 : 	if ( !gObjIsConnectedGP(aIndex) )

  00061	53		 push	 ebx
  00062	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00067	83 c4 04	 add	 esp, 4
  0006a	85 c0		 test	 eax, eax
  0006c	75 2e		 jne	 SHORT $LN37@CGTalkRequ

; 5185 : 	{
; 5186 : 		LogAddTD("[ANTI-HACK][NPC Talk] Couldn't talk.. (%s)(%s)",
; 5187 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);

  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00073	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  00077	51		 push	 ecx
  00078	8d 54 07 52	 lea	 edx, DWORD PTR [edi+eax+82]
  0007c	52		 push	 edx
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5283 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 122)), aIndex);

  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 5395 : 	}
; 5396 : }

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00091	33 cd		 xor	 ecx, ebp
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
$LN37@CGTalkRequ:

; 5188 : 
; 5189 : 		return;
; 5190 : 	}
; 5191 : 
; 5192 : 	BYTE SendByte[2048];
; 5193 : 	int lOfs = 0;
; 5194 : 
; 5195 : 	if ( lpObj->m_IfState.use > 0 )

  0009c	f6 86 b8 11 00
	00 03		 test	 BYTE PTR [esi+4536], 3
  000a3	0f 87 5f 05 00
	00		 ja	 $LN31@CGTalkRequ

; 5196 : 		return;
; 5197 : 
; 5198 : 	DealerNumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  000a9	8b 85 e8 f7 ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  000af	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000b3	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  000b7	66 c1 e1 08	 shl	 cx, 8
  000bb	0f b7 f9	 movzx	 edi, cx
  000be	0b fa		 or	 edi, edx

; 5199 : 	
; 5200 : 	if ( DealerNumber < 0 || DealerNumber > OBJMAX-1)

  000c0	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  000c6	0f 87 3c 05 00
	00		 ja	 $LN31@CGTalkRequ

; 5201 : 		return;
; 5202 : 
; 5203 : 	if ( lpObj->MapNumber != gObj[DealerNumber].MapNumber )

  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d1	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  000d7	8a 8e 23 01 00
	00		 mov	 cl, BYTE PTR [esi+291]
  000dd	03 c7		 add	 eax, edi
  000df	3a 88 23 01 00
	00		 cmp	 cl, BYTE PTR [eax+291]
  000e5	0f 85 1d 05 00
	00		 jne	 $LN31@CGTalkRequ

; 5204 : 		return;
; 5205 : 
; 5206 : 	if ( (lpObj->X < (gObj[DealerNumber].X-5) )|| (lpObj->X> (gObj[DealerNumber].X+5) )||(lpObj->Y < (gObj[DealerNumber].Y-5)) ||(lpObj->Y > (gObj[DealerNumber].Y+5)))

  000eb	0f b6 88 20 01
	00 00		 movzx	 ecx, BYTE PTR [eax+288]
  000f2	0f b6 96 20 01
	00 00		 movzx	 edx, BYTE PTR [esi+288]
  000f9	8d 59 fb	 lea	 ebx, DWORD PTR [ecx-5]
  000fc	3b d3		 cmp	 edx, ebx
  000fe	0f 8c 04 05 00
	00		 jl	 $LN31@CGTalkRequ
  00104	83 c1 05	 add	 ecx, 5
  00107	3b d1		 cmp	 edx, ecx
  00109	0f 8f f9 04 00
	00		 jg	 $LN31@CGTalkRequ
  0010f	0f b6 88 21 01
	00 00		 movzx	 ecx, BYTE PTR [eax+289]
  00116	0f b6 96 21 01
	00 00		 movzx	 edx, BYTE PTR [esi+289]
  0011d	8d 59 fb	 lea	 ebx, DWORD PTR [ecx-5]
  00120	3b d3		 cmp	 edx, ebx
  00122	0f 8c e0 04 00
	00		 jl	 $LN31@CGTalkRequ
  00128	83 c1 05	 add	 ecx, 5
  0012b	3b d1		 cmp	 edx, ecx
  0012d	0f 8f d5 04 00
	00		 jg	 $LN31@CGTalkRequ

; 5207 : 	{
; 5208 : 		return;
; 5209 : 	}
; 5210 : 
; 5211 : 	int ShopNum = gObj[DealerNumber].ShopNumber;
; 5212 : 
; 5213 : 	if ( gObj[DealerNumber].Type == OBJ_NPC )

  00133	80 78 50 03	 cmp	 BYTE PTR [eax+80], 3
  00137	0f bf 98 3c 06
	00 00		 movsx	 ebx, WORD PTR [eax+1596]
  0013e	89 9d e8 f7 ff
	ff		 mov	 DWORD PTR _ShopNum$[ebp], ebx
  00144	75 13		 jne	 SHORT $LN29@CGTalkRequ

; 5214 : 	{
; 5215 : 		if ( NpcTalk(&gObj[DealerNumber], lpObj) == TRUE )

  00146	56		 push	 esi
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ?NpcTalk@@YAHPAUOBJECTSTRUCT@@0@Z ; NpcTalk
  0014d	83 c4 08	 add	 esp, 8
  00150	83 f8 01	 cmp	 eax, 1
  00153	0f 84 af 04 00
	00		 je	 $LN31@CGTalkRequ
$LN29@CGTalkRequ:

; 5216 : 			return;
; 5217 : 	}
; 5218 : 
; 5219 : 	if ( ::gObjFixInventoryPointer(aIndex) == false )

  00159	8b 95 ec f7 ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0015f	52		 push	 edx
  00160	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00165	83 c4 04	 add	 esp, 4
  00168	84 c0		 test	 al, al
  0016a	75 18		 jne	 SHORT $LN28@CGTalkRequ

; 5220 : 	{
; 5221 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0016c	68 65 14 00 00	 push	 5221			; 00001465H
  00171	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00176	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  0017b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@CGTalkRequ:

; 5222 : 	}
; 5223 : 
; 5224 : 	if ( gObj[DealerNumber].Class == 234 )	// Npc Server Division

  00184	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00189	b9 ea 00 00 00	 mov	 ecx, 234		; 000000eaH
  0018e	66 39 8c 07 90
	00 00 00	 cmp	 WORD PTR [edi+eax+144], cx
  00196	75 40		 jne	 SHORT $LN27@CGTalkRequ

; 5225 : 	{
; 5226 : 		pResult.h.c = 0xC3;
; 5227 : 		pResult.h.headcode = 0x30;
; 5228 : 		pResult.h.size = sizeof(pResult);
; 5229 : 		pResult.result = 0;
; 5230 : 		pResult.result = 5;
; 5231 : 
; 5232 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00198	8b 85 ec f7 ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0019e	6a 0b		 push	 11			; 0000000bH
  001a0	8d 95 f0 f7 ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  001a6	52		 push	 edx
  001a7	50		 push	 eax
  001a8	c6 85 f0 f7 ff
	ff c3		 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H
  001af	66 c7 85 f1 f7
	ff ff 0b 30	 mov	 WORD PTR _pResult$[ebp+1], 12299 ; 0000300bH
  001b8	c6 85 f3 f7 ff
	ff 05		 mov	 BYTE PTR _pResult$[ebp+3], 5
  001bf	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5283 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 122)), aIndex);

  001c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c7	5f		 pop	 edi
  001c8	5e		 pop	 esi
  001c9	5b		 pop	 ebx

; 5395 : 	}
; 5396 : }

  001ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001cd	33 cd		 xor	 ecx, ebp
  001cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d4	8b e5		 mov	 esp, ebp
  001d6	5d		 pop	 ebp
  001d7	c3		 ret	 0
$LN27@CGTalkRequ:

; 5233 : 		return;
; 5234 : 	}
; 5235 : 
; 5236 : 	if ( gObj[DealerNumber].Type == OBJ_NPC && ShopNum < 0)

  001d8	80 7c 07 50 03	 cmp	 BYTE PTR [edi+eax+80], 3
  001dd	75 08		 jne	 SHORT $LN26@CGTalkRequ
  001df	85 db		 test	 ebx, ebx
  001e1	0f 88 21 04 00
	00		 js	 $LN31@CGTalkRequ
$LN26@CGTalkRequ:

; 5237 : 		return;
; 5238 : 
; 5239 : 	CShop* lpShop = g_ShopManager.Get(ShopNum);

  001e7	53		 push	 ebx
  001e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopManager@@3VShopManager@@A ; g_ShopManager
  001ed	e8 00 00 00 00	 call	 ?Get@ShopManager@@QAEPAVCShop@@H@Z ; ShopManager::Get
  001f2	8b d8		 mov	 ebx, eax

; 5240 : 
; 5241 : 	if( lpShop )

  001f4	85 db		 test	 ebx, ebx
  001f6	74 38		 je	 SHORT $LN44@CGTalkRequ

; 5242 : 	{
; 5243 : 		if ( lpShop->ItemCount < TRUE )

  001f8	83 bb 84 00 00
	00 01		 cmp	 DWORD PTR [ebx+132], 1
  001ff	7d 2f		 jge	 SHORT $LN44@CGTalkRequ

; 5244 : 		{
; 5245 : 			if ( (rand()%2) != 0 )

  00201	e8 00 00 00 00	 call	 _rand
  00206	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0020b	79 05		 jns	 SHORT $LN47@CGTalkRequ
  0020d	48		 dec	 eax
  0020e	83 c8 fe	 or	 eax, -2			; fffffffeH
  00211	40		 inc	 eax
$LN47@CGTalkRequ:
  00212	74 0e		 je	 SHORT $LN23@CGTalkRequ

; 5246 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 119)), aIndex);

  00214	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0021a	51		 push	 ecx
  0021b	68 77 04 00 00	 push	 1143			; 00000477H

; 5247 : 			else

  00220	eb 4d		 jmp	 SHORT $LN49@CGTalkRequ
$LN23@CGTalkRequ:

; 5248 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 120)), aIndex);

  00222	8b 85 ec f7 ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00228	50		 push	 eax
  00229	68 78 04 00 00	 push	 1144			; 00000478H

; 5249 : 
; 5250 : 			return;

  0022e	eb 3f		 jmp	 SHORT $LN49@CGTalkRequ
$LN44@CGTalkRequ:

; 5251 : 		}
; 5252 : 	}
; 5253 : 
; 5254 : 	if ( gPkLimitFree == FALSE )

  00230	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00237	75 61		 jne	 SHORT $LN19@CGTalkRequ

; 5255 : 	{
; 5256 : 		int bPk = FALSE;
; 5257 : 
; 5258 : #if (ENABLE_FIX_NPCTALKPK == 1)
; 5259 : 		if( lpObj->m_PK_Level > 4 )

  00239	80 be 19 01 00
	00 04		 cmp	 BYTE PTR [esi+281], 4
  00240	7e 58		 jle	 SHORT $LN19@CGTalkRequ

; 5260 : 		{
; 5261 : 			bPk = TRUE;
; 5262 : 		}
; 5263 : #else
; 5264 : 
; 5265 : 		if( lpObj->PartyNumber >= 0 )
; 5266 : 		{
; 5267 : 			if( gParty.GetPartyPkLevel(lpObj->PartyNumber) > 4 )
; 5268 : 			{
; 5269 : 				bPk = TRUE;
; 5270 : 			}
; 5271 : 		}
; 5272 : 		else if( lpObj->m_PK_Level > 4 )
; 5273 : 		{
; 5274 : 			bPk = TRUE;
; 5275 : 		}
; 5276 : #endif
; 5277 : 
; 5278 : 		if ( bPk == TRUE )
; 5279 : 		{
; 5280 : 			if ( (rand()%2) != 0 )

  00242	e8 00 00 00 00	 call	 _rand
  00247	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0024c	79 05		 jns	 SHORT $LN48@CGTalkRequ
  0024e	48		 dec	 eax
  0024f	83 c8 fe	 or	 eax, -2			; fffffffeH
  00252	40		 inc	 eax
$LN48@CGTalkRequ:
  00253	74 0e		 je	 SHORT $LN18@CGTalkRequ

; 5281 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 121)), aIndex);

  00255	8b 95 ec f7 ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0025b	52		 push	 edx
  0025c	68 79 04 00 00	 push	 1145			; 00000479H

; 5282 : 			else

  00261	eb 0c		 jmp	 SHORT $LN49@CGTalkRequ
$LN18@CGTalkRequ:

; 5283 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 122)), aIndex);

  00263	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00269	51		 push	 ecx
  0026a	68 7a 04 00 00	 push	 1146			; 0000047aH
$LN49@CGTalkRequ:
  0026f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00274	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00279	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0027f	50		 push	 eax
  00280	57		 push	 edi
  00281	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  00286	83 c4 0c	 add	 esp, 12			; 0000000cH
  00289	5f		 pop	 edi
  0028a	5e		 pop	 esi
  0028b	5b		 pop	 ebx

; 5395 : 	}
; 5396 : }

  0028c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028f	33 cd		 xor	 ecx, ebp
  00291	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00296	8b e5		 mov	 esp, ebp
  00298	5d		 pop	 ebp
  00299	c3		 ret	 0
$LN19@CGTalkRequ:

; 5284 : 			return;
; 5285 : 		}
; 5286 : 	}
; 5287 : 
; 5288 : 	if ( gMerryXMasNpcEvent == TRUE )

  0029a	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gMerryXMasNpcEvent@@3HA, 1 ; gMerryXMasNpcEvent
  002a1	75 39		 jne	 SHORT $LN45@CGTalkRequ

; 5289 : 	{
; 5290 : 		if ( (rand()%6) == 0 )

  002a3	e8 00 00 00 00	 call	 _rand
  002a8	99		 cdq
  002a9	b9 06 00 00 00	 mov	 ecx, 6
  002ae	f7 f9		 idiv	 ecx
  002b0	85 d2		 test	 edx, edx
  002b2	75 28		 jne	 SHORT $LN45@CGTalkRequ

; 5291 : 		{
; 5292 : 			ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 123)), aIndex);

  002b4	8b 95 ec f7 ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  002ba	52		 push	 edx
  002bb	68 7b 04 00 00	 push	 1147			; 0000047bH
  002c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  002c5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  002ca	50		 push	 eax
  002cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d0	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  002d3	51		 push	 ecx
  002d4	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  002d9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN45@CGTalkRequ:

; 5293 : 		}
; 5294 : 	}
; 5295 : 
; 5296 : 	if ( ::gHappyNewYearNpcEvent == TRUE )

  002dc	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gHappyNewYearNpcEvent@@3HA, 1 ; gHappyNewYearNpcEvent
  002e3	75 39		 jne	 SHORT $LN46@CGTalkRequ

; 5297 : 	{
; 5298 : 		if ( (rand()%6) == 0 )

  002e5	e8 00 00 00 00	 call	 _rand
  002ea	99		 cdq
  002eb	b9 06 00 00 00	 mov	 ecx, 6
  002f0	f7 f9		 idiv	 ecx
  002f2	85 d2		 test	 edx, edx
  002f4	75 28		 jne	 SHORT $LN46@CGTalkRequ

; 5299 : 		{
; 5300 : 			ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 124)), aIndex);

  002f6	8b 95 ec f7 ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  002fc	52		 push	 edx
  002fd	68 7c 04 00 00	 push	 1148			; 0000047cH
  00302	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00307	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0030c	50		 push	 eax
  0030d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00312	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00315	51		 push	 ecx
  00316	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  0031b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN46@CGTalkRequ:

; 5301 : 		}
; 5302 : 	}
; 5303 : 
; 5304 : 	lpObj->TargetShopNumber = ShopNum;
; 5305 : 	lpObj->m_IfState.use = 1;
; 5306 : 	lpObj->m_IfState.type = 3;

  0031e	8b 96 b8 11 00
	00		 mov	 edx, DWORD PTR [esi+4536]
  00324	8b 85 e8 f7 ff
	ff		 mov	 eax, DWORD PTR _ShopNum$[ebp]
  0032a	81 e2 fd 00 ff
	ff		 and	 edx, -65283		; ffff00fdH
  00330	81 ca c1 00 00
	00		 or	 edx, 193		; 000000c1H
  00336	66 89 86 3a 06
	00 00		 mov	 WORD PTR [esi+1594], ax
  0033d	89 96 b8 11 00
	00		 mov	 DWORD PTR [esi+4536], edx

; 5307 : 	lpObj->m_ShopTime = 0;

  00343	c6 86 80 05 00
	00 00		 mov	 BYTE PTR [esi+1408], 0

; 5308 : 	pResult.h.c = 0xC3;

  0034a	c6 85 f0 f7 ff
	ff c3		 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H

; 5309 : 	pResult.h.headcode = 0x30;

  00351	66 c7 85 f1 f7
	ff ff 0b 30	 mov	 WORD PTR _pResult$[ebp+1], 12299 ; 0000300bH

; 5310 : 	pResult.h.size = sizeof(pResult);
; 5311 : 	pResult.result = 0;

  0035a	c6 85 f3 f7 ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0

; 5312 : 
; 5313 : 	if ( ShopNum == 100 )

  00361	83 f8 64	 cmp	 eax, 100		; 00000064H
  00364	75 6f		 jne	 SHORT $LN12@CGTalkRequ

; 5314 : 	{
; 5315 : 		if ( gObj[aIndex].m_ReqWarehouseOpen != false )

  00366	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0036b	8b 8d dc f7 ff
	ff		 mov	 ecx, DWORD PTR tv512[ebp]
  00371	80 bc 01 b0 14
	00 00 00	 cmp	 BYTE PTR [ecx+eax+5296], 0
  00379	0f 85 89 02 00
	00		 jne	 $LN31@CGTalkRequ

; 5316 : 			return;
; 5317 : 		
; 5318 : 		gObj[aIndex].m_ReqWarehouseOpen = true;

  0037f	c6 84 01 b0 14
	00 00 01	 mov	 BYTE PTR [ecx+eax+5296], 1

; 5319 : 		lpObj->m_IfState.type = 6;
; 5320 : 		lpObj->m_IfState.state = 0;

  00387	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  0038d	25 83 01 ff ff	 and	 eax, -65149		; ffff0183H
  00392	0d 80 01 00 00	 or	 eax, 384		; 00000180H
  00397	89 86 b8 11 00
	00		 mov	 DWORD PTR [esi+4536], eax

; 5365 : 	}
; 5366 : 
; 5367 : 	if ( ShopNum == 100 )
; 5368 : 	{
; 5369 : 		gObj[aIndex].WarehouseCount = 0;

  0039d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a2	c6 84 01 01 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4609], 0

; 5370 : 		GDGetWarehouseList(aIndex, gObj[aIndex].AccountID);

  003aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003b0	8d 44 11 52	 lea	 eax, DWORD PTR [ecx+edx+82]
  003b4	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  003ba	50		 push	 eax
  003bb	51		 push	 ecx
  003bc	e8 00 00 00 00	 call	 ?GDGetWarehouseList@@YAXHPAD@Z ; GDGetWarehouseList
  003c1	83 c4 08	 add	 esp, 8
  003c4	5f		 pop	 edi
  003c5	5e		 pop	 esi
  003c6	5b		 pop	 ebx

; 5395 : 	}
; 5396 : }

  003c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ca	33 cd		 xor	 ecx, ebp
  003cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d1	8b e5		 mov	 esp, ebp
  003d3	5d		 pop	 ebp
  003d4	c3		 ret	 0
$LN12@CGTalkRequ:

; 5321 : 	}
; 5322 : 	else if ( ShopNum == 101 )

  003d5	83 f8 65	 cmp	 eax, 101		; 00000065H
  003d8	0f 85 67 01 00
	00		 jne	 $LN9@CGTalkRequ

; 5323 : 	{
; 5324 : 		if ( bCanChaosBox == TRUE )

  003de	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanChaosBox@@3HA, 1 ; bCanChaosBox
  003e5	0f 85 1d 02 00
	00		 jne	 $LN31@CGTalkRequ

; 5325 : 		{
; 5326 : 			if ( lpObj->m_bPShopOpen == true )

  003eb	80 be 5c 12 00
	00 01		 cmp	 BYTE PTR [esi+4700], 1
  003f2	75 44		 jne	 SHORT $LN7@CGTalkRequ

; 5327 : 			{
; 5328 : 				LogAdd("[%s][%s] is Already Opening PShop, ChaosBox Failed",
; 5329 : 					lpObj->AccountID, lpObj->Name);

  003f4	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  003f7	51		 push	 ecx
  003f8	8d 56 52	 lea	 edx, DWORD PTR [esi+82]
  003fb	52		 push	 edx
  003fc	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
  00401	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 5330 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(4, 194)), lpObj->m_Index, 1);

  00407	8b 06		 mov	 eax, DWORD PTR [esi]
  00409	83 c4 0c	 add	 esp, 12			; 0000000cH
  0040c	6a 01		 push	 1
  0040e	50		 push	 eax
  0040f	68 c2 04 00 00	 push	 1218			; 000004c2H
  00414	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00419	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0041e	50		 push	 eax
  0041f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00424	83 c4 0c	 add	 esp, 12			; 0000000cH
  00427	5f		 pop	 edi
  00428	5e		 pop	 esi
  00429	5b		 pop	 ebx

; 5395 : 	}
; 5396 : }

  0042a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0042d	33 cd		 xor	 ecx, ebp
  0042f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00434	8b e5		 mov	 esp, ebp
  00436	5d		 pop	 ebp
  00437	c3		 ret	 0
$LN7@CGTalkRequ:

; 5331 : 
; 5332 : 				return;
; 5333 : 			}
; 5334 : 
; 5335 : 			lpObj->m_IfState.type = 7;
; 5336 : 			lpObj->m_IfState.state = 0;

  00438	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  0043e	81 e1 c3 01 ff
	ff		 and	 ecx, -65085		; ffff01c3H
  00444	81 c9 c0 01 00
	00		 or	 ecx, 448		; 000001c0H
  0044a	89 8e b8 11 00
	00		 mov	 DWORD PTR [esi+4536], ecx

; 5337 : 			pResult.result = 3;
; 5338 : 
; 5339 : 			if( gObj[DealerNumber].Class == 450 )

  00450	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00455	ba c2 01 00 00	 mov	 edx, 450		; 000001c2H
  0045a	c6 85 f3 f7 ff
	ff 03		 mov	 BYTE PTR _pResult$[ebp+3], 3
  00461	66 39 94 07 90
	00 00 00	 cmp	 WORD PTR [edi+eax+144], dx
  00469	75 07		 jne	 SHORT $LN6@CGTalkRequ

; 5340 : 			{
; 5341 : 				pResult.result = 22;

  0046b	c6 85 f3 f7 ff
	ff 16		 mov	 BYTE PTR _pResult$[ebp+3], 22 ; 00000016H
$LN6@CGTalkRequ:

; 5342 : 			}
; 5343 : 
; 5344 : 			lpObj->bIsChaosMixCompleted = false;

  00472	c6 86 09 16 00
	00 00		 mov	 BYTE PTR [esi+5641], 0

; 5345 : 			pResult.level1 = gDQChaosSuccessRateLevel1;
; 5346 : 			pResult.level2 = gDQChaosSuccessRateLevel2;

  00479	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?gDQChaosSuccessRateLevel2@@3HA
  00480	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?gDQChaosSuccessRateLevel1@@3HA

; 5347 : 			pResult.level3 = gDQChaosSuccessRateLevel3;

  00487	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?gDQChaosSuccessRateLevel3@@3HA
  0048e	88 8d f4 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+4], cl

; 5348 : 			pResult.level4 = gDQChaosSuccessRateLevel4;

  00494	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?gDQChaosSuccessRateLevel4@@3HA
  0049b	88 95 f5 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+5], dl

; 5349 : 			pResult.level5 = gDQChaosSuccessRateLevel5;

  004a1	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?gDQChaosSuccessRateLevel5@@3HA
  004a8	88 85 f6 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+6], al

; 5350 : 			pResult.level6 = gDQChaosSuccessRateLevel6;

  004ae	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?gDQChaosSuccessRateLevel6@@3HA
  004b5	88 8d f7 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+7], cl

; 5351 : 			pResult.level7 = gDQChaosSuccessRateLevel7;

  004bb	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?gDQChaosSuccessRateLevel7@@3HA
  004c2	88 95 f8 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+8], dl

; 5352 : 
; 5353 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  004c8	0f b6 95 f1 f7
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  004cf	88 85 f9 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+9], al
  004d5	52		 push	 edx
  004d6	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  004dc	88 8d fa f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+10], cl
  004e2	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  004e8	50		 push	 eax
  004e9	51		 push	 ecx
  004ea	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5354 : 			gObjInventoryTrans(lpObj->m_Index);

  004ef	8b 16		 mov	 edx, DWORD PTR [esi]
  004f1	52		 push	 edx
  004f2	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans

; 5355 : 
; 5356 : 			LogAddTD("[%s][%s] Open Chaos Box", lpObj->AccountID, lpObj->Name);

  004f7	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  004fa	50		 push	 eax
  004fb	8d 4e 52	 lea	 ecx, DWORD PTR [esi+82]
  004fe	51		 push	 ecx
  004ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@
  00504	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5357 : 			gObjItemTextSave(lpObj);

  0050a	56		 push	 esi
  0050b	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjItemTextSave

; 5358 : 			gObjWarehouseTextSave(lpObj);

  00510	56		 push	 esi
  00511	e8 00 00 00 00	 call	 ?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjWarehouseTextSave

; 5359 : 			GCAnsCsMapSvrTaxInfo( lpObj->m_Index, 1, ::g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index));

  00516	8b 16		 mov	 edx, DWORD PTR [esi]
  00518	83 c4 24	 add	 esp, 36			; 00000024H
  0051b	52		 push	 edx
  0051c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00521	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00526	50		 push	 eax
  00527	8b 06		 mov	 eax, DWORD PTR [esi]
  00529	6a 01		 push	 1
  0052b	50		 push	 eax
  0052c	e8 00 00 00 00	 call	 ?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z ; GCAnsCsMapSvrTaxInfo
  00531	83 c4 0c	 add	 esp, 12			; 0000000cH
  00534	5f		 pop	 edi
  00535	5e		 pop	 esi
  00536	5b		 pop	 ebx

; 5395 : 	}
; 5396 : }

  00537	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0053a	33 cd		 xor	 ecx, ebp
  0053c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00541	8b e5		 mov	 esp, ebp
  00543	5d		 pop	 ebp
  00544	c3		 ret	 0
$LN9@CGTalkRequ:

; 5360 : 		}
; 5361 : 	}
; 5362 : 	else
; 5363 : 	{
; 5364 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00545	8b 95 ec f7 ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0054b	6a 0b		 push	 11			; 0000000bH
  0054d	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00553	51		 push	 ecx
  00554	52		 push	 edx
  00555	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0055a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5371 : 
; 5372 : 		return;
; 5373 : 	}
; 5374 : 
; 5375 : 	if ( ShopNum == 101 )
; 5376 : 	{
; 5377 : 		return;
; 5378 : 	}
; 5379 : 	else if( lpShop )

  0055d	85 db		 test	 ebx, ebx
  0055f	0f 84 a3 00 00
	00		 je	 $LN31@CGTalkRequ

; 5380 : 	{
; 5381 : 		lOfs = 0;
; 5382 : 		lOfs += sizeof(pShopItemCount);
; 5383 : 
; 5384 : 		int size = lOfs + lpShop->SendItemDataLen;

  00565	8b bb 00 6a 00
	00		 mov	 edi, DWORD PTR [ebx+27136]
  0056b	83 c7 06	 add	 edi, 6

; 5385 : 		PHeadSetW((LPBYTE)&pShopItemCount, 0x31, size);

  0056e	57		 push	 edi
  0056f	8d 95 e0 f7 ff
	ff		 lea	 edx, DWORD PTR _pShopItemCount$[ebp]
  00575	6a 31		 push	 49			; 00000031H
  00577	52		 push	 edx
  00578	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 5386 : 		pShopItemCount.Type = 0;
; 5387 : 		pShopItemCount.count = lpShop->ItemCount;
; 5388 : 		memcpy(SendByte, &pShopItemCount, sizeof(pShopItemCount));

  0057d	8b 8d e0 f7 ff
	ff		 mov	 ecx, DWORD PTR _pShopItemCount$[ebp]
  00583	c6 85 e4 f7 ff
	ff 00		 mov	 BYTE PTR _pShopItemCount$[ebp+4], 0
  0058a	8a 83 84 00 00
	00		 mov	 al, BYTE PTR [ebx+132]
  00590	88 85 e5 f7 ff
	ff		 mov	 BYTE PTR _pShopItemCount$[ebp+5], al
  00596	66 8b 95 e4 f7
	ff ff		 mov	 dx, WORD PTR _pShopItemCount$[ebp+4]
  0059d	89 8d fc f7 ff
	ff		 mov	 DWORD PTR _SendByte$[ebp], ecx
  005a3	66 89 95 00 f8
	ff ff		 mov	 WORD PTR _SendByte$[ebp+4], dx

; 5389 : 		memcpy(&SendByte[lOfs], lpShop->SendItemData, lpShop->SendItemDataLen);

  005aa	8b 83 00 6a 00
	00		 mov	 eax, DWORD PTR [ebx+27136]
  005b0	50		 push	 eax
  005b1	81 c3 e8 63 00
	00		 add	 ebx, 25576		; 000063e8H
  005b7	8d 8d 02 f8 ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp+6]
  005bd	53		 push	 ebx
  005be	51		 push	 ecx
  005bf	e8 00 00 00 00	 call	 _memcpy

; 5390 : 
; 5391 : 		DataSend(aIndex, SendByte, size);

  005c4	57		 push	 edi
  005c5	8b bd ec f7 ff
	ff		 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  005cb	8d 95 fc f7 ff
	ff		 lea	 edx, DWORD PTR _SendByte$[ebp]
  005d1	52		 push	 edx
  005d2	57		 push	 edi
  005d3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5392 : 		GCAnsCsMapSvrTaxInfo(lpObj->m_Index,2, g_CastleSiegeSync.GetTaxRateStore(lpObj->m_Index));

  005d8	8b 06		 mov	 eax, DWORD PTR [esi]
  005da	83 c4 24	 add	 esp, 36			; 00000024H
  005dd	50		 push	 eax
  005de	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  005e3	e8 00 00 00 00	 call	 ?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateStore
  005e8	8b 0e		 mov	 ecx, DWORD PTR [esi]
  005ea	50		 push	 eax
  005eb	6a 02		 push	 2
  005ed	51		 push	 ecx
  005ee	e8 00 00 00 00	 call	 ?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z ; GCAnsCsMapSvrTaxInfo

; 5393 : 
; 5394 : 		g_ItemPrice.SendPrice(aIndex, ShopNum);

  005f3	8b 95 e8 f7 ff
	ff		 mov	 edx, DWORD PTR _ShopNum$[ebp]
  005f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  005fc	52		 push	 edx
  005fd	57		 push	 edi
  005fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemPrice@@3VItemPrice@@A ; g_ItemPrice
  00603	e8 00 00 00 00	 call	 ?SendPrice@ItemPrice@@QAEXHH@Z ; ItemPrice::SendPrice
$LN31@CGTalkRequ:

; 5395 : 	}
; 5396 : }

  00608	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0060b	5f		 pop	 edi
  0060c	5e		 pop	 esi
  0060d	33 cd		 xor	 ecx, ebp
  0060f	5b		 pop	 ebx
  00610	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00615	8b e5		 mov	 esp, ebp
  00617	5d		 pop	 ebp
  00618	c3		 ret	 0
?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z ENDP	; CGTalkRequestRecv
_TEXT	ENDS
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z	; GCUserWarehouseSend
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$GSCopy$ = -4120					; size = 4
tv251 = -4116						; size = 4
_n$219097 = -4112					; size = 4
_pMsg$ = -4108						; size = 6
_SendByte$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z PROC	; GCUserWarehouseSend, COMDAT

; 5404 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 18 10 00 00	 mov	 eax, 4120		; 00001018H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 5405 : 	if ( lpObj->m_IfState.type != 6 )

  0001c	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  00022	8b c8		 mov	 ecx, eax
  00024	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0002a	57		 push	 edi

; 5428 : 		}
; 5429 : 	}
; 5430 : 
; 5431 : 	pMsg.h.sizeH = SET_NUMBERH(lOfs);

  0002b	89 b5 e8 ef ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], esi
  00031	81 f9 80 01 00
	00		 cmp	 ecx, 384		; 00000180H
  00037	0f 85 30 01 00
	00		 jne	 $LN1@GCUserWare

; 5406 : 		return;
; 5407 : 
; 5408 : 	if ( lpObj->m_IfState.type == 6 && lpObj->m_IfState.state == 1 )

  0003d	24 3c		 and	 al, 60			; 0000003cH
  0003f	3c 04		 cmp	 al, 4
  00041	0f 84 26 01 00
	00		 je	 $LN1@GCUserWare

; 5409 : 		return;
; 5410 : 
; 5411 : 	PMSG_SHOPITEMCOUNT pMsg;
; 5412 : 	BYTE SendByte[4096];
; 5413 : 	int lOfs = sizeof(pMsg);
; 5414 : 
; 5415 : 	PHeadSetW((LPBYTE)&pMsg, 0x31, 0);

  00047	33 ff		 xor	 edi, edi
  00049	57		 push	 edi
  0004a	8d 95 f4 ef ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  00050	6a 31		 push	 49			; 00000031H
  00052	52		 push	 edx
  00053	bb 06 00 00 00	 mov	 ebx, 6
  00058	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5416 : 	pMsg.count = 0;

  00060	66 89 bd f8 ef
	ff ff		 mov	 WORD PTR _pMsg$[ebp+4], di

; 5417 : 	pMsg.Type = 0;
; 5418 : 
; 5419 : 	for ( int n=0;n<WAREHOUSE_SIZE;n++)

  00067	89 bd f0 ef ff
	ff		 mov	 DWORD PTR _n$219097[ebp], edi
  0006d	89 bd ec ef ff
	ff		 mov	 DWORD PTR tv251[ebp], edi
$LL5@GCUserWare:

; 5420 : 	{
; 5421 : 		if ( lpObj->pWarehouse[n].IsItem() == TRUE )

  00073	8b 8e f8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4600]
  00079	03 cf		 add	 ecx, edi
  0007b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00080	83 f8 01	 cmp	 eax, 1
  00083	75 4c		 jne	 SHORT $LN4@GCUserWare

; 5422 : 		{
; 5423 : 			SendByte[lOfs] = n;
; 5424 : 			lOfs++;
; 5425 : 			ItemByteConvert(&SendByte[lOfs], lpObj->pWarehouse[n] );

  00085	8b b6 f8 11 00
	00		 mov	 esi, DWORD PTR [esi+4600]
  0008b	8a 85 f0 ef ff
	ff		 mov	 al, BYTE PTR _n$219097[ebp]
  00091	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00097	03 f7		 add	 esi, edi
  00099	8b fc		 mov	 edi, esp
  0009b	88 84 1d fc ef
	ff ff		 mov	 BYTE PTR _SendByte$[ebp+ebx], al
  000a2	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  000a7	f3 a5		 rep movsd
  000a9	8d 8c 1d fd ef
	ff ff		 lea	 ecx, DWORD PTR _SendByte$[ebp+ebx+1]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 5426 : 			lOfs += MAX_ITEM_INFO;
; 5427 : 			pMsg.count ++;

  000b6	8b b5 e8 ef ff
	ff		 mov	 esi, DWORD PTR _lpObj$GSCopy$[ebp]
  000bc	8b bd ec ef ff
	ff		 mov	 edi, DWORD PTR tv251[ebp]
  000c2	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000c8	83 c3 0d	 add	 ebx, 13			; 0000000dH
  000cb	fe 85 f9 ef ff
	ff		 inc	 BYTE PTR _pMsg$[ebp+5]
$LN4@GCUserWare:

; 5417 : 	pMsg.Type = 0;
; 5418 : 
; 5419 : 	for ( int n=0;n<WAREHOUSE_SIZE;n++)

  000d1	ff 85 f0 ef ff
	ff		 inc	 DWORD PTR _n$219097[ebp]
  000d7	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  000dd	89 bd ec ef ff
	ff		 mov	 DWORD PTR tv251[ebp], edi
  000e3	81 ff c0 c6 00
	00		 cmp	 edi, 50880		; 0000c6c0H
  000e9	7c 88		 jl	 SHORT $LL5@GCUserWare

; 5432 : 	pMsg.h.sizeL = SET_NUMBERL(lOfs);
; 5433 : 	memcpy(SendByte, &pMsg, sizeof(pMsg));

  000eb	66 8b 8d f8 ef
	ff ff		 mov	 cx, WORD PTR _pMsg$[ebp+4]
  000f2	8b d3		 mov	 edx, ebx
  000f4	c1 ea 08	 shr	 edx, 8
  000f7	88 95 f5 ef ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+1], dl
  000fd	88 9d f6 ef ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+2], bl
  00103	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _pMsg$[ebp]

; 5434 : 
; 5435 : 	DataSend(lpObj->m_Index, SendByte, lOfs);

  00109	53		 push	 ebx
  0010a	8d 95 fc ef ff
	ff		 lea	 edx, DWORD PTR _SendByte$[ebp]
  00110	89 85 fc ef ff
	ff		 mov	 DWORD PTR _SendByte$[ebp], eax
  00116	8b 06		 mov	 eax, DWORD PTR [esi]
  00118	52		 push	 edx
  00119	50		 push	 eax
  0011a	66 89 8d 00 f0
	ff ff		 mov	 WORD PTR _SendByte$[ebp+4], cx
  00121	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5436 : 	GCWarehouseInventoryMoneySend(lpObj->m_Index, 1, lpObj->Money, lpObj->WarehouseMoney);

  00126	8b 8e 08 12 00
	00		 mov	 ecx, DWORD PTR [esi+4616]
  0012c	8b 96 cc 00 00
	00		 mov	 edx, DWORD PTR [esi+204]
  00132	8b 06		 mov	 eax, DWORD PTR [esi]
  00134	51		 push	 ecx
  00135	52		 push	 edx
  00136	6a 01		 push	 1
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend

; 5437 : 
; 5438 : 	if ( lpObj->m_IfState.type == 6 )

  0013e	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  00144	8b c8		 mov	 ecx, eax
  00146	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0014c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0014f	81 f9 80 01 00
	00		 cmp	 ecx, 384		; 00000180H
  00155	75 16		 jne	 SHORT $LN1@GCUserWare

; 5439 : 	{
; 5440 : 		lpObj->m_IfState.state = 1;

  00157	83 e0 c7	 and	 eax, -57		; ffffffc7H
  0015a	83 c8 04	 or	 eax, 4
  0015d	89 86 b8 11 00
	00		 mov	 DWORD PTR [esi+4536], eax

; 5441 : 		lpObj->WarehouseSave = TRUE;

  00163	c7 86 0c 12 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4620], 1
$LN1@GCUserWare:

; 5442 : 	}
; 5443 : }

  0016d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	33 cd		 xor	 ecx, ebp
  00174	5b		 pop	 ebx
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; GCUserWarehouseSend
_TEXT	ENDS
PUBLIC	?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire
EXTRN	?Convert@CItem@@QAEXHEEEEEEPAEEE@Z:PROC		; CItem::Convert
; Function compile flags: /Ogtp
;	COMDAT ?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 8
tv402 = 8						; size = 4
tv400 = 8						; size = 4
_lpObj$ = 8						; size = 4
tv423 = 12						; size = 4
_DurItem$ = 12						; size = 4
tv407 = 14						; size = 2
_pos$ = 16						; size = 4
_RequestPos$ = 20					; size = 4
?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z PROC ; ItemDurRepaire, COMDAT

; 6003 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 6004 : 	PMSG_ITEMDURREPAIR_RESULT pResult;
; 6005 : 	int result = TRUE;
; 6006 : 
; 6007 : 	PHeadSetB((LPBYTE)&pResult, 0x34, sizeof(pResult));

  00008	6a 08		 push	 8
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000d	6a 34		 push	 52			; 00000034H
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6008 : 	int itemtype = DurItem->m_Type;
; 6009 : 
; 6010 : 	if ( lpObj->m_IfState.type != 13 )

  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00018	8b 8f b8 11 00
	00		 mov	 ecx, DWORD PTR [edi+4536]
  0001e	8b 75 0c	 mov	 esi, DWORD PTR _DurItem$[ebp]
  00021	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  00025	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	81 f9 40 03 00
	00		 cmp	 ecx, 832		; 00000340H
  00034	74 16		 je	 SHORT $LN30@ItemDurRep

; 6011 : 	{
; 6012 : 		if ( itemtype ==ITEMGET(13,4)  || itemtype == ITEMGET(13,5))

  00036	3d 04 1a 00 00	 cmp	 eax, 6660		; 00001a04H
  0003b	0f 84 3d 02 00
	00		 je	 $LN26@ItemDurRep
  00041	3d 05 1a 00 00	 cmp	 eax, 6661		; 00001a05H

; 6013 : 		{
; 6014 : 			pResult.Money = 0;
; 6015 : 			DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6016 : 
; 6017 : 			return;

  00046	0f 84 32 02 00
	00		 je	 $LN26@ItemDurRep
$LN30@ItemDurRep:

; 6018 : 		}
; 6019 : 	}
; 6020 : 
; 6021 : 	if( DurItem->m_bLuckySet == TRUE )

  0004c	80 be ce 00 00
	00 01		 cmp	 BYTE PTR [esi+206], 1

; 6022 : 	{
; 6023 : 		pResult.Money = 0;
; 6024 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6025 : 		return;

  00053	0f 84 25 02 00
	00		 je	 $LN26@ItemDurRep

; 6026 : 	}
; 6027 : 
; 6028 : 	if (itemtype == ITEMGET(13,64) || 
; 6029 : 		itemtype == ITEMGET(13,65) ||
; 6030 : 		itemtype == ITEMGET(13,67))

  00059	3d 40 1a 00 00	 cmp	 eax, 6720		; 00001a40H
  0005e	0f 84 1a 02 00
	00		 je	 $LN26@ItemDurRep
  00064	3d 41 1a 00 00	 cmp	 eax, 6721		; 00001a41H
  00069	0f 84 0f 02 00
	00		 je	 $LN26@ItemDurRep
  0006f	3d 43 1a 00 00	 cmp	 eax, 6723		; 00001a43H
  00074	0f 84 04 02 00
	00		 je	 $LN26@ItemDurRep

; 6034 : 		return;
; 6035 : 	}
; 6036 : 
; 6037 : 	if ( itemtype == ITEMGET(13,80) )

  0007a	3d 50 1a 00 00	 cmp	 eax, 6736		; 00001a50H

; 6038 : 	{
; 6039 : 		pResult.Money = 0;
; 6040 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6041 : 		return;

  0007f	0f 84 f9 01 00
	00		 je	 $LN26@ItemDurRep

; 6042 : 	}
; 6043 : 
; 6044 : 	if ( itemtype == ITEMGET(13,106) )

  00085	3d 6a 1a 00 00	 cmp	 eax, 6762		; 00001a6aH

; 6045 : 	{
; 6046 : 		pResult.Money = 0;
; 6047 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6048 : 		return;

  0008a	0f 84 ee 01 00
	00		 je	 $LN26@ItemDurRep

; 6049 : 	}
; 6050 : 
; 6051 : 	if ( itemtype == ITEMGET(13,123) )

  00090	3d 7b 1a 00 00	 cmp	 eax, 6779		; 00001a7bH

; 6052 : 	{
; 6053 : 		pResult.Money = 0;
; 6054 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6055 : 		return;

  00095	0f 84 e3 01 00
	00		 je	 $LN26@ItemDurRep

; 6056 : 	}
; 6057 : 
; 6058 : 	if( itemtype ==ITEMGET(4,7) ||
; 6059 : 		itemtype ==ITEMGET(4,15) ||
; 6060 : 		itemtype == ITEMGET(13,10) )

  0009b	3d 07 08 00 00	 cmp	 eax, 2055		; 00000807H
  000a0	0f 84 d8 01 00
	00		 je	 $LN26@ItemDurRep
  000a6	3d 0f 08 00 00	 cmp	 eax, 2063		; 0000080fH
  000ab	0f 84 cd 01 00
	00		 je	 $LN26@ItemDurRep
  000b1	3d 0a 1a 00 00	 cmp	 eax, 6666		; 00001a0aH
  000b6	0f 84 c2 01 00
	00		 je	 $LN26@ItemDurRep

; 6061 : 	{
; 6062 : 		pResult.Money = 0;
; 6063 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6064 : 		return;
; 6065 : 	}
; 6066 : 
; 6067 : 	if( itemtype == ITEMGET(0,41) )

  000bc	83 f8 29	 cmp	 eax, 41			; 00000029H

; 6068 : 	{
; 6069 : 		pResult.Money = 0;
; 6070 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6071 : 		return;

  000bf	0f 84 b9 01 00
	00		 je	 $LN26@ItemDurRep

; 6072 : 	}
; 6073 : 	
; 6074 : 	if ( itemtype >= ITEMGET(14,0) ||
; 6075 : 		( itemtype >= ITEMGET(13,0) && itemtype  < ITEMGET(13,4) ) ||
; 6076 : 		( itemtype >= ITEMGET(12,7) && itemtype < ITEMGET(12,36) ) ||
; 6077 : 		( itemtype > ITEMGET(12,43) && itemtype < ITEMGET(12,49) ) ||
; 6078 : 		( itemtype > ITEMGET(12,50) && itemtype < ITEMGET(12,262) ) ||
; 6079 : 		( itemtype > ITEMGET(12,267) && itemtype < ITEMGET(13,0) ) )

  000c5	3d 00 1c 00 00	 cmp	 eax, 7168		; 00001c00H
  000ca	0f 8d ae 01 00
	00		 jge	 $LN26@ItemDurRep
  000d0	3d 00 1a 00 00	 cmp	 eax, 6656		; 00001a00H
  000d5	7c 0b		 jl	 SHORT $LN17@ItemDurRep
  000d7	3d 04 1a 00 00	 cmp	 eax, 6660		; 00001a04H
  000dc	0f 8c 9c 01 00
	00		 jl	 $LN26@ItemDurRep
$LN17@ItemDurRep:
  000e2	3d 07 18 00 00	 cmp	 eax, 6151		; 00001807H
  000e7	7c 0b		 jl	 SHORT $LN16@ItemDurRep
  000e9	3d 24 18 00 00	 cmp	 eax, 6180		; 00001824H
  000ee	0f 8c 8a 01 00
	00		 jl	 $LN26@ItemDurRep
$LN16@ItemDurRep:
  000f4	3d 2b 18 00 00	 cmp	 eax, 6187		; 0000182bH
  000f9	7e 0b		 jle	 SHORT $LN15@ItemDurRep
  000fb	3d 31 18 00 00	 cmp	 eax, 6193		; 00001831H
  00100	0f 8c 78 01 00
	00		 jl	 $LN26@ItemDurRep
$LN15@ItemDurRep:
  00106	3d 32 18 00 00	 cmp	 eax, 6194		; 00001832H
  0010b	7e 0b		 jle	 SHORT $LN14@ItemDurRep
  0010d	3d 06 19 00 00	 cmp	 eax, 6406		; 00001906H
  00112	0f 8c 66 01 00
	00		 jl	 $LN26@ItemDurRep
$LN14@ItemDurRep:
  00118	3d 0b 19 00 00	 cmp	 eax, 6411		; 0000190bH
  0011d	7e 0b		 jle	 SHORT $LN19@ItemDurRep
  0011f	3d 00 1a 00 00	 cmp	 eax, 6656		; 00001a00H
  00124	0f 8c 54 01 00
	00		 jl	 $LN26@ItemDurRep
$LN19@ItemDurRep:

; 6080 : 	{
; 6081 : #if (CUSTOM_WINGS == 1)
; 6082 : 		if( itemtype >= ITEMGET(12,440) && itemtype <= ITEMGET(12,445) )
; 6083 : 		{
; 6084 : 
; 6085 : 		}
; 6086 : 		else
; 6087 : 		{
; 6088 : 			pResult.Money = 0;
; 6089 : 			DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6090 : 			return;
; 6091 : 		}
; 6092 : #else
; 6093 : 		pResult.Money = 0;
; 6094 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6095 : 		return;
; 6096 : #endif
; 6097 : 	}
; 6098 : 
; 6099 : 	if ( itemtype == ITEMGET(13,38) )

  0012a	3d 26 1a 00 00	 cmp	 eax, 6694		; 00001a26H

; 6100 : 	{
; 6101 : 		pResult.Money = 0;
; 6102 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6103 : 
; 6104 : 		return;

  0012f	0f 84 49 01 00
	00		 je	 $LN26@ItemDurRep

; 6105 : 	}
; 6106 : 
; 6107 : 	if ( itemtype == ITEMGET(13,39) )

  00135	3d 27 1a 00 00	 cmp	 eax, 6695		; 00001a27H

; 6108 : 	{
; 6109 : 		pResult.Money = 0;
; 6110 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6111 : 
; 6112 : 		return;

  0013a	0f 84 3e 01 00
	00		 je	 $LN26@ItemDurRep

; 6113 : 	}
; 6114 : 
; 6115 : 	if ( itemtype == ITEMGET(13,40) )

  00140	3d 28 1a 00 00	 cmp	 eax, 6696		; 00001a28H

; 6116 : 	{
; 6117 : 		pResult.Money = 0;
; 6118 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6119 : 
; 6120 : 		return;

  00145	0f 84 33 01 00
	00		 je	 $LN26@ItemDurRep

; 6121 : 	}
; 6122 : 
; 6123 : 	if ( itemtype == ITEMGET(13,41) )

  0014b	3d 29 1a 00 00	 cmp	 eax, 6697		; 00001a29H

; 6124 : 	{
; 6125 : 		pResult.Money = 0;
; 6126 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6127 : 
; 6128 : 		return;

  00150	0f 84 28 01 00
	00		 je	 $LN26@ItemDurRep

; 6129 : 	}
; 6130 : 
; 6131 : 	if ( itemtype == ITEMGET(13,42) )

  00156	3d 2a 1a 00 00	 cmp	 eax, 6698		; 00001a2aH

; 6132 : 	{
; 6133 : 		pResult.Money = 0;
; 6134 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6135 : 
; 6136 : 		return;

  0015b	0f 84 1d 01 00
	00		 je	 $LN26@ItemDurRep

; 6137 : 	}
; 6138 : 
; 6139 : 	if ( itemtype == ITEMGET(13,68) )

  00161	3d 44 1a 00 00	 cmp	 eax, 6724		; 00001a44H

; 6140 : 	{
; 6141 : 		pResult.Money = 0;
; 6142 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6143 : 
; 6144 : 		return;

  00166	0f 84 12 01 00
	00		 je	 $LN26@ItemDurRep

; 6145 : 	}
; 6146 : 
; 6147 : 	if ( itemtype == ITEMGET(13,66) )

  0016c	3d 42 1a 00 00	 cmp	 eax, 6722		; 00001a42H

; 6148 : 	{
; 6149 : 		pResult.Money = 0;
; 6150 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6151 : 
; 6152 : 		return;

  00171	0f 84 07 01 00
	00		 je	 $LN26@ItemDurRep

; 6153 : 	}
; 6154 : 
; 6155 : 	if ( itemtype == ITEMGET(13,76) || itemtype == ITEMGET(13,77) || itemtype == ITEMGET(13,78))

  00177	3d 4c 1a 00 00	 cmp	 eax, 6732		; 00001a4cH
  0017c	0f 84 fc 00 00
	00		 je	 $LN26@ItemDurRep
  00182	3d 4d 1a 00 00	 cmp	 eax, 6733		; 00001a4dH
  00187	0f 84 f1 00 00
	00		 je	 $LN26@ItemDurRep
  0018d	3d 4e 1a 00 00	 cmp	 eax, 6734		; 00001a4eH
  00192	0f 84 e6 00 00
	00		 je	 $LN26@ItemDurRep

; 6156 : 	{
; 6157 : 		pResult.Money = 0;
; 6158 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6159 : 
; 6160 : 		return;
; 6161 : 	}
; 6162 : 
; 6163 : 
; 6164 : 	if ( itemtype == ITEMGET(13,122) )

  00198	3d 7a 1a 00 00	 cmp	 eax, 6778		; 00001a7aH

; 6165 : 	{
; 6166 : 		pResult.Money = 0;
; 6167 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6168 : 
; 6169 : 		return;

  0019d	0f 84 db 00 00
	00		 je	 $LN26@ItemDurRep

; 6170 : 	}
; 6171 : 
; 6172 : 	pResult.Money = GetNeedMoneyItemDurRepaire(DurItem, RequestPos);

  001a3	8b 55 14	 mov	 edx, DWORD PTR _RequestPos$[ebp]
  001a6	52		 push	 edx
  001a7	56		 push	 esi
  001a8	e8 00 00 00 00	 call	 ?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z ; GetNeedMoneyItemDurRepaire

; 6173 : 
; 6174 : 	if ( pResult.Money <= 0 )

  001ad	33 d2		 xor	 edx, edx
  001af	83 c4 08	 add	 esp, 8
  001b2	3b c2		 cmp	 eax, edx
  001b4	7f 1d		 jg	 SHORT $LN3@ItemDurRep

; 6175 : 	{
; 6176 : 		pResult.Money = 0;
; 6177 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  001b6	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001ba	50		 push	 eax
  001bb	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001be	89 55 fc	 mov	 DWORD PTR _pResult$[ebp+4], edx
  001c1	8b 17		 mov	 edx, DWORD PTR [edi]
  001c3	51		 push	 ecx
  001c4	52		 push	 edx
  001c5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cd	5f		 pop	 edi
  001ce	5e		 pop	 esi

; 6195 : }

  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c3		 ret	 0
$LN3@ItemDurRep:

; 6178 : 
; 6179 : 		return;
; 6180 : 	}
; 6181 : 
; 6182 : 	if ( (lpObj->Money - pResult.Money) < 1 )

  001d3	8b 8f cc 00 00
	00		 mov	 ecx, DWORD PTR [edi+204]
  001d9	2b c8		 sub	 ecx, eax
  001db	83 f9 01	 cmp	 ecx, 1
  001de	7d 08		 jge	 SHORT $LN2@ItemDurRep

; 6183 : 		pResult.Money = 0;

  001e0	89 55 fc	 mov	 DWORD PTR _pResult$[ebp+4], edx

; 6184 : 	else

  001e3	e9 9d 00 00 00	 jmp	 $LN1@ItemDurRep
$LN2@ItemDurRep:

; 6185 : 	{
; 6186 : 		lpObj->Money -= pResult.Money;

  001e8	89 8f cc 00 00
	00		 mov	 DWORD PTR [edi+204], ecx

; 6187 : 		pResult.Money = lpObj->Money;
; 6188 : 		DurItem->m_Durability = (float)((int)DurItem->m_BaseDurability);

  001ee	d9 46 2c	 fld	 DWORD PTR [esi+44]
  001f1	53		 push	 ebx
  001f2	89 4d fc	 mov	 DWORD PTR _pResult$[ebp+4], ecx
  001f5	e8 00 00 00 00	 call	 __ftol2_sse

; 6189 : 		DurItem->Convert(DurItem->m_Type, DurItem->m_Option1, DurItem->m_Option2, DurItem->m_Option3,
; 6190 : 			DurItem->m_NewOption, DurItem->m_SetOption,DurItem->m_ItemOptionEx,0,-1, CURRENT_DB_VERSION);

  001fa	0f b6 8e aa 00
	00 00		 movzx	 ecx, BYTE PTR [esi+170]
  00201	0f b6 96 93 00
	00 00		 movzx	 edx, BYTE PTR [esi+147]
  00208	6a 03		 push	 3
  0020a	68 ff 00 00 00	 push	 255			; 000000ffH
  0020f	89 45 0c	 mov	 DWORD PTR tv423[ebp], eax
  00212	0f b6 86 c6 00
	00 00		 movzx	 eax, BYTE PTR [esi+198]
  00219	db 45 0c	 fild	 DWORD PTR tv423[ebp]
  0021c	6a 00		 push	 0
  0021e	50		 push	 eax
  0021f	0f b6 86 92 00
	00 00		 movzx	 eax, BYTE PTR [esi+146]
  00226	d9 5e 24	 fstp	 DWORD PTR [esi+36]
  00229	51		 push	 ecx
  0022a	0f b6 8e 91 00
	00 00		 movzx	 ecx, BYTE PTR [esi+145]
  00231	52		 push	 edx
  00232	0f b6 96 90 00
	00 00		 movzx	 edx, BYTE PTR [esi+144]
  00239	50		 push	 eax
  0023a	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  0023e	51		 push	 ecx
  0023f	52		 push	 edx
  00240	50		 push	 eax
  00241	8b ce		 mov	 ecx, esi
  00243	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEE@Z ; CItem::Convert

; 6191 : 		GCItemDurSend(lpObj->m_Index, pos, (BYTE)DurItem->m_Durability, FALSE);

  00248	6a 00		 push	 0
  0024a	d9 46 24	 fld	 DWORD PTR [esi+36]
  0024d	d9 7d 0e	 fnstcw	 WORD PTR tv407[ebp]
  00250	0f b7 45 0e	 movzx	 eax, WORD PTR tv407[ebp]
  00254	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00259	89 45 08	 mov	 DWORD PTR tv402[ebp], eax
  0025c	8b 45 10	 mov	 eax, DWORD PTR _pos$[ebp]
  0025f	d9 6d 08	 fldcw	 WORD PTR tv402[ebp]
  00262	db 5d 08	 fistp	 DWORD PTR tv400[ebp]
  00265	8a 4d 08	 mov	 cl, BYTE PTR tv400[ebp]
  00268	0f b6 d1	 movzx	 edx, cl
  0026b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0026d	d9 6d 0e	 fldcw	 WORD PTR tv407[ebp]
  00270	52		 push	 edx
  00271	50		 push	 eax
  00272	51		 push	 ecx
  00273	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00278	83 c4 10	 add	 esp, 16			; 00000010H
  0027b	5b		 pop	 ebx

; 6192 : 	}
; 6193 : 
; 6194 : 	DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  0027c	eb 07		 jmp	 SHORT $LN1@ItemDurRep
$LN26@ItemDurRep:

; 6031 : 	{
; 6032 : 		pResult.Money = 0;

  0027e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
$LN1@ItemDurRep:

; 6033 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  00285	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00289	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0028b	52		 push	 edx
  0028c	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0028f	50		 push	 eax
  00290	51		 push	 ecx
  00291	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00296	83 c4 0c	 add	 esp, 12			; 0000000cH
  00299	5f		 pop	 edi
  0029a	5e		 pop	 esi

; 6195 : }

  0029b	8b e5		 mov	 esp, ebp
  0029d	5d		 pop	 ebp
  0029e	c3		 ret	 0
?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ENDP ; ItemDurRepaire
_TEXT	ENDS
PUBLIC	?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ; CGModifyRequestItem
; Function compile flags: /Ogtp
;	COMDAT ?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 8
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z PROC ; CGModifyRequestItem, COMDAT

; 6203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 6204 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00011	8b f7		 mov	 esi, edi
  00013	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H

; 6205 : 	PMSG_ITEMDURREPAIR_RESULT pResult;
; 6206 : 
; 6207 : 	PHeadSetB((LPBYTE)&pResult, 0x34, sizeof(pResult));

  00019	6a 08		 push	 8
  0001b	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0001e	6a 34		 push	 52			; 00000034H
  00020	51		 push	 ecx
  00021	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  00024	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6208 : 	pResult.Money = 0;
; 6209 : 
; 6210 : 
; 6211 : 	if ( gObj[aIndex].CloseType != -1 )

  00029	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
  00039	80 7c 16 0d ff	 cmp	 BYTE PTR [esi+edx+13], -1
  0003e	74 19		 je	 SHORT $LN34@CGModifyRe

; 6212 : 	{
; 6213 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00040	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00044	50		 push	 eax
  00045	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00048	51		 push	 ecx
  00049	57		 push	 edi
  0004a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx

; 6318 : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN34@CGModifyRe:

; 6214 : 		return;
; 6215 : 	}
; 6216 : 
; 6217 : 	if ( !PacketCheckTime(lpObj))

  00059	53		 push	 ebx
  0005a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0005f	83 c4 04	 add	 esp, 4
  00062	85 c0		 test	 eax, eax

; 6218 : 	{
; 6219 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 6220 : 		return;

  00064	74 21		 je	 SHORT $LN41@CGModifyRe

; 6221 : 	}
; 6222 : 
; 6223 : 	if (lpMsg->Requestpos == 1 && gObj[aIndex].Level < 50 )

  00066	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00069	80 78 04 01	 cmp	 BYTE PTR [eax+4], 1
  0006d	75 31		 jne	 SHORT $LN32@CGModifyRe
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00075	66 83 bc 0e 96
	00 00 00 32	 cmp	 WORD PTR [esi+ecx+150], 50 ; 00000032H
  0007e	7d 20		 jge	 SHORT $LN32@CGModifyRe

; 6224 : 	{
; 6225 : 		pResult.Money = 0;

  00080	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
$LN41@CGModifyRe:

; 6226 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00087	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0008b	52		 push	 edx
  0008c	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0008f	50		 push	 eax
  00090	57		 push	 edi
  00091	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 6318 : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN32@CGModifyRe:

; 6227 : 		return;
; 6228 : 	}
; 6229 : 
; 6230 : 	if ( lpMsg->Position == 0xFF )

  000a0	8a 40 03	 mov	 al, BYTE PTR [eax+3]
  000a3	3c ff		 cmp	 al, 255			; 000000ffH
  000a5	0f 85 69 01 00
	00		 jne	 $LN31@CGModifyRe

; 6231 : 	{
; 6232 : 		for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  000ab	33 ff		 xor	 edi, edi
  000ad	33 f6		 xor	 esi, esi
  000af	90		 npad	 1
$LL30@CGModifyRe:

; 6233 : 		{
; 6234 : 			if ( lpObj->pInventory[n].IsItem())

  000b0	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  000b6	03 ce		 add	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000bd	85 c0		 test	 eax, eax
  000bf	0f 84 2a 01 00
	00		 je	 $LN29@CGModifyRe

; 6235 : 			{
; 6236 : 				if ( IsCashItem(lpObj->pInventory[n].m_Type ) == TRUE )

  000c5	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  000cb	0f bf 54 0e 06	 movsx	 edx, WORD PTR [esi+ecx+6]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ?IsCashItem@@YAHH@Z	; IsCashItem
  000d6	83 c4 04	 add	 esp, 4
  000d9	83 f8 01	 cmp	 eax, 1
  000dc	0f 84 0d 01 00
	00		 je	 $LN29@CGModifyRe

; 6237 : 					continue;
; 6238 : 
; 6239 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,20) && (lpObj->pInventory[n].m_Level == 0 ||lpObj->pInventory[n].m_Level == 1 ))

  000e2	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  000e8	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]
  000eb	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  000ef	b9 14 1a 00 00	 mov	 ecx, 6676		; 00001a14H
  000f4	66 3b c1	 cmp	 ax, cx
  000f7	75 17		 jne	 SHORT $LN25@CGModifyRe
  000f9	0f b7 4a 08	 movzx	 ecx, WORD PTR [edx+8]
  000fd	66 85 c9	 test	 cx, cx
  00100	0f 84 e9 00 00
	00		 je	 $LN29@CGModifyRe
  00106	66 83 f9 01	 cmp	 cx, 1

; 6240 : 					continue;

  0010a	0f 84 df 00 00
	00		 je	 $LN29@CGModifyRe
$LN25@CGModifyRe:

; 6241 : 
; 6242 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,20) && lpObj->pInventory[n].m_Level == 2 )

  00110	b9 14 1a 00 00	 mov	 ecx, 6676		; 00001a14H
  00115	66 3b c1	 cmp	 ax, cx
  00118	75 0b		 jne	 SHORT $LN23@CGModifyRe
  0011a	66 83 7a 08 02	 cmp	 WORD PTR [edx+8], 2
  0011f	0f 84 ca 00 00
	00		 je	 $LN29@CGModifyRe
$LN23@CGModifyRe:

; 6243 : 					continue;
; 6244 : 
; 6245 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,4) || lpObj->pInventory[n].m_Type == ITEMGET(13,5) )

  00125	b9 04 1a 00 00	 mov	 ecx, 6660		; 00001a04H
  0012a	66 3b c1	 cmp	 ax, cx
  0012d	0f 84 bc 00 00
	00		 je	 $LN29@CGModifyRe
  00133	b9 05 1a 00 00	 mov	 ecx, 6661		; 00001a05H
  00138	66 3b c1	 cmp	 ax, cx
  0013b	0f 84 ae 00 00
	00		 je	 $LN29@CGModifyRe

; 6246 : 					continue;
; 6247 : 				
; 6248 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,37) )

  00141	b9 25 1a 00 00	 mov	 ecx, 6693		; 00001a25H
  00146	66 3b c1	 cmp	 ax, cx
  00149	0f 84 a0 00 00
	00		 je	 $LN29@CGModifyRe

; 6249 : 					continue;
; 6250 : 
; 6251 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,38) )

  0014f	b9 26 1a 00 00	 mov	 ecx, 6694		; 00001a26H
  00154	66 3b c1	 cmp	 ax, cx
  00157	0f 84 92 00 00
	00		 je	 $LN29@CGModifyRe

; 6252 : 					continue;
; 6253 : 
; 6254 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,39) )

  0015d	b9 27 1a 00 00	 mov	 ecx, 6695		; 00001a27H
  00162	66 3b c1	 cmp	 ax, cx
  00165	0f 84 84 00 00
	00		 je	 $LN29@CGModifyRe

; 6255 : 					continue;
; 6256 : 
; 6257 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,40) )

  0016b	b9 28 1a 00 00	 mov	 ecx, 6696		; 00001a28H
  00170	66 3b c1	 cmp	 ax, cx
  00173	74 7a		 je	 SHORT $LN29@CGModifyRe

; 6258 : 					continue;
; 6259 : 
; 6260 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,68) )

  00175	b9 44 1a 00 00	 mov	 ecx, 6724		; 00001a44H
  0017a	66 3b c1	 cmp	 ax, cx
  0017d	74 70		 je	 SHORT $LN29@CGModifyRe

; 6261 : 					continue;
; 6262 : 
; 6263 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,76) || lpObj->pInventory[n].m_Type == ITEMGET(13,77) || lpObj->pInventory[n].m_Type == ITEMGET(13,78)) 

  0017f	b9 4c 1a 00 00	 mov	 ecx, 6732		; 00001a4cH
  00184	66 3b c1	 cmp	 ax, cx
  00187	74 66		 je	 SHORT $LN29@CGModifyRe
  00189	b9 4d 1a 00 00	 mov	 ecx, 6733		; 00001a4dH
  0018e	66 3b c1	 cmp	 ax, cx
  00191	74 5c		 je	 SHORT $LN29@CGModifyRe
  00193	b9 4e 1a 00 00	 mov	 ecx, 6734		; 00001a4eH
  00198	66 3b c1	 cmp	 ax, cx
  0019b	74 52		 je	 SHORT $LN29@CGModifyRe

; 6264 : 					continue;
; 6265 : 
; 6266 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(12,26) &&
; 6267 : 					(lpObj->pInventory[n].m_Level == 1 ||
; 6268 : 					 lpObj->pInventory[n].m_Level == 2 || 
; 6269 : 					 lpObj->pInventory[n].m_Level == 3 || 
; 6270 : 					 lpObj->pInventory[n].m_Level == 4 || 
; 6271 : 					 lpObj->pInventory[n].m_Level == 5 ))

  0019d	b9 1a 18 00 00	 mov	 ecx, 6170		; 0000181aH
  001a2	66 3b c1	 cmp	 ax, cx
  001a5	75 22		 jne	 SHORT $LN13@CGModifyRe
  001a7	0f b7 4a 08	 movzx	 ecx, WORD PTR [edx+8]
  001ab	66 83 f9 01	 cmp	 cx, 1
  001af	74 3e		 je	 SHORT $LN29@CGModifyRe
  001b1	66 83 f9 02	 cmp	 cx, 2
  001b5	74 38		 je	 SHORT $LN29@CGModifyRe
  001b7	66 83 f9 03	 cmp	 cx, 3
  001bb	74 32		 je	 SHORT $LN29@CGModifyRe
  001bd	66 83 f9 04	 cmp	 cx, 4
  001c1	74 2c		 je	 SHORT $LN29@CGModifyRe
  001c3	66 83 f9 05	 cmp	 cx, 5

; 6272 : 					 continue;

  001c7	74 26		 je	 SHORT $LN29@CGModifyRe
$LN13@CGModifyRe:

; 6273 : 
; 6274 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,107) )

  001c9	b9 6b 1a 00 00	 mov	 ecx, 6763		; 00001a6bH
  001ce	66 3b c1	 cmp	 ax, cx
  001d1	74 1c		 je	 SHORT $LN29@CGModifyRe

; 6275 : 					 continue;
; 6276 : 
; 6277 : 				if ( lpObj->pInventory[n].m_bLuckySet == TRUE )

  001d3	80 ba ce 00 00
	00 01		 cmp	 BYTE PTR [edx+206], 1
  001da	74 13		 je	 SHORT $LN29@CGModifyRe

; 6278 : 					continue;
; 6279 : 					
; 6280 : 				ItemDurRepaire(lpObj,&lpObj->pInventory[n] , n, lpMsg->Requestpos);

  001dc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001df	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  001e3	51		 push	 ecx
  001e4	57		 push	 edi
  001e5	52		 push	 edx
  001e6	53		 push	 ebx
  001e7	e8 00 00 00 00	 call	 ?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire
  001ec	83 c4 10	 add	 esp, 16			; 00000010H
$LN29@CGModifyRe:

; 6231 : 	{
; 6232 : 		for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  001ef	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  001f5	47		 inc	 edi
  001f6	81 fe f0 a8 00
	00		 cmp	 esi, 43248		; 0000a8f0H
  001fc	0f 8c ae fe ff
	ff		 jl	 $LL30@CGModifyRe

; 6281 : 			}
; 6282 : 		}
; 6283 : 
; 6284 : 		gObjCalCharacter(lpObj->m_Index);

  00202	8b 13		 mov	 edx, DWORD PTR [ebx]
  00204	52		 push	 edx
  00205	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  0020a	83 c4 04	 add	 esp, 4
  0020d	5f		 pop	 edi
  0020e	5e		 pop	 esi
  0020f	5b		 pop	 ebx

; 6318 : }

  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c3		 ret	 0
$LN31@CGModifyRe:

; 6285 : 		return;
; 6286 : 	}
; 6287 : 
; 6288 : 	if ( lpMsg->Position > MAIN_INVENTORY_SIZE-1)

  00214	3c cb		 cmp	 al, 203			; 000000cbH
  00216	0f 87 b5 00 00
	00		 ja	 $LN35@CGModifyRe

; 6289 : 	{
; 6290 : 		pResult.Money = 0;
; 6291 : 		return;
; 6292 : 	}
; 6293 : 
; 6294 : 	if ( IsCashItem(lpObj->pInventory[lpMsg->Position].m_Type ) == TRUE )

  0021c	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  00222	0f b6 c0	 movzx	 eax, al
  00225	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0022b	0f bf 54 08 06	 movsx	 edx, WORD PTR [eax+ecx+6]
  00230	52		 push	 edx
  00231	e8 00 00 00 00	 call	 ?IsCashItem@@YAHH@Z	; IsCashItem
  00236	83 c4 04	 add	 esp, 4
  00239	83 f8 01	 cmp	 eax, 1
  0023c	0f 84 8f 00 00
	00		 je	 $LN35@CGModifyRe

; 6295 : 		return;
; 6296 : 
; 6297 : 
; 6298 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,20) && (lpObj->pInventory[lpMsg->Position].m_Level == 0 ||lpObj->pInventory[lpMsg->Position].m_Level == 1 ))

  00242	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00245	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00249	8b 93 c0 11 00
	00		 mov	 edx, DWORD PTR [ebx+4544]
  0024f	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00255	0f b7 4c 10 06	 movzx	 ecx, WORD PTR [eax+edx+6]
  0025a	03 c2		 add	 eax, edx
  0025c	be 14 1a 00 00	 mov	 esi, 6676		; 00001a14H
  00261	66 3b ce	 cmp	 cx, si
  00264	75 0f		 jne	 SHORT $LN7@CGModifyRe
  00266	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0026a	66 85 f6	 test	 si, si
  0026d	74 62		 je	 SHORT $LN35@CGModifyRe
  0026f	66 83 fe 01	 cmp	 si, 1

; 6299 : 		return;

  00273	74 5c		 je	 SHORT $LN35@CGModifyRe
$LN7@CGModifyRe:

; 6300 : 
; 6301 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,20) && lpObj->pInventory[lpMsg->Position].m_Level == 2 )

  00275	be 14 1a 00 00	 mov	 esi, 6676		; 00001a14H
  0027a	66 3b ce	 cmp	 cx, si
  0027d	75 07		 jne	 SHORT $LN5@CGModifyRe
  0027f	66 83 78 08 02	 cmp	 WORD PTR [eax+8], 2
  00284	74 4b		 je	 SHORT $LN35@CGModifyRe
$LN5@CGModifyRe:

; 6302 : 		return;
; 6303 : 
; 6304 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,37) )

  00286	be 25 1a 00 00	 mov	 esi, 6693		; 00001a25H
  0028b	66 3b ce	 cmp	 cx, si
  0028e	74 41		 je	 SHORT $LN35@CGModifyRe

; 6305 : 		return;
; 6306 : 
; 6307 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,38) )

  00290	be 26 1a 00 00	 mov	 esi, 6694		; 00001a26H
  00295	66 3b ce	 cmp	 cx, si
  00298	74 37		 je	 SHORT $LN35@CGModifyRe

; 6308 : 		return;
; 6309 : 
; 6310 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,107) )

  0029a	be 6b 1a 00 00	 mov	 esi, 6763		; 00001a6bH
  0029f	66 3b ce	 cmp	 cx, si
  002a2	74 2d		 je	 SHORT $LN35@CGModifyRe

; 6311 : 		return;
; 6312 : 
; 6313 : 	if ( lpObj->pInventory[lpMsg->Position].m_bLuckySet == TRUE )

  002a4	80 b8 ce 00 00
	00 01		 cmp	 BYTE PTR [eax+206], 1
  002ab	74 24		 je	 SHORT $LN35@CGModifyRe

; 6314 : 		return;
; 6315 : 
; 6316 : 	ItemDurRepaire(lpObj, &lpObj->pInventory[lpMsg->Position], lpMsg->Position, lpMsg->Requestpos);

  002ad	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  002b1	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  002b5	51		 push	 ecx
  002b6	50		 push	 eax
  002b7	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  002bd	03 c2		 add	 eax, edx
  002bf	50		 push	 eax
  002c0	53		 push	 ebx
  002c1	e8 00 00 00 00	 call	 ?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire

; 6317 : 	gObjCalCharacter(lpObj->m_Index);

  002c6	8b 13		 mov	 edx, DWORD PTR [ebx]
  002c8	52		 push	 edx
  002c9	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  002ce	83 c4 14	 add	 esp, 20			; 00000014H
$LN35@CGModifyRe:
  002d1	5f		 pop	 edi
  002d2	5e		 pop	 esi
  002d3	5b		 pop	 ebx

; 6318 : }

  002d4	8b e5		 mov	 esp, ebp
  002d6	5d		 pop	 ebp
  002d7	c3		 ret	 0
?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ENDP ; CGModifyRequestItem
_TEXT	ENDS
PUBLIC	??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@ ; `string'
PUBLIC	??_C@_0CA@CHOLFFAK@Trade?5not?5allowed?5on?5duel?5arena?$AA@ ; `string'
PUBLIC	??_C@_0CH@BFADMIPH@You?5cannot?5trade?5inside?5Imperial@ ; `string'
PUBLIC	??_C@_0CG@MDHDJBIA@You?5cannot?5trade?5inside?5Doppelga@ ; `string'
PUBLIC	??_C@_0CJ@GFPCHONE@You?5cannot?5trade?5inside?5Illusion@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ; CGTradeRequestSend
EXTRN	?bCanTrade@@3HA:DWORD				; bCanTrade
;	COMDAT ??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@
CONST	SEGMENT
??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@ DB '['
	DB	'%s][%s] CGTradeRequestSend() Failed : Transaction == 1, IF_TY'
	DB	'PE : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CHOLFFAK@Trade?5not?5allowed?5on?5duel?5arena?$AA@
CONST	SEGMENT
??_C@_0CA@CHOLFFAK@Trade?5not?5allowed?5on?5duel?5arena?$AA@ DB 'Trade no'
	DB	't allowed on duel arena', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BFADMIPH@You?5cannot?5trade?5inside?5Imperial@
CONST	SEGMENT
??_C@_0CH@BFADMIPH@You?5cannot?5trade?5inside?5Imperial@ DB 'You cannot t'
	DB	'rade inside Imperial Fort.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MDHDJBIA@You?5cannot?5trade?5inside?5Doppelga@
CONST	SEGMENT
??_C@_0CG@MDHDJBIA@You?5cannot?5trade?5inside?5Doppelga@ DB 'You cannot t'
	DB	'rade inside Doppelganger.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GFPCHONE@You?5cannot?5trade?5inside?5Illusion@
CONST	SEGMENT
??_C@_0CJ@GFPCHONE@You?5cannot?5trade?5inside?5Illusion@ DB 'You cannot t'
	DB	'rade inside Illusion Temple.', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z
_TEXT	SEGMENT
tv578 = -36						; size = 4
tv601 = -32						; size = 4
_lpObj$ = -28						; size = 4
_lpMsg$GSCopy$ = -24					; size = 4
_number$ = -24						; size = 4
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z PROC	; CGTradeRequestSend, COMDAT

; 6333 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6334 : 	int number;
; 6335 : 
; 6336 : 	if (bCanTrade == FALSE )

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bCanTrade@@3HA, 0 ; bCanTrade
  00017	53		 push	 ebx
  00018	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001b	56		 push	 esi
  0001c	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]

; 6363 : 		return;
; 6364 : 
; 6365 : 	if ( gObj[number].Type == OBJ_MONSTER )

  0001f	89 75 e8	 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], esi
  00022	75 46		 jne	 SHORT $LN27@CGTradeReq

; 6337 : 	{
; 6338 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 125)), aIndex, 1);

  00024	6a 01		 push	 1
  00026	53		 push	 ebx
  00027	68 7d 04 00 00	 push	 1149			; 0000047dH
  0002c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00031	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6339 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 126)), aIndex, 1);

  0003f	6a 01		 push	 1
  00041	53		 push	 ebx
  00042	68 7e 04 00 00	 push	 1150			; 0000047eH
  00047	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0004c	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 6487 : }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN27@CGTradeReq:

; 6340 : 		return;
; 6341 : 	}
; 6342 : 
; 6343 : 	if ( gObj[aIndex].CloseType != -1 )

  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	57		 push	 edi
  00070	8b fb		 mov	 edi, ebx
  00072	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00078	03 c7		 add	 eax, edi
  0007a	80 78 0d ff	 cmp	 BYTE PTR [eax+13], -1
  0007e	0f 85 54 04 00
	00		 jne	 $LN55@CGTradeReq

; 6344 : 		return;
; 6345 : 
; 6346 : 	LPOBJ lpObj = &gObj[aIndex];
; 6347 : 
; 6348 : 	if ( !PacketCheckTime(lpObj))

  00084	50		 push	 eax
  00085	89 45 e4	 mov	 DWORD PTR _lpObj$[ebp], eax
  00088	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0008d	83 c4 04	 add	 esp, 4
  00090	85 c0		 test	 eax, eax
  00092	0f 84 40 04 00
	00		 je	 $LN55@CGTradeReq

; 6349 : 		return;
; 6350 : 
; 6351 : 	number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00098	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  0009c	8b 55 e8	 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  0009f	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  000a3	66 c1 e1 08	 shl	 cx, 8
  000a7	0f b7 f1	 movzx	 esi, cx
  000aa	0b f0		 or	 esi, eax
  000ac	89 75 e8	 mov	 DWORD PTR _number$[ebp], esi

; 6352 : 
; 6353 : 	if ( OBJMAX_RANGE(number) == FALSE )

  000af	7c 0f		 jl	 SHORT $LN48@CGTradeReq
  000b1	33 c0		 xor	 eax, eax
  000b3	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  000b9	0f 9e c0	 setle	 al
  000bc	85 c0		 test	 eax, eax
  000be	75 2a		 jne	 SHORT $LN24@CGTradeReq
$LN48@CGTradeReq:

; 6354 : 	{
; 6355 : 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, number);

  000c0	56		 push	 esi
  000c1	68 d3 18 00 00	 push	 6355			; 000018d3H
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d6	83 c4 10	 add	 esp, 16			; 00000010H
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx

; 6487 : }

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	33 cd		 xor	 ecx, ebp
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
$LN24@CGTradeReq:

; 6356 : 		return;
; 6357 : 	}
; 6358 : 
; 6359 : 	if ( number == aIndex )

  000ea	3b f3		 cmp	 esi, ebx
  000ec	0f 84 e6 03 00
	00		 je	 $LN55@CGTradeReq

; 6360 : 		return;
; 6361 : 
; 6362 : 	if ( !gObjIsConnected(number))

  000f2	56		 push	 esi
  000f3	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000f8	83 c4 04	 add	 esp, 4
  000fb	85 c0		 test	 eax, eax
  000fd	0f 84 d5 03 00
	00		 je	 $LN55@CGTradeReq

; 6363 : 		return;
; 6364 : 
; 6365 : 	if ( gObj[number].Type == OBJ_MONSTER )

  00103	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00109	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0010f	80 7c 0e 50 02	 cmp	 BYTE PTR [esi+ecx+80], 2
  00114	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00117	89 45 e0	 mov	 DWORD PTR tv601[ebp], eax
  0011a	0f 84 b8 03 00
	00		 je	 $LN55@CGTradeReq

; 6366 : 		return;
; 6367 : 
; 6368 : 	if ( gObj[number].CloseCount >= 0 )

  00120	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00124	0f 8d ae 03 00
	00		 jge	 $LN55@CGTradeReq

; 6369 : 		return;
; 6370 : 
; 6371 : #if (ENABLETEST_NEWPVP == 1)
; 6372 : 	if (g_NewPVP.IsDuel(gObj[aIndex]) || g_NewPVP.IsDuel(gObj[number])) {

  0012a	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  0012d	50		 push	 eax
  0012e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00133	89 45 dc	 mov	 DWORD PTR tv578[ebp], eax
  00136	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  0013b	85 c0		 test	 eax, eax
  0013d	0f 85 7a 03 00
	00		 jne	 $LN18@CGTradeReq
  00143	8b 4d e0	 mov	 ecx, DWORD PTR tv601[ebp]
  00146	51		 push	 ecx
  00147	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0014c	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  00151	85 c0		 test	 eax, eax
  00153	0f 85 64 03 00
	00		 jne	 $LN18@CGTradeReq

; 6374 : 		 return;
; 6375 : 	}
; 6376 : 
; 6377 : 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  00159	8b 55 dc	 mov	 edx, DWORD PTR tv578[ebp]
  0015c	52		 push	 edx
  0015d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00162	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00167	85 c0		 test	 eax, eax

; 6378 : 		 GCServerMsgStringSend(lMsg.Get(MSGGET(2, 199)), aIndex, 1);
; 6379 : 		 return;

  00169	0f 85 4e 03 00
	00		 jne	 $LN18@CGTradeReq

; 6380 : 	}
; 6381 : #endif
; 6382 : 
; 6383 : 	if ( DS_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  0016f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00175	8a 84 0e 23 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+291]
  0017c	3c 09		 cmp	 al, 9
  0017e	0f 84 39 03 00
	00		 je	 $LN18@CGTradeReq
  00184	33 d2		 xor	 edx, edx
  00186	3c 20		 cmp	 al, 32			; 00000020H
  00188	0f 94 c2	 sete	 dl
  0018b	85 d2		 test	 edx, edx

; 6384 : 	{
; 6385 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(2, 199)), aIndex, 1);
; 6386 : 		return;

  0018d	0f 85 2a 03 00
	00		 jne	 $LN18@CGTradeReq

; 6387 : 	}
; 6388 : 
; 6389 : 	if ( IT_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  00193	3c 2d		 cmp	 al, 45			; 0000002dH
  00195	72 19		 jb	 SHORT $LN15@CGTradeReq
  00197	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  0019c	3a d0		 cmp	 dl, al
  0019e	1b d2		 sbb	 edx, edx
  001a0	42		 inc	 edx
  001a1	74 0d		 je	 SHORT $LN15@CGTradeReq

; 6390 : 	{
; 6391 : 		::GCServerMsgStringSend("You cannot trade inside Illusion Temple.", aIndex, 1);

  001a3	6a 01		 push	 1
  001a5	53		 push	 ebx
  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@GFPCHONE@You?5cannot?5trade?5inside?5Illusion@

; 6392 : 		return;

  001ab	e9 20 03 00 00	 jmp	 $LN56@CGTradeReq
$LN15@CGTradeReq:

; 6393 : 	}
; 6394 : 
; 6395 : 	if ( DG_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  001b0	3c 41		 cmp	 al, 65			; 00000041H
  001b2	72 19		 jb	 SHORT $LN14@CGTradeReq
  001b4	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  001b9	3a d0		 cmp	 dl, al
  001bb	1b d2		 sbb	 edx, edx
  001bd	42		 inc	 edx
  001be	74 0d		 je	 SHORT $LN14@CGTradeReq

; 6396 : 	{
; 6397 : 		::GCServerMsgStringSend("You cannot trade inside Doppelganger.", aIndex, 1);

  001c0	6a 01		 push	 1
  001c2	53		 push	 ebx
  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@MDHDJBIA@You?5cannot?5trade?5inside?5Doppelga@

; 6398 : 		return;

  001c8	e9 03 03 00 00	 jmp	 $LN56@CGTradeReq
$LN14@CGTradeReq:

; 6399 : 	}
; 6400 : 
; 6401 : 	if ( IF_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  001cd	3c 45		 cmp	 al, 69			; 00000045H
  001cf	72 19		 jb	 SHORT $LN13@CGTradeReq
  001d1	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  001d6	3a d0		 cmp	 dl, al
  001d8	1b d2		 sbb	 edx, edx
  001da	42		 inc	 edx
  001db	74 0d		 je	 SHORT $LN13@CGTradeReq

; 6402 : 	{
; 6403 : 		::GCServerMsgStringSend("You cannot trade inside Imperial Fort.", aIndex, 1);

  001dd	6a 01		 push	 1
  001df	53		 push	 ebx
  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BFADMIPH@You?5cannot?5trade?5inside?5Imperial@

; 6404 : 		return;

  001e5	e9 e6 02 00 00	 jmp	 $LN56@CGTradeReq
$LN13@CGTradeReq:

; 6405 : 	}
; 6406 : 
; 6407 : 	if ( gObj[aIndex].m_bPShopOpen == true )

  001ea	80 bc 0f 5c 12
	00 00 01	 cmp	 BYTE PTR [edi+ecx+4700], 1
  001f2	0f 84 e0 02 00
	00		 je	 $LN55@CGTradeReq

; 6408 : 		return;
; 6409 : 
; 6410 : 	if ( gObj[number].m_bPShopOpen == true )

  001f8	80 bc 0e 5c 12
	00 00 01	 cmp	 BYTE PTR [esi+ecx+4700], 1
  00200	0f 84 d2 02 00
	00		 je	 $LN55@CGTradeReq

; 6411 : 		return;
; 6412 : 
; 6413 : 	if ( CC_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  00206	3c 35		 cmp	 al, 53			; 00000035H
  00208	74 0d		 je	 SHORT $LN50@CGTradeReq
  0020a	3c 12		 cmp	 al, 18			; 00000012H
  0020c	72 16		 jb	 SHORT $LN53@CGTradeReq
  0020e	b2 17		 mov	 dl, 23			; 00000017H
  00210	3a d0		 cmp	 dl, al
  00212	1b c0		 sbb	 eax, eax
  00214	40		 inc	 eax
  00215	74 0d		 je	 SHORT $LN53@CGTradeReq
$LN50@CGTradeReq:

; 6414 : 	{
; 6415 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 196)), aIndex, 1);

  00217	6a 01		 push	 1
  00219	53		 push	 ebx
  0021a	68 c4 04 00 00	 push	 1220			; 000004c4H

; 6416 : 		return;

  0021f	e9 a1 02 00 00	 jmp	 $LN57@CGTradeReq
$LN53@CGTradeReq:

; 6417 : 	}
; 6418 : 
; 6419 : 	if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  00224	8a 84 0f 23 01
	00 00		 mov	 al, BYTE PTR [edi+ecx+291]
  0022b	3c 34		 cmp	 al, 52			; 00000034H
  0022d	74 10		 je	 SHORT $LN51@CGTradeReq
  0022f	3c 0b		 cmp	 al, 11			; 0000000bH
  00231	72 5d		 jb	 SHORT $LN54@CGTradeReq
  00233	ba 11 00 00 00	 mov	 edx, 17			; 00000011H
  00238	3a d0		 cmp	 dl, al
  0023a	1b d2		 sbb	 edx, edx
  0023c	42		 inc	 edx
  0023d	74 51		 je	 SHORT $LN54@CGTradeReq
$LN51@CGTradeReq:

; 6420 : 	{
; 6421 : 		if ( g_BloodCastle.GetCurrentState(g_BloodCastle.GetBridgeLevel(gObj[aIndex].MapNumber)) != 1 || g_BloodCastle.CheckCanEnter(gObj[aIndex].MapNumber-MAP_INDEX_BLOODCASTLE1) == false )

  0023f	0f b6 c0	 movzx	 eax, al
  00242	50		 push	 eax
  00243	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00248	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  0024d	50		 push	 eax
  0024e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00253	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  00258	83 f8 01	 cmp	 eax, 1
  0025b	75 20		 jne	 SHORT $LN7@CGTradeReq
  0025d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00263	0f b6 94 0f 23
	01 00 00	 movzx	 edx, BYTE PTR [edi+ecx+291]
  0026b	83 ea 0b	 sub	 edx, 11			; 0000000bH
  0026e	52		 push	 edx
  0026f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00274	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  00279	84 c0		 test	 al, al
  0027b	75 0d		 jne	 SHORT $LN52@CGTradeReq
$LN7@CGTradeReq:

; 6422 : 		{
; 6423 : 			::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 188)), aIndex, 1);

  0027d	6a 01		 push	 1
  0027f	53		 push	 ebx
  00280	68 bc 04 00 00	 push	 1212			; 000004bcH

; 6424 : 			return;

  00285	e9 3b 02 00 00	 jmp	 $LN57@CGTradeReq
$LN52@CGTradeReq:
  0028a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN54@CGTradeReq:

; 6425 : 		}	
; 6426 : 	}
; 6427 : 
; 6428 : 	if ( gObj[aIndex].MapNumber == MAP_INDEX_PKFIELD )

  00290	80 bc 0f 23 01
	00 00 40	 cmp	 BYTE PTR [edi+ecx+291], 64 ; 00000040H
  00298	75 0d		 jne	 SHORT $LN6@CGTradeReq

; 6429 : 	{
; 6430 : 		::GCServerMsgStringSend("Trade not allowed on duel arena", aIndex, 1);

  0029a	6a 01		 push	 1
  0029c	53		 push	 ebx
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@CHOLFFAK@Trade?5not?5allowed?5on?5duel?5arena?$AA@

; 6431 : 		return;

  002a2	e9 29 02 00 00	 jmp	 $LN56@CGTradeReq
$LN6@CGTradeReq:

; 6432 : 	}
; 6433 : 
; 6434 : 	if ( (gObj[number].m_Option &1) != 1 )

  002a7	f6 84 0e 24 12
	00 00 01	 test	 BYTE PTR [esi+ecx+4644], 1
  002af	75 25		 jne	 SHORT $LN5@CGTradeReq

; 6435 : 	{
; 6436 : 		::GCTradeResponseSend(0, aIndex, gObj[number].Name, 0, 0);

  002b1	6a 00		 push	 0
  002b3	6a 00		 push	 0
  002b5	8d 44 0e 5d	 lea	 eax, DWORD PTR [esi+ecx+93]
  002b9	50		 push	 eax
  002ba	53		 push	 ebx
  002bb	6a 00		 push	 0
  002bd	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  002c2	83 c4 14	 add	 esp, 20			; 00000014H
  002c5	5f		 pop	 edi
  002c6	5e		 pop	 esi
  002c7	5b		 pop	 ebx

; 6487 : }

  002c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002cb	33 cd		 xor	 ecx, ebp
  002cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d2	8b e5		 mov	 esp, ebp
  002d4	5d		 pop	 ebp
  002d5	c3		 ret	 0
$LN5@CGTradeReq:

; 6437 : 		return;
; 6438 : 	}
; 6439 : 
; 6440 : 	if ( lpObj->m_IfState.use > 0 )

  002d6	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002d9	b8 03 00 00 00	 mov	 eax, 3
  002de	84 82 b8 11 00
	00		 test	 BYTE PTR [edx+4536], al
  002e4	76 24		 jbe	 SHORT $LN4@CGTradeReq

; 6441 : 	{
; 6442 : 		::GCTradeResponseSend(3, aIndex, gObj[number].Name, 0, 0);

  002e6	6a 00		 push	 0
  002e8	6a 00		 push	 0
  002ea	8d 4c 0e 5d	 lea	 ecx, DWORD PTR [esi+ecx+93]
  002ee	51		 push	 ecx
  002ef	53		 push	 ebx
  002f0	50		 push	 eax
  002f1	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  002f6	83 c4 14	 add	 esp, 20			; 00000014H
  002f9	5f		 pop	 edi
  002fa	5e		 pop	 esi
  002fb	5b		 pop	 ebx

; 6487 : }

  002fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ff	33 cd		 xor	 ecx, ebp
  00301	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00306	8b e5		 mov	 esp, ebp
  00308	5d		 pop	 ebp
  00309	c3		 ret	 0
$LN4@CGTradeReq:

; 6443 : 		return;
; 6444 : 	}
; 6445 : 
; 6446 : 	if (gObj[number].m_IfState.use > 0 )

  0030a	84 84 0e b8 11
	00 00		 test	 BYTE PTR [esi+ecx+4536], al
  00311	76 25		 jbe	 SHORT $LN3@CGTradeReq

; 6447 : 	{
; 6448 : 		::GCTradeResponseSend(2, aIndex, gObj[number].Name, 0, 0);

  00313	6a 00		 push	 0
  00315	6a 00		 push	 0
  00317	8d 54 0e 5d	 lea	 edx, DWORD PTR [esi+ecx+93]
  0031b	52		 push	 edx
  0031c	53		 push	 ebx
  0031d	6a 02		 push	 2
  0031f	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  00324	83 c4 14	 add	 esp, 20			; 00000014H
  00327	5f		 pop	 edi
  00328	5e		 pop	 esi
  00329	5b		 pop	 ebx

; 6487 : }

  0032a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032d	33 cd		 xor	 ecx, ebp
  0032f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00334	8b e5		 mov	 esp, ebp
  00336	5d		 pop	 ebp
  00337	c3		 ret	 0
$LN3@CGTradeReq:

; 6449 : 		return;
; 6450 : 	}
; 6451 : 
; 6452 : 	if ( ::gObjFixInventoryPointer(aIndex) == false )

  00338	53		 push	 ebx
  00339	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0033e	83 c4 04	 add	 esp, 4
  00341	84 c0		 test	 al, al
  00343	75 18		 jne	 SHORT $LN2@CGTradeReq

; 6453 : 	{
; 6454 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  00345	68 36 19 00 00	 push	 6454			; 00001936H
  0034a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0034f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00354	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0035a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGTradeReq:

; 6455 : 	}
; 6456 : 
; 6457 : 	if ( gObj[aIndex].pTransaction == 1 )

  0035d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00362	80 bc 07 cc 11
	00 00 01	 cmp	 BYTE PTR [edi+eax+4556], 1
  0036a	75 3a		 jne	 SHORT $LN1@CGTradeReq

; 6458 : 	{
; 6459 : 		LogAddTD("[%s][%s] CGTradeRequestSend() Failed : Transaction == 1, IF_TYPE : %d",
; 6460 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  0036c	8b 8c 07 b8 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4536]
  00373	c1 e9 06	 shr	 ecx, 6
  00376	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0037c	51		 push	 ecx
  0037d	8d 54 07 5d	 lea	 edx, DWORD PTR [edi+eax+93]
  00381	52		 push	 edx
  00382	8d 44 07 52	 lea	 eax, DWORD PTR [edi+eax+82]
  00386	50		 push	 eax
  00387	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@
  0038c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00392	83 c4 10	 add	 esp, 16			; 00000010H
  00395	5f		 pop	 edi
  00396	5e		 pop	 esi
  00397	5b		 pop	 ebx

; 6487 : }

  00398	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039b	33 cd		 xor	 ecx, ebp
  0039d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a2	8b e5		 mov	 esp, ebp
  003a4	5d		 pop	 ebp
  003a5	c3		 ret	 0
$LN1@CGTradeReq:

; 6461 : 
; 6462 : 		return;
; 6463 : 	}
; 6464 : 
; 6465 : 	lpObj->m_IfState.use = 1;
; 6466 : 	lpObj->m_IfState.state = 0;
; 6467 : 	lpObj->m_IfState.type = 1;

  003a6	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a9	8b 88 b8 11 00
	00		 mov	 ecx, DWORD PTR [eax+4536]

; 6468 : 	lpObj->TargetNumber = number;

  003af	66 8b 55 e8	 mov	 dx, WORD PTR _number$[ebp]
  003b3	66 89 90 38 06
	00 00		 mov	 WORD PTR [eax+1592], dx
  003ba	81 e1 41 00 ff
	ff		 and	 ecx, -65471		; ffff0041H
  003c0	83 c9 41	 or	 ecx, 65			; 00000041H
  003c3	89 88 b8 11 00
	00		 mov	 DWORD PTR [eax+4536], ecx

; 6469 : 	gObj[number].m_IfState.use = 1;

  003c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ce	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  003d5	83 e1 fd	 and	 ecx, -3			; fffffffdH
  003d8	83 c9 01	 or	 ecx, 1
  003db	89 8c 06 b8 11
	00 00		 mov	 DWORD PTR [esi+eax+4536], ecx

; 6470 : 	gObj[number].m_IfState.state = 0;

  003e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003e7	83 a4 06 b8 11
	00 00 c3	 and	 DWORD PTR [esi+eax+4536], -61 ; ffffffc3H

; 6471 : 	gObj[number].m_IfState.type = 1;

  003ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003f4	8b 94 06 b8 11
	00 00		 mov	 edx, DWORD PTR [esi+eax+4536]
  003fb	81 e2 7f 00 ff
	ff		 and	 edx, -65409		; ffff007fH
  00401	83 ca 40	 or	 edx, 64			; 00000040H
  00404	89 94 06 b8 11
	00 00		 mov	 DWORD PTR [esi+eax+4536], edx

; 6472 : 	gObj[number].TargetNumber = aIndex;

  0040b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00410	66 89 9c 06 38
	06 00 00	 mov	 WORD PTR [esi+eax+1592], bx

; 6473 : 	lpObj->m_InterfaceTime = GetTickCount();

  00418	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0041e	ff d3		 call	 ebx
  00420	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00423	89 81 bc 11 00
	00		 mov	 DWORD PTR [ecx+4540], eax

; 6474 : 	gObj[number].m_InterfaceTime = GetTickCount();

  00429	ff d3		 call	 ebx
  0042b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00431	89 84 16 bc 11
	00 00		 mov	 DWORD PTR [esi+edx+4540], eax

; 6475 : 
; 6476 : 	PMSG_TRADE_REQUESTSEND pMsg;
; 6477 : 
; 6478 : 	pMsg.h.c = 0xC3;
; 6479 : 	pMsg.h.headcode = 0x36;
; 6480 : 	pMsg.h.size = sizeof(pMsg);
; 6481 : 	memcpy(pMsg.szId, gObj[aIndex].Name, sizeof(pMsg.szId));

  00438	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0043d	c6 45 ec c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H
  00441	66 c7 45 ed 0d
	36		 mov	 WORD PTR _pMsg$[ebp+1], 13837 ; 0000360dH
  00447	8b 4c 07 5d	 mov	 ecx, DWORD PTR [edi+eax+93]
  0044b	89 4d ef	 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  0044e	8b 54 07 61	 mov	 edx, DWORD PTR [edi+eax+97]
  00452	89 55 f3	 mov	 DWORD PTR _pMsg$[ebp+7], edx

; 6482 : 
; 6483 : 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  00455	8b 55 e8	 mov	 edx, DWORD PTR _number$[ebp]
  00458	66 8b 44 07 65	 mov	 ax, WORD PTR [edi+eax+101]
  0045d	6a 0d		 push	 13			; 0000000dH
  0045f	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00462	51		 push	 ecx
  00463	52		 push	 edx
  00464	66 89 45 f7	 mov	 WORD PTR _pMsg$[ebp+11], ax
  00468	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6484 : 
; 6485 : 	LogAddTD(lMsg.Get(MSGGET(1, 230)), gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Ip_addr,
; 6486 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);

  0046d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00472	83 c4 0c	 add	 esp, 12			; 0000000cH
  00475	8d 4c 06 1c	 lea	 ecx, DWORD PTR [esi+eax+28]
  00479	51		 push	 ecx
  0047a	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  0047e	52		 push	 edx
  0047f	8d 4c 06 52	 lea	 ecx, DWORD PTR [esi+eax+82]
  00483	51		 push	 ecx
  00484	8d 54 07 1c	 lea	 edx, DWORD PTR [edi+eax+28]
  00488	52		 push	 edx
  00489	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  0048d	51		 push	 ecx
  0048e	8d 54 07 52	 lea	 edx, DWORD PTR [edi+eax+82]
  00492	52		 push	 edx
  00493	68 e6 01 00 00	 push	 486			; 000001e6H
  00498	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0049d	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  004a2	50		 push	 eax
  004a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004a9	83 c4 1c	 add	 esp, 28			; 0000001cH
  004ac	5f		 pop	 edi
  004ad	5e		 pop	 esi
  004ae	5b		 pop	 ebx

; 6487 : }

  004af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b2	33 cd		 xor	 ecx, ebp
  004b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004b9	8b e5		 mov	 esp, ebp
  004bb	5d		 pop	 ebp
  004bc	c3		 ret	 0
$LN18@CGTradeReq:

; 6373 : 		 GCServerMsgStringSend(lMsg.Get(MSGGET(2, 199)), aIndex, 1);

  004bd	6a 01		 push	 1
  004bf	53		 push	 ebx
  004c0	68 c7 02 00 00	 push	 711			; 000002c7H
$LN57@CGTradeReq:
  004c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  004ca	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  004cf	50		 push	 eax
$LN56@CGTradeReq:
  004d0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004d5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN55@CGTradeReq:

; 6487 : }

  004d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004db	5f		 pop	 edi
  004dc	5e		 pop	 esi
  004dd	33 cd		 xor	 ecx, ebp
  004df	5b		 pop	 ebx
  004e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004e5	8b e5		 mov	 esp, ebp
  004e7	5d		 pop	 ebp
  004e8	c3		 ret	 0
?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ENDP	; CGTradeRequestSend
_TEXT	ENDS
PUBLIC	??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@ ; `string'
PUBLIC	??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@ ; `string'
PUBLIC	??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@ ; `string'
PUBLIC	??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@ ; `string'
PUBLIC	??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ; CGTradeResponseRecv
;	COMDAT ??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@
CONST	SEGMENT
??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@ DB '('
	DB	'%s)(%s) Trade Interface State Error : use:%d type:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ DB '['
	DB	'%s][%s] Trade Ready [%s][%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@ DB 'Interface State :'
	DB	' %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@
CONST	SEGMENT
??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@ DB '['
	DB	'%s][%s] Made Trade Error (in Transaction) [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@
CONST	SEGMENT
??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@ DB '['
	DB	'%s][%s] CGTradeResponseRecv() Failed : Transaction == 1, IF_T'
	DB	'YPE : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@
CONST	SEGMENT
??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@ DB 'e'
	DB	'rror-L1 : target:%d (A_ID:%s) %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@ DB 'e'
	DB	'rror-L1 : %d (A_ID:%s) %s %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z
_TEXT	SEGMENT
_number$ = -8						; size = 4
_Result$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z PROC ; CGTradeResponseRecv, COMDAT

; 6493 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 6494 : 	BOOL Result = TRUE;
; 6495 : 	int number = gObj[aIndex].TargetNumber;

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00018	57		 push	 edi
  00019	0f bf bc 06 38
	06 00 00	 movsx	 edi, WORD PTR [esi+eax+1592]
  00021	89 7d f8	 mov	 DWORD PTR _number$[ebp], edi

; 6496 : 
; 6497 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00024	85 c9		 test	 ecx, ecx
  00026	78 11		 js	 SHORT $LN41@CGTradeRes
  00028	33 d2		 xor	 edx, edx
  0002a	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00030	0f 9e c2	 setle	 dl
  00033	8b ca		 mov	 ecx, edx
  00035	85 c9		 test	 ecx, ecx
  00037	75 2c		 jne	 SHORT $LN46@CGTradeRes
$LN41@CGTradeRes:

; 6498 : 	{
; 6499 : 		LogAdd("error-L1 : %d (A_ID:%s) %s %d", number, gObj[aIndex].AccountID, __FILE__, __LINE__);

  00039	68 63 19 00 00	 push	 6499			; 00001963H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00043	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00047	50		 push	 eax
  00048	57		 push	 edi
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 6500 : 		Result = FALSE;
; 6501 : 		lpMsg->Response = false;

  00054	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00057	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	83 c4 14	 add	 esp, 20			; 00000014H
  00063	eb 03		 jmp	 SHORT $LN32@CGTradeRes
$LN46@CGTradeRes:
  00065	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
$LN32@CGTradeRes:

; 6502 : 	}
; 6503 : 
; 6504 : 	if ( OBJMAX_RANGE(number) == FALSE )

  00068	85 ff		 test	 edi, edi
  0006a	78 0f		 js	 SHORT $LN42@CGTradeRes
  0006c	33 c9		 xor	 ecx, ecx
  0006e	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00074	0f 9e c1	 setle	 cl
  00077	85 c9		 test	 ecx, ecx
  00079	75 57		 jne	 SHORT $LN49@CGTradeRes
$LN42@CGTradeRes:

; 6505 : 	{
; 6506 : 		if ( gObj[aIndex].m_IfState.use != FALSE )

  0007b	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  00082	f6 c1 03	 test	 cl, 3
  00085	74 29		 je	 SHORT $LN47@CGTradeRes

; 6507 : 		{
; 6508 : 			if ( gObj[aIndex].m_IfState.type == 1 )

  00087	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0008d	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00090	75 1e		 jne	 SHORT $LN47@CGTradeRes

; 6509 : 			{
; 6510 : 				gObj[aIndex].m_IfState.use = FALSE;

  00092	83 a4 06 b8 11
	00 00 fc	 and	 DWORD PTR [esi+eax+4536], -4 ; fffffffcH

; 6511 : 				gObj[aIndex].TargetNumber = -1;

  0009a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a0	83 c9 ff	 or	 ecx, -1
  000a3	66 89 8c 16 38
	06 00 00	 mov	 WORD PTR [esi+edx+1592], cx
  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN47@CGTradeRes:

; 6512 : 			}
; 6513 : 		}
; 6514 : 
; 6515 : 		LogAdd("error-L1 : target:%d (A_ID:%s) %s %d", number, gObj[aIndex].AccountID, __FILE__, __LINE__);

  000b0	68 73 19 00 00	 push	 6515			; 00001973H
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000ba	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  000be	50		 push	 eax
  000bf	57		 push	 edi
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000cb	83 c4 14	 add	 esp, 20			; 00000014H

; 6516 : 		Result = FALSE;
; 6517 : 		lpMsg->Response = false;

  000ce	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
$LN49@CGTradeRes:

; 6518 : 	}
; 6519 : 
; 6520 : 	if ( gObjIsConnected(number) == FALSE )

  000d2	57		 push	 edi
  000d3	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000d8	83 c4 04	 add	 esp, 4
  000db	85 c0		 test	 eax, eax
  000dd	75 03		 jne	 SHORT $LN28@CGTradeRes

; 6521 : 	{
; 6522 : 		Result = FALSE;
; 6523 : 		lpMsg->Response = false;

  000df	88 43 03	 mov	 BYTE PTR [ebx+3], al
$LN28@CGTradeRes:

; 6524 : 	}
; 6525 : 	
; 6526 : 	if ( gObj[aIndex].CloseType != -1 )

  000e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e7	80 7c 06 0d ff	 cmp	 BYTE PTR [esi+eax+13], -1
  000ec	74 09		 je	 SHORT $LN27@CGTradeRes

; 6527 : 	{
; 6528 : 		Result = FALSE;
; 6529 : 		lpMsg->Response = false;

  000ee	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN27@CGTradeRes:

; 6530 : 	}
; 6531 : 
; 6532 : 	if ( gObj[aIndex].m_bPShopOpen == true )

  000f7	80 bc 06 5c 12
	00 00 01	 cmp	 BYTE PTR [esi+eax+4700], 1
  000ff	75 09		 jne	 SHORT $LN26@CGTradeRes

; 6533 : 	{
; 6534 : 		Result = FALSE;
; 6535 : 		lpMsg->Response = false;

  00101	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  00105	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN26@CGTradeRes:

; 6536 : 	}
; 6537 : 
; 6538 : 	if ( gObj[number].m_bPShopOpen == true )

  0010a	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00110	80 bc 07 5c 12
	00 00 01	 cmp	 BYTE PTR [edi+eax+4700], 1
  00118	75 09		 jne	 SHORT $LN25@CGTradeRes

; 6539 : 	{
; 6540 : 		Result = FALSE;
; 6541 : 		lpMsg->Response = false;

  0011a	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  0011e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN25@CGTradeRes:

; 6542 : 	}
; 6543 : 
; 6544 : 	if ( gObj[aIndex].X < (gObj[number].X -2 ) || gObj[aIndex].X > (gObj[number].X +2 ) || gObj[aIndex].Y < (gObj[number].Y -2 ) || gObj[aIndex].Y > (gObj[number].Y +2 ) )

  00123	0f b6 8c 07 20
	01 00 00	 movzx	 ecx, BYTE PTR [edi+eax+288]
  0012b	0f b6 94 06 20
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+288]
  00133	8d 59 fe	 lea	 ebx, DWORD PTR [ecx-2]
  00136	3b d3		 cmp	 edx, ebx
  00138	7c 25		 jl	 SHORT $LN52@CGTradeRes
  0013a	83 c1 02	 add	 ecx, 2
  0013d	3b d1		 cmp	 edx, ecx
  0013f	7f 1e		 jg	 SHORT $LN52@CGTradeRes
  00141	0f b6 8c 07 21
	01 00 00	 movzx	 ecx, BYTE PTR [edi+eax+289]
  00149	0f b6 94 06 21
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+289]
  00151	8d 59 fe	 lea	 ebx, DWORD PTR [ecx-2]
  00154	3b d3		 cmp	 edx, ebx
  00156	7c 07		 jl	 SHORT $LN52@CGTradeRes
  00158	83 c1 02	 add	 ecx, 2
  0015b	3b d1		 cmp	 edx, ecx
  0015d	7e 0c		 jle	 SHORT $LN53@CGTradeRes
$LN52@CGTradeRes:

; 6545 : 	{
; 6546 : 		Result = FALSE;
; 6547 : 		lpMsg->Response = false;

  0015f	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00162	c6 41 03 00	 mov	 BYTE PTR [ecx+3], 0
  00166	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN53@CGTradeRes:

; 6548 : 	}
; 6549 : 
; 6550 : 	if ( gObj[aIndex].m_IfState.use == FALSE || gObj[aIndex].m_IfState.type != 1 || gObj[aIndex].m_IfState.state != 0 )

  0016b	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  00172	f6 c1 03	 test	 cl, 3
  00175	0f 84 f1 03 00
	00		 je	 $LN21@CGTradeRes
  0017b	8b d1		 mov	 edx, ecx
  0017d	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00183	83 fa 40	 cmp	 edx, 64			; 00000040H
  00186	0f 85 e0 03 00
	00		 jne	 $LN21@CGTradeRes
  0018c	f6 c1 3c	 test	 cl, 60			; 0000003cH
  0018f	0f 85 d7 03 00
	00		 jne	 $LN21@CGTradeRes

; 6554 : 
; 6555 : 		return;
; 6556 : 	}
; 6557 : 
; 6558 : 	if ( gObj[number].m_IfState.use == FALSE || gObj[number].m_IfState.type != 1 || gObj[number].m_IfState.state != 0 )

  00195	8b 8c 07 b8 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4536]
  0019c	f6 c1 03	 test	 cl, 3
  0019f	0f 84 ad 03 00
	00		 je	 $LN19@CGTradeRes
  001a5	8b d1		 mov	 edx, ecx
  001a7	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  001ad	83 fa 40	 cmp	 edx, 64			; 00000040H
  001b0	0f 85 9c 03 00
	00		 jne	 $LN19@CGTradeRes
  001b6	f6 c1 3c	 test	 cl, 60			; 0000003cH
  001b9	0f 85 93 03 00
	00		 jne	 $LN19@CGTradeRes

; 6564 : 	}
; 6565 : 
; 6566 : 	if ( gObjFixInventoryPointer(aIndex) == false )

  001bf	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001c2	50		 push	 eax
  001c3	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  001c8	83 c4 04	 add	 esp, 4
  001cb	84 c0		 test	 al, al
  001cd	75 18		 jne	 SHORT $LN18@CGTradeRes

; 6567 : 	{
; 6568 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  001cf	68 a8 19 00 00	 push	 6568			; 000019a8H
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  001de	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001e4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@CGTradeRes:

; 6569 : 	}
; 6570 : 
; 6571 : 	if ( gObj[aIndex].pTransaction == 1 )

  001e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ec	80 bc 06 cc 11
	00 00 01	 cmp	 BYTE PTR [esi+eax+4556], 1
  001f4	75 30		 jne	 SHORT $LN17@CGTradeRes

; 6572 : 	{
; 6573 : 		LogAddTD("[%s][%s] CGTradeResponseRecv() Failed : Transaction == 1, IF_TYPE : %d",
; 6574 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  001f6	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  001fd	c1 e9 06	 shr	 ecx, 6
  00200	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00206	51		 push	 ecx
  00207	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  0020b	52		 push	 edx
  0020c	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00210	50		 push	 eax
  00211	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0021c	83 c4 10	 add	 esp, 16			; 00000010H
  0021f	5f		 pop	 edi
  00220	5e		 pop	 esi
  00221	5b		 pop	 ebx

; 6656 : 			}
; 6657 : 		}
; 6658 : 	}
; 6659 : }

  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	c3		 ret	 0
$LN17@CGTradeRes:

; 6575 : 
; 6576 : 		return;
; 6577 : 	}
; 6578 : 
; 6579 : 	if ( lpMsg->Response == false )

  00226	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00229	80 79 03 00	 cmp	 BYTE PTR [ecx+3], 0
  0022d	75 19		 jne	 SHORT $LN16@CGTradeRes

; 6580 : 	{
; 6581 : 		GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name, 0, 0);

  0022f	6a 00		 push	 0
  00231	6a 00		 push	 0
  00233	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  00237	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  0023a	52		 push	 edx
  0023b	50		 push	 eax
  0023c	6a 00		 push	 0
  0023e	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 6582 : 		Result = FALSE;
; 6583 : 	}
; 6584 : 	else

  00243	e9 93 01 00 00	 jmp	 $LN57@CGTradeRes
$LN16@CGTradeRes:

; 6585 : 	{
; 6586 : 		Result = TRUE;

  00248	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 1
  0024f	33 db		 xor	 ebx, ebx
  00251	eb 12		 jmp	 SHORT $LN14@CGTradeRes
  00253	eb 0b 8d a4 24
	00 00 00 00 8d
	64 24 00	 npad	 13
$LL45@CGTradeRes:
  00260	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN14@CGTradeRes:

; 6587 : 
; 6588 : 		for ( int i=0;i<TRADE_BOX_SIZE;i++)
; 6589 : 		{
; 6590 : 			gObj[aIndex].Trade[i].Clear();

  00265	8b 8c 06 e8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4584]
  0026c	03 cb		 add	 ecx, ebx
  0026e	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 6591 : 			gObj[number].Trade[i].Clear();

  00273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00279	8b 8c 0f e8 11
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+4584]
  00280	03 cb		 add	 ecx, ebx
  00282	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00287	81 c3 d4 00 00
	00		 add	 ebx, 212		; 000000d4H
  0028d	81 fb 80 1a 00
	00		 cmp	 ebx, 6784		; 00001a80H
  00293	7c cb		 jl	 SHORT $LL45@CGTradeRes

; 6592 : 		}
; 6593 : 
; 6594 : 		memset(gObj[aIndex].TradeMap, (BYTE)-1, TRADE_BOX_MAP_SIZE );

  00295	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029b	8b 8c 16 ec 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4588]
  002a2	83 c8 ff	 or	 eax, -1
  002a5	89 01		 mov	 DWORD PTR [ecx], eax
  002a7	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  002aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  002ad	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  002b0	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  002b3	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  002b6	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  002b9	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 6595 : 		memset(gObj[number].TradeMap, (BYTE)-1, TRADE_BOX_MAP_SIZE );

  002bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c2	8b 8c 0f ec 11
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+4588]
  002c9	0b c0		 or	 eax, eax
  002cb	89 01		 mov	 DWORD PTR [ecx], eax
  002cd	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  002d0	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  002d3	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  002d6	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  002d9	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  002dc	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  002df	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 6596 : 		gObj[aIndex].m_IfState.state = 1;

  002e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e7	8b 94 06 b8 11
	00 00		 mov	 edx, DWORD PTR [esi+eax+4536]

; 6597 : 		gObj[number].m_IfState.state = 1;
; 6598 : 		gObj[aIndex].TradeMoney = 0;
; 6599 : 		gObj[number].TradeMoney = 0;
; 6600 : 
; 6601 : 		if (::gObjInventoryTrans(aIndex) == FALSE )

  002ee	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  002f1	83 e2 c7	 and	 edx, -57		; ffffffc7H
  002f4	83 ca 04	 or	 edx, 4
  002f7	89 94 06 b8 11
	00 00		 mov	 DWORD PTR [esi+eax+4536], edx
  002fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00303	8b 8c 07 b8 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4536]
  0030a	83 e1 c7	 and	 ecx, -57		; ffffffc7H
  0030d	83 c9 04	 or	 ecx, 4
  00310	89 8c 07 b8 11
	00 00		 mov	 DWORD PTR [edi+eax+4536], ecx
  00317	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0031d	33 c0		 xor	 eax, eax
  0031f	89 84 16 f0 11
	00 00		 mov	 DWORD PTR [esi+edx+4592], eax
  00326	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0032c	53		 push	 ebx
  0032d	89 84 0f f0 11
	00 00		 mov	 DWORD PTR [edi+ecx+4592], eax
  00334	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans
  00339	83 c4 04	 add	 esp, 4
  0033c	85 c0		 test	 eax, eax
  0033e	75 07		 jne	 SHORT $LN50@CGTradeRes

; 6602 : 			Result = 2;

  00340	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 2
$LN50@CGTradeRes:

; 6603 : 
; 6604 : 		if (::gObjInventoryTrans(number) == FALSE )

  00347	8b 55 f8	 mov	 edx, DWORD PTR _number$[ebp]
  0034a	52		 push	 edx
  0034b	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans
  00350	83 c4 04	 add	 esp, 4
  00353	85 c0		 test	 eax, eax
  00355	75 09		 jne	 SHORT $LN10@CGTradeRes

; 6605 : 			Result = 3;

  00357	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 3

; 6606 : 
; 6607 : 		if ( Result != TRUE )

  0035e	eb 0a		 jmp	 SHORT $LN44@CGTradeRes
$LN10@CGTradeRes:
  00360	83 7d fc 01	 cmp	 DWORD PTR _Result$[ebp], 1
  00364	0f 84 64 01 00
	00		 je	 $LN9@CGTradeRes
$LN44@CGTradeRes:

; 6608 : 		{
; 6609 : 			lpMsg->Response = false;

  0036a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0036d	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 6610 : 			GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name, 0, 0);

  00371	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00377	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  0037a	6a 00		 push	 0
  0037c	6a 00		 push	 0
  0037e	8d 54 0e 5d	 lea	 edx, DWORD PTR [esi+ecx+93]
  00382	52		 push	 edx
  00383	50		 push	 eax
  00384	6a 00		 push	 0
  00386	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 6611 : 			GCTradeResponseSend(lpMsg->Response, aIndex, gObj[number].Name, 0, 0);

  0038b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00391	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00394	6a 00		 push	 0
  00396	6a 00		 push	 0
  00398	8d 54 0f 5d	 lea	 edx, DWORD PTR [edi+ecx+93]
  0039c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  003a0	52		 push	 edx
  003a1	53		 push	 ebx
  003a2	51		 push	 ecx
  003a3	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 6612 : 
; 6613 : 			if ( Result == 2 )

  003a8	8b 45 fc	 mov	 eax, DWORD PTR _Result$[ebp]
  003ab	83 c4 28	 add	 esp, 40			; 00000028H
  003ae	83 f8 02	 cmp	 eax, 2
  003b1	0f 85 f0 00 00
	00		 jne	 $LN8@CGTradeRes

; 6614 : 			{
; 6615 : 				LogAddTD("[%s][%s] Made Trade Error (in Transaction) [%s][%s]",
; 6616 : 					gObj[aIndex].AccountID, gObj[aIndex].Name,
; 6617 : 					gObj[number].AccountID, gObj[number].Name);

  003b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003bc	8d 54 07 5d	 lea	 edx, DWORD PTR [edi+eax+93]
  003c0	52		 push	 edx
  003c1	8d 4c 07 52	 lea	 ecx, DWORD PTR [edi+eax+82]
  003c5	51		 push	 ecx
  003c6	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  003ca	52		 push	 edx
  003cb	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  003cf	50		 push	 eax
$LN59@CGTradeRes:
  003d0	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@
  003d5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
$LN57@CGTradeRes:

; 6620 : 			{
; 6621 : 				LogAddTD("[%s][%s] Made Trade Error (in Transaction) [%s][%s]",
; 6622 : 					gObj[number].AccountID, gObj[number].Name,
; 6623 : 					gObj[aIndex].AccountID, gObj[aIndex].Name);

  003db	83 c4 14	 add	 esp, 20			; 00000014H
$LN51@CGTradeRes:

; 6637 : 		}
; 6638 : 	}
; 6639 : 
; 6640 : 	if ( Result == FALSE )
; 6641 : 	{
; 6642 : 		if ( gObj[aIndex].m_IfState.use != FALSE && gObj[aIndex].m_IfState.type == 1 )

  003de	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003e3	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  003ea	f6 c1 03	 test	 cl, 3
  003ed	74 47		 je	 SHORT $LN55@CGTradeRes
  003ef	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  003f5	83 f9 40	 cmp	 ecx, 64			; 00000040H
  003f8	75 3c		 jne	 SHORT $LN55@CGTradeRes

; 6643 : 		{
; 6644 : 			gObj[aIndex].m_IfState.use = FALSE;

  003fa	83 a4 06 b8 11
	00 00 fc	 and	 DWORD PTR [esi+eax+4536], -4 ; fffffffcH

; 6645 : 			gObj[aIndex].TargetNumber = -1;

  00402	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00408	83 c9 ff	 or	 ecx, -1
  0040b	66 89 8c 16 38
	06 00 00	 mov	 WORD PTR [esi+edx+1592], cx

; 6646 : 			LogAddTD("Interface State : %d", gObj[aIndex].m_IfState.use);

  00413	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00418	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  0041f	83 e1 03	 and	 ecx, 3
  00422	51		 push	 ecx
  00423	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@
  00428	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0042e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00433	83 c4 08	 add	 esp, 8
$LN55@CGTradeRes:

; 6647 : 		}
; 6648 : 
; 6649 : 		if ( gObj[number].TargetNumber == aIndex )

  00436	0f bf 94 07 38
	06 00 00	 movsx	 edx, WORD PTR [edi+eax+1592]
  0043e	3b 55 0c	 cmp	 edx, DWORD PTR _aIndex$[ebp]
  00441	0f 85 4d 01 00
	00		 jne	 $LN1@CGTradeRes

; 6650 : 		{
; 6651 : 			if ( gObj[number].m_IfState.use != FALSE && gObj[number].m_IfState.type == 1 )

  00447	8b 8c 07 b8 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4536]
  0044e	8d 84 07 b8 11
	00 00		 lea	 eax, DWORD PTR [edi+eax+4536]
  00455	f6 c1 03	 test	 cl, 3
  00458	0f 84 36 01 00
	00		 je	 $LN1@CGTradeRes
  0045e	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00464	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00467	0f 85 27 01 00
	00		 jne	 $LN1@CGTradeRes

; 6652 : 			{
; 6653 : 				gObj[number].m_IfState.use = FALSE;

  0046d	83 20 fc	 and	 DWORD PTR [eax], -4	; fffffffcH

; 6654 : 				gObj[number].TargetNumber = -1;

  00470	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00476	83 c8 ff	 or	 eax, -1
  00479	66 89 84 0f 38
	06 00 00	 mov	 WORD PTR [edi+ecx+1592], ax

; 6655 : 				LogAddTD("Interface State : %d", gObj[number].m_IfState.use);

  00481	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00487	8b 84 17 b8 11
	00 00		 mov	 eax, DWORD PTR [edi+edx+4536]
  0048e	83 e0 03	 and	 eax, 3
  00491	50		 push	 eax
  00492	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@
  00497	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0049d	83 c4 08	 add	 esp, 8
  004a0	5f		 pop	 edi
  004a1	5e		 pop	 esi
  004a2	5b		 pop	 ebx

; 6656 : 			}
; 6657 : 		}
; 6658 : 	}
; 6659 : }

  004a3	8b e5		 mov	 esp, ebp
  004a5	5d		 pop	 ebp
  004a6	c3		 ret	 0
$LN8@CGTradeRes:

; 6618 : 			}
; 6619 : 			else if ( Result == 3 )

  004a7	83 f8 03	 cmp	 eax, 3
  004aa	0f 85 2e ff ff
	ff		 jne	 $LN51@CGTradeRes

; 6620 : 			{
; 6621 : 				LogAddTD("[%s][%s] Made Trade Error (in Transaction) [%s][%s]",
; 6622 : 					gObj[number].AccountID, gObj[number].Name,
; 6623 : 					gObj[aIndex].AccountID, gObj[aIndex].Name);

  004b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004b5	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  004b9	51		 push	 ecx
  004ba	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  004be	52		 push	 edx
  004bf	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  004c3	51		 push	 ecx
  004c4	8d 54 07 52	 lea	 edx, DWORD PTR [edi+eax+82]
  004c8	52		 push	 edx

; 6624 : 			}
; 6625 : 
; 6626 : 			Result = FALSE;
; 6627 : 		}
; 6628 : 		else

  004c9	e9 02 ff ff ff	 jmp	 $LN59@CGTradeRes
$LN9@CGTradeRes:

; 6629 : 		{
; 6630 : 			lpMsg->Response = true;

  004ce	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004d1	c6 40 03 01	 mov	 BYTE PTR [eax+3], 1

; 6631 : 			GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name, gObj[aIndex].Level, gObj[aIndex].GuildNumber);

  004d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004da	8b 8c 06 14 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1556]
  004e1	0f b7 94 06 96
	00 00 00	 movzx	 edx, WORD PTR [esi+eax+150]
  004e9	51		 push	 ecx
  004ea	8b 4d f8	 mov	 ecx, DWORD PTR _number$[ebp]
  004ed	52		 push	 edx
  004ee	8d 44 06 5d	 lea	 eax, DWORD PTR [esi+eax+93]
  004f2	50		 push	 eax
  004f3	51		 push	 ecx
  004f4	6a 01		 push	 1
  004f6	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 6632 : 			GCTradeResponseSend(lpMsg->Response, aIndex, gObj[number].Name, gObj[number].Level, gObj[number].GuildNumber);

  004fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00500	8b 94 07 14 06
	00 00		 mov	 edx, DWORD PTR [edi+eax+1556]
  00507	0f b7 8c 07 96
	00 00 00	 movzx	 ecx, WORD PTR [edi+eax+150]
  0050f	52		 push	 edx
  00510	51		 push	 ecx
  00511	8d 54 07 5d	 lea	 edx, DWORD PTR [edi+eax+93]
  00515	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00518	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0051c	52		 push	 edx
  0051d	53		 push	 ebx
  0051e	51		 push	 ecx
  0051f	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 6633 : 
; 6634 : 			LogAddTD("[%s][%s] Trade Ready [%s][%s]", 
; 6635 : 				gObj[number].AccountID, gObj[number].Name,
; 6636 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  00524	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00529	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  0052d	52		 push	 edx
  0052e	8d 4c 06 52	 lea	 ecx, DWORD PTR [esi+eax+82]
  00532	51		 push	 ecx
  00533	8d 54 07 5d	 lea	 edx, DWORD PTR [edi+eax+93]
  00537	52		 push	 edx
  00538	8d 44 07 52	 lea	 eax, DWORD PTR [edi+eax+82]
  0053c	50		 push	 eax
  0053d	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
  00542	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00548	83 c4 3c	 add	 esp, 60			; 0000003cH
  0054b	5f		 pop	 edi
  0054c	5e		 pop	 esi
  0054d	5b		 pop	 ebx

; 6656 : 			}
; 6657 : 		}
; 6658 : 	}
; 6659 : }

  0054e	8b e5		 mov	 esp, ebp
  00550	5d		 pop	 ebp
  00551	c3		 ret	 0
$LN19@CGTradeRes:

; 6559 : 	{
; 6560 : 		LogAddTD("(%s)(%s) Trade Interface State Error : use:%d type:%d", gObj[number].AccountID, gObj[number].Name, 
; 6561 : 			gObj[number].m_IfState.use, gObj[number].m_IfState.type);

  00552	8b d1		 mov	 edx, ecx
  00554	c1 ea 06	 shr	 edx, 6
  00557	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0055d	52		 push	 edx
  0055e	83 e1 03	 and	 ecx, 3
  00561	51		 push	 ecx
  00562	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  00566	8d 54 07 52	 lea	 edx, DWORD PTR [edi+eax+82]

; 6562 : 
; 6563 : 		return;

  0056a	eb 18		 jmp	 SHORT $LN58@CGTradeRes
$LN21@CGTradeRes:

; 6551 : 	{
; 6552 : 		LogAddTD("(%s)(%s) Trade Interface State Error : use:%d type:%d", gObj[aIndex].AccountID, gObj[aIndex].Name, 
; 6553 : 			gObj[aIndex].m_IfState.use, gObj[aIndex].m_IfState.type);

  0056c	8b d1		 mov	 edx, ecx
  0056e	c1 ea 06	 shr	 edx, 6
  00571	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00577	52		 push	 edx
  00578	83 e1 03	 and	 ecx, 3
  0057b	51		 push	 ecx
  0057c	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00580	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
$LN58@CGTradeRes:
  00584	51		 push	 ecx
  00585	52		 push	 edx
  00586	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@
  0058b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00591	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@CGTradeRes:
  00594	5f		 pop	 edi
  00595	5e		 pop	 esi
  00596	5b		 pop	 ebx

; 6656 : 			}
; 6657 : 		}
; 6658 : 	}
; 6659 : }

  00597	8b e5		 mov	 esp, ebp
  00599	5d		 pop	 ebp
  0059a	c3		 ret	 0
?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ENDP ; CGTradeResponseRecv
_TEXT	ENDS
PUBLIC	?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z	; CGTradeMoneyRecv
; Function compile flags: /Ogtp
;	COMDAT ?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z
_TEXT	SEGMENT
tv326 = -8						; size = 4
_pMsg$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z PROC	; CGTradeMoneyRecv, COMDAT

; 6735 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6736 : 	PMSG_DEFRESULT pMsg;
; 6737 : 	int money = 0;
; 6738 : 	int number;
; 6739 : 
; 6740 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00010	8b f7		 mov	 esi, edi
  00012	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00018	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	0f 84 c9 01 00
	00		 je	 $LN1@CGTradeMon

; 6741 : 		return;
; 6742 : 
; 6743 : 	if ( !OBJMAX_RANGE(aIndex) )

  0002c	85 ff		 test	 edi, edi
  0002e	78 0f		 js	 SHORT $LN17@CGTradeMon
  00030	33 c0		 xor	 eax, eax
  00032	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00038	0f 9e c0	 setle	 al
  0003b	85 c0		 test	 eax, eax
  0003d	75 1f		 jne	 SHORT $LN9@CGTradeMon
$LN17@CGTradeMon:

; 6744 : 	{
; 6745 : 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, aIndex);

  0003f	57		 push	 edi
  00040	68 59 1a 00 00	 push	 6745			; 00001a59H
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00055	83 c4 10	 add	 esp, 16			; 00000010H
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi

; 6799 : 	}
; 6800 : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN9@CGTradeMon:

; 6746 : 		return;
; 6747 : 	}
; 6748 : 
; 6749 : 	if ( gObj[aIndex].CloseType != -1 )

  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00067	80 ca ff	 or	 dl, -1
  0006a	38 50 0d	 cmp	 BYTE PTR [eax+13], dl
  0006d	74 27		 je	 SHORT $LN8@CGTradeMon

; 6750 : 	{
; 6751 : 		LogAdd(lMsg.Get(MSGGET(1, 231)), gObj[aIndex].AccountID, gObj[aIndex].Name);

  0006f	8d 50 5d	 lea	 edx, DWORD PTR [eax+93]
  00072	52		 push	 edx
  00073	83 c0 52	 add	 eax, 82			; 00000052H
  00076	50		 push	 eax
  00077	68 e7 01 00 00	 push	 487			; 000001e7H
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00081	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00086	50		 push	 eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi

; 6799 : 	}
; 6800 : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
$LN8@CGTradeMon:

; 6752 : 		return;
; 6753 : 	}
; 6754 : 
; 6755 : 	number = gObj[aIndex].TargetNumber;

  00096	0f bf b8 38 06
	00 00		 movsx	 edi, WORD PTR [eax+1592]
  0009d	53		 push	 ebx

; 6756 : 
; 6757 : 	if ( !OBJMAX_RANGE(number) )

  0009e	85 ff		 test	 edi, edi
  000a0	78 0f		 js	 SHORT $LN18@CGTradeMon
  000a2	33 db		 xor	 ebx, ebx
  000a4	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  000aa	0f 9e c3	 setle	 bl
  000ad	85 db		 test	 ebx, ebx
  000af	75 29		 jne	 SHORT $LN7@CGTradeMon
$LN18@CGTradeMon:

; 6758 : 	{
; 6759 : 		LogAdd(lMsg.Get(MSGGET(1, 232)), gObj[aIndex].AccountID, gObj[aIndex].Name, number);

  000b1	57		 push	 edi
  000b2	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  000b5	51		 push	 ecx
  000b6	83 c0 52	 add	 eax, 82			; 00000052H
  000b9	50		 push	 eax
  000ba	68 e8 01 00 00	 push	 488			; 000001e8H
  000bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000c4	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d0	83 c4 10	 add	 esp, 16			; 00000010H
  000d3	5b		 pop	 ebx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi

; 6799 : 	}
; 6800 : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
$LN7@CGTradeMon:

; 6760 : 		return;
; 6761 : 	}
; 6762 : 
; 6763 : 	if ( gObj[number].CloseType != -1 )

  000da	8b df		 mov	 ebx, edi
  000dc	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  000e2	38 54 0b 0d	 cmp	 BYTE PTR [ebx+ecx+13], dl
  000e6	74 32		 je	 SHORT $LN6@CGTradeMon

; 6764 : 	{
; 6765 : 		LogAdd(lMsg.Get(MSGGET(1, 233)), gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[number].AccountID, gObj[number].Name);

  000e8	8d 54 0b 5d	 lea	 edx, DWORD PTR [ebx+ecx+93]
  000ec	52		 push	 edx
  000ed	8d 4c 0b 52	 lea	 ecx, DWORD PTR [ebx+ecx+82]
  000f1	51		 push	 ecx
  000f2	8d 50 5d	 lea	 edx, DWORD PTR [eax+93]
  000f5	52		 push	 edx
  000f6	83 c0 52	 add	 eax, 82			; 00000052H
  000f9	50		 push	 eax
  000fa	68 e9 01 00 00	 push	 489			; 000001e9H
  000ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00104	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00109	50		 push	 eax
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00110	83 c4 14	 add	 esp, 20			; 00000014H
  00113	5b		 pop	 ebx
  00114	5f		 pop	 edi
  00115	5e		 pop	 esi

; 6799 : 	}
; 6800 : }

  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
$LN6@CGTradeMon:

; 6766 : 		return;
; 6767 : 	}
; 6768 : 
; 6769 : 	if ( gObj[aIndex].m_IfState.use == FALSE && gObj[aIndex].m_IfState.type != 1 )

  0011a	8b 88 b8 11 00
	00		 mov	 ecx, DWORD PTR [eax+4536]
  00120	f6 c1 03	 test	 cl, 3
  00123	75 0f		 jne	 SHORT $LN5@CGTradeMon
  00125	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0012b	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0012e	0f 85 c0 00 00
	00		 jne	 $LN19@CGTradeMon
$LN5@CGTradeMon:

; 6770 : 		return;
; 6771 : 
; 6772 : 	if ( ::gObjCanItemTouch(&gObj[aIndex], 1) == FALSE )

  00134	6a 01		 push	 1
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  0013c	83 c4 08	 add	 esp, 8
  0013f	85 c0		 test	 eax, eax
  00141	0f 84 ad 00 00
	00		 je	 $LN19@CGTradeMon

; 6773 : 		return;
; 6774 : 
; 6775 : 	if ( lpMsg->Money > 1000000000 )

  00147	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0014a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014d	89 4d f8	 mov	 DWORD PTR tv326[ebp], ecx
  00150	81 f9 00 ca 9a
	3b		 cmp	 ecx, 1000000000		; 3b9aca00H
  00156	0f 87 98 00 00
	00		 ja	 $LN19@CGTradeMon

; 6776 : 		return;
; 6777 : 
; 6778 : 	money = lpMsg->Money;
; 6779 : 
; 6780 : 	if ( (gObj[aIndex].Money - money) < 0 )

  0015c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00162	8b 84 16 cc 00
	00 00		 mov	 eax, DWORD PTR [esi+edx+204]
  00169	2b c1		 sub	 eax, ecx
  0016b	0f 88 83 00 00
	00		 js	 $LN19@CGTradeMon

; 6781 : 		return;
; 6782 : 
; 6783 : 	GCMoneySend(aIndex, gObj[aIndex].Money - money);

  00171	50		 push	 eax
  00172	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 6784 : 
; 6785 : 	PHeadSetB((LPBYTE)&pMsg, 0x3A, sizeof(pMsg));

  0017b	6a 04		 push	 4
  0017d	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00180	6a 3a		 push	 58			; 0000003aH
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6786 : 	pMsg.result = 1;
; 6787 : 
; 6788 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00188	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0018f	52		 push	 edx
  00190	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00193	50		 push	 eax
  00194	51		 push	 ecx
  00195	c6 45 ff 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1
  00199	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6789 : 
; 6790 : 	if ( number >= 0)
; 6791 : 	{
; 6792 : 		gObj[aIndex].TradeMoney = money;

  0019e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a4	8b 45 f8	 mov	 eax, DWORD PTR tv326[ebp]
  001a7	89 84 16 f0 11
	00 00		 mov	 DWORD PTR [esi+edx+4592], eax

; 6793 : 		gObj[aIndex].TradeOk  = false;

  001ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b4	c6 84 0e f4 11
	00 00 00	 mov	 BYTE PTR [esi+ecx+4596], 0

; 6794 : 		gObj[number].TradeOk  = false;

  001bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6795 : 
; 6796 : 		GCTradeOkButtonSend(number, 2);

  001c2	6a 02		 push	 2
  001c4	57		 push	 edi
  001c5	c6 84 13 f4 11
	00 00 00	 mov	 BYTE PTR [ebx+edx+4596], 0
  001cd	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 6797 : 		GCTradeOkButtonSend(aIndex, 0);

  001d2	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001d5	6a 00		 push	 0
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 6798 : 		GCTradeMoneyOther(number, gObj[aIndex].TradeMoney);

  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e3	8b 94 0e f0 11
	00 00		 mov	 edx, DWORD PTR [esi+ecx+4592]
  001ea	52		 push	 edx
  001eb	57		 push	 edi
  001ec	e8 00 00 00 00	 call	 ?GCTradeMoneyOther@@YAHHK@Z ; GCTradeMoneyOther
  001f1	83 c4 38	 add	 esp, 56			; 00000038H
$LN19@CGTradeMon:
  001f4	5b		 pop	 ebx
$LN1@CGTradeMon:
  001f5	5f		 pop	 edi
  001f6	5e		 pop	 esi

; 6799 : 	}
; 6800 : }

  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c3		 ret	 0
?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z ENDP	; CGTradeMoneyRecv
_TEXT	ENDS
PUBLIC	?CGTradeCancelButtonRecv@@YAXH@Z		; CGTradeCancelButtonRecv
EXTRN	?gObjTradeCancel@@YAXH@Z:PROC			; gObjTradeCancel
; Function compile flags: /Ogtp
;	COMDAT ?CGTradeCancelButtonRecv@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGTradeCancelButtonRecv@@YAXH@Z PROC			; CGTradeCancelButtonRecv, COMDAT

; 6883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6884 : 	int number = gObj[aIndex].TargetNumber;

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000e	8b c7		 mov	 eax, edi
  00010	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00016	0f bf b4 08 38
	06 00 00	 movsx	 esi, WORD PTR [eax+ecx+1592]

; 6885 : 	gObjTradeCancel(aIndex);

  0001e	57		 push	 edi
  0001f	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel

; 6886 : 	CGTradeResult(aIndex, 0);

  00024	6a 00		 push	 0
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6887 : 
; 6888 : 	if ( number >= 0 )

  0002f	85 f6		 test	 esi, esi
  00031	78 11		 js	 SHORT $LN1@CGTradeCan

; 6889 : 	{
; 6890 : 		gObjTradeCancel(number);

  00033	56		 push	 esi
  00034	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel

; 6891 : 		CGTradeResult(number, 0);

  00039	6a 00		 push	 0
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGTradeCan:
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 6892 : 	}
; 6893 : }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?CGTradeCancelButtonRecv@@YAXH@Z ENDP			; CGTradeCancelButtonRecv
_TEXT	ENDS
PUBLIC	??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@ ; `string'
PUBLIC	??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@ ; `string'
PUBLIC	??_C@_0CK@ODKADHDC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Ou@ ; `string'
PUBLIC	??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@ ; `string'
PUBLIC	??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@ ; `string'
PUBLIC	??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ ; `string'
PUBLIC	??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@ ; `string'
PUBLIC	??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@ ; `string'
PUBLIC	??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@ ; `string'
PUBLIC	??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@ ; `string'
PUBLIC	??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@ ; `string'
PUBLIC	?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ; CGPShopReqSetItemPrice
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?GetNumber@CItem@@QAEKXZ:PROC			; CItem::GetNumber
;	COMDAT ??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@
CONST	SEGMENT
??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@ DB '['
	DB	'PShop] [%s][%s] ERROR : Personal Shop Item Price <= 0 : %d ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@
CONST	SEGMENT
??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Price Change - Item Block', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@ODKADHDC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Ou@
CONST	SEGMENT
??_C@_0CK@ODKADHDC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Ou@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Outof Bound', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@
CONST	SEGMENT
??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@ DB '['
	DB	'PShop] [%s][%s] Changing Item Price : %d (B: %d, S: %d, C: %d'
	DB	') (Type:%d (%s), Lev:%d, Serial:%d, Dur:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
CONST	SEGMENT
??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@ DB 'e'
	DB	'rror-L2 : CopyItem [%s][%s] return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
CONST	SEGMENT
??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [PShop] (%s)(%s) Item(%s) Pos(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@
CONST	SEGMENT
??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Does Not Exist : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@
CONST	SEGMENT
??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Position Out of Bound : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@
CONST	SEGMENT
??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@ DB '['
	DB	'PShop] [%s][%s] ERROR : Level is Under 6 : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
CONST	SEGMENT
??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@ DB '[PS'
	DB	'hop] ERROR : Index is not CHARACTER : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
CONST	SEGMENT
??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@ DB '[PS'
	DB	'hop] ERROR : Index is not CONNECTED : %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z
_TEXT	SEGMENT
tv622 = -16						; size = 4
tv620 = -16						; size = 4
tv608 = -16						; size = 4
tv606 = -16						; size = 4
_aChaosCnt$ = -16					; size = 2
_aSoulCnt$ = -12					; size = 2
_aBlessCnt$ = -8					; size = 2
_iItemPrice$ = -4					; size = 4
tv625 = -2						; size = 2
tv611 = -2						; size = 2
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z PROC ; CGPShopReqSetItemPrice, COMDAT

; 6930 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 6931 : 	if ( gDoPShopOpen  == FALSE )

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0000d	75 1a		 jne	 SHORT $LN14@CGPShopReq@2

; 6932 : 	{
; 6933 : 		CGPShopAnsSetItemPrice(aIndex, 0, lpMsg->btItemPos);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00012	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00016	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00019	51		 push	 ecx
  0001a	6a 00		 push	 0
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7039 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN14@CGPShopReq@2:
  00029	53		 push	 ebx

; 6934 : 		return;
; 6935 : 	}
; 6936 : 
; 6937 : 	if ( !gObjIsConnected(aIndex))

  0002a	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0002d	53		 push	 ebx
  0002e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00033	83 c4 04	 add	 esp, 4
  00036	85 c0		 test	 eax, eax
  00038	75 14		 jne	 SHORT $LN13@CGPShopReq@2

; 6938 : 	{
; 6939 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d", aIndex);

  0003a	53		 push	 ebx
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00046	83 c4 08	 add	 esp, 8
  00049	5b		 pop	 ebx

; 7039 : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN13@CGPShopReq@2:
  0004e	56		 push	 esi

; 6940 : 		return;
; 6941 : 	}
; 6942 : 
; 6943 : 	if ( gObj[aIndex].Type != OBJ_USER )

  0004f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	57		 push	 edi
  00056	8b fb		 mov	 edi, ebx
  00058	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  0005e	80 7c 37 50 01	 cmp	 BYTE PTR [edi+esi+80], 1
  00063	74 16		 je	 SHORT $LN12@CGPShopReq@2

; 6944 : 	{
; 6945 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  00065	53		 push	 ebx
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00071	83 c4 08	 add	 esp, 8
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx

; 7039 : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN12@CGPShopReq@2:

; 6946 : 		return;
; 6947 : 	}
; 6948 : 
; 6949 : 	if ( gObj[aIndex].Level <= 5 )

  0007b	0f b7 84 37 96
	00 00 00	 movzx	 eax, WORD PTR [edi+esi+150]
  00083	66 83 f8 05	 cmp	 ax, 5
  00087	7f 31		 jg	 SHORT $LN11@CGPShopReq@2

; 6950 : 	{
; 6951 : 		LogAddTD("[PShop] [%s][%s] ERROR : Level is Under 6 : %d",
; 6952 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Level);

  00089	98		 cwde
  0008a	50		 push	 eax
  0008b	8d 4c 37 5d	 lea	 ecx, DWORD PTR [edi+esi+93]
  0008f	51		 push	 ecx
  00090	8d 54 37 52	 lea	 edx, DWORD PTR [edi+esi+82]
  00094	52		 push	 edx
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 6953 : 		CGPShopAnsSetItemPrice(aIndex, 5, lpMsg->btItemPos);

  000a0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a3	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000a7	51		 push	 ecx
  000a8	6a 05		 push	 5
  000aa	53		 push	 ebx

; 7007 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  000ab	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  000b0	83 c4 1c	 add	 esp, 28			; 0000001cH
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx

; 7039 : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
$LN11@CGPShopReq@2:

; 6954 : 
; 6955 : 		return;
; 6956 : 	}
; 6957 : 
; 6958 : 	if ( INVENTORY_RANGE(lpMsg->btItemPos) == FALSE )

  000ba	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  000bd	8a 43 04	 mov	 al, BYTE PTR [ebx+4]
  000c0	b2 ec		 mov	 dl, 236			; 000000ecH
  000c2	3a d0		 cmp	 dl, al
  000c4	1b c9		 sbb	 ecx, ecx
  000c6	41		 inc	 ecx
  000c7	75 33		 jne	 SHORT $LN10@CGPShopReq@2

; 6959 : 	{
; 6960 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Position Out of Bound : %d",
; 6961 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, lpMsg->btItemPos);

  000c9	0f b6 c0	 movzx	 eax, al
  000cc	50		 push	 eax
  000cd	8d 4c 37 5d	 lea	 ecx, DWORD PTR [edi+esi+93]
  000d1	51		 push	 ecx
  000d2	8d 54 37 52	 lea	 edx, DWORD PTR [edi+esi+82]
  000d6	52		 push	 edx
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 6962 : 		CGPShopAnsSetItemPrice(aIndex, 2, lpMsg->btItemPos);

  000e2	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]

; 7007 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  000e6	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000e9	50		 push	 eax
  000ea	6a 02		 push	 2
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  000f2	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx

; 7039 : }

  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
$LN10@CGPShopReq@2:

; 6963 : 
; 6964 : 		return;
; 6965 : 	}
; 6966 : 
; 6967 : 	if ( gObj[aIndex].Inventory1[lpMsg->btItemPos].IsItem() == FALSE )

  000fc	0f b6 c8	 movzx	 ecx, al
  000ff	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00105	03 8c 37 d0 11
	00 00		 add	 ecx, DWORD PTR [edi+esi+4560]
  0010c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00111	85 c0		 test	 eax, eax
  00113	75 39		 jne	 SHORT $LN9@CGPShopReq@2

; 6968 : 	{
; 6969 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Does Not Exist : %d",
; 6970 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, lpMsg->btItemPos);

  00115	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  00119	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011e	52		 push	 edx
  0011f	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  00123	51		 push	 ecx
  00124	8d 54 07 52	 lea	 edx, DWORD PTR [edi+eax+82]
  00128	52		 push	 edx
  00129	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 6971 : 		CGPShopAnsSetItemPrice(aIndex, 3, lpMsg->btItemPos);

  00134	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]

; 7007 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  00138	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0013b	50		 push	 eax
  0013c	6a 03		 push	 3
  0013e	51		 push	 ecx
  0013f	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00144	83 c4 1c	 add	 esp, 28			; 0000001cH
  00147	5f		 pop	 edi
  00148	5e		 pop	 esi
  00149	5b		 pop	 ebx

; 7039 : }

  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
$LN9@CGPShopReq@2:

; 6972 : 
; 6973 : 		return;
; 6974 : 	}
; 6975 : 
; 6976 : 	CItem * sitem = &gObj[aIndex].Inventory1[lpMsg->btItemPos];

  0014e	0f b6 73 04	 movzx	 esi, BYTE PTR [ebx+4]

; 6977 : 	int iItemPrice = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->sItemPrice4, lpMsg->sItemPrice3), MAKE_NUMBERW(lpMsg->sItemPrice2, lpMsg->sItemPrice1));

  00152	0f b6 43 08	 movzx	 eax, BYTE PTR [ebx+8]
  00156	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  0015c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00162	03 b4 17 d0 11
	00 00		 add	 esi, DWORD PTR [edi+edx+4560]
  00169	0f b6 53 06	 movzx	 edx, BYTE PTR [ebx+6]
  0016d	0f b6 4b 07	 movzx	 ecx, BYTE PTR [ebx+7]
  00171	66 c1 e0 08	 shl	 ax, 8
  00175	0f b7 c0	 movzx	 eax, ax
  00178	0b c1		 or	 eax, ecx
  0017a	66 c1 e2 08	 shl	 dx, 8
  0017e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00181	0f b7 ca	 movzx	 ecx, dx
  00184	0f b6 53 05	 movzx	 edx, BYTE PTR [ebx+5]
  00188	0b ca		 or	 ecx, edx
  0018a	0b c1		 or	 eax, ecx

; 6978 : 	short aBlessCnt = MAKE_NUMBERW(lpMsg->sBlessCnt2,lpMsg->sBlessCnt1);

  0018c	0f b6 4b 09	 movzx	 ecx, BYTE PTR [ebx+9]
  00190	89 45 fc	 mov	 DWORD PTR _iItemPrice$[ebp], eax
  00193	0f b6 43 0a	 movzx	 eax, BYTE PTR [ebx+10]
  00197	66 c1 e0 08	 shl	 ax, 8
  0019b	66 0b c1	 or	 ax, cx

; 6979 : 	short aSoulCnt = MAKE_NUMBERW(lpMsg->sSoulCnt2,lpMsg->sSoulCnt1);

  0019e	0f b6 4b 0b	 movzx	 ecx, BYTE PTR [ebx+11]
  001a2	0f b7 d0	 movzx	 edx, ax
  001a5	0f b6 43 0c	 movzx	 eax, BYTE PTR [ebx+12]
  001a9	66 c1 e0 08	 shl	 ax, 8
  001ad	66 0b c1	 or	 ax, cx

; 6980 : 	short aChaosCnt = MAKE_NUMBERW(lpMsg->sChaosCnt2,lpMsg->sChaosCnt1);

  001b0	0f b6 4b 0d	 movzx	 ecx, BYTE PTR [ebx+13]
  001b4	89 55 f8	 mov	 DWORD PTR _aBlessCnt$[ebp], edx
  001b7	0f b7 d0	 movzx	 edx, ax
  001ba	0f b6 43 0e	 movzx	 eax, BYTE PTR [ebx+14]
  001be	66 c1 e0 08	 shl	 ax, 8
  001c2	66 0b c1	 or	 ax, cx
  001c5	89 55 f4	 mov	 DWORD PTR _aSoulCnt$[ebp], edx
  001c8	0f b7 d0	 movzx	 edx, ax

; 6981 : 
; 6982 : 
; 6983 : 	if ( gObjCheckSerial0ItemList(sitem) != FALSE )

  001cb	56		 push	 esi
  001cc	89 55 f0	 mov	 DWORD PTR _aChaosCnt$[ebp], edx
  001cf	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  001d4	83 c4 04	 add	 esp, 4
  001d7	85 c0		 test	 eax, eax
  001d9	0f 84 91 00 00
	00		 je	 $LN8@CGPShopReq@2

; 6984 : 	{
; 6985 : 		MsgOutput(aIndex, lMsg.Get(MSGGET(13, 26)));

  001df	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  001e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001e9	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001ee	50		 push	 eax
  001ef	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 6986 : 		GCReFillSend(aIndex, (WORD) gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  001f8	d9 7d fe	 fnstcw	 WORD PTR tv625[ebp]
  001fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00200	d9 84 07 d8 00
	00 00		 fld	 DWORD PTR [edi+eax+216]
  00207	0f b7 8c 07 2c
	01 00 00	 movzx	 ecx, WORD PTR [edi+eax+300]
  0020f	0f b7 45 fe	 movzx	 eax, WORD PTR tv625[ebp]
  00213	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00218	89 45 f0	 mov	 DWORD PTR tv622[ebp], eax
  0021b	51		 push	 ecx
  0021c	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0021f	d9 6d f0	 fldcw	 WORD PTR tv622[ebp]
  00222	6a 01		 push	 1
  00224	68 fd 00 00 00	 push	 253			; 000000fdH
  00229	db 5d f0	 fistp	 DWORD PTR tv620[ebp]
  0022c	66 8b 55 f0	 mov	 dx, WORD PTR tv620[ebp]
  00230	0f b7 c2	 movzx	 eax, dx
  00233	50		 push	 eax
  00234	d9 6d fe	 fldcw	 WORD PTR tv625[ebp]
  00237	51		 push	 ecx
  00238	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 6987 : 
; 6988 : 		LogAddTD("[ANTI-HACK][Serial 0 Item] [PShop] (%s)(%s) Item(%s) Pos(%d)",
; 6989 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->GetName(), lpMsg->btItemPos);

  0023d	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00241	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00247	83 c4 1c	 add	 esp, 28			; 0000001cH
  0024a	50		 push	 eax
  0024b	8b ce		 mov	 ecx, esi
  0024d	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00252	50		 push	 eax
  00253	8d 4f 5d	 lea	 ecx, DWORD PTR [edi+93]
  00256	51		 push	 ecx
  00257	83 c7 52	 add	 edi, 82			; 00000052H
  0025a	57		 push	 edi
  0025b	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00266	83 c4 14	 add	 esp, 20			; 00000014H
  00269	5f		 pop	 edi
  0026a	5e		 pop	 esi
  0026b	5b		 pop	 ebx

; 7039 : }

  0026c	8b e5		 mov	 esp, ebp
  0026e	5d		 pop	 ebp
  0026f	c3		 ret	 0
$LN8@CGPShopReq@2:

; 6990 : 
; 6991 : 		return;
; 6992 : 	}
; 6993 : 
; 6994 : 
; 6995 : 	if ( gObjInventorySearchSerialNumber(&gObj[aIndex], sitem->GetNumber()) == FALSE )

  00270	8b ce		 mov	 ecx, esi
  00272	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00277	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0027d	50		 push	 eax
  0027e	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00281	50		 push	 eax
  00282	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00287	83 c4 08	 add	 esp, 8
  0028a	85 c0		 test	 eax, eax
  0028c	75 73		 jne	 SHORT $LN7@CGPShopReq@2

; 6996 : 	{
; 6997 : 		GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, TRUE, gObj[aIndex].iShield);

  0028e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00293	d9 7d fe	 fnstcw	 WORD PTR tv611[ebp]
  00296	d9 84 07 d8 00
	00 00		 fld	 DWORD PTR [edi+eax+216]
  0029d	0f b7 8c 07 2c
	01 00 00	 movzx	 ecx, WORD PTR [edi+eax+300]
  002a5	0f b7 45 fe	 movzx	 eax, WORD PTR tv611[ebp]
  002a9	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002ae	89 45 f0	 mov	 DWORD PTR tv608[ebp], eax
  002b1	51		 push	 ecx
  002b2	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  002b5	d9 6d f0	 fldcw	 WORD PTR tv608[ebp]
  002b8	6a 01		 push	 1
  002ba	68 fd 00 00 00	 push	 253			; 000000fdH
  002bf	db 5d f0	 fistp	 DWORD PTR tv606[ebp]
  002c2	66 8b 55 f0	 mov	 dx, WORD PTR tv606[ebp]
  002c6	0f b7 c2	 movzx	 eax, dx
  002c9	50		 push	 eax
  002ca	d9 6d fe	 fldcw	 WORD PTR tv611[ebp]
  002cd	51		 push	 ecx
  002ce	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 6998 : 		LogAdd("error-L2 : CopyItem [%s][%s] return %s %d", gObj[aIndex].AccountID, gObj[aIndex].Name, __FILE__, __LINE__);

  002d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d8	68 56 1b 00 00	 push	 6998			; 00001b56H
  002dd	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  002e2	8d 54 07 5d	 lea	 edx, DWORD PTR [edi+eax+93]
  002e6	52		 push	 edx
  002e7	8d 44 07 52	 lea	 eax, DWORD PTR [edi+eax+82]
  002eb	50		 push	 eax
  002ec	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  002f1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002f7	83 c4 28	 add	 esp, 40			; 00000028H
  002fa	5f		 pop	 edi
  002fb	5e		 pop	 esi
  002fc	5b		 pop	 ebx

; 7039 : }

  002fd	8b e5		 mov	 esp, ebp
  002ff	5d		 pop	 ebp
  00300	c3		 ret	 0
$LN7@CGPShopReq@2:

; 6999 : 
; 7000 : 		return;
; 7001 : 	}
; 7002 : 
; 7003 : 	if ( iItemPrice < 0 || aBlessCnt < 0 || aSoulCnt < 0 || aChaosCnt < 0 )

  00301	8b 4d fc	 mov	 ecx, DWORD PTR _iItemPrice$[ebp]
  00304	85 c9		 test	 ecx, ecx
  00306	0f 88 47 01 00
	00		 js	 $LN5@CGPShopReq@2
  0030c	66 83 7d f8 00	 cmp	 WORD PTR _aBlessCnt$[ebp], 0
  00311	0f 8c 3c 01 00
	00		 jl	 $LN5@CGPShopReq@2
  00317	66 83 7d f4 00	 cmp	 WORD PTR _aSoulCnt$[ebp], 0
  0031c	0f 8c 31 01 00
	00		 jl	 $LN5@CGPShopReq@2
  00322	66 83 7d f0 00	 cmp	 WORD PTR _aChaosCnt$[ebp], 0
  00327	0f 8c 26 01 00
	00		 jl	 $LN5@CGPShopReq@2

; 7008 : 		return;
; 7009 : 	}
; 7010 : 
; 7011 : 	if ( (gObj[aIndex].Penalty&4) == 4 || (gObj[aIndex].Penalty&8) == 8 )

  0032d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00333	f6 84 0f c0 01
	00 00 0c	 test	 BYTE PTR [edi+ecx+448], 12 ; 0000000cH
  0033b	0f 85 df 00 00
	00		 jne	 $LN3@CGPShopReq@2

; 7015 : 
; 7016 : 		return;
; 7017 : 	}
; 7018 : 
; 7019 : 	if ( sitem->m_Type < 0 || sitem->m_Type >= ITEMGET(16,0))

  00341	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  00345	66 85 c0	 test	 ax, ax
  00348	0f 88 b3 00 00
	00		 js	 $LN1@CGPShopReq@2
  0034e	ba 00 20 00 00	 mov	 edx, 8192		; 00002000H
  00353	66 3b c2	 cmp	 ax, dx
  00356	0f 8d a5 00 00
	00		 jge	 $LN1@CGPShopReq@2

; 7022 : 		return;
; 7023 : 	}
; 7024 : 
; 7025 : 	sitem->m_iPShopValue = iItemPrice;
; 7026 : 	sitem->m_PShopBlessValue = aBlessCnt;

  0035c	0f b7 55 f8	 movzx	 edx, WORD PTR _aBlessCnt$[ebp]
  00360	8b 4d fc	 mov	 ecx, DWORD PTR _iItemPrice$[ebp]

; 7027 : 	sitem->m_PShopSoulValue = aSoulCnt;
; 7028 : 	sitem->m_PShopChaosValue = aChaosCnt;
; 7029 : 
; 7030 : 	ItemAttribute[sitem->m_Type].Name[31] = 0;	// Zero String Terminated

  00363	98		 cwde
  00364	66 89 96 80 00
	00 00		 mov	 WORD PTR [esi+128], dx
  0036b	6b c0 70	 imul	 eax, 112		; 00000070H
  0036e	0f b7 55 f0	 movzx	 edx, WORD PTR _aChaosCnt$[ebp]
  00372	66 89 96 84 00
	00 00		 mov	 WORD PTR [esi+132], dx

; 7031 : 
; 7032 : 	LogAddTD("[PShop] [%s][%s] Changing Item Price : %d (B: %d, S: %d, C: %d) (Type:%d (%s), Lev:%d, Serial:%d, Dur:%d",
; 7033 : 		gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->m_iPShopValue,
; 7034 : 		sitem->m_PShopBlessValue,sitem->m_PShopSoulValue,sitem->m_PShopChaosValue,sitem->m_Type, 
; 7035 : 		ItemAttribute[sitem->m_Type].Name, sitem->m_Level, sitem->m_Number,
; 7036 : 		sitem->m_Durability);

  00379	83 ec 08	 sub	 esp, 8
  0037c	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
  0037f	66 8b 4d f4	 mov	 cx, WORD PTR _aSoulCnt$[ebp]
  00383	66 89 8e 82 00
	00 00		 mov	 WORD PTR [esi+130], cx
  0038a	c6 80 1f 00 00
	00 00		 mov	 BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+31], 0
  00391	8b 16		 mov	 edx, DWORD PTR [esi]
  00393	d9 46 24	 fld	 DWORD PTR [esi+36]
  00396	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  0039a	dd 1c 24	 fstp	 QWORD PTR [esp]
  0039d	52		 push	 edx
  0039e	0f bf 56 08	 movsx	 edx, WORD PTR [esi+8]
  003a2	52		 push	 edx
  003a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a9	8b d0		 mov	 edx, eax
  003ab	6b d2 70	 imul	 edx, 112		; 00000070H
  003ae	81 c2 00 00 00
	00		 add	 edx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  003b4	52		 push	 edx
  003b5	0f bf 96 82 00
	00 00		 movsx	 edx, WORD PTR [esi+130]
  003bc	50		 push	 eax
  003bd	0f bf 86 84 00
	00 00		 movsx	 eax, WORD PTR [esi+132]
  003c4	50		 push	 eax
  003c5	0f bf 86 80 00
	00 00		 movsx	 eax, WORD PTR [esi+128]
  003cc	52		 push	 edx
  003cd	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  003d0	50		 push	 eax
  003d1	52		 push	 edx
  003d2	8d 44 0f 5d	 lea	 eax, DWORD PTR [edi+ecx+93]
  003d6	50		 push	 eax
  003d7	8d 4c 0f 52	 lea	 ecx, DWORD PTR [edi+ecx+82]
  003db	51		 push	 ecx
  003dc	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@
  003e1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7037 : 
; 7038 : 	CGPShopAnsSetItemPrice(aIndex, 1, lpMsg->btItemPos);

  003e7	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  003eb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003ee	52		 push	 edx
  003ef	6a 01		 push	 1
  003f1	50		 push	 eax
  003f2	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  003f7	83 c4 40	 add	 esp, 64			; 00000040H
  003fa	5f		 pop	 edi
  003fb	5e		 pop	 esi
  003fc	5b		 pop	 ebx

; 7039 : }

  003fd	8b e5		 mov	 esp, ebp
  003ff	5d		 pop	 ebp
  00400	c3		 ret	 0
$LN1@CGPShopReq@2:

; 7020 : 	{
; 7021 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Outof Bound",gObj[aIndex].AccountID,gObj[aIndex].Name);

  00401	8d 54 0f 5d	 lea	 edx, DWORD PTR [edi+ecx+93]
  00405	52		 push	 edx
  00406	8d 44 0f 52	 lea	 eax, DWORD PTR [edi+ecx+82]
  0040a	50		 push	 eax
  0040b	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@ODKADHDC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Ou@
  00410	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00416	83 c4 0c	 add	 esp, 12			; 0000000cH
  00419	5f		 pop	 edi
  0041a	5e		 pop	 esi
  0041b	5b		 pop	 ebx

; 7039 : }

  0041c	8b e5		 mov	 esp, ebp
  0041e	5d		 pop	 ebp
  0041f	c3		 ret	 0
$LN3@CGPShopReq@2:

; 7012 : 	{
; 7013 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Price Change - Item Block",gObj[aIndex].AccountID, gObj[aIndex].Name,sitem->m_iPShopValue);	// Deathway fix Here - Last parameter can cause crash

  00420	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  00423	52		 push	 edx
  00424	8d 44 0f 5d	 lea	 eax, DWORD PTR [edi+ecx+93]
  00428	50		 push	 eax
  00429	8d 4c 0f 52	 lea	 ecx, DWORD PTR [edi+ecx+82]
  0042d	51		 push	 ecx
  0042e	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@
  00433	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7014 : 		CGPShopAnsSetItemPrice(aIndex, 6	, lpMsg->btItemPos);

  00439	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  0043d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00440	52		 push	 edx
  00441	6a 06		 push	 6
  00443	50		 push	 eax
  00444	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00449	83 c4 1c	 add	 esp, 28			; 0000001cH
  0044c	5f		 pop	 edi
  0044d	5e		 pop	 esi
  0044e	5b		 pop	 ebx

; 7039 : }

  0044f	8b e5		 mov	 esp, ebp
  00451	5d		 pop	 ebp
  00452	c3		 ret	 0
$LN5@CGPShopReq@2:

; 7004 : 	{
; 7005 : 		LogAddTD("[PShop] [%s][%s] ERROR : Personal Shop Item Price <= 0 : %d ",
; 7006 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, iItemPrice);

  00453	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00458	51		 push	 ecx
  00459	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  0045d	51		 push	 ecx
  0045e	8d 54 07 52	 lea	 edx, DWORD PTR [edi+eax+82]
  00462	52		 push	 edx
  00463	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@
  00468	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7007 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  0046e	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00472	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00475	50		 push	 eax
  00476	6a 04		 push	 4
  00478	51		 push	 ecx
  00479	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  0047e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00481	5f		 pop	 edi
  00482	5e		 pop	 esi
  00483	5b		 pop	 ebx

; 7039 : }

  00484	8b e5		 mov	 esp, ebp
  00486	5d		 pop	 ebp
  00487	c3		 ret	 0
?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ENDP ; CGPShopReqSetItemPrice
_TEXT	ENDS
PUBLIC	??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@ ; `string'
PUBLIC	??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@ ; `string'
PUBLIC	??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@ ; `string'
PUBLIC	??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@ ; `string'
PUBLIC	??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@ ; `string'
PUBLIC	??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@ ; `string'
PUBLIC	??_C@_0CD@LDAHIIFG@You?5cannot?5open?5a?5shop?5in?5this?5m@ ; `string'
PUBLIC	??_C@_0CC@IFDFOFJ@attempting?5to?5open?5shop?$CB?0?5map?3?5?$CF@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z	; CGPShopReqOpen
EXTRN	?CanOpenShopAtMap@PersonalShopMapping@@QAE_NE@Z:PROC ; PersonalShopMapping::CanOpenShopAtMap
EXTRN	?pShop@@3VPersonalShopMapping@@A:BYTE		; pShop
;	COMDAT ??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.h
CONST	SEGMENT
??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@ DB '['
	DB	'PShop] [%s][%s] ERROR : Cant''t Open Shop - Item Block', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@
CONST	SEGMENT
??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@ DB '['
	DB	'PShop] [%s][%s] ERROR : Unknown m_IfState.type : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@
CONST	SEGMENT
??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@ DB '['
	DB	'PShop] [%s][%s] Personal Shop Already Opened - Changing PShop'
	DB	' Name', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@
CONST	SEGMENT
??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@ DB '['
	DB	'PShop] [%s][%s] Personal Shop Opened', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@
CONST	SEGMENT
??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@ DB '['
	DB	'PShop] [%s][%s] ERROR : Transaction == 1, IF_TYPE : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@
CONST	SEGMENT
??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@ DB '['
	DB	'PShop] [%s][%s] ERROR : m_IfState.type is Using : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LDAHIIFG@You?5cannot?5open?5a?5shop?5in?5this?5m@
CONST	SEGMENT
??_C@_0CD@LDAHIIFG@You?5cannot?5open?5a?5shop?5in?5this?5m@ DB 'You canno'
	DB	't open a shop in this map', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IFDFOFJ@attempting?5to?5open?5shop?$CB?0?5map?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@IFDFOFJ@attempting?5to?5open?5shop?$CB?0?5map?3?5?$CF@ DB 'atte'
	DB	'mpting to open shop!, map: %d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z
_TEXT	SEGMENT
tv470 = -68						; size = 4
_aIndex$GSCopy$ = -64					; size = 4
_bEnablePShopOpen$ = -57				; size = 1
_pMsg$219799 = -56					; size = 52
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z PROC	; CGPShopReqOpen, COMDAT

; 7078 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 7079 : 	if ( ::gDoPShopOpen == FALSE )

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  00017	53		 push	 ebx
  00018	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 7118 : 	{
; 7119 : 		LogAddTD("[PShop] [%s][%s] ERROR : Cant't Open Shop - Item Block" ,gObj[aIndex].AccountID, gObj[aIndex].Name);

  0001f	89 5d c0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00022	0f 84 9e 03 00
	00		 je	 $LN24@CGPShopReq@3

; 7080 : 		return;
; 7081 : 
; 7082 : 	if ( !gObjIsConnected(aIndex))

  00028	53		 push	 ebx
  00029	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	75 1f		 jne	 SHORT $LN22@CGPShopReq@3

; 7083 : 	{
; 7084 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d",aIndex);

  00035	53		 push	 ebx
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00041	83 c4 08	 add	 esp, 8
  00044	5f		 pop	 edi
  00045	5b		 pop	 ebx

; 7250 : }

  00046	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN22@CGPShopReq@3:

; 7085 : 		return;
; 7086 : 	}
; 7087 : 
; 7088 : 	if ( gObj[aIndex].Type != OBJ_USER )

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00059	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  0005f	80 7c 03 50 01	 cmp	 BYTE PTR [ebx+eax+80], 1
  00064	74 22		 je	 SHORT $LN21@CGPShopReq@3

; 7089 : 	{
; 7090 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  00066	8b 45 c0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00069	50		 push	 eax
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00075	83 c4 08	 add	 esp, 8
  00078	5f		 pop	 edi
  00079	5b		 pop	 ebx

; 7250 : }

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007d	33 cd		 xor	 ecx, ebp
  0007f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN21@CGPShopReq@3:

; 7091 : 		return;
; 7092 : 	}
; 7093 : 
; 7094 : 	LogAddC(2, "attempting to open shop!, map: %d", gObj[aIndex].MapNumber);

  00088	0f b6 8c 03 23
	01 00 00	 movzx	 ecx, BYTE PTR [ebx+eax+291]
  00090	56		 push	 esi
  00091	51		 push	 ecx
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@IFDFOFJ@attempting?5to?5open?5shop?$CB?0?5map?3?5?$CF@
  00097	6a 02		 push	 2
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 7095 : 	
; 7096 : #if (ENABLETEST_NEWPVP == 1)
; 7097 : 	if (g_NewPVP.IsDuel(gObj[aIndex])) {

  0009f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a5	8b 84 13 50 12
	00 00		 mov	 eax, DWORD PTR [ebx+edx+4688]
  000ac	8d 34 13	 lea	 esi, DWORD PTR [ebx+edx]
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b2	85 c0		 test	 eax, eax
  000b4	78 1d		 js	 SHORT $LN20@CGPShopReq@3
  000b6	33 c9		 xor	 ecx, ecx
  000b8	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  000bd	0f 9e c1	 setle	 cl
  000c0	8b c1		 mov	 eax, ecx
  000c2	85 c0		 test	 eax, eax
  000c4	74 0d		 je	 SHORT $LN20@CGPShopReq@3

; 7098 : 		 GCServerMsgStringSend(lMsg.Get(3429), aIndex, 1);

  000c6	8b 55 c0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  000c9	6a 01		 push	 1
  000cb	52		 push	 edx
  000cc	68 65 0d 00 00	 push	 3429			; 00000d65H

; 7099 : 		 return;

  000d1	eb 1a		 jmp	 SHORT $LN33@CGPShopReq@3
$LN20@CGPShopReq@3:

; 7100 : 	}
; 7101 : 
; 7102 : 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  000d3	56		 push	 esi
  000d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000d9	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  000de	85 c0		 test	 eax, eax
  000e0	74 2f		 je	 SHORT $LN19@CGPShopReq@3

; 7103 : 		 GCServerMsgStringSend(lMsg.Get(3430), aIndex, 1);

  000e2	8b 45 c0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  000e5	6a 01		 push	 1
  000e7	50		 push	 eax
  000e8	68 66 0d 00 00	 push	 3430			; 00000d66H
$LN33@CGPShopReq@3:
  000ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000f2	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00100	5e		 pop	 esi
  00101	5f		 pop	 edi
  00102	5b		 pop	 ebx

; 7250 : }

  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
$LN19@CGPShopReq@3:

; 7104 : 		 return;
; 7105 : 	}
; 7106 : #endif
; 7107 : 
; 7108 : 	if ( gObj[aIndex].Level <= 5 )

  00111	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00116	0f b7 8c 03 96
	00 00 00	 movzx	 ecx, WORD PTR [ebx+eax+150]
  0011e	66 83 f9 05	 cmp	 cx, 5
  00122	7f 38		 jg	 SHORT $LN18@CGPShopReq@3

; 7109 : 	{
; 7110 : 		LogAddTD("[PShop] [%s][%s] ERROR : Level is Under 6 : %d",
; 7111 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Level);

  00124	0f bf c9	 movsx	 ecx, cx
  00127	51		 push	 ecx
  00128	8d 54 03 5d	 lea	 edx, DWORD PTR [ebx+eax+93]
  0012c	52		 push	 edx
  0012d	8d 44 03 52	 lea	 eax, DWORD PTR [ebx+eax+82]
  00131	50		 push	 eax
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7112 : 		::CGPShopAnsOpen( aIndex, 2);

  0013d	8b 4d c0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00140	6a 02		 push	 2
  00142	51		 push	 ecx
  00143	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  00148	83 c4 18	 add	 esp, 24			; 00000018H
  0014b	5e		 pop	 esi
  0014c	5f		 pop	 edi
  0014d	5b		 pop	 ebx

; 7250 : }

  0014e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00151	33 cd		 xor	 ecx, ebp
  00153	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c3		 ret	 0
$LN18@CGPShopReq@3:

; 7113 : 
; 7114 : 		return;
; 7115 : 	}
; 7116 : 
; 7117 : 	if ( (gObj[aIndex].Penalty&4) == 4 || (gObj[aIndex].Penalty&8) == 8 )

  0015c	f6 84 03 c0 01
	00 00 0c	 test	 BYTE PTR [ebx+eax+448], 12 ; 0000000cH
  00164	0f 85 38 02 00
	00		 jne	 $LN16@CGPShopReq@3

; 7121 : 
; 7122 : 		return;
; 7123 : 	}	
; 7124 : 
; 7125 : 	if(!pShop.CanOpenShopAtMap(gObj[aIndex].MapNumber))

  0016a	0f b6 94 03 23
	01 00 00	 movzx	 edx, BYTE PTR [ebx+eax+291]
  00172	52		 push	 edx
  00173	b9 00 00 00 00	 mov	 ecx, OFFSET ?pShop@@3VPersonalShopMapping@@A ; pShop
  00178	e8 00 00 00 00	 call	 ?CanOpenShopAtMap@PersonalShopMapping@@QAE_NE@Z ; PersonalShopMapping::CanOpenShopAtMap
  0017d	84 c0		 test	 al, al
  0017f	75 18		 jne	 SHORT $LN15@CGPShopReq@3

; 7126 : 	{
; 7127 : 		::GCServerMsgStringSend("You cannot open a shop in this map", aIndex, 1);

  00181	8b 75 c0	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00184	6a 01		 push	 1
  00186	56		 push	 esi
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LDAHIIFG@You?5cannot?5open?5a?5shop?5in?5this?5m@
  0018c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 7128 : 		::CGPShopAnsOpen(aIndex, 0);

  00191	6a 00		 push	 0
  00193	56		 push	 esi

; 7129 : 		return;

  00194	e9 24 02 00 00	 jmp	 $LN32@CGPShopReq@3
$LN15@CGPShopReq@3:

; 7130 : 	}
; 7131 : 
; 7132 : 
; 7133 : 	/*
; 7134 : 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )
; 7135 : 	{
; 7136 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 197)), aIndex, 1);
; 7137 : 		::CGPShopAnsOpen( aIndex, 0);
; 7138 : 
; 7139 : 		return;
; 7140 : 	}
; 7141 : 
; 7142 : 	if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) )
; 7143 : 	{
; 7144 : 		::GCServerMsgStringSend("You cannot open your Personal Shop within Illusion Temple.", aIndex, 1);
; 7145 : 		::CGPShopAnsOpen( aIndex, 0);
; 7146 : 		return;
; 7147 : 	}
; 7148 : 
; 7149 : 	if ( DG_MAP_RANGE(gObj[aIndex].MapNumber) )
; 7150 : 	{
; 7151 : 		::GCServerMsgStringSend("You cannot open your Personal Shop within Doppelganger.", aIndex, 1);
; 7152 : 		::CGPShopAnsOpen( aIndex, 0);
; 7153 : 		return;
; 7154 : 	}
; 7155 : 
; 7156 : 	if ( IF_MAP_RANGE(gObj[aIndex].MapNumber) )
; 7157 : 	{
; 7158 : 		::GCServerMsgStringSend("You cannot open your Personal Shop within Imperial Fort.", aIndex, 1);
; 7159 : 		::CGPShopAnsOpen( aIndex, 0);
; 7160 : 		return;
; 7161 : 	} */
; 7162 : 
; 7163 : #if (__NOVUS__ == 1)
; 7164 : 	if ( gObj[aIndex].MapNumber != MAP_INDEX_LOREN_MARKET )
; 7165 : 	{
; 7166 : 		::GCServerMsgStringSend("You can open your Personal Shop only in Market!", aIndex, 1);
; 7167 : 		::CGPShopAnsOpen( aIndex, 0);
; 7168 : 		return;
; 7169 : 	}
; 7170 : #endif
; 7171 : 
; 7172 : 	bool bEnablePShopOpen = false;
; 7173 : 
; 7174 : 	if ( gObj[aIndex].m_IfState.use == FALSE )

  00199	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0019f	8b 84 0b b8 11
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+4536]
  001a6	8b d0		 mov	 edx, eax
  001a8	83 e2 03	 and	 edx, 3
  001ab	c6 45 c7 00	 mov	 BYTE PTR _bEnablePShopOpen$[ebp], 0
  001af	75 06		 jne	 SHORT $LN14@CGPShopReq@3

; 7175 : 		bEnablePShopOpen  = true;

  001b1	c6 45 c7 01	 mov	 BYTE PTR _bEnablePShopOpen$[ebp], 1

; 7176 : 	else

  001b5	eb 34		 jmp	 SHORT $LN8@CGPShopReq@3
$LN14@CGPShopReq@3:

; 7177 : 	{
; 7178 : 		if ( gObj[aIndex].m_IfState.use == TRUE )
; 7179 : 		{
; 7180 : 			switch ( gObj[aIndex].m_IfState.type )

  001b7	c1 e8 06	 shr	 eax, 6
  001ba	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  001bf	83 fa 01	 cmp	 edx, 1
  001c2	0f 85 b0 01 00
	00		 jne	 $LN12@CGPShopReq@3
  001c8	83 f8 08	 cmp	 eax, 8
  001cb	75 05		 jne	 SHORT $LN30@CGPShopReq@3

; 7181 : 			{
; 7182 : 				case 8:
; 7183 : 					bEnablePShopOpen = true; 

  001cd	88 55 c7	 mov	 BYTE PTR _bEnablePShopOpen$[ebp], dl

; 7184 : 					break;
; 7185 : 			}
; 7186 : 
; 7187 : 			if ( !bEnablePShopOpen  )

  001d0	eb 19		 jmp	 SHORT $LN8@CGPShopReq@3
$LN30@CGPShopReq@3:

; 7188 : 			{
; 7189 : 				LogAddTD("[PShop] [%s][%s] ERROR : m_IfState.type is Using : %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  001d2	50		 push	 eax
  001d3	8d 44 0b 5d	 lea	 eax, DWORD PTR [ebx+ecx+93]
  001d7	50		 push	 eax
  001d8	8d 4c 0b 52	 lea	 ecx, DWORD PTR [ebx+ecx+82]
  001dc	51		 push	 ecx
  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001e8	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@CGPShopReq@3:

; 7195 : 			return;
; 7196 : 		}
; 7197 : 	}
; 7198 : 
; 7199 : 	if ( !::gObjFixInventoryPointer(aIndex))

  001eb	8b 55 c0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  001ee	52		 push	 edx
  001ef	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  001f4	83 c4 04	 add	 esp, 4
  001f7	84 c0		 test	 al, al
  001f9	75 18		 jne	 SHORT $LN6@CGPShopReq@3

; 7200 : 	{
; 7201 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__ ,__LINE__);

  001fb	68 21 1c 00 00	 push	 7201			; 00001c21H
  00200	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00205	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  0020a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00210	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@CGPShopReq@3:

; 7202 : 	}
; 7203 : 
; 7204 : 	if ( gObj[aIndex].pTransaction == 1 )

  00213	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00218	80 bc 03 cc 11
	00 00 01	 cmp	 BYTE PTR [ebx+eax+4556], 1
  00220	75 48		 jne	 SHORT $LN5@CGPShopReq@3

; 7205 : 	{
; 7206 : 		LogAddTD("[PShop] [%s][%s] ERROR : Transaction == 1, IF_TYPE : %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  00222	8b 8c 03 b8 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4536]
  00229	c1 e9 06	 shr	 ecx, 6
  0022c	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00232	51		 push	 ecx
  00233	8d 54 03 5d	 lea	 edx, DWORD PTR [ebx+eax+93]
  00237	52		 push	 edx
  00238	8d 44 03 52	 lea	 eax, DWORD PTR [ebx+eax+82]
  0023c	50		 push	 eax
  0023d	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@
  00242	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00248	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@CGPShopReq@3:

; 7241 : 		}
; 7242 : 	}
; 7243 : 	else
; 7244 : 	{
; 7245 : 		CGPShopAnsOpen(aIndex, 0);

  0024b	8b 55 c0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0024e	6a 00		 push	 0
  00250	52		 push	 edx
  00251	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  00256	83 c4 08	 add	 esp, 8
  00259	5e		 pop	 esi
  0025a	5f		 pop	 edi
  0025b	5b		 pop	 ebx

; 7250 : }

  0025c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025f	33 cd		 xor	 ecx, ebp
  00261	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00266	8b e5		 mov	 esp, ebp
  00268	5d		 pop	 ebp
  00269	c3		 ret	 0
$LN5@CGPShopReq@3:

; 7207 : 		bEnablePShopOpen = false;
; 7208 : 	}
; 7209 : 
; 7210 : 	if ( bEnablePShopOpen )

  0026a	80 7d c7 00	 cmp	 BYTE PTR _bEnablePShopOpen$[ebp], 0
  0026e	74 db		 je	 SHORT $LN4@CGPShopReq@3

; 7211 : 	{
; 7212 : 		if ( gObj[aIndex].m_bPShopOpen == false )

  00270	80 bc 03 5c 12
	00 00 00	 cmp	 BYTE PTR [ebx+eax+4700], 0
  00278	8d 8c 03 5c 12
	00 00		 lea	 ecx, DWORD PTR [ebx+eax+4700]

; 7213 : 		{
; 7214 : 			gObj[aIndex].m_bPShopOpen = true;
; 7215 : 			memcpy(gObj[aIndex].m_szPShopText, lpMsg->szPShopText, sizeof(lpMsg->szPShopText));

  0027f	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00282	75 53		 jne	 SHORT $LN3@CGPShopReq@3
  00284	c6 01 01	 mov	 BYTE PTR [ecx], 1
  00287	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0028d	8d bc 0b 60 12
	00 00		 lea	 edi, DWORD PTR [ebx+ecx+4704]
  00294	b9 09 00 00 00	 mov	 ecx, 9
  00299	f3 a5		 rep movsd

; 7216 : 			LogAddTD("[PShop] [%s][%s] Personal Shop Opened", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0029b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a0	8d 54 03 5d	 lea	 edx, DWORD PTR [ebx+eax+93]
  002a4	52		 push	 edx
  002a5	8d 44 03 52	 lea	 eax, DWORD PTR [ebx+eax+82]
  002a9	50		 push	 eax
  002aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@
  002af	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7246 : 		return;
; 7247 : 	}
; 7248 : 	
; 7249 : 	CGPShopAnsOpen(aIndex, 1);

  002b5	8b 4d c0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  002b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002bb	6a 01		 push	 1
  002bd	51		 push	 ecx
  002be	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  002c3	83 c4 08	 add	 esp, 8
  002c6	5e		 pop	 esi
  002c7	5f		 pop	 edi
  002c8	5b		 pop	 ebx

; 7250 : }

  002c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002cc	33 cd		 xor	 ecx, ebp
  002ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d3	8b e5		 mov	 esp, ebp
  002d5	5d		 pop	 ebp
  002d6	c3		 ret	 0
$LN3@CGPShopReq@3:

; 7217 : #if( __NOVUS__ == 1 )
; 7218 : 			char Text[256];
; 7219 : 			ZeroMemory(Text, sizeof(Text));
; 7220 : 			sprintf(Text, "'%s' open new shop (%s)!", gObj[aIndex].Name, gObj[aIndex].m_szPShopText);
; 7221 : 			AllSendServerMsg(Text);
; 7222 : #endif
; 7223 : 		}
; 7224 : 
; 7225 : 		else
; 7226 : 		{
; 7227 : 			memcpy(gObj[aIndex].m_szPShopText, lpMsg->szPShopText, sizeof(lpMsg->szPShopText));
; 7228 : 			
; 7229 : 			PMSG_ANS_PSHOP_TEXT_CHANGED pMsg;
; 7230 : 
; 7231 : 			PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x10, sizeof(pMsg));

  002d7	6a 34		 push	 52			; 00000034H
  002d9	8d bc 03 60 12
	00 00		 lea	 edi, DWORD PTR [ebx+eax+4704]
  002e0	b9 09 00 00 00	 mov	 ecx, 9
  002e5	6a 10		 push	 16			; 00000010H
  002e7	89 75 bc	 mov	 DWORD PTR tv470[ebp], esi
  002ea	f3 a5		 rep movsd
  002ec	8d 4d c8	 lea	 ecx, DWORD PTR _pMsg$219799[ebp]
  002ef	6a 3f		 push	 63			; 0000003fH
  002f1	51		 push	 ecx
  002f2	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 7232 : 			pMsg.NumberH = SET_NUMBERH(aIndex);

  002f7	8b 45 c0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]

; 7233 : 			pMsg.NumberL = SET_NUMBERL(aIndex);
; 7234 : 			memcpy(pMsg.btPShopText, lpMsg->szPShopText, sizeof(pMsg.btPShopText));

  002fa	8b 75 bc	 mov	 esi, DWORD PTR tv470[ebp]
  002fd	88 45 cd	 mov	 BYTE PTR _pMsg$219799[ebp+5], al
  00300	8b d0		 mov	 edx, eax

; 7235 : 			memcpy(pMsg.btName, gObj[aIndex].Name, sizeof(pMsg.btName));

  00302	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00307	c1 ea 08	 shr	 edx, 8
  0030a	88 55 cc	 mov	 BYTE PTR _pMsg$219799[ebp+4], dl
  0030d	03 c3		 add	 eax, ebx
  0030f	b9 09 00 00 00	 mov	 ecx, 9
  00314	8d 7d ce	 lea	 edi, DWORD PTR _pMsg$219799[ebp+6]
  00317	f3 a5		 rep movsd
  00319	8b 48 5d	 mov	 ecx, DWORD PTR [eax+93]
  0031c	89 4d f2	 mov	 DWORD PTR _pMsg$219799[ebp+42], ecx
  0031f	8b 50 61	 mov	 edx, DWORD PTR [eax+97]
  00322	89 55 f6	 mov	 DWORD PTR _pMsg$219799[ebp+46], edx
  00325	66 8b 48 65	 mov	 cx, WORD PTR [eax+101]

; 7236 : 
; 7237 : 			MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  00329	0f b6 55 c9	 movzx	 edx, BYTE PTR _pMsg$219799[ebp+1]
  0032d	66 89 4d fa	 mov	 WORD PTR _pMsg$219799[ebp+50], cx
  00331	52		 push	 edx
  00332	8d 4d c8	 lea	 ecx, DWORD PTR _pMsg$219799[ebp]
  00335	51		 push	 ecx
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 7238 : 
; 7239 : 			LogAddTD("[PShop] [%s][%s] Personal Shop Already Opened - Changing PShop Name",
; 7240 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00341	8d 54 03 5d	 lea	 edx, DWORD PTR [ebx+eax+93]
  00345	52		 push	 edx
  00346	8d 44 03 52	 lea	 eax, DWORD PTR [ebx+eax+82]
  0034a	50		 push	 eax
  0034b	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@
  00350	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7246 : 		return;
; 7247 : 	}
; 7248 : 	
; 7249 : 	CGPShopAnsOpen(aIndex, 1);

  00356	8b 4d c0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00359	83 c4 28	 add	 esp, 40			; 00000028H
  0035c	6a 01		 push	 1
  0035e	51		 push	 ecx
  0035f	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  00364	83 c4 08	 add	 esp, 8
  00367	5e		 pop	 esi
  00368	5f		 pop	 edi
  00369	5b		 pop	 ebx

; 7250 : }

  0036a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0036d	33 cd		 xor	 ecx, ebp
  0036f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00374	8b e5		 mov	 esp, ebp
  00376	5d		 pop	 ebp
  00377	c3		 ret	 0
$LN12@CGPShopReq@3:

; 7190 : 			}
; 7191 : 		}
; 7192 : 		else
; 7193 : 		{
; 7194 : 			LogAddTD("[PShop] [%s][%s] ERROR : Unknown m_IfState.type : %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  00378	50		 push	 eax
  00379	8d 44 0b 5d	 lea	 eax, DWORD PTR [ebx+ecx+93]
  0037d	50		 push	 eax
  0037e	8d 4c 0b 52	 lea	 ecx, DWORD PTR [ebx+ecx+82]
  00382	51		 push	 ecx
  00383	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@
  00388	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0038e	83 c4 10	 add	 esp, 16			; 00000010H
  00391	5e		 pop	 esi
  00392	5f		 pop	 edi
  00393	5b		 pop	 ebx

; 7250 : }

  00394	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00397	33 cd		 xor	 ecx, ebp
  00399	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0039e	8b e5		 mov	 esp, ebp
  003a0	5d		 pop	 ebp
  003a1	c3		 ret	 0
$LN16@CGPShopReq@3:

; 7118 : 	{
; 7119 : 		LogAddTD("[PShop] [%s][%s] ERROR : Cant't Open Shop - Item Block" ,gObj[aIndex].AccountID, gObj[aIndex].Name);

  003a2	8d 54 03 5d	 lea	 edx, DWORD PTR [ebx+eax+93]
  003a6	52		 push	 edx
  003a7	8d 44 03 52	 lea	 eax, DWORD PTR [ebx+eax+82]
  003ab	50		 push	 eax
  003ac	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@
  003b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7120 : 		::CGPShopAnsOpen( aIndex, 3);

  003b7	8b 4d c0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  003ba	6a 03		 push	 3
  003bc	51		 push	 ecx
$LN32@CGPShopReq@3:
  003bd	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  003c2	83 c4 14	 add	 esp, 20			; 00000014H
  003c5	5e		 pop	 esi
$LN24@CGPShopReq@3:

; 7250 : }

  003c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c9	5f		 pop	 edi
  003ca	33 cd		 xor	 ecx, ebp
  003cc	5b		 pop	 ebx
  003cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d2	8b e5		 mov	 esp, ebp
  003d4	5d		 pop	 ebp
  003d5	c3		 ret	 0
?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z ENDP	; CGPShopReqOpen
_TEXT	ENDS
PUBLIC	??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@ ; `string'
PUBLIC	?CGPShopReqClose@@YAXH@Z			; CGPShopReqClose
;	COMDAT ??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.h
CONST	SEGMENT
??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@ DB '['
	DB	'PShop] [%s][%s] Requested to Close PShop', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?CGPShopReqClose@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGPShopReqClose@@YAXH@Z PROC				; CGPShopReqClose, COMDAT

; 7276 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 7277 : 	if ( !gObjIsConnected(aIndex))

  00004	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 12		 jne	 SHORT $LN4@CGPShopReq@4

; 7278 : 	{
; 7279 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d", aIndex);

  00014	57		 push	 edi
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00020	83 c4 08	 add	 esp, 8
  00023	5f		 pop	 edi

; 7305 : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN4@CGPShopReq@4:

; 7280 : 		return;
; 7281 : 	}
; 7282 : 
; 7283 : 	if ( gObj[aIndex].Type != OBJ_USER )

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	56		 push	 esi
  0002c	8b f7		 mov	 esi, edi
  0002e	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00034	03 c6		 add	 eax, esi
  00036	80 78 50 01	 cmp	 BYTE PTR [eax+80], 1
  0003a	74 13		 je	 SHORT $LN3@CGPShopReq@4

; 7284 : 	{
; 7285 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  0003c	57		 push	 edi
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00048	83 c4 08	 add	 esp, 8
  0004b	5e		 pop	 esi
  0004c	5f		 pop	 edi

; 7305 : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN3@CGPShopReq@4:

; 7286 : 		return;
; 7287 : 	}
; 7288 : 
; 7289 : #if (ENABLETEST_NEWPVP == 1)
; 7290 : 	if (g_NewPVP.IsDuel(gObj[aIndex])) {

  0004f	8b 88 50 12 00
	00		 mov	 ecx, DWORD PTR [eax+4688]
  00055	85 c9		 test	 ecx, ecx
  00057	78 1b		 js	 SHORT $LN2@CGPShopReq@4
  00059	33 d2		 xor	 edx, edx
  0005b	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00061	0f 9e c2	 setle	 dl
  00064	8b ca		 mov	 ecx, edx
  00066	85 c9		 test	 ecx, ecx
  00068	74 0a		 je	 SHORT $LN2@CGPShopReq@4

; 7291 : 		 GCServerMsgStringSend(lMsg.Get(3429), aIndex, 1);

  0006a	6a 01		 push	 1
  0006c	57		 push	 edi
  0006d	68 65 0d 00 00	 push	 3429			; 00000d65H

; 7292 : 		 return;

  00072	eb 17		 jmp	 SHORT $LN12@CGPShopReq@4
$LN2@CGPShopReq@4:

; 7293 : 	}
; 7294 : 
; 7295 : 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  00074	50		 push	 eax
  00075	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0007a	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  0007f	85 c0		 test	 eax, eax
  00081	74 1f		 je	 SHORT $LN1@CGPShopReq@4

; 7296 : 		 GCServerMsgStringSend(lMsg.Get(3430), aIndex, 1);

  00083	6a 01		 push	 1
  00085	57		 push	 edi
  00086	68 66 0d 00 00	 push	 3430			; 00000d66H
$LN12@CGPShopReq@4:
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00090	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009e	5e		 pop	 esi
  0009f	5f		 pop	 edi

; 7305 : }

  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
$LN1@CGPShopReq@4:

; 7297 : 		 return;
; 7298 : 	}
; 7299 : #endif
; 7300 : 
; 7301 : 	LogAddTD("[PShop] [%s][%s] Requested to Close PShop", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a7	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  000ab	51		 push	 ecx
  000ac	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  000b0	52		 push	 edx
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7302 : 	gObj[aIndex].m_bPShopOpen = false;

  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c1	c6 84 06 5c 12
	00 00 00	 mov	 BYTE PTR [esi+eax+4700], 0

; 7303 : 	memset(gObj[aIndex].m_szPShopText, 0, sizeof(gObj[aIndex].m_szPShopText));

  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cf	33 c0		 xor	 eax, eax
  000d1	8d 8c 0e 60 12
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+4704]
  000d8	89 01		 mov	 DWORD PTR [ecx], eax
  000da	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000dd	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  000e0	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  000e3	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  000e6	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  000e9	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 7304 : 	CGPShopAnsClose(aIndex, 1);

  000ec	6a 01		 push	 1
  000ee	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  000f1	57		 push	 edi
  000f2	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  000f5	e8 00 00 00 00	 call	 ?CGPShopAnsClose@@YAXHE@Z ; CGPShopAnsClose
  000fa	83 c4 14	 add	 esp, 20			; 00000014H
  000fd	5e		 pop	 esi
  000fe	5f		 pop	 edi

; 7305 : }

  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
?CGPShopReqClose@@YAXH@Z ENDP				; CGPShopReqClose
_TEXT	ENDS
PUBLIC	??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@ ; `string'
PUBLIC	??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ; CGPShopReqBuyList
EXTRN	?SendShopElementalItem@CElementalSystem@@QAEXHH@Z:PROC ; CElementalSystem::SendShopElementalItem
;	COMDAT ??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : [%s][%s] is in It'
	DB	'em Block', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@
CONST	SEGMENT
??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@ DB '['
	DB	'PShop] [%s][%s] is Receiving PShop List From [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Requester Transac'
	DB	'tion == 1, IF_TYPE : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : [%s][%s] Did not '
	DB	'Open PShop', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Requested to Him(/Her)Self', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Clos'
	DB	'ing (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Clo'
	DB	'sing (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Seller is Not CHA'
	DB	'RACTER (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Seller did Not CO'
	DB	'NNECTED (%d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z
_TEXT	SEGMENT
tv526 = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aSourceIndex$ = 12					; size = 4
?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z PROC ; CGPShopReqBuyList, COMDAT

; 7341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 7342 : 	if ( ::gDoPShopOpen == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0000b	0f 84 26 03 00
	00		 je	 $LN14@CGPShopReq@5

; 7343 : 		return;
; 7344 : 
; 7345 : 	if ( gObjIsConnected(MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)) == FALSE)

  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00015	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00019	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  0001d	66 c1 e0 08	 shl	 ax, 8
  00021	0f b7 c8	 movzx	 ecx, ax
  00024	0b ca		 or	 ecx, edx
  00026	57		 push	 edi
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected

; 7346 : 	{
; 7347 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Seller did Not CONNECTED (%d)",
; 7348 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  0002d	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	66 c1 e2 08	 shl	 dx, 8
  00038	85 c0		 test	 eax, eax
  0003a	75 43		 jne	 SHORT $LN12@CGPShopReq@5
  0003c	8b 7d 0c	 mov	 edi, DWORD PTR _aSourceIndex$[ebp]
  0003f	8b c7		 mov	 eax, edi
  00041	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00047	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004d	0f b7 ca	 movzx	 ecx, dx
  00050	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  00054	0b ca		 or	 ecx, edx
  00056	51		 push	 ecx
  00057	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  0005a	51		 push	 ecx
  0005b	83 c0 52	 add	 eax, 82			; 00000052H
  0005e	50		 push	 eax
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7349 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 2, 0);

  0006a	6a 00		 push	 0
  0006c	6a 02		 push	 2
  0006e	6a ff		 push	 -1
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  00076	83 c4 20	 add	 esp, 32			; 00000020H
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi

; 7439 : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN12@CGPShopReq@5:

; 7350 : 		return;
; 7351 : 	}
; 7352 : 
; 7353 : 	LPOBJ lpObj = &gObj[MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)];

  0007f	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  00083	0f b7 c2	 movzx	 eax, dx
  00086	0b c1		 or	 eax, ecx
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008e	8b f8		 mov	 edi, eax
  00090	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00096	03 f9		 add	 edi, ecx

; 7354 : 
; 7355 : 	if ( lpObj->Type != OBJ_USER )

  00098	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0009c	74 36		 je	 SHORT $LN11@CGPShopReq@5

; 7356 : 	{
; 7357 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Seller is Not CHARACTER (%d)"
; 7358 : 			,gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  0009e	8b 75 0c	 mov	 esi, DWORD PTR _aSourceIndex$[ebp]
  000a1	8b d6		 mov	 edx, esi
  000a3	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  000a9	50		 push	 eax
  000aa	03 ca		 add	 ecx, edx
  000ac	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000af	50		 push	 eax
  000b0	83 c1 52	 add	 ecx, 82			; 00000052H
  000b3	51		 push	 ecx
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7359 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 2, 0);

  000bf	6a 00		 push	 0
  000c1	6a 02		 push	 2
  000c3	6a ff		 push	 -1
  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  000cb	83 c4 20	 add	 esp, 32			; 00000020H
  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi

; 7439 : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN11@CGPShopReq@5:

; 7360 : 		return;
; 7361 : 	}
; 7362 : 
; 7363 : 	if ( lpObj->CloseCount >= 0 )	

  000d4	80 7f 0c 00	 cmp	 BYTE PTR [edi+12], 0
  000d8	7c 36		 jl	 SHORT $LN10@CGPShopReq@5

; 7364 : 	{
; 7365 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Closing (%d)"
; 7366 : 			,gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL) );

  000da	8b 75 0c	 mov	 esi, DWORD PTR _aSourceIndex$[ebp]
  000dd	8b d6		 mov	 edx, esi
  000df	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  000e5	50		 push	 eax
  000e6	03 ca		 add	 ecx, edx
  000e8	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000eb	50		 push	 eax
  000ec	83 c1 52	 add	 ecx, 82			; 00000052H
  000ef	51		 push	 ecx
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7367 : 		CGPShopAnsBuyItem(aSourceIndex, -1, 0,2);

  000fb	6a 02		 push	 2
  000fd	6a 00		 push	 0
  000ff	6a ff		 push	 -1
  00101	56		 push	 esi
  00102	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00107	83 c4 20	 add	 esp, 32			; 00000020H
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi

; 7439 : }

  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
$LN10@CGPShopReq@5:
  00110	53		 push	 ebx

; 7368 : 		return;
; 7369 : 	}
; 7370 : 
; 7371 : 	if ( gObj[aSourceIndex].CloseCount >= 0 )	

  00111	8b 5d 0c	 mov	 ebx, DWORD PTR _aSourceIndex$[ebp]
  00114	8b f3		 mov	 esi, ebx
  00116	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0011c	03 ce		 add	 ecx, esi
  0011e	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00122	89 4d fc	 mov	 DWORD PTR tv526[ebp], ecx
  00125	7c 2a		 jl	 SHORT $LN9@CGPShopReq@5

; 7372 : 	{
; 7373 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Closing (%d)",
; 7374 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  00127	50		 push	 eax
  00128	8d 51 5d	 lea	 edx, DWORD PTR [ecx+93]
  0012b	52		 push	 edx
  0012c	83 c1 52	 add	 ecx, 82			; 00000052H
  0012f	51		 push	 ecx
  00130	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7375 : 		CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  0013b	6a 02		 push	 2
  0013d	6a 00		 push	 0
  0013f	6a ff		 push	 -1
  00141	53		 push	 ebx
  00142	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00147	83 c4 20	 add	 esp, 32			; 00000020H
  0014a	5b		 pop	 ebx
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi

; 7439 : }

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
$LN9@CGPShopReq@5:

; 7376 : 		return;
; 7377 : 	}
; 7378 : 
; 7379 : #if (ENABLETEST_NEWPVP == 1)
; 7380 : 	if (g_NewPVP.IsDuel(gObj[aSourceIndex])) {

  00151	51		 push	 ecx
  00152	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00157	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  0015c	85 c0		 test	 eax, eax
  0015e	74 0a		 je	 SHORT $LN8@CGPShopReq@5

; 7381 : 		 GCServerMsgStringSend(lMsg.Get(3429), aSourceIndex, 1);

  00160	6a 01		 push	 1
  00162	53		 push	 ebx
  00163	68 65 0d 00 00	 push	 3429			; 00000d65H

; 7382 : 		 return;

  00168	eb 1a		 jmp	 SHORT $LN20@CGPShopReq@5
$LN8@CGPShopReq@5:

; 7383 : 	}
; 7384 : 
; 7385 : 	if(g_NewPVP.IsObserver(gObj[aSourceIndex])) {

  0016a	8b 45 fc	 mov	 eax, DWORD PTR tv526[ebp]
  0016d	50		 push	 eax
  0016e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00173	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00178	85 c0		 test	 eax, eax
  0017a	74 22		 je	 SHORT $LN7@CGPShopReq@5

; 7386 : 		 GCServerMsgStringSend(lMsg.Get(3430), aSourceIndex, 1);

  0017c	6a 01		 push	 1
  0017e	53		 push	 ebx
  0017f	68 66 0d 00 00	 push	 3430			; 00000d66H
$LN20@CGPShopReq@5:
  00184	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00189	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH
  00197	5b		 pop	 ebx
  00198	5f		 pop	 edi
  00199	5e		 pop	 esi

; 7439 : }

  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c3		 ret	 0
$LN7@CGPShopReq@5:

; 7387 : 		 return;
; 7388 : 	}
; 7389 : #endif
; 7390 : 
; 7391 : 	if ( lpObj->m_Index == aSourceIndex )

  0019e	39 1f		 cmp	 DWORD PTR [edi], ebx
  001a0	75 30		 jne	 SHORT $LN6@CGPShopReq@5

; 7392 : 	{
; 7393 : 		LogAddTD("[PShop] [%s][%s] PShop List Requested to Him(/Her)Self",
; 7394 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name);

  001a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a7	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  001ab	51		 push	 ecx
  001ac	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  001b0	52		 push	 edx
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7395 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 2, 0);

  001bc	6a 00		 push	 0
  001be	6a 02		 push	 2
  001c0	6a ff		 push	 -1
  001c2	53		 push	 ebx
  001c3	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  001c8	83 c4 1c	 add	 esp, 28			; 0000001cH
  001cb	5b		 pop	 ebx
  001cc	5f		 pop	 edi
  001cd	5e		 pop	 esi

; 7439 : }

  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c3		 ret	 0
$LN6@CGPShopReq@5:

; 7396 : 		return;
; 7397 : 	}
; 7398 : 
; 7399 : 	if ( lpObj->m_bPShopOpen == false )

  001d2	80 bf 5c 12 00
	00 00		 cmp	 BYTE PTR [edi+4700], 0
  001d9	75 38		 jne	 SHORT $LN5@CGPShopReq@5

; 7400 : 	{
; 7401 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : [%s][%s] Did not Open PShop",
; 7402 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 7403 : 			lpObj->AccountID, lpObj->Name);

  001db	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e0	8d 4f 5d	 lea	 ecx, DWORD PTR [edi+93]
  001e3	51		 push	 ecx
  001e4	83 c7 52	 add	 edi, 82			; 00000052H
  001e7	57		 push	 edi
  001e8	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  001ec	52		 push	 edx
  001ed	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  001f1	50		 push	 eax
  001f2	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7404 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 3, 0);

  001fd	6a 00		 push	 0
  001ff	6a 03		 push	 3

; 7413 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 4, 0);

  00201	6a ff		 push	 -1
  00203	53		 push	 ebx
  00204	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  00209	83 c4 24	 add	 esp, 36			; 00000024H
  0020c	5b		 pop	 ebx
  0020d	5f		 pop	 edi
  0020e	5e		 pop	 esi

; 7439 : }

  0020f	8b e5		 mov	 esp, ebp
  00211	5d		 pop	 ebp
  00212	c3		 ret	 0
$LN5@CGPShopReq@5:

; 7405 : 		return;
; 7406 : 	}
; 7407 : 
; 7408 : 	if ( (lpObj->Penalty &4) == 4 || (lpObj->Penalty&8) == 8 )

  00213	f6 87 c0 01 00
	00 0c		 test	 BYTE PTR [edi+448], 12	; 0000000cH
  0021a	0f 85 e3 00 00
	00		 jne	 $LN3@CGPShopReq@5

; 7414 : 		return;
; 7415 : 	}
; 7416 : 
; 7417 : 	if ( !::gObjFixInventoryPointer(aSourceIndex))

  00220	53		 push	 ebx
  00221	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00226	83 c4 04	 add	 esp, 4
  00229	84 c0		 test	 al, al
  0022b	75 18		 jne	 SHORT $LN2@CGPShopReq@5

; 7418 : 	{
; 7419 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0022d	68 fb 1c 00 00	 push	 7419			; 00001cfbH
  00232	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00237	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00242	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGPShopReq@5:

; 7420 : 	}
; 7421 : 
; 7422 : 	if ( gObj[aSourceIndex].pTransaction == 1 )

  00245	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0024a	80 bc 06 cc 11
	00 00 01	 cmp	 BYTE PTR [esi+eax+4556], 1

; 7423 : 	{
; 7424 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Requester Transaction == 1, IF_TYPE : %d",
; 7425 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, gObj[aSourceIndex].m_IfState.type);

  00252	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  00256	75 2c		 jne	 SHORT $LN1@CGPShopReq@5
  00258	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  0025f	c1 e9 06	 shr	 ecx, 6
  00262	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00268	51		 push	 ecx
  00269	52		 push	 edx
  0026a	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  0026e	50		 push	 eax
  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  00274	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0027a	83 c4 10	 add	 esp, 16			; 00000010H
  0027d	5b		 pop	 ebx
  0027e	5f		 pop	 edi
  0027f	5e		 pop	 esi

; 7439 : }

  00280	8b e5		 mov	 esp, ebp
  00282	5d		 pop	 ebp
  00283	c3		 ret	 0
$LN1@CGPShopReq@5:

; 7426 : 		return;
; 7427 : 	}
; 7428 : 
; 7429 : 	LogAddTD("[PShop] [%s][%s] is Receiving PShop List From [%s][%s]",
; 7430 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 7431 : 			lpObj->AccountID, lpObj->Name);

  00284	8d 5f 5d	 lea	 ebx, DWORD PTR [edi+93]
  00287	53		 push	 ebx
  00288	8d 4f 52	 lea	 ecx, DWORD PTR [edi+82]
  0028b	51		 push	 ecx
  0028c	52		 push	 edx
  0028d	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00291	50		 push	 eax
  00292	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@
  00297	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7432 : 
; 7433 : 	gObj[aSourceIndex].m_bPShopWantDeal = true;

  0029d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a3	c6 84 0e 84 12
	00 00 01	 mov	 BYTE PTR [esi+ecx+4740], 1

; 7434 : 	gObj[aSourceIndex].m_iPShopDealerIndex = lpObj->m_Index;

  002ab	8b 17		 mov	 edx, DWORD PTR [edi]
  002ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b2	89 94 06 88 12
	00 00		 mov	 DWORD PTR [esi+eax+4744], edx

; 7435 : 	memcpy(gObj[aSourceIndex].m_szPShopDealerName, lpObj->Name, MAX_ACCOUNT_LEN);

  002b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002bf	8b 13		 mov	 edx, DWORD PTR [ebx]
  002c1	8d b4 0e 8c 12
	00 00		 lea	 esi, DWORD PTR [esi+ecx+4748]
  002c8	89 16		 mov	 DWORD PTR [esi], edx
  002ca	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  002cd	89 46 04	 mov	 DWORD PTR [esi+4], eax
  002d0	66 8b 4b 08	 mov	 cx, WORD PTR [ebx+8]
  002d4	66 89 4e 08	 mov	 WORD PTR [esi+8], cx

; 7436 : 
; 7437 : 	g_ElementalSystem.SendShopElementalItem(lpObj->m_Index,aSourceIndex);

  002d8	8b 75 0c	 mov	 esi, DWORD PTR _aSourceIndex$[ebp]
  002db	8b 17		 mov	 edx, DWORD PTR [edi]
  002dd	83 c4 14	 add	 esp, 20			; 00000014H
  002e0	56		 push	 esi
  002e1	52		 push	 edx
  002e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  002e7	e8 00 00 00 00	 call	 ?SendShopElementalItem@CElementalSystem@@QAEXHH@Z ; CElementalSystem::SendShopElementalItem

; 7438 : 	::CGPShopAnsBuyList(aSourceIndex, lpObj->m_Index, 1, false);

  002ec	8b 07		 mov	 eax, DWORD PTR [edi]
  002ee	6a 00		 push	 0
  002f0	6a 01		 push	 1
  002f2	50		 push	 eax
  002f3	56		 push	 esi
  002f4	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  002f9	83 c4 10	 add	 esp, 16			; 00000010H
  002fc	5b		 pop	 ebx
  002fd	5f		 pop	 edi
  002fe	5e		 pop	 esi

; 7439 : }

  002ff	8b e5		 mov	 esp, ebp
  00301	5d		 pop	 ebp
  00302	c3		 ret	 0
$LN3@CGPShopReq@5:

; 7409 : 	{
; 7410 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : [%s][%s] is in Item Block",
; 7411 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 7412 : 			lpObj->AccountID, lpObj->Name);

  00303	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00308	8d 4f 5d	 lea	 ecx, DWORD PTR [edi+93]
  0030b	51		 push	 ecx
  0030c	83 c7 52	 add	 edi, 82			; 00000052H
  0030f	57		 push	 edi
  00310	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  00314	52		 push	 edx
  00315	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00319	50		 push	 eax
  0031a	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  0031f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7413 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 4, 0);

  00325	6a 00		 push	 0
  00327	6a 04		 push	 4
  00329	6a ff		 push	 -1
  0032b	53		 push	 ebx
  0032c	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  00331	83 c4 24	 add	 esp, 36			; 00000024H
  00334	5b		 pop	 ebx
  00335	5f		 pop	 edi
  00336	5e		 pop	 esi
$LN14@CGPShopReq@5:

; 7439 : }

  00337	8b e5		 mov	 esp, ebp
  00339	5d		 pop	 ebp
  0033a	c3		 ret	 0
?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ENDP ; CGPShopReqBuyList
_TEXT	ENDS
PUBLIC	??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@ ; `string'
PUBLIC	??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@ ; `string'
PUBLIC	??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FC@CGGBJBAH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ ; `string'
PUBLIC	??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EG@KFEECMPB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	_aSourceIndex$GSCopy$
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ; CGPShopReqBuyItem
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?PShop_CheckInventoryEmpty@@YA_NF@Z:PROC	; PShop_CheckInventoryEmpty
EXTRN	?gObjInventoryItemSet_PShop@@YAXHHE@Z:PROC	; gObjInventoryItemSet_PShop
EXTRN	?PShopErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z:PROC ; CElementalSystem::PShopErtel
EXTRN	?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z:PROC ; gObjOnlyInventoryInsertItem
EXTRN	__except_handler4:PROC
EXTRN	__local_unwind4:PROC
;	COMDAT ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is i'
	DB	'n Item Block', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did '
	DB	'Not Choose Item Price', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@
CONST	SEGMENT
??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@ DB '['
	DB	'PShop] [%s][%s] Sold All Items - Auto Closing PShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@
CONST	SEGMENT
??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@ DB '['
	DB	'PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s]'
	DB	'[%s] (Price=%d, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, S'
	DB	'erial:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No R'
	DB	'oom to Buy Item', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Boun'
	DB	'dle Jewels - Type: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No e'
	DB	'nough Jewels - Type: %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@CGGBJBAH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FC@CGGBJBAH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No R'
	DB	'oom to Store Reward', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Exce'
	DB	'eding Zen of the Host', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack'
	DB	' of Zen', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Requester Tra'
	DB	'nsaction == 1, IF_TYPE : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
CONST	SEGMENT
??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [PShop Buy] (%s)(%s) Item(%s) Pos(%'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Alre'
	DB	'ady Trade With Other', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is C'
	DB	'losing Connection', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Name Mismatch'
	DB	' [%s] - [%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did '
	DB	'not Open PShop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@KFEECMPB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EG@KFEECMPB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Mini'
	DB	'ng (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Not'
	DB	' CHARACTER (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller did No'
	DB	't CONNECTED (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z DD 0ffffffe4H
	DD	00H
	DD	0ffffff30H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN110@CGPShopReq@6
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z
_TEXT	SEGMENT
_iITEM_LOG_DUR$ = -192					; size = 4
_iITEM_LOG_LEVEL$ = -188				; size = 4
_iITEM_LOG_SERIAL$ = -184				; size = 4
_lpObj$ = -180						; size = 4
_x$220147 = -176					; size = 4
_x$220072 = -172					; size = 4
_iEmptyCount$220070 = -168				; size = 4
_iITEM_LOG_TYPE$ = -164					; size = 4
_x$220139 = -160					; size = 4
_x$220135 = -156					; size = 4
_x$220143 = -152					; size = 4
_iFreeSpaceReq$220061 = -148				; size = 4
tv1669 = -144						; size = 4
_invSize$220050 = -144					; size = 4
tv1674 = -140						; size = 4
_JewelLevel$220115 = -140				; size = 4
_lpMsg$GSCopy$ = -136					; size = 4
_lpSourceObj$ = -132					; size = 4
tv1759 = -128						; size = 4
tv1757 = -128						; size = 4
tv1743 = -128						; size = 4
tv1741 = -128						; size = 4
tv1729 = -128						; size = 4
tv1727 = -128						; size = 4
tv1573 = -128						; size = 4
tv1506 = -128						; size = 4
_iPShopValue$220051 = -128				; size = 4
tv1762 = -124						; size = 2
tv1746 = -124						; size = 2
tv1733 = -124						; size = 2
_bBoundle$220079 = -124					; size = 3
_btNewItemPos$220105 = -122				; size = 1
tv1725 = -120						; size = 4
tv1505 = -120						; size = 4
_n$220049 = -120					; size = 4
_aSourceIndex$GSCopy$ = -116				; size = 4
_iJewelId$220130 = -112					; size = 12
_iBoundleId$220129 = -100				; size = 12
_JewelCount$220080 = -88				; size = 12
_aPShopJewel$220062 = -76				; size = 6
_aPShopJewelBoundle$220063 = -68			; size = 18
_szName$ = -48						; size = 11
_aPShopJewelValue$220052 = -36				; size = 6
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_lpMsg$ = 8						; size = 4
_aSourceIndex$ = 12					; size = 4
?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z PROC ; CGPShopReqBuyItem, COMDAT

; 7555 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	50		 push	 eax
  0002d	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 7652 : 	{
; 7653 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",
; 7654 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  00039	89 bd 78 ff ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], edi
  0003f	8b 5d 0c	 mov	 ebx, DWORD PTR _aSourceIndex$[ebp]
  00042	89 5d 8c	 mov	 DWORD PTR _aSourceIndex$GSCopy$[ebp], ebx

; 7556 : 	if ( gDoPShopOpen == FALSE )

  00045	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0004c	0f 84 f2 10 00
	00		 je	 $LN113@CGPShopReq@6

; 7557 : 		return;
; 7558 : 
; 7559 : 	LPOBJ lpSourceObj = &gObj[aSourceIndex];

  00052	8b f3		 mov	 esi, ebx
  00054	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0005a	89 75 88	 mov	 DWORD PTR tv1505[ebp], esi
  0005d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00063	89 b5 7c ff ff
	ff		 mov	 DWORD PTR _lpSourceObj$[ebp], esi

; 7560 : 
; 7561 : 	if ( gObjIsConnected( MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)) == FALSE )

  00069	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  0006d	66 c1 e1 08	 shl	 cx, 8
  00071	0f b7 d1	 movzx	 edx, cx
  00074	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00078	0b d0		 or	 edx, eax
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00080	83 c4 04	 add	 esp, 4
  00083	85 c0		 test	 eax, eax
  00085	75 39		 jne	 SHORT $LN96@CGPShopReq@6

; 7562 : 	{
; 7563 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller did Not CONNECTED (%d)",
; 7564 : 			lpSourceObj->AccountID, lpSourceObj->Name, MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  00087	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  0008b	66 c1 e1 08	 shl	 cx, 8
  0008f	0f b7 d1	 movzx	 edx, cx
  00092	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00096	0b d0		 or	 edx, eax
  00098	52		 push	 edx
  00099	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  0009c	51		 push	 ecx
  0009d	83 c6 52	 add	 esi, 82			; 00000052H
  000a0	56		 push	 esi
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7565 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  000ac	6a 02		 push	 2
  000ae	6a 00		 push	 0
  000b0	6a ff		 push	 -1
  000b2	53		 push	 ebx
  000b3	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  000b8	83 c4 20	 add	 esp, 32			; 00000020H

; 7566 : 		return;

  000bb	e9 84 10 00 00	 jmp	 $LN113@CGPShopReq@6
$LN96@CGPShopReq@6:

; 7567 : 	}
; 7568 : 
; 7569 : 	LPOBJ lpObj = &gObj[MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)];

  000c0	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  000c4	66 c1 e2 08	 shl	 dx, 8
  000c8	0f b7 c2	 movzx	 eax, dx
  000cb	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  000cf	0b c1		 or	 eax, ecx
  000d1	8b d8		 mov	 ebx, eax
  000d3	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000df	03 d9		 add	 ebx, ecx
  000e1	89 9d 4c ff ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], ebx

; 7570 : 	
; 7571 : 
; 7572 : 	if ( lpObj->Type != OBJ_USER )

  000e7	80 7b 50 01	 cmp	 BYTE PTR [ebx+80], 1
  000eb	74 2b		 je	 SHORT $LN95@CGPShopReq@6

; 7573 : 	{
; 7574 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Not CHARACTER (%d)",
; 7575 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  000ed	50		 push	 eax
  000ee	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  000f1	52		 push	 edx
  000f2	83 c6 52	 add	 esi, 82			; 00000052H
  000f5	56		 push	 esi
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7576 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  00101	6a 02		 push	 2
  00103	6a 00		 push	 0
  00105	6a ff		 push	 -1
  00107	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00110	83 c4 20	 add	 esp, 32			; 00000020H

; 7577 : 		return;

  00113	e9 2c 10 00 00	 jmp	 $LN113@CGPShopReq@6
$LN95@CGPShopReq@6:

; 7578 : 	}
; 7579 : 
; 7580 : 	if ( lpObj->CloseCount >= 0 )	

  00118	80 7b 0c 00	 cmp	 BYTE PTR [ebx+12], 0
  0011c	7c 2b		 jl	 SHORT $LN94@CGPShopReq@6

; 7581 : 	{
; 7582 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Closing (%d)",
; 7583 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)  );

  0011e	50		 push	 eax
  0011f	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  00122	51		 push	 ecx
  00123	83 c6 52	 add	 esi, 82			; 00000052H
  00126	56		 push	 esi
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7584 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0,2);

  00132	6a 02		 push	 2
  00134	6a 00		 push	 0
  00136	6a ff		 push	 -1
  00138	8b 55 8c	 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0013b	52		 push	 edx
  0013c	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00141	83 c4 20	 add	 esp, 32			; 00000020H

; 7585 : 		return;

  00144	e9 fb 0f 00 00	 jmp	 $LN113@CGPShopReq@6
$LN94@CGPShopReq@6:

; 7586 : 	}
; 7587 : 
; 7588 : 
; 7589 : 	if ( lpSourceObj->CloseCount >= 0 )	

  00149	80 7e 0c 00	 cmp	 BYTE PTR [esi+12], 0
  0014d	7c 2b		 jl	 SHORT $LN93@CGPShopReq@6

; 7590 : 	{
; 7591 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Closing (%d)",
; 7592 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  0014f	50		 push	 eax
  00150	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00153	50		 push	 eax
  00154	83 c6 52	 add	 esi, 82			; 00000052H
  00157	56		 push	 esi
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7593 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  00163	6a 02		 push	 2
$LN147@CGPShopReq@6:
  00165	6a 00		 push	 0
  00167	6a ff		 push	 -1
  00169	8b 4d 8c	 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00172	83 c4 20	 add	 esp, 32			; 00000020H

; 7594 : 		return;

  00175	e9 ca 0f 00 00	 jmp	 $LN113@CGPShopReq@6
$LN93@CGPShopReq@6:

; 7595 : 	}
; 7596 : 
; 7597 : 	if ( lpSourceObj->pInventory[0].m_Type == ITEMGET(0,41) )

  0017a	8b 96 c0 11 00
	00		 mov	 edx, DWORD PTR [esi+4544]
  00180	66 83 7a 06 29	 cmp	 WORD PTR [edx+6], 41	; 00000029H
  00185	75 18		 jne	 SHORT $LN92@CGPShopReq@6

; 7598 : 	{
; 7599 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Mining (%d)",
; 7600 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  00187	50		 push	 eax
  00188	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0018b	50		 push	 eax
  0018c	83 c6 52	 add	 esi, 82			; 00000052H
  0018f	56		 push	 esi
  00190	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KFEECMPB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7601 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 10);

  0019b	6a 0a		 push	 10			; 0000000aH

; 7602 : 		return;

  0019d	eb c6		 jmp	 SHORT $LN147@CGPShopReq@6
$LN92@CGPShopReq@6:

; 7603 : 	}
; 7604 : 
; 7605 : #if (ENABLETEST_NEWPVP == 1)
; 7606 : 	if (g_NewPVP.IsDuel(gObj[aSourceIndex])) {

  0019f	8b 45 88	 mov	 eax, DWORD PTR tv1505[ebp]
  001a2	03 c1		 add	 eax, ecx
  001a4	89 45 80	 mov	 DWORD PTR tv1506[ebp], eax
  001a7	50		 push	 eax
  001a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  001ad	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  001b2	85 c0		 test	 eax, eax
  001b4	74 23		 je	 SHORT $LN91@CGPShopReq@6

; 7607 : 		 GCServerMsgStringSend(lMsg.Get(3429), aSourceIndex, 1);

  001b6	6a 01		 push	 1
  001b8	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  001bb	50		 push	 eax
  001bc	68 65 0d 00 00	 push	 3429			; 00000d65H
$LN148@CGPShopReq@6:
  001c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001c6	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7608 : 		 return;

  001d4	e9 6b 0f 00 00	 jmp	 $LN113@CGPShopReq@6
$LN91@CGPShopReq@6:

; 7609 : 	}
; 7610 : 	
; 7611 : 	if (g_NewPVP.IsObserver(gObj[aSourceIndex])) {

  001d9	8b 4d 80	 mov	 ecx, DWORD PTR tv1506[ebp]
  001dc	51		 push	 ecx
  001dd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  001e2	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  001e7	85 c0		 test	 eax, eax
  001e9	74 0d		 je	 SHORT $LN90@CGPShopReq@6

; 7612 : 		 GCServerMsgStringSend(lMsg.Get(3430), aSourceIndex, 1);

  001eb	6a 01		 push	 1
  001ed	8b 55 8c	 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  001f0	52		 push	 edx
  001f1	68 66 0d 00 00	 push	 3430			; 00000d66H

; 7613 : 		 return;

  001f6	eb c9		 jmp	 SHORT $LN148@CGPShopReq@6
$LN90@CGPShopReq@6:

; 7614 : 	}
; 7615 : #endif
; 7616 : 
; 7617 : 	if ( lpObj->m_bPShopOpen == false )

  001f8	80 bb 5c 12 00
	00 00		 cmp	 BYTE PTR [ebx+4700], 0
  001ff	75 2b		 jne	 SHORT $LN89@CGPShopReq@6

; 7618 : 	{
; 7619 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did not Open PShop",
; 7620 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  00201	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00204	50		 push	 eax
  00205	8d 4b 52	 lea	 ecx, DWORD PTR [ebx+82]
  00208	51		 push	 ecx
  00209	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  0020c	52		 push	 edx
  0020d	83 c6 52	 add	 esi, 82			; 00000052H
  00210	56		 push	 esi
  00211	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7621 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 3);

  0021c	6a 03		 push	 3
  0021e	6a 00		 push	 0
  00220	8b 03		 mov	 eax, DWORD PTR [ebx]
  00222	50		 push	 eax
  00223	8b 4d 8c	 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00226	51		 push	 ecx

; 7622 : 		return;

  00227	e9 10 0f 00 00	 jmp	 $LN136@CGPShopReq@6
$LN89@CGPShopReq@6:

; 7623 : 	}
; 7624 : 
; 7625 : 	char szName[MAX_ACCOUNT_LEN+1] = {0};

  0022c	33 c0		 xor	 eax, eax
  0022e	89 45 d1	 mov	 DWORD PTR _szName$[ebp+1], eax
  00231	89 45 d5	 mov	 DWORD PTR _szName$[ebp+5], eax
  00234	66 89 45 d9	 mov	 WORD PTR _szName$[ebp+9], ax

; 7626 : 	memcpy(szName, lpMsg->btName, sizeof(lpMsg->btName));

  00238	8b 57 06	 mov	 edx, DWORD PTR [edi+6]
  0023b	89 55 d0	 mov	 DWORD PTR _szName$[ebp], edx
  0023e	8b 47 0a	 mov	 eax, DWORD PTR [edi+10]
  00241	89 45 d4	 mov	 DWORD PTR _szName$[ebp+4], eax
  00244	66 8b 4f 0e	 mov	 cx, WORD PTR [edi+14]
  00248	66 89 4d d8	 mov	 WORD PTR _szName$[ebp+8], cx

; 7627 : 	szName[MAX_ACCOUNT_LEN] = 0;

  0024c	c6 45 da 00	 mov	 BYTE PTR _szName$[ebp+10], 0

; 7628 : 	int iITEM_LOG_TYPE;
; 7629 : 	int iITEM_LOG_LEVEL;
; 7630 : 	int iITEM_LOG_DUR;
; 7631 : 	int iITEM_LOG_SERIAL;
; 7632 : 
; 7633 : 	if ( strcmp(szName, lpObj->Name) )

  00250	8d 4b 5d	 lea	 ecx, DWORD PTR [ebx+93]
  00253	8d 45 d0	 lea	 eax, DWORD PTR _szName$[ebp]
$LL125@CGPShopReq@6:
  00256	8a 10		 mov	 dl, BYTE PTR [eax]
  00258	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0025a	75 1a		 jne	 SHORT $LN126@CGPShopReq@6
  0025c	84 d2		 test	 dl, dl
  0025e	74 12		 je	 SHORT $LN127@CGPShopReq@6
  00260	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00263	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00266	75 0e		 jne	 SHORT $LN126@CGPShopReq@6
  00268	83 c0 02	 add	 eax, 2
  0026b	83 c1 02	 add	 ecx, 2
  0026e	84 d2		 test	 dl, dl
  00270	75 e4		 jne	 SHORT $LL125@CGPShopReq@6
$LN127@CGPShopReq@6:
  00272	33 c0		 xor	 eax, eax
  00274	eb 05		 jmp	 SHORT $LN128@CGPShopReq@6
$LN126@CGPShopReq@6:
  00276	1b c0		 sbb	 eax, eax
  00278	83 d8 ff	 sbb	 eax, -1
$LN128@CGPShopReq@6:
  0027b	85 c0		 test	 eax, eax
  0027d	74 2b		 je	 SHORT $LN88@CGPShopReq@6

; 7634 : 	{
; 7635 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Name Mismatch [%s] - [%s]",
; 7636 : 			lpSourceObj->AccountID, lpSourceObj->Name,szName, lpObj->Name);

  0027f	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00282	50		 push	 eax
  00283	8d 55 d0	 lea	 edx, DWORD PTR _szName$[ebp]
  00286	52		 push	 edx
  00287	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0028a	50		 push	 eax
  0028b	83 c6 52	 add	 esi, 82			; 00000052H
  0028e	56		 push	 esi
  0028f	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00294	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7637 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 6);

  0029a	6a 06		 push	 6
  0029c	6a 00		 push	 0
  0029e	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  002a0	51		 push	 ecx
  002a1	8b 55 8c	 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  002a4	52		 push	 edx

; 7638 : 
; 7639 : 		return;

  002a5	e9 92 0e 00 00	 jmp	 $LN136@CGPShopReq@6
$LN88@CGPShopReq@6:

; 7640 : 	}
; 7641 : 
; 7642 : 	if ( lpObj->CloseType != -1 )

  002aa	80 7b 0d ff	 cmp	 BYTE PTR [ebx+13], -1
  002ae	74 22		 je	 SHORT $LN87@CGPShopReq@6

; 7643 : 	{
; 7644 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is Closing Connection",
; 7645 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  002b0	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  002b3	50		 push	 eax
  002b4	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  002b7	50		 push	 eax
  002b8	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  002bb	51		 push	 ecx
  002bc	83 c6 52	 add	 esi, 82			; 00000052H
  002bf	56		 push	 esi
  002c0	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  002c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7646 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,2);

  002cb	6a 02		 push	 2

; 7647 : 
; 7648 : 		return;

  002cd	e9 61 0e 00 00	 jmp	 $LN137@CGPShopReq@6
$LN87@CGPShopReq@6:

; 7649 : 	}
; 7650 : 
; 7651 : 	if ( (lpObj->Penalty &4) == 4 || (lpObj->Penalty &8) == 8 )

  002d2	8b 83 c0 01 00
	00		 mov	 eax, DWORD PTR [ebx+448]
  002d8	a8 0c		 test	 al, 12			; 0000000cH
  002da	0f 85 36 0e 00
	00		 jne	 $LN85@CGPShopReq@6

; 7656 : 
; 7657 : 		return;
; 7658 : 	}
; 7659 : 
; 7660 : 	if ( (lpSourceObj->Penalty &4) == 4 || (lpSourceObj->Penalty &8) == 8 )

  002e0	f6 86 c0 01 00
	00 0c		 test	 BYTE PTR [esi+448], 12	; 0000000cH
  002e7	0f 85 01 0e 00
	00		 jne	 $LN83@CGPShopReq@6

; 7666 : 	}
; 7667 : 
; 7668 : 	EnterCriticalSection(&lpObj->m_critPShopTrade);

  002ed	8d 83 98 12 00
	00		 lea	 eax, DWORD PTR [ebx+4760]
  002f3	89 45 80	 mov	 DWORD PTR tv1573[ebp], eax
  002f6	50		 push	 eax
  002f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7669 : 
; 7670 : 	if ( lpObj->m_bPShopTransaction == true )

  002fd	80 bb 5d 12 00
	00 01		 cmp	 BYTE PTR [ebx+4701], 1
  00304	75 3d		 jne	 SHORT $LN82@CGPShopReq@6

; 7671 : 	{
; 7672 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Already Trade With Other",
; 7673 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  00306	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00309	50		 push	 eax
  0030a	8d 4b 52	 lea	 ecx, DWORD PTR [ebx+82]
  0030d	51		 push	 ecx
  0030e	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  00311	52		 push	 edx
  00312	83 c6 52	 add	 esi, 82			; 00000052H
  00315	56		 push	 esi
  00316	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0031b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7674 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,4);

  00321	6a 04		 push	 4
  00323	6a 00		 push	 0
  00325	8b 03		 mov	 eax, DWORD PTR [ebx]
  00327	50		 push	 eax
  00328	8b 4d 8c	 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0032b	51		 push	 ecx
  0032c	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00331	83 c4 24	 add	 esp, 36			; 00000024H

; 7675 : 		LeaveCriticalSection(&lpObj->m_critPShopTrade);

  00334	8b 55 80	 mov	 edx, DWORD PTR tv1573[ebp]
  00337	52		 push	 edx
  00338	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7676 : 
; 7677 : 	}
; 7678 : 	else

  0033e	e9 01 0e 00 00	 jmp	 $LN113@CGPShopReq@6
$LN82@CGPShopReq@6:

; 7679 : 	{
; 7680 : 		lpObj->m_bPShopTransaction = true;

  00343	c6 83 5d 12 00
	00 01		 mov	 BYTE PTR [ebx+4701], 1

; 7681 : 		LeaveCriticalSection(&lpObj->m_critPShopTrade);

  0034a	8b 45 80	 mov	 eax, DWORD PTR tv1573[ebp]
  0034d	50		 push	 eax
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7682 : 
; 7683 : 		if ( gObjCheckSerial0ItemList(&lpObj->Inventory1[lpMsg->btItemPos]) != FALSE )

  00354	0f b6 4f 10	 movzx	 ecx, BYTE PTR [edi+16]
  00358	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0035e	03 8b d0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4560]
  00364	51		 push	 ecx
  00365	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  0036a	83 c4 04	 add	 esp, 4
  0036d	85 c0		 test	 eax, eax
  0036f	0f 84 8b 00 00
	00		 je	 $LN80@CGPShopReq@6

; 7684 : 		{
; 7685 : 			MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(13, 26)));

  00375	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  0037a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0037f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00384	50		 push	 eax
  00385	8b 13		 mov	 edx, DWORD PTR [ebx]
  00387	52		 push	 edx
  00388	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 7686 : 			GCReFillSend(aSourceIndex,(WORD)lpSourceObj->Life, 0xFD, 1, lpSourceObj->iShield);

  0038d	0f b7 86 2c 01
	00 00		 movzx	 eax, WORD PTR [esi+300]
  00394	50		 push	 eax
  00395	6a 01		 push	 1
  00397	68 fd 00 00 00	 push	 253			; 000000fdH
  0039c	d9 86 d8 00 00
	00		 fld	 DWORD PTR [esi+216]
  003a2	d9 7d 84	 fnstcw	 WORD PTR tv1762[ebp]
  003a5	0f b7 45 84	 movzx	 eax, WORD PTR tv1762[ebp]
  003a9	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003ae	89 45 80	 mov	 DWORD PTR tv1759[ebp], eax
  003b1	d9 6d 80	 fldcw	 WORD PTR tv1759[ebp]
  003b4	db 5d 80	 fistp	 DWORD PTR tv1757[ebp]
  003b7	d9 6d 84	 fldcw	 WORD PTR tv1762[ebp]
  003ba	66 8b 4d 80	 mov	 cx, WORD PTR tv1757[ebp]
  003be	0f b7 d1	 movzx	 edx, cx
  003c1	52		 push	 edx
  003c2	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  003c5	50		 push	 eax
  003c6	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  003cb	83 c4 1c	 add	 esp, 28			; 0000001cH

; 7687 : 
; 7688 : 			LogAddTD("[ANTI-HACK][Serial 0 Item] [PShop Buy] (%s)(%s) Item(%s) Pos(%d)",
; 7689 : 				lpObj->AccountID, lpObj->Name, lpObj->Inventory1[lpMsg->btItemPos].GetName(), lpMsg->btItemPos);

  003ce	0f b6 4f 10	 movzx	 ecx, BYTE PTR [edi+16]
  003d2	51		 push	 ecx
  003d3	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  003d9	03 8b d0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4560]
  003df	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  003e4	50		 push	 eax
  003e5	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  003e8	50		 push	 eax
  003e9	83 c3 52	 add	 ebx, 82			; 00000052H
  003ec	53		 push	 ebx
  003ed	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
  003f2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003f8	83 c4 14	 add	 esp, 20			; 00000014H

; 7690 : 
; 7691 : 			return;

  003fb	e9 44 0d 00 00	 jmp	 $LN113@CGPShopReq@6
$LN80@CGPShopReq@6:

; 7692 : 		}
; 7693 : 
; 7694 : 
; 7695 : 
; 7696 : 		// New for Check Item Serials
; 7697 : 		if ( ::gObjInventorySearchSerialNumber(&gObj[aSourceIndex], lpObj->Inventory1[lpMsg->btItemPos].GetNumber()) == FALSE )

  00400	0f b6 4f 10	 movzx	 ecx, BYTE PTR [edi+16]
  00404	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0040a	03 8b d0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4560]
  00410	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00415	50		 push	 eax
  00416	8b 55 88	 mov	 edx, DWORD PTR tv1505[ebp]
  00419	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0041f	52		 push	 edx
  00420	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00425	83 c4 08	 add	 esp, 8
  00428	85 c0		 test	 eax, eax
  0042a	75 6d		 jne	 SHORT $LN79@CGPShopReq@6

; 7698 : 		{
; 7699 : 			::GCReFillSend(aSourceIndex,(WORD)lpSourceObj->Life, -3, 1, lpSourceObj->iShield);

  0042c	0f b7 86 2c 01
	00 00		 movzx	 eax, WORD PTR [esi+300]
  00433	50		 push	 eax
  00434	6a 01		 push	 1
  00436	68 fd 00 00 00	 push	 253			; 000000fdH
  0043b	d9 86 d8 00 00
	00		 fld	 DWORD PTR [esi+216]
  00441	d9 7d 84	 fnstcw	 WORD PTR tv1746[ebp]
  00444	0f b7 45 84	 movzx	 eax, WORD PTR tv1746[ebp]
  00448	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0044d	89 45 80	 mov	 DWORD PTR tv1743[ebp], eax
  00450	d9 6d 80	 fldcw	 WORD PTR tv1743[ebp]
  00453	db 5d 80	 fistp	 DWORD PTR tv1741[ebp]
  00456	d9 6d 84	 fldcw	 WORD PTR tv1746[ebp]
  00459	66 8b 4d 80	 mov	 cx, WORD PTR tv1741[ebp]
  0045d	0f b7 d1	 movzx	 edx, cx
  00460	52		 push	 edx
  00461	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00464	50		 push	 eax
  00465	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 7700 : 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d", gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 7701 : 				__FILE__, __LINE__);

  0046a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0046f	68 15 1e 00 00	 push	 7701			; 00001e15H
  00474	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00479	8b 4d 88	 mov	 ecx, DWORD PTR tv1505[ebp]
  0047c	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  00480	52		 push	 edx
  00481	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  00485	50		 push	 eax
  00486	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  0048b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00491	83 c4 28	 add	 esp, 40			; 00000028H

; 7702 : 
; 7703 : 			return;

  00494	e9 ab 0c 00 00	 jmp	 $LN113@CGPShopReq@6
$LN79@CGPShopReq@6:

; 7704 : 		}
; 7705 : 
; 7706 : 		if ( ::gObjInventorySearchSerialNumber(lpObj, lpObj->Inventory1[lpMsg->btItemPos].GetNumber()) == FALSE )

  00499	0f b6 4f 10	 movzx	 ecx, BYTE PTR [edi+16]
  0049d	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  004a3	03 8b d0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4560]
  004a9	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  004ae	50		 push	 eax
  004af	53		 push	 ebx
  004b0	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  004b5	83 c4 08	 add	 esp, 8
  004b8	85 c0		 test	 eax, eax
  004ba	75 62		 jne	 SHORT $LN78@CGPShopReq@6

; 7707 : 		{
; 7708 : 			GCReFillSend(lpObj->m_Index,(WORD)lpObj->Life, -3, 1, lpObj->iShield);

  004bc	0f b7 8b 2c 01
	00 00		 movzx	 ecx, WORD PTR [ebx+300]
  004c3	51		 push	 ecx
  004c4	6a 01		 push	 1
  004c6	68 fd 00 00 00	 push	 253			; 000000fdH
  004cb	d9 83 d8 00 00
	00		 fld	 DWORD PTR [ebx+216]
  004d1	d9 7d 84	 fnstcw	 WORD PTR tv1733[ebp]
  004d4	0f b7 45 84	 movzx	 eax, WORD PTR tv1733[ebp]
  004d8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  004dd	89 45 80	 mov	 DWORD PTR tv1729[ebp], eax
  004e0	d9 6d 80	 fldcw	 WORD PTR tv1729[ebp]
  004e3	db 5d 80	 fistp	 DWORD PTR tv1727[ebp]
  004e6	d9 6d 84	 fldcw	 WORD PTR tv1733[ebp]
  004e9	66 8b 55 80	 mov	 dx, WORD PTR tv1727[ebp]
  004ed	0f b7 c2	 movzx	 eax, dx
  004f0	50		 push	 eax
  004f1	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  004f3	51		 push	 ecx
  004f4	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 7709 : 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d",
; 7710 : 				lpObj->AccountID, lpObj->Name,
; 7711 : 				__FILE__, __LINE__);

  004f9	68 1f 1e 00 00	 push	 7711			; 00001e1fH
  004fe	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00503	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00506	50		 push	 eax
  00507	83 c3 52	 add	 ebx, 82			; 00000052H
  0050a	53		 push	 ebx
  0050b	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  00510	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00516	83 c4 28	 add	 esp, 40			; 00000028H

; 7712 : 
; 7713 : 			return;

  00519	e9 26 0c 00 00	 jmp	 $LN113@CGPShopReq@6
$LN78@CGPShopReq@6:

; 7714 : 		}
; 7715 : 
; 7716 : 		if (gObjFixInventoryPointer(aSourceIndex) == false )

  0051e	8b 55 8c	 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00521	52		 push	 edx
  00522	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00527	83 c4 04	 add	 esp, 4
  0052a	84 c0		 test	 al, al
  0052c	75 18		 jne	 SHORT $LN77@CGPShopReq@6

; 7717 : 		{
; 7718 : 			LogAdd( "[Fix Inv.Ptr] False Location - %s, %d", 
; 7719 : 				__FILE__, __LINE__);

  0052e	68 27 1e 00 00	 push	 7719			; 00001e27H
  00533	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00538	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  0053d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00543	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN77@CGPShopReq@6:

; 7720 : 		}
; 7721 : 
; 7722 : 		if ( gObj[aSourceIndex].pTransaction == 1 )

  00546	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0054b	8b 4d 88	 mov	 ecx, DWORD PTR tv1505[ebp]
  0054e	80 bc 01 cc 11
	00 00 01	 cmp	 BYTE PTR [ecx+eax+4556], 1
  00556	75 2b		 jne	 SHORT $LN76@CGPShopReq@6

; 7723 : 		{
; 7724 : 			LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Requester Transaction == 1, IF_TYPE : %d",
; 7725 : 				lpSourceObj->AccountID, lpSourceObj->Name, lpSourceObj->m_IfState.type);

  00558	8b 96 b8 11 00
	00		 mov	 edx, DWORD PTR [esi+4536]
  0055e	c1 ea 06	 shr	 edx, 6
  00561	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00567	52		 push	 edx
  00568	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0056b	50		 push	 eax
  0056c	83 c6 52	 add	 esi, 82			; 00000052H
  0056f	56		 push	 esi
  00570	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00575	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0057b	83 c4 10	 add	 esp, 16			; 00000010H

; 7726 : 			return;

  0057e	e9 c1 0b 00 00	 jmp	 $LN113@CGPShopReq@6
$LN76@CGPShopReq@6:

; 7727 : 		}
; 7728 : 
; 7729 : 		iITEM_LOG_TYPE=0;
; 7730 : 		iITEM_LOG_LEVEL=0;
; 7731 : 		iITEM_LOG_DUR=0;
; 7732 : 		iITEM_LOG_SERIAL = 0;
; 7733 : 
; 7734 : 		__try

  00583	9b		 fwait
  00584	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 7735 : 		{
; 7736 : 			if ( PSHOP_RANGE(lpMsg->btItemPos) == FALSE )

  0058b	0f b6 77 10	 movzx	 esi, BYTE PTR [edi+16]
  0058f	8d 86 34 ff ff
	ff		 lea	 eax, DWORD PTR [esi-204]
  00595	85 c0		 test	 eax, eax
  00597	78 0e		 js	 SHORT $LN124@CGPShopReq@6
  00599	33 c9		 xor	 ecx, ecx
  0059b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0059e	0f 9e c1	 setle	 cl
  005a1	8b c1		 mov	 eax, ecx
  005a3	85 c0		 test	 eax, eax
  005a5	75 29		 jne	 SHORT $LN74@CGPShopReq@6
$LN124@CGPShopReq@6:

; 7737 : 			{
; 7738 : 				::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 5);

  005a7	6a 05		 push	 5
  005a9	6a 00		 push	 0
  005ab	8b 13		 mov	 edx, DWORD PTR [ebx]
  005ad	52		 push	 edx
  005ae	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  005b1	50		 push	 eax
  005b2	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7739 : 				return;

  005b7	6a fe		 push	 -2			; fffffffeH
  005b9	9b		 fwait
  005ba	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  005bd	51		 push	 ecx
  005be	68 00 00 00 00	 push	 OFFSET ___security_cookie
  005c3	e8 00 00 00 00	 call	 __local_unwind4
  005c8	83 c4 1c	 add	 esp, 28			; 0000001cH
  005cb	e9 74 0b 00 00	 jmp	 $LN113@CGPShopReq@6
$LN74@CGPShopReq@6:

; 7740 : 			}
; 7741 : 
; 7742 : 			if ( lpObj->m_bMapSvrMoveQuit == true )

  005d0	80 bb 3c 20 00
	00 01		 cmp	 BYTE PTR [ebx+8252], 1
  005d7	75 28		 jne	 SHORT $LN73@CGPShopReq@6

; 7743 : 			{
; 7744 : 				CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  005d9	6a 02		 push	 2
  005db	6a 00		 push	 0
  005dd	6a ff		 push	 -1
  005df	8b 55 8c	 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  005e2	52		 push	 edx
  005e3	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7745 : 				return;

  005e8	6a fe		 push	 -2			; fffffffeH
  005ea	9b		 fwait
  005eb	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  005ee	50		 push	 eax
  005ef	68 00 00 00 00	 push	 OFFSET ___security_cookie
  005f4	e8 00 00 00 00	 call	 __local_unwind4
  005f9	83 c4 1c	 add	 esp, 28			; 0000001cH
  005fc	e9 43 0b 00 00	 jmp	 $LN113@CGPShopReq@6
$LN73@CGPShopReq@6:

; 7746 : 			}
; 7747 : 
; 7748 : 			if ( lpObj->Inventory1[lpMsg->btItemPos].IsItem() == TRUE )

  00601	8b ce		 mov	 ecx, esi
  00603	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00609	03 8b d0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4560]
  0060f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00614	83 f8 01	 cmp	 eax, 1
  00617	0f 85 61 0a 00
	00		 jne	 $LN1@CGPShopReq@6

; 7749 : 			{
; 7750 : 				int n;
; 7751 : 				int invSize;
; 7752 : 				int iPShopValue = lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue;

  0061d	8b 93 d0 11 00
	00		 mov	 edx, DWORD PTR [ebx+4560]
  00623	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00629	0f b6 41 10	 movzx	 eax, BYTE PTR [ecx+16]
  0062d	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00633	03 c2		 add	 eax, edx
  00635	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  00638	89 4d 80	 mov	 DWORD PTR _iPShopValue$220051[ebp], ecx

; 7753 : 				short aPShopJewelValue[3];
; 7754 : 				
; 7755 : 				aPShopJewelValue[0] = lpObj->Inventory1[lpMsg->btItemPos].m_PShopBlessValue;

  0063b	66 8b b0 80 00
	00 00		 mov	 si, WORD PTR [eax+128]
  00642	66 89 75 dc	 mov	 WORD PTR _aPShopJewelValue$220052[ebp], si

; 7756 : 				aPShopJewelValue[1] = lpObj->Inventory1[lpMsg->btItemPos].m_PShopSoulValue;

  00646	66 8b b8 82 00
	00 00		 mov	 di, WORD PTR [eax+130]
  0064d	66 89 7d de	 mov	 WORD PTR _aPShopJewelValue$220052[ebp+2], di

; 7757 : 				aPShopJewelValue[2] = lpObj->Inventory1[lpMsg->btItemPos].m_PShopChaosValue;

  00651	66 8b 80 84 00
	00 00		 mov	 ax, WORD PTR [eax+132]
  00658	66 89 45 e0	 mov	 WORD PTR _aPShopJewelValue$220052[ebp+4], ax

; 7758 : 
; 7759 : 				if ( iPShopValue < 0 ||
; 7760 : 					 aPShopJewelValue[0] < 0 ||
; 7761 : 					 aPShopJewelValue[1] < 0 ||
; 7762 : 					 aPShopJewelValue[2] < 0 )

  0065c	85 c9		 test	 ecx, ecx
  0065e	0f 88 35 0a 00
	00		 js	 $LN70@CGPShopReq@6
  00664	66 85 f6	 test	 si, si
  00667	0f 88 2c 0a 00
	00		 js	 $LN70@CGPShopReq@6
  0066d	66 85 ff	 test	 di, di
  00670	0f 88 23 0a 00
	00		 js	 $LN70@CGPShopReq@6
  00676	66 85 c0	 test	 ax, ax
  00679	0f 88 1a 0a 00
	00		 js	 $LN70@CGPShopReq@6

; 7770 : 				}
; 7771 : 
; 7772 : 				if( iPShopValue > 0 )

  0067f	85 c9		 test	 ecx, ecx
  00681	0f 8e ca 00 00
	00		 jle	 $LN67@CGPShopReq@6

; 7773 : 				{
; 7774 : 					if ( gObj[aSourceIndex].Money < lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue )

  00687	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  0068d	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00691	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00697	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0069d	8b 7d 88	 mov	 edi, DWORD PTR tv1505[ebp]
  006a0	8b b4 37 cc 00
	00 00		 mov	 esi, DWORD PTR [edi+esi+204]
  006a7	3b 74 10 7c	 cmp	 esi, DWORD PTR [eax+edx+124]
  006ab	7d 4a		 jge	 SHORT $LN68@CGPShopReq@6

; 7775 : 					{
; 7776 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack of Zen",
; 7777 : 							lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  006ad	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  006b0	50		 push	 eax
  006b1	8d 4b 52	 lea	 ecx, DWORD PTR [ebx+82]
  006b4	51		 push	 ecx
  006b5	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  006bb	8d 50 5d	 lea	 edx, DWORD PTR [eax+93]
  006be	52		 push	 edx
  006bf	83 c0 52	 add	 eax, 82			; 00000052H
  006c2	50		 push	 eax
  006c3	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  006c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7778 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 7);

  006ce	6a 07		 push	 7
  006d0	6a 00		 push	 0
  006d2	8b 03		 mov	 eax, DWORD PTR [ebx]
  006d4	50		 push	 eax
  006d5	8b 4d 8c	 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  006d8	51		 push	 ecx
  006d9	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7779 : 						return;

  006de	6a fe		 push	 -2			; fffffffeH
  006e0	9b		 fwait
  006e1	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  006e4	52		 push	 edx
  006e5	68 00 00 00 00	 push	 OFFSET ___security_cookie
  006ea	e8 00 00 00 00	 call	 __local_unwind4
  006ef	83 c4 30	 add	 esp, 48			; 00000030H
  006f2	e9 4d 0a 00 00	 jmp	 $LN113@CGPShopReq@6
$LN68@CGPShopReq@6:

; 7780 : 					}
; 7781 : 
; 7782 : 					if ( gObjCheckMaxZen(lpObj->m_Index, iPShopValue) == FALSE )

  006f7	51		 push	 ecx
  006f8	8b 03		 mov	 eax, DWORD PTR [ebx]
  006fa	50		 push	 eax
  006fb	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  00700	83 c4 08	 add	 esp, 8
  00703	85 c0		 test	 eax, eax
  00705	75 4a		 jne	 SHORT $LN67@CGPShopReq@6

; 7783 : 					{
; 7784 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Exceeding Zen of the Host",
; 7785 : 							lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  00707	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  0070a	50		 push	 eax
  0070b	8d 4b 52	 lea	 ecx, DWORD PTR [ebx+82]
  0070e	51		 push	 ecx
  0070f	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  00715	8d 50 5d	 lea	 edx, DWORD PTR [eax+93]
  00718	52		 push	 edx
  00719	83 c0 52	 add	 eax, 82			; 00000052H
  0071c	50		 push	 eax
  0071d	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00722	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7786 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);

  00728	6a 08		 push	 8
  0072a	6a 00		 push	 0
  0072c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0072e	50		 push	 eax
  0072f	8b 4d 8c	 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00732	51		 push	 ecx
  00733	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7787 : 						return;

  00738	6a fe		 push	 -2			; fffffffeH
  0073a	9b		 fwait
  0073b	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  0073e	52		 push	 edx
  0073f	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00744	e8 00 00 00 00	 call	 __local_unwind4
  00749	83 c4 30	 add	 esp, 48			; 00000030H
  0074c	e9 f3 09 00 00	 jmp	 $LN113@CGPShopReq@6
$LN67@CGPShopReq@6:

; 7788 : 					}
; 7789 : 				}
; 7790 : 
; 7791 : 				int iFreeSpaceReq = 0;

  00751	33 f6		 xor	 esi, esi
  00753	89 b5 6c ff ff
	ff		 mov	 DWORD PTR _iFreeSpaceReq$220061[ebp], esi
$LN138@CGPShopReq@6:

; 7792 : 				short aPShopJewel[3];
; 7793 : 				short aPShopJewelBoundle[3][3];
; 7794 : 				
; 7795 : 				for( n = 0; n < 3; n++)

  00759	89 75 88	 mov	 DWORD PTR _n$220049[ebp], esi
  0075c	83 fe 03	 cmp	 esi, 3
  0075f	0f 8d bb 00 00
	00		 jge	 $LN64@CGPShopReq@6

; 7796 : 				{
; 7797 : 					int tmpJewelCnt = aPShopJewelValue[n];

  00765	0f bf 7c 75 dc	 movsx	 edi, WORD PTR _aPShopJewelValue$220052[ebp+esi*2]

; 7798 : 
; 7799 : 					if( tmpJewelCnt > 0 )

  0076a	85 ff		 test	 edi, edi
  0076c	0f 8e a8 00 00
	00		 jle	 $LN63@CGPShopReq@6

; 7800 : 					{
; 7801 : 						aPShopJewelBoundle[n][0] = tmpJewelCnt/30;

  00772	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00777	f7 ef		 imul	 edi
  00779	03 d7		 add	 edx, edi
  0077b	c1 fa 04	 sar	 edx, 4
  0077e	8b c2		 mov	 eax, edx
  00780	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00783	03 c2		 add	 eax, edx
  00785	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00788	03 c9		 add	 ecx, ecx
  0078a	8d 54 0d bc	 lea	 edx, DWORD PTR _aPShopJewelBoundle$220063[ebp+ecx]
  0078e	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv1669[ebp], edx
  00794	66 89 02	 mov	 WORD PTR [edx], ax

; 7802 : 						tmpJewelCnt = tmpJewelCnt%30;

  00797	8b d0		 mov	 edx, eax
  00799	c1 e2 04	 shl	 edx, 4
  0079c	2b d0		 sub	 edx, eax
  0079e	f7 da		 neg	 edx
  007a0	8d 3c 57	 lea	 edi, DWORD PTR [edi+edx*2]

; 7803 : 						aPShopJewelBoundle[n][1] = tmpJewelCnt/20;

  007a3	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  007a8	f7 ef		 imul	 edi
  007aa	c1 fa 03	 sar	 edx, 3
  007ad	8b c2		 mov	 eax, edx
  007af	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  007b2	03 c2		 add	 eax, edx
  007b4	8d 54 0d be	 lea	 edx, DWORD PTR _aPShopJewelBoundle$220063[ebp+ecx+2]
  007b8	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv1674[ebp], edx
  007be	66 89 02	 mov	 WORD PTR [edx], ax

; 7804 : 						tmpJewelCnt = tmpJewelCnt%20;

  007c1	8b d0		 mov	 edx, eax
  007c3	f7 da		 neg	 edx
  007c5	03 d2		 add	 edx, edx
  007c7	03 d2		 add	 edx, edx
  007c9	2b d0		 sub	 edx, eax
  007cb	8d 3c 97	 lea	 edi, DWORD PTR [edi+edx*4]

; 7805 : 						aPShopJewelBoundle[n][2] = tmpJewelCnt/10;

  007ce	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  007d3	f7 ef		 imul	 edi
  007d5	c1 fa 02	 sar	 edx, 2
  007d8	8b c2		 mov	 eax, edx
  007da	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  007dd	03 c2		 add	 eax, edx
  007df	66 89 44 0d c0	 mov	 WORD PTR _aPShopJewelBoundle$220063[ebp+ecx+4], ax

; 7806 : 						aPShopJewel[n] = tmpJewelCnt%10;

  007e4	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  007e7	03 d2		 add	 edx, edx
  007e9	8b cf		 mov	 ecx, edi
  007eb	2b ca		 sub	 ecx, edx
  007ed	66 89 4c 75 b4	 mov	 WORD PTR _aPShopJewel$220062[ebp+esi*2], cx

; 7807 : 
; 7808 : 						iFreeSpaceReq += aPShopJewel[n] + aPShopJewelBoundle[n][0] + aPShopJewelBoundle[n][1] + aPShopJewelBoundle[n][2];

  007f2	98		 cwde
  007f3	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv1674[ebp]
  007f9	0f bf 12	 movsx	 edx, WORD PTR [edx]
  007fc	03 c2		 add	 eax, edx
  007fe	0f bf c9	 movsx	 ecx, cx
  00801	03 c1		 add	 eax, ecx
  00803	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR tv1669[ebp]
  00809	0f bf 0a	 movsx	 ecx, WORD PTR [edx]
  0080c	03 8d 6c ff ff
	ff		 add	 ecx, DWORD PTR _iFreeSpaceReq$220061[ebp]
  00812	03 c8		 add	 ecx, eax
  00814	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _iFreeSpaceReq$220061[ebp], ecx
$LN63@CGPShopReq@6:

; 7792 : 				short aPShopJewel[3];
; 7793 : 				short aPShopJewelBoundle[3][3];
; 7794 : 				
; 7795 : 				for( n = 0; n < 3; n++)

  0081a	46		 inc	 esi
  0081b	e9 39 ff ff ff	 jmp	 $LN138@CGPShopReq@6
$LN64@CGPShopReq@6:

; 7809 : 					}
; 7810 : 				}
; 7811 : 
; 7812 : 				if( iFreeSpaceReq > 0 )

  00820	33 d2		 xor	 edx, edx
  00822	8b b5 6c ff ff
	ff		 mov	 esi, DWORD PTR _iFreeSpaceReq$220061[ebp]
  00828	3b f2		 cmp	 esi, edx
  0082a	0f 8e 90 00 00
	00		 jle	 $LN56@CGPShopReq@6

; 7813 : 				{
; 7814 : 					int iEmptyCount = 0;

  00830	89 95 58 ff ff
	ff		 mov	 DWORD PTR _iEmptyCount$220070[ebp], edx

; 7815 : 					invSize = MAIN_INVENTORY_SIZE;

  00836	b9 cc 00 00 00	 mov	 ecx, 204		; 000000ccH

; 7816 : 				
; 7817 : 					if( lpObj->pInventoryExtend < 4 )	{

  0083b	8a 83 cd 11 00
	00		 mov	 al, BYTE PTR [ebx+4557]
  00841	3c 04		 cmp	 al, 4
  00843	73 09		 jae	 SHORT $LN61@CGPShopReq@6

; 7818 : 						invSize = (MAIN_INVENTORY_SIZE)-(32*(4-lpObj->pInventoryExtend));

  00845	0f b6 c8	 movzx	 ecx, al
  00848	c1 e1 05	 shl	 ecx, 5
  0084b	83 c1 4c	 add	 ecx, 76			; 0000004cH
$LN61@CGPShopReq@6:

; 7819 : 					}
; 7820 : 
; 7821 : 					for ( int x=0; x<invSize;x++)

  0084e	33 c0		 xor	 eax, eax
$LN139@CGPShopReq@6:
  00850	89 85 54 ff ff
	ff		 mov	 DWORD PTR _x$220072[ebp], eax
  00856	3b c1		 cmp	 eax, ecx
  00858	7d 16		 jge	 SHORT $LN58@CGPShopReq@6

; 7822 : 					{
; 7823 : 						if ( lpObj->pInventoryMap[x] == 0xFF )

  0085a	8b bb c8 11 00
	00		 mov	 edi, DWORD PTR [ebx+4552]
  00860	80 3c 38 ff	 cmp	 BYTE PTR [eax+edi], 255	; 000000ffH
  00864	75 07		 jne	 SHORT $LN57@CGPShopReq@6

; 7824 : 						{
; 7825 : 							iEmptyCount++;

  00866	42		 inc	 edx
  00867	89 95 58 ff ff
	ff		 mov	 DWORD PTR _iEmptyCount$220070[ebp], edx
$LN57@CGPShopReq@6:

; 7819 : 					}
; 7820 : 
; 7821 : 					for ( int x=0; x<invSize;x++)

  0086d	40		 inc	 eax
  0086e	eb e0		 jmp	 SHORT $LN139@CGPShopReq@6
$LN58@CGPShopReq@6:

; 7826 : 						}
; 7827 : 					}
; 7828 : 
; 7829 : 					if( iEmptyCount < iFreeSpaceReq )

  00870	3b d6		 cmp	 edx, esi
  00872	7d 4a		 jge	 SHORT $LN133@CGPShopReq@6

; 7830 : 					{
; 7831 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Store Reward",
; 7832 : 							lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  00874	8d 53 5d	 lea	 edx, DWORD PTR [ebx+93]
  00877	52		 push	 edx
  00878	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  0087b	50		 push	 eax
  0087c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  00882	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  00885	51		 push	 ecx
  00886	83 c0 52	 add	 eax, 82			; 00000052H
  00889	50		 push	 eax
  0088a	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@CGGBJBAH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0088f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7833 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 17);

  00895	6a 11		 push	 17			; 00000011H
  00897	6a 00		 push	 0
  00899	8b 13		 mov	 edx, DWORD PTR [ebx]
  0089b	52		 push	 edx
  0089c	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0089f	50		 push	 eax
  008a0	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7834 : 						return;

  008a5	6a fe		 push	 -2			; fffffffeH
  008a7	9b		 fwait
  008a8	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  008ab	51		 push	 ecx
  008ac	68 00 00 00 00	 push	 OFFSET ___security_cookie
  008b1	e8 00 00 00 00	 call	 __local_unwind4
  008b6	83 c4 30	 add	 esp, 48			; 00000030H
  008b9	e9 86 08 00 00	 jmp	 $LN113@CGPShopReq@6
$LN133@CGPShopReq@6:
  008be	33 d2		 xor	 edx, edx
$LN56@CGPShopReq@6:

; 7835 : 					}
; 7836 : 				}
; 7837 : 
; 7838 : 				bool bBoundle[3];
; 7839 : 				bBoundle[0] = false;

  008c0	66 c7 45 84 00
	00		 mov	 WORD PTR _bBoundle$220079[ebp], 0

; 7840 : 				bBoundle[1] = false;
; 7841 : 				bBoundle[2] = false;

  008c6	c6 45 86 00	 mov	 BYTE PTR _bBoundle$220079[ebp+2], 0

; 7842 : 
; 7843 : 				int JewelCount[3];
; 7844 : 				JewelCount[0] = 0;

  008ca	89 55 a8	 mov	 DWORD PTR _JewelCount$220080[ebp], edx

; 7845 : 				JewelCount[1] = 0;

  008cd	89 55 ac	 mov	 DWORD PTR _JewelCount$220080[ebp+4], edx

; 7846 : 				JewelCount[2] = 0;

  008d0	89 55 b0	 mov	 DWORD PTR _JewelCount$220080[ebp+8], edx

; 7847 : 					
; 7848 : 				invSize = MAIN_INVENTORY_SIZE;

  008d3	b9 cc 00 00 00	 mov	 ecx, 204		; 000000ccH
  008d8	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _invSize$220050[ebp], ecx

; 7849 : 				
; 7850 : 				if( lpSourceObj->pInventoryExtend < 4 )	{

  008de	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _lpSourceObj$[ebp]
  008e4	8a 87 cd 11 00
	00		 mov	 al, BYTE PTR [edi+4557]
  008ea	3c 04		 cmp	 al, 4
  008ec	73 0f		 jae	 SHORT $LN55@CGPShopReq@6

; 7851 : 					invSize = (MAIN_INVENTORY_SIZE)-(32*(4-lpSourceObj->pInventoryExtend));

  008ee	0f b6 c8	 movzx	 ecx, al
  008f1	c1 e1 05	 shl	 ecx, 5
  008f4	83 c1 4c	 add	 ecx, 76			; 0000004cH
  008f7	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _invSize$220050[ebp], ecx
$LN55@CGPShopReq@6:

; 7852 : 				}
; 7853 : 
; 7854 : 				for( n = INVENTORY_BAG_START; n < invSize; n++)

  008fd	c7 45 88 0c 00
	00 00		 mov	 DWORD PTR _n$220049[ebp], 12 ; 0000000cH
$LL54@CGPShopReq@6:
  00904	39 4d 88	 cmp	 DWORD PTR _n$220049[ebp], ecx
  00907	0f 8d c6 00 00
	00		 jge	 $LN52@CGPShopReq@6

; 7855 : 				{
; 7856 : 					if( !lpSourceObj->pInventory[n].IsItem() )

  0090d	8b 75 88	 mov	 esi, DWORD PTR _n$220049[ebp]
  00910	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  00916	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  0091c	03 ce		 add	 ecx, esi
  0091e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00923	85 c0		 test	 eax, eax

; 7857 : 						continue;

  00925	0f 84 9a 00 00
	00		 je	 $LN53@CGPShopReq@6

; 7858 : 
; 7859 : 					if( lpSourceObj->pInventory[n].m_Type == ITEMGET(14,13) )

  0092b	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  00931	03 ce		 add	 ecx, esi
  00933	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00937	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  0093c	66 3b c2	 cmp	 ax, dx
  0093f	75 05		 jne	 SHORT $LN50@CGPShopReq@6

; 7860 : 					{
; 7861 : 						JewelCount[0]++;

  00941	ff 45 a8	 inc	 DWORD PTR _JewelCount$220080[ebp]
  00944	eb 7f		 jmp	 SHORT $LN53@CGPShopReq@6
$LN50@CGPShopReq@6:

; 7862 : 					}
; 7863 : 					else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(14,14) )

  00946	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  0094b	66 3b c2	 cmp	 ax, dx
  0094e	75 05		 jne	 SHORT $LN48@CGPShopReq@6

; 7864 : 					{
; 7865 : 						JewelCount[1]++;

  00950	ff 45 ac	 inc	 DWORD PTR _JewelCount$220080[ebp+4]
  00953	eb 70		 jmp	 SHORT $LN53@CGPShopReq@6
$LN48@CGPShopReq@6:

; 7866 : 					}
; 7867 : 					else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,15) )

  00955	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  0095a	66 3b c2	 cmp	 ax, dx
  0095d	75 05		 jne	 SHORT $LN46@CGPShopReq@6

; 7868 : 					{
; 7869 : 						JewelCount[2]++;

  0095f	ff 45 b0	 inc	 DWORD PTR _JewelCount$220080[ebp+8]
  00962	eb 61		 jmp	 SHORT $LN53@CGPShopReq@6
$LN46@CGPShopReq@6:

; 7870 : 					}
; 7871 : 					else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,30) )

  00964	ba 1e 18 00 00	 mov	 edx, 6174		; 0000181eH
  00969	66 3b c2	 cmp	 ax, dx
  0096c	75 17		 jne	 SHORT $LN44@CGPShopReq@6

; 7872 : 					{
; 7873 : 						bBoundle[0] = true;

  0096e	c6 45 84 01	 mov	 BYTE PTR _bBoundle$220079[ebp], 1

; 7874 : 						JewelCount[0] += 10 * (lpSourceObj->pInventory[n].m_Level+1);

  00972	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  00976	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00979	8b 4d a8	 mov	 ecx, DWORD PTR _JewelCount$220080[ebp]
  0097c	8d 54 41 0a	 lea	 edx, DWORD PTR [ecx+eax*2+10]
  00980	89 55 a8	 mov	 DWORD PTR _JewelCount$220080[ebp], edx
  00983	eb 40		 jmp	 SHORT $LN53@CGPShopReq@6
$LN44@CGPShopReq@6:

; 7875 : 					}
; 7876 : 					else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,31) )

  00985	ba 1f 18 00 00	 mov	 edx, 6175		; 0000181fH
  0098a	66 3b c2	 cmp	 ax, dx
  0098d	75 17		 jne	 SHORT $LN42@CGPShopReq@6

; 7877 : 					{
; 7878 : 						bBoundle[1] = true;

  0098f	c6 45 85 01	 mov	 BYTE PTR _bBoundle$220079[ebp+1], 1

; 7879 : 						JewelCount[1] += 10 * (lpSourceObj->pInventory[n].m_Level+1);

  00993	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  00997	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0099a	8b 4d ac	 mov	 ecx, DWORD PTR _JewelCount$220080[ebp+4]
  0099d	8d 54 41 0a	 lea	 edx, DWORD PTR [ecx+eax*2+10]
  009a1	89 55 ac	 mov	 DWORD PTR _JewelCount$220080[ebp+4], edx
  009a4	eb 1f		 jmp	 SHORT $LN53@CGPShopReq@6
$LN42@CGPShopReq@6:

; 7880 : 					}
; 7881 : 					else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,141) )

  009a6	ba 8d 18 00 00	 mov	 edx, 6285		; 0000188dH
  009ab	66 3b c2	 cmp	 ax, dx
  009ae	75 15		 jne	 SHORT $LN53@CGPShopReq@6

; 7882 : 					{
; 7883 : 						bBoundle[2] = true;

  009b0	c6 45 86 01	 mov	 BYTE PTR _bBoundle$220079[ebp+2], 1

; 7884 : 						JewelCount[2] += 10 * (lpSourceObj->pInventory[n].m_Level+1);

  009b4	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  009b8	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  009bb	8b 4d b0	 mov	 ecx, DWORD PTR _JewelCount$220080[ebp+8]
  009be	8d 54 41 0a	 lea	 edx, DWORD PTR [ecx+eax*2+10]
  009c2	89 55 b0	 mov	 DWORD PTR _JewelCount$220080[ebp+8], edx
$LN53@CGPShopReq@6:

; 7852 : 				}
; 7853 : 
; 7854 : 				for( n = INVENTORY_BAG_START; n < invSize; n++)

  009c5	ff 45 88	 inc	 DWORD PTR _n$220049[ebp]
  009c8	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _invSize$220050[ebp]
  009ce	e9 31 ff ff ff	 jmp	 $LL54@CGPShopReq@6
$LN52@CGPShopReq@6:

; 7885 : 					}
; 7886 : 				}
; 7887 : 
; 7888 : 				for( n = 0; n < 3; n++)

  009d3	33 c0		 xor	 eax, eax
$LN140@CGPShopReq@6:
  009d5	89 45 88	 mov	 DWORD PTR _n$220049[ebp], eax
  009d8	83 f8 03	 cmp	 eax, 3
  009db	0f 8d b6 00 00
	00		 jge	 $LN37@CGPShopReq@6

; 7889 : 				{
; 7890 : 					if( JewelCount[n] < aPShopJewelValue[n] )

  009e1	0f bf 4c 45 dc	 movsx	 ecx, WORD PTR _aPShopJewelValue$220052[ebp+eax*2]
  009e6	8b 54 85 a8	 mov	 edx, DWORD PTR _JewelCount$220080[ebp+eax*4]
  009ea	3b d1		 cmp	 edx, ecx
  009ec	7d 4c		 jge	 SHORT $LN36@CGPShopReq@6

; 7891 : 					{
; 7892 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No enough Jewels - Type: %d",
; 7893 : 						lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name, n);

  009ee	50		 push	 eax
  009ef	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  009f2	50		 push	 eax
  009f3	8d 4b 52	 lea	 ecx, DWORD PTR [ebx+82]
  009f6	51		 push	 ecx
  009f7	8d 57 5d	 lea	 edx, DWORD PTR [edi+93]
  009fa	52		 push	 edx
  009fb	83 c7 52	 add	 edi, 82			; 00000052H
  009fe	57		 push	 edi
  009ff	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00a04	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7894 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 11+n);

  00a0a	8a 45 88	 mov	 al, BYTE PTR _n$220049[ebp]
  00a0d	04 0b		 add	 al, 11			; 0000000bH
  00a0f	0f b6 c0	 movzx	 eax, al
  00a12	50		 push	 eax
  00a13	6a 00		 push	 0
  00a15	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00a17	51		 push	 ecx
  00a18	8b 55 8c	 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00a1b	52		 push	 edx
  00a1c	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7895 : 						return;

  00a21	6a fe		 push	 -2			; fffffffeH
  00a23	9b		 fwait
  00a24	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00a27	50		 push	 eax
  00a28	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00a2d	e8 00 00 00 00	 call	 __local_unwind4
  00a32	83 c4 34	 add	 esp, 52			; 00000034H
  00a35	e9 0a 07 00 00	 jmp	 $LN113@CGPShopReq@6
$LN36@CGPShopReq@6:

; 7896 : 					}
; 7897 : 					else if( bBoundle[n] && JewelCount[n] > aPShopJewelValue[n] )

  00a3a	80 7c 05 84 00	 cmp	 BYTE PTR _bBoundle$220079[ebp+eax], 0
  00a3f	74 50		 je	 SHORT $LN34@CGPShopReq@6
  00a41	3b d1		 cmp	 edx, ecx
  00a43	7e 4c		 jle	 SHORT $LN34@CGPShopReq@6

; 7898 : 					{
; 7899 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Boundle Jewels - Type: %d",
; 7900 : 						lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name, n);

  00a45	50		 push	 eax
  00a46	8d 4b 5d	 lea	 ecx, DWORD PTR [ebx+93]
  00a49	51		 push	 ecx
  00a4a	8d 53 52	 lea	 edx, DWORD PTR [ebx+82]
  00a4d	52		 push	 edx
  00a4e	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00a51	50		 push	 eax
  00a52	83 c7 52	 add	 edi, 82			; 00000052H
  00a55	57		 push	 edi
  00a56	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00a5b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7901 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 14+n);

  00a61	8a 45 88	 mov	 al, BYTE PTR _n$220049[ebp]
  00a64	04 0e		 add	 al, 14			; 0000000eH
  00a66	0f b6 c8	 movzx	 ecx, al
  00a69	51		 push	 ecx
  00a6a	6a 00		 push	 0
  00a6c	8b 13		 mov	 edx, DWORD PTR [ebx]
  00a6e	52		 push	 edx
  00a6f	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00a72	50		 push	 eax
  00a73	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7902 : 						return;

  00a78	6a fe		 push	 -2			; fffffffeH
  00a7a	9b		 fwait
  00a7b	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00a7e	51		 push	 ecx
  00a7f	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00a84	e8 00 00 00 00	 call	 __local_unwind4
  00a89	83 c4 34	 add	 esp, 52			; 00000034H
  00a8c	e9 b3 06 00 00	 jmp	 $LN113@CGPShopReq@6
$LN34@CGPShopReq@6:

; 7885 : 					}
; 7886 : 				}
; 7887 : 
; 7888 : 				for( n = 0; n < 3; n++)

  00a91	40		 inc	 eax
  00a92	e9 3e ff ff ff	 jmp	 $LN140@CGPShopReq@6
$LN37@CGPShopReq@6:

; 7903 : 					}
; 7904 : 				}
; 7905 : 				
; 7906 : 				BYTE btNewItemPos = 0;
; 7907 : 				btNewItemPos = ::gObjOnlyInventoryInsertItem(aSourceIndex, lpObj->Inventory1[lpMsg->btItemPos]);

  00a97	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00a9d	0f b6 72 10	 movzx	 esi, BYTE PTR [edx+16]
  00aa1	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  00aa7	03 b3 d0 11 00
	00		 add	 esi, DWORD PTR [ebx+4560]
  00aad	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00ab3	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00ab8	8b fc		 mov	 edi, esp
  00aba	f3 a5		 rep movsd
  00abc	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00abf	50		 push	 eax
  00ac0	e8 00 00 00 00	 call	 ?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjOnlyInventoryInsertItem
  00ac5	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00acb	88 45 86	 mov	 BYTE PTR _btNewItemPos$220105[ebp], al

; 7908 : 
; 7909 : 				if ( btNewItemPos == 0xFF )

  00ace	3c ff		 cmp	 al, 255			; 000000ffH
  00ad0	75 52		 jne	 SHORT $LN33@CGPShopReq@6

; 7910 : 				{
; 7911 : 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Buy Item",
; 7912 : 						gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 7913 : 						lpObj->AccountID, lpObj->Name);

  00ad2	8b 75 8c	 mov	 esi, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00ad5	8b c6		 mov	 eax, esi
  00ad7	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00add	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ae3	8d 4b 5d	 lea	 ecx, DWORD PTR [ebx+93]
  00ae6	51		 push	 ecx
  00ae7	8d 53 52	 lea	 edx, DWORD PTR [ebx+82]
  00aea	52		 push	 edx
  00aeb	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  00aee	51		 push	 ecx
  00aef	83 c0 52	 add	 eax, 82			; 00000052H
  00af2	50		 push	 eax
  00af3	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00af8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7914 : 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);

  00afe	6a 08		 push	 8
  00b00	6a 00		 push	 0
  00b02	8b 13		 mov	 edx, DWORD PTR [ebx]
  00b04	52		 push	 edx
  00b05	56		 push	 esi
  00b06	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7915 : 
; 7916 : 					return;

  00b0b	6a fe		 push	 -2			; fffffffeH
  00b0d	9b		 fwait
  00b0e	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00b11	50		 push	 eax
  00b12	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00b17	e8 00 00 00 00	 call	 __local_unwind4
  00b1c	83 c4 30	 add	 esp, 48			; 00000030H
  00b1f	e9 20 06 00 00	 jmp	 $LN113@CGPShopReq@6
$LN33@CGPShopReq@6:

; 7917 : 				}
; 7918 : 				
; 7919 : 				g_ElementalSystem.PShopErtel(lpObj,&gObj[aSourceIndex],&gObj[aSourceIndex].pInventory[btNewItemPos]);

  00b24	8b 7d 8c	 mov	 edi, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00b27	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00b2d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b33	03 cf		 add	 ecx, edi
  00b35	0f b6 d0	 movzx	 edx, al
  00b38	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00b3e	03 91 c0 11 00
	00		 add	 edx, DWORD PTR [ecx+4544]
  00b44	52		 push	 edx
  00b45	51		 push	 ecx
  00b46	53		 push	 ebx
  00b47	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00b4c	e8 00 00 00 00	 call	 ?PShopErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z ; CElementalSystem::PShopErtel

; 7920 : 				
; 7921 : 				iITEM_LOG_TYPE = lpObj->Inventory1[lpMsg->btItemPos].m_Type;

  00b51	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  00b57	0f b6 70 10	 movzx	 esi, BYTE PTR [eax+16]
  00b5b	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  00b61	03 b3 d0 11 00
	00		 add	 esi, DWORD PTR [ebx+4560]
  00b67	0f bf 56 06	 movsx	 edx, WORD PTR [esi+6]
  00b6b	89 95 5c ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_TYPE$[ebp], edx

; 7922 : 				iITEM_LOG_LEVEL = lpObj->Inventory1[lpMsg->btItemPos].m_Level;

  00b71	0f bf 46 08	 movsx	 eax, WORD PTR [esi+8]
  00b75	89 85 44 ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_LEVEL$[ebp], eax

; 7923 : 				iITEM_LOG_DUR = (int)lpObj->Inventory1[lpMsg->btItemPos].m_Durability;

  00b7b	d9 46 24	 fld	 DWORD PTR [esi+36]
  00b7e	e8 00 00 00 00	 call	 __ftol2_sse
  00b83	89 85 40 ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_DUR$[ebp], eax

; 7924 : 				iITEM_LOG_SERIAL = lpObj->Inventory1[lpMsg->btItemPos].m_Number;

  00b89	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00b8b	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_SERIAL$[ebp], ecx

; 7925 : 				::gObjInventoryItemSet_PShop(lpObj->m_Index, lpMsg->btItemPos, -1);

  00b91	68 ff 00 00 00	 push	 255			; 000000ffH
  00b96	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00b9c	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00ba0	50		 push	 eax
  00ba1	8b 03		 mov	 eax, DWORD PTR [ebx]
  00ba3	50		 push	 eax
  00ba4	e8 00 00 00 00	 call	 ?gObjInventoryItemSet_PShop@@YAXHHE@Z ; gObjInventoryItemSet_PShop
  00ba9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7926 : 				lpObj->Inventory1[lpMsg->btItemPos].Clear();

  00bac	8b b5 78 ff ff
	ff		 mov	 esi, DWORD PTR _lpMsg$GSCopy$[ebp]
  00bb2	0f b6 4e 10	 movzx	 ecx, BYTE PTR [esi+16]
  00bb6	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00bbc	03 8b d0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4560]
  00bc2	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 7927 : 				::GCInventoryItemDeleteSend(lpObj->m_Index, lpMsg->btItemPos, TRUE);

  00bc7	6a 01		 push	 1
  00bc9	0f b6 4e 10	 movzx	 ecx, BYTE PTR [esi+16]
  00bcd	51		 push	 ecx
  00bce	8b 13		 mov	 edx, DWORD PTR [ebx]
  00bd0	52		 push	 edx
  00bd1	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00bd6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7928 : 
; 7929 : 				if( iPShopValue > 0 )

  00bd9	83 7d 80 00	 cmp	 DWORD PTR _iPShopValue$220051[ebp], 0
  00bdd	7e 3d		 jle	 SHORT $LN32@CGPShopReq@6

; 7930 : 				{
; 7931 : 					gObj[aSourceIndex].Money -= iPShopValue;

  00bdf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00be4	8b 4d 80	 mov	 ecx, DWORD PTR _iPShopValue$220051[ebp]
  00be7	29 8c 07 cc 00
	00 00		 sub	 DWORD PTR [edi+eax+204], ecx

; 7932 : 					lpObj->Money += iPShopValue;

  00bee	01 8b cc 00 00
	00		 add	 DWORD PTR [ebx+204], ecx

; 7933 : 					::GCMoneySend(aSourceIndex, lpSourceObj->Money);

  00bf4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  00bfa	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00c00	51		 push	 ecx
  00c01	8b 55 8c	 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00c04	52		 push	 edx
  00c05	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 7934 : 					::GCMoneySend(lpObj->m_Index, lpObj->Money);

  00c0a	8b 83 cc 00 00
	00		 mov	 eax, DWORD PTR [ebx+204]
  00c10	50		 push	 eax
  00c11	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00c13	51		 push	 ecx
  00c14	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00c19	83 c4 10	 add	 esp, 16			; 00000010H
$LN32@CGPShopReq@6:

; 7935 : 				}
; 7936 : 
; 7937 : 				JewelCount[0] = 0;

  00c1c	33 c0		 xor	 eax, eax
  00c1e	89 45 a8	 mov	 DWORD PTR _JewelCount$220080[ebp], eax

; 7938 : 				JewelCount[1] = 0;

  00c21	89 45 ac	 mov	 DWORD PTR _JewelCount$220080[ebp+4], eax

; 7939 : 				JewelCount[2] = 0;

  00c24	89 45 b0	 mov	 DWORD PTR _JewelCount$220080[ebp+8], eax

; 7940 : 
; 7941 : 				for ( n = INVETORY_WEAR_SIZE ; n< invSize; n++)

  00c27	bf 0c 00 00 00	 mov	 edi, 12			; 0000000cH
$LN141@CGPShopReq@6:
  00c2c	89 7d 88	 mov	 DWORD PTR _n$220049[ebp], edi
  00c2f	3b bd 70 ff ff
	ff		 cmp	 edi, DWORD PTR _invSize$220050[ebp]
  00c35	0f 8d a6 01 00
	00		 jge	 $LN29@CGPShopReq@6

; 7942 : 				{
; 7943 : 					if ( !lpSourceObj->pInventory[n].IsItem() )

  00c3b	8b c7		 mov	 eax, edi
  00c3d	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00c43	89 45 88	 mov	 DWORD PTR tv1725[ebp], eax
  00c46	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _lpSourceObj$[ebp]
  00c4c	8b 8a c0 11 00
	00		 mov	 ecx, DWORD PTR [edx+4544]
  00c52	03 c8		 add	 ecx, eax
  00c54	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00c59	85 c0		 test	 eax, eax

; 7944 : 						continue;

  00c5b	0f 84 7a 01 00
	00		 je	 $LN30@CGPShopReq@6

; 7945 : 
; 7946 : 					int JewelType = lpSourceObj->pInventory[n].m_Type;

  00c61	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  00c67	8b 80 c0 11 00
	00		 mov	 eax, DWORD PTR [eax+4544]
  00c6d	8b 55 88	 mov	 edx, DWORD PTR tv1725[ebp]
  00c70	0f bf 74 10 06	 movsx	 esi, WORD PTR [eax+edx+6]

; 7947 : 					int JewelLevel = lpSourceObj->pInventory[n].m_Level;

  00c75	0f bf 44 10 08	 movsx	 eax, WORD PTR [eax+edx+8]
  00c7a	89 85 74 ff ff
	ff		 mov	 DWORD PTR _JewelLevel$220115[ebp], eax

; 7948 : 
; 7949 : 					switch(JewelType)

  00c80	81 fe 8d 18 00
	00		 cmp	 esi, 6285		; 0000188dH
  00c86	0f 8f 81 00 00
	00		 jg	 $LN108@CGPShopReq@6
  00c8c	74 1a		 je	 SHORT $LN21@CGPShopReq@6
  00c8e	8b c6		 mov	 eax, esi
  00c90	2d 0f 18 00 00	 sub	 eax, 6159		; 0000180fH
  00c95	74 11		 je	 SHORT $LN21@CGPShopReq@6
  00c97	83 e8 0f	 sub	 eax, 15			; 0000000fH
  00c9a	0f 84 df 00 00
	00		 je	 $LN25@CGPShopReq@6
  00ca0	48		 dec	 eax
  00ca1	74 7a		 je	 SHORT $LN23@CGPShopReq@6
  00ca3	e9 33 01 00 00	 jmp	 $LN30@CGPShopReq@6
$LN21@CGPShopReq@6:

; 7971 : 					case ITEMGET(12,15):
; 7972 : 					case ITEMGET(12,141):
; 7973 : 						if( JewelCount[2] < aPShopJewelValue[2] )

  00ca8	0f bf 4d e0	 movsx	 ecx, WORD PTR _aPShopJewelValue$220052[ebp+4]
  00cac	39 4d b0	 cmp	 DWORD PTR _JewelCount$220080[ebp+8], ecx
  00caf	0f 8d 26 01 00
	00		 jge	 $LN30@CGPShopReq@6

; 7974 : 						{
; 7975 : 							gObjInventoryItemSet(aSourceIndex, n, (BYTE)-1);

  00cb5	68 ff 00 00 00	 push	 255			; 000000ffH
  00cba	57		 push	 edi
  00cbb	8b 55 8c	 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00cbe	52		 push	 edx
  00cbf	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00cc4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7976 : 							lpSourceObj->pInventory[n].Clear();

  00cc7	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  00ccd	8b 88 c0 11 00
	00		 mov	 ecx, DWORD PTR [eax+4544]
  00cd3	03 4d 88	 add	 ecx, DWORD PTR tv1725[ebp]
  00cd6	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 7977 : 							GCInventoryItemDeleteSend(aSourceIndex, n, TRUE);

  00cdb	6a 01		 push	 1
  00cdd	57		 push	 edi
  00cde	8b 4d 8c	 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00ce1	51		 push	 ecx
  00ce2	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00ce7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7978 : 							JewelCount[2] += (JewelType == ITEMGET(12,15) ) ? 1 : ((JewelLevel+1)*10);

  00cea	81 fe 0f 18 00
	00		 cmp	 esi, 6159		; 0000180fH
  00cf0	75 07		 jne	 SHORT $LN106@CGPShopReq@6
  00cf2	b8 01 00 00 00	 mov	 eax, 1
  00cf7	eb 0c		 jmp	 SHORT $LN107@CGPShopReq@6
$LN106@CGPShopReq@6:
  00cf9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _JewelLevel$220115[ebp]
  00cff	8d 44 80 05	 lea	 eax, DWORD PTR [eax+eax*4+5]
  00d03	03 c0		 add	 eax, eax
$LN107@CGPShopReq@6:
  00d05	01 45 b0	 add	 DWORD PTR _JewelCount$220080[ebp+8], eax

; 7979 : 						}
; 7980 : 						break;

  00d08	e9 ce 00 00 00	 jmp	 $LN30@CGPShopReq@6
$LN108@CGPShopReq@6:

; 7948 : 
; 7949 : 					switch(JewelType)

  00d0d	8b c6		 mov	 eax, esi
  00d0f	2d 0d 1c 00 00	 sub	 eax, 7181		; 00001c0dH
  00d14	74 69		 je	 SHORT $LN25@CGPShopReq@6
  00d16	48		 dec	 eax
  00d17	0f 85 be 00 00
	00		 jne	 $LN30@CGPShopReq@6
$LN23@CGPShopReq@6:

; 7959 : 						}
; 7960 : 						break;
; 7961 : 					case ITEMGET(14,14):
; 7962 : 					case ITEMGET(12,31):
; 7963 : 						if( JewelCount[1] < aPShopJewelValue[1] )

  00d1d	0f bf 55 de	 movsx	 edx, WORD PTR _aPShopJewelValue$220052[ebp+2]
  00d21	39 55 ac	 cmp	 DWORD PTR _JewelCount$220080[ebp+4], edx
  00d24	0f 8d b1 00 00
	00		 jge	 $LN30@CGPShopReq@6

; 7964 : 						{
; 7965 : 							gObjInventoryItemSet(aSourceIndex, n, (BYTE)-1);

  00d2a	68 ff 00 00 00	 push	 255			; 000000ffH
  00d2f	57		 push	 edi
  00d30	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00d33	50		 push	 eax
  00d34	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00d39	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7966 : 							lpSourceObj->pInventory[n].Clear();

  00d3c	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _lpSourceObj$[ebp]
  00d42	8b 89 c0 11 00
	00		 mov	 ecx, DWORD PTR [ecx+4544]
  00d48	03 4d 88	 add	 ecx, DWORD PTR tv1725[ebp]
  00d4b	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 7967 : 							GCInventoryItemDeleteSend(aSourceIndex, n, TRUE);

  00d50	6a 01		 push	 1
  00d52	57		 push	 edi
  00d53	8b 55 8c	 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00d56	52		 push	 edx
  00d57	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00d5c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7968 : 							JewelCount[1] += (JewelType == ITEMGET(14,14) ) ? 1 : ((JewelLevel+1)*10);

  00d5f	81 fe 0e 1c 00
	00		 cmp	 esi, 7182		; 00001c0eH
  00d65	75 07		 jne	 SHORT $LN104@CGPShopReq@6
  00d67	b8 01 00 00 00	 mov	 eax, 1
  00d6c	eb 0c		 jmp	 SHORT $LN105@CGPShopReq@6
$LN104@CGPShopReq@6:
  00d6e	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _JewelLevel$220115[ebp]
  00d74	8d 44 80 05	 lea	 eax, DWORD PTR [eax+eax*4+5]
  00d78	03 c0		 add	 eax, eax
$LN105@CGPShopReq@6:
  00d7a	01 45 ac	 add	 DWORD PTR _JewelCount$220080[ebp+4], eax

; 7969 : 						}
; 7970 : 						break;

  00d7d	eb 5c		 jmp	 SHORT $LN30@CGPShopReq@6
$LN25@CGPShopReq@6:

; 7950 : 					{
; 7951 : 					case ITEMGET(14,13):
; 7952 : 					case ITEMGET(12,30):
; 7953 : 						if( JewelCount[0] < aPShopJewelValue[0] )

  00d7f	0f bf 45 dc	 movsx	 eax, WORD PTR _aPShopJewelValue$220052[ebp]
  00d83	39 45 a8	 cmp	 DWORD PTR _JewelCount$220080[ebp], eax
  00d86	7d 53		 jge	 SHORT $LN30@CGPShopReq@6

; 7954 : 						{
; 7955 : 							gObjInventoryItemSet(aSourceIndex, n, (BYTE)-1);

  00d88	68 ff 00 00 00	 push	 255			; 000000ffH
  00d8d	57		 push	 edi
  00d8e	8b 4d 8c	 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00d91	51		 push	 ecx
  00d92	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00d97	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7956 : 							lpSourceObj->pInventory[n].Clear();

  00d9a	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _lpSourceObj$[ebp]
  00da0	8b 8a c0 11 00
	00		 mov	 ecx, DWORD PTR [edx+4544]
  00da6	03 4d 88	 add	 ecx, DWORD PTR tv1725[ebp]
  00da9	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 7957 : 							GCInventoryItemDeleteSend(aSourceIndex, n, TRUE);

  00dae	6a 01		 push	 1
  00db0	57		 push	 edi
  00db1	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00db4	50		 push	 eax
  00db5	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00dba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7958 : 							JewelCount[0] += (JewelType == ITEMGET(14,13) ) ? 1 : ((JewelLevel+1)*10);

  00dbd	81 fe 0d 1c 00
	00		 cmp	 esi, 7181		; 00001c0dH
  00dc3	75 07		 jne	 SHORT $LN102@CGPShopReq@6
  00dc5	b8 01 00 00 00	 mov	 eax, 1
  00dca	eb 0c		 jmp	 SHORT $LN103@CGPShopReq@6
$LN102@CGPShopReq@6:
  00dcc	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _JewelLevel$220115[ebp]
  00dd2	8d 44 80 05	 lea	 eax, DWORD PTR [eax+eax*4+5]
  00dd6	03 c0		 add	 eax, eax
$LN103@CGPShopReq@6:
  00dd8	01 45 a8	 add	 DWORD PTR _JewelCount$220080[ebp], eax
$LN30@CGPShopReq@6:

; 7940 : 
; 7941 : 				for ( n = INVETORY_WEAR_SIZE ; n< invSize; n++)

  00ddb	47		 inc	 edi
  00ddc	e9 4b fe ff ff	 jmp	 $LN141@CGPShopReq@6
$LN29@CGPShopReq@6:

; 7981 : 					}
; 7982 : 				}
; 7983 : 
; 7984 : 
; 7985 : 				int iBoundleId[3] = {ITEMGET(12,30), ITEMGET(12,31), ITEMGET(12,141)};

  00de1	c7 45 9c 1e 18
	00 00		 mov	 DWORD PTR _iBoundleId$220129[ebp], 6174 ; 0000181eH
  00de8	c7 45 a0 1f 18
	00 00		 mov	 DWORD PTR _iBoundleId$220129[ebp+4], 6175 ; 0000181fH
  00def	c7 45 a4 8d 18
	00 00		 mov	 DWORD PTR _iBoundleId$220129[ebp+8], 6285 ; 0000188dH

; 7986 : 				int iJewelId[3] = {ITEMGET(14,13), ITEMGET(14,14), ITEMGET(12,15)};

  00df6	c7 45 90 0d 1c
	00 00		 mov	 DWORD PTR _iJewelId$220130[ebp], 7181 ; 00001c0dH
  00dfd	c7 45 94 0e 1c
	00 00		 mov	 DWORD PTR _iJewelId$220130[ebp+4], 7182 ; 00001c0eH
  00e04	c7 45 98 0f 18
	00 00		 mov	 DWORD PTR _iJewelId$220130[ebp+8], 6159 ; 0000180fH

; 7987 : 
; 7988 : 				for( n = 0; n < 3; n++ )

  00e0b	33 f6		 xor	 esi, esi
$LN146@CGPShopReq@6:
  00e0d	89 75 88	 mov	 DWORD PTR _n$220049[ebp], esi
  00e10	83 fe 03	 cmp	 esi, 3
  00e13	0f 8d 33 01 00
	00		 jge	 $LN17@CGPShopReq@6

; 7989 : 				{
; 7990 : 					if( aPShopJewelValue[n] > 0 )

  00e19	66 83 7c 75 dc
	00		 cmp	 WORD PTR _aPShopJewelValue$220052[ebp+esi*2], 0
  00e1f	0f 8e 21 01 00
	00		 jle	 $LN4@CGPShopReq@6

; 7991 : 					{
; 7992 : 						for(int x = 0; x < aPShopJewelBoundle[n][0]; x++)

  00e25	33 ff		 xor	 edi, edi
$LN142@CGPShopReq@6:
  00e27	89 bd 64 ff ff
	ff		 mov	 DWORD PTR _x$220135[ebp], edi
  00e2d	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00e30	0f bf 54 4d bc	 movsx	 edx, WORD PTR _aPShopJewelBoundle$220063[ebp+ecx*2]
  00e35	3b fa		 cmp	 edi, edx
  00e37	7d 35		 jge	 SHORT $LN13@CGPShopReq@6

; 7993 : 						{	
; 7994 : 							ItemSerialCreateSend(lpObj->m_Index,235,0,0,iBoundleId[n],2,1,0,0,0,lpObj->m_Index,0,0,0,0);							

  00e39	8b 03		 mov	 eax, DWORD PTR [ebx]
  00e3b	6a 00		 push	 0
  00e3d	6a 00		 push	 0
  00e3f	6a 00		 push	 0
  00e41	6a 00		 push	 0
  00e43	50		 push	 eax
  00e44	6a 00		 push	 0
  00e46	6a 00		 push	 0
  00e48	6a 00		 push	 0
  00e4a	6a 01		 push	 1
  00e4c	6a 02		 push	 2
  00e4e	8b 4c b5 9c	 mov	 ecx, DWORD PTR _iBoundleId$220129[ebp+esi*4]
  00e52	51		 push	 ecx
  00e53	6a 00		 push	 0
  00e55	6a 00		 push	 0
  00e57	68 eb 00 00 00	 push	 235			; 000000ebH
  00e5c	50		 push	 eax
  00e5d	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00e62	83 c4 3c	 add	 esp, 60			; 0000003cH

; 7995 : #if (ENABLE_CUSTOM_OFFLINETRADE == 1)
; 7996 : 							lpObj->OffTradeWaitItem++;

  00e65	fe 83 30 27 00
	00		 inc	 BYTE PTR [ebx+10032]

; 7991 : 					{
; 7992 : 						for(int x = 0; x < aPShopJewelBoundle[n][0]; x++)

  00e6b	47		 inc	 edi
  00e6c	eb b9		 jmp	 SHORT $LN142@CGPShopReq@6
$LN13@CGPShopReq@6:

; 7997 : #endif
; 7998 : 						}
; 7999 : 
; 8000 : 						for(int x = 0; x < aPShopJewelBoundle[n][1]; x++)

  00e6e	33 ff		 xor	 edi, edi
$LN143@CGPShopReq@6:
  00e70	89 bd 60 ff ff
	ff		 mov	 DWORD PTR _x$220139[ebp], edi
  00e76	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  00e79	0f bf 44 55 be	 movsx	 eax, WORD PTR _aPShopJewelBoundle$220063[ebp+edx*2+2]
  00e7e	3b f8		 cmp	 edi, eax
  00e80	7d 35		 jge	 SHORT $LN10@CGPShopReq@6

; 8001 : 						{	
; 8002 : 							ItemSerialCreateSend(lpObj->m_Index,235,0,0,iBoundleId[n],1,1,0,0,0,lpObj->m_Index,0,0,0,0);

  00e82	8b 03		 mov	 eax, DWORD PTR [ebx]
  00e84	6a 00		 push	 0
  00e86	6a 00		 push	 0
  00e88	6a 00		 push	 0
  00e8a	6a 00		 push	 0
  00e8c	50		 push	 eax
  00e8d	6a 00		 push	 0
  00e8f	6a 00		 push	 0
  00e91	6a 00		 push	 0
  00e93	6a 01		 push	 1
  00e95	6a 01		 push	 1
  00e97	8b 4c b5 9c	 mov	 ecx, DWORD PTR _iBoundleId$220129[ebp+esi*4]
  00e9b	51		 push	 ecx
  00e9c	6a 00		 push	 0
  00e9e	6a 00		 push	 0
  00ea0	68 eb 00 00 00	 push	 235			; 000000ebH
  00ea5	50		 push	 eax
  00ea6	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00eab	83 c4 3c	 add	 esp, 60			; 0000003cH

; 8003 : #if (ENABLE_CUSTOM_OFFLINETRADE == 1)
; 8004 : 							lpObj->OffTradeWaitItem++;

  00eae	fe 83 30 27 00
	00		 inc	 BYTE PTR [ebx+10032]

; 7997 : #endif
; 7998 : 						}
; 7999 : 
; 8000 : 						for(int x = 0; x < aPShopJewelBoundle[n][1]; x++)

  00eb4	47		 inc	 edi
  00eb5	eb b9		 jmp	 SHORT $LN143@CGPShopReq@6
$LN10@CGPShopReq@6:

; 8005 : #endif
; 8006 : 						}
; 8007 : 
; 8008 : 						for(int x = 0; x < aPShopJewelBoundle[n][2]; x++)

  00eb7	33 ff		 xor	 edi, edi
$LN144@CGPShopReq@6:
  00eb9	89 bd 68 ff ff
	ff		 mov	 DWORD PTR _x$220143[ebp], edi
  00ebf	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  00ec2	0f bf 44 55 c0	 movsx	 eax, WORD PTR _aPShopJewelBoundle$220063[ebp+edx*2+4]
  00ec7	3b f8		 cmp	 edi, eax
  00ec9	7d 35		 jge	 SHORT $LN7@CGPShopReq@6

; 8009 : 						{	
; 8010 : 							ItemSerialCreateSend(lpObj->m_Index,235,0,0,iBoundleId[n],0,1,0,0,0,lpObj->m_Index,0,0,0,0);

  00ecb	8b 03		 mov	 eax, DWORD PTR [ebx]
  00ecd	6a 00		 push	 0
  00ecf	6a 00		 push	 0
  00ed1	6a 00		 push	 0
  00ed3	6a 00		 push	 0
  00ed5	50		 push	 eax
  00ed6	6a 00		 push	 0
  00ed8	6a 00		 push	 0
  00eda	6a 00		 push	 0
  00edc	6a 01		 push	 1
  00ede	6a 00		 push	 0
  00ee0	8b 4c b5 9c	 mov	 ecx, DWORD PTR _iBoundleId$220129[ebp+esi*4]
  00ee4	51		 push	 ecx
  00ee5	6a 00		 push	 0
  00ee7	6a 00		 push	 0
  00ee9	68 eb 00 00 00	 push	 235			; 000000ebH
  00eee	50		 push	 eax
  00eef	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00ef4	83 c4 3c	 add	 esp, 60			; 0000003cH

; 8011 : #if (ENABLE_CUSTOM_OFFLINETRADE == 1)
; 8012 : 							lpObj->OffTradeWaitItem++;

  00ef7	fe 83 30 27 00
	00		 inc	 BYTE PTR [ebx+10032]

; 8005 : #endif
; 8006 : 						}
; 8007 : 
; 8008 : 						for(int x = 0; x < aPShopJewelBoundle[n][2]; x++)

  00efd	47		 inc	 edi
  00efe	eb b9		 jmp	 SHORT $LN144@CGPShopReq@6
$LN7@CGPShopReq@6:

; 8013 : #endif
; 8014 : 						}
; 8015 : 
; 8016 : 						for(int x = 0; x < aPShopJewel[n]; x++)

  00f00	33 ff		 xor	 edi, edi
$LN145@CGPShopReq@6:
  00f02	89 bd 50 ff ff
	ff		 mov	 DWORD PTR _x$220147[ebp], edi
  00f08	0f bf 54 75 b4	 movsx	 edx, WORD PTR _aPShopJewel$220062[ebp+esi*2]
  00f0d	3b fa		 cmp	 edi, edx
  00f0f	7d 35		 jge	 SHORT $LN4@CGPShopReq@6

; 8017 : 						{	
; 8018 : 							ItemSerialCreateSend(lpObj->m_Index,235,0,0,iJewelId[n],0,1,0,0,0,lpObj->m_Index,0,0,0,0);

  00f11	8b 03		 mov	 eax, DWORD PTR [ebx]
  00f13	6a 00		 push	 0
  00f15	6a 00		 push	 0
  00f17	6a 00		 push	 0
  00f19	6a 00		 push	 0
  00f1b	50		 push	 eax
  00f1c	6a 00		 push	 0
  00f1e	6a 00		 push	 0
  00f20	6a 00		 push	 0
  00f22	6a 01		 push	 1
  00f24	6a 00		 push	 0
  00f26	8b 4c b5 90	 mov	 ecx, DWORD PTR _iJewelId$220130[ebp+esi*4]
  00f2a	51		 push	 ecx
  00f2b	6a 00		 push	 0
  00f2d	6a 00		 push	 0
  00f2f	68 eb 00 00 00	 push	 235			; 000000ebH
  00f34	50		 push	 eax
  00f35	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00f3a	83 c4 3c	 add	 esp, 60			; 0000003cH

; 8019 : #if (ENABLE_CUSTOM_OFFLINETRADE == 1)
; 8020 : 							lpObj->OffTradeWaitItem++;

  00f3d	fe 83 30 27 00
	00		 inc	 BYTE PTR [ebx+10032]

; 8013 : #endif
; 8014 : 						}
; 8015 : 
; 8016 : 						for(int x = 0; x < aPShopJewel[n]; x++)

  00f43	47		 inc	 edi
  00f44	eb bc		 jmp	 SHORT $LN145@CGPShopReq@6
$LN4@CGPShopReq@6:

; 7987 : 
; 7988 : 				for( n = 0; n < 3; n++ )

  00f46	46		 inc	 esi
  00f47	e9 c1 fe ff ff	 jmp	 $LN146@CGPShopReq@6
$LN17@CGPShopReq@6:

; 8021 : #endif
; 8022 : 						}
; 8023 : 					}
; 8024 : 				}
; 8025 : 
; 8026 : 				::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, btNewItemPos, 1);

  00f4c	6a 01		 push	 1
  00f4e	0f b6 55 86	 movzx	 edx, BYTE PTR _btNewItemPos$220105[ebp]
  00f52	52		 push	 edx
  00f53	8b 03		 mov	 eax, DWORD PTR [ebx]
  00f55	50		 push	 eax
  00f56	8b 75 8c	 mov	 esi, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00f59	56		 push	 esi
  00f5a	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 8027 : 				::CGPShopAnsSoldItem(lpObj->m_Index, aSourceIndex, lpMsg->btItemPos);

  00f5f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00f65	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00f69	52		 push	 edx
  00f6a	56		 push	 esi
  00f6b	8b 03		 mov	 eax, DWORD PTR [ebx]
  00f6d	50		 push	 eax
  00f6e	e8 00 00 00 00	 call	 ?CGPShopAnsSoldItem@@YAXHHH@Z ; CGPShopAnsSoldItem

; 8028 : 
; 8029 : 				LogAddTD("[PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s][%s] (Price=%d, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, Serial:%d",
; 8030 : 					gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, gObj[aSourceIndex].Ip_addr,
; 8031 : 					lpObj->AccountID, lpObj->Name, lpObj->Ip_addr, iPShopValue, iITEM_LOG_TYPE,
; 8032 : 					ItemAttribute[iITEM_LOG_TYPE].Name, iITEM_LOG_LEVEL, iITEM_LOG_DUR, iITEM_LOG_SERIAL);

  00f73	8d 7b 5d	 lea	 edi, DWORD PTR [ebx+93]
  00f76	8d 53 52	 lea	 edx, DWORD PTR [ebx+82]
  00f79	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00f7f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f85	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00f88	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _iITEM_LOG_SERIAL$[ebp]
  00f8e	51		 push	 ecx
  00f8f	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _iITEM_LOG_DUR$[ebp]
  00f95	51		 push	 ecx
  00f96	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _iITEM_LOG_LEVEL$[ebp]
  00f9c	51		 push	 ecx
  00f9d	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iITEM_LOG_TYPE$[ebp]
  00fa3	8b f1		 mov	 esi, ecx
  00fa5	6b f6 70	 imul	 esi, 112		; 00000070H
  00fa8	81 c6 00 00 00
	00		 add	 esi, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00fae	56		 push	 esi
  00faf	51		 push	 ecx
  00fb0	8b 4d 80	 mov	 ecx, DWORD PTR _iPShopValue$220051[ebp]
  00fb3	51		 push	 ecx
  00fb4	8d 4b 1c	 lea	 ecx, DWORD PTR [ebx+28]
  00fb7	51		 push	 ecx
  00fb8	57		 push	 edi
  00fb9	52		 push	 edx
  00fba	8d 50 1c	 lea	 edx, DWORD PTR [eax+28]
  00fbd	52		 push	 edx
  00fbe	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  00fc1	51		 push	 ecx
  00fc2	83 c0 52	 add	 eax, 82			; 00000052H
  00fc5	50		 push	 eax
  00fc6	68 00 00 00 00	 push	 OFFSET ??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@
  00fcb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00fd1	83 c4 50	 add	 esp, 80			; 00000050H

; 8033 : 
; 8034 : 				if (PShop_CheckInventoryEmpty(lpObj->m_Index) == true )

  00fd4	0f b7 13	 movzx	 edx, WORD PTR [ebx]
  00fd7	52		 push	 edx
  00fd8	e8 00 00 00 00	 call	 ?PShop_CheckInventoryEmpty@@YA_NF@Z ; PShop_CheckInventoryEmpty
  00fdd	83 c4 04	 add	 esp, 4
  00fe0	3c 01		 cmp	 al, 1
  00fe2	0f 85 a8 00 00
	00		 jne	 $LN3@CGPShopReq@6

; 8035 : 				{
; 8036 : 					LogAddTD("[PShop] [%s][%s] Sold All Items - Auto Closing PShop",
; 8037 : 						lpObj->AccountID, lpObj->Name);::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 195)), lpObj->m_Index, 1);

  00fe8	57		 push	 edi
  00fe9	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00fec	50		 push	 eax
  00fed	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@
  00ff2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00ff8	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ffb	6a 01		 push	 1
  00ffd	8b 03		 mov	 eax, DWORD PTR [ebx]
  00fff	50		 push	 eax
  01000	68 c3 04 00 00	 push	 1219			; 000004c3H
  01005	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0100a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0100f	50		 push	 eax
  01010	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8038 : 					lpObj->m_bPShopOpen = false;

  01015	c6 83 5c 12 00
	00 00		 mov	 BYTE PTR [ebx+4700], 0

; 8039 : 					memset(lpObj->m_szPShopText, 0, sizeof(lpObj->m_szPShopText));

  0101c	33 c0		 xor	 eax, eax
  0101e	89 83 60 12 00
	00		 mov	 DWORD PTR [ebx+4704], eax
  01024	89 83 64 12 00
	00		 mov	 DWORD PTR [ebx+4708], eax
  0102a	89 83 68 12 00
	00		 mov	 DWORD PTR [ebx+4712], eax
  01030	89 83 6c 12 00
	00		 mov	 DWORD PTR [ebx+4716], eax
  01036	89 83 70 12 00
	00		 mov	 DWORD PTR [ebx+4720], eax
  0103c	89 83 74 12 00
	00		 mov	 DWORD PTR [ebx+4724], eax
  01042	89 83 78 12 00
	00		 mov	 DWORD PTR [ebx+4728], eax
  01048	89 83 7c 12 00
	00		 mov	 DWORD PTR [ebx+4732], eax
  0104e	89 83 80 12 00
	00		 mov	 DWORD PTR [ebx+4736], eax

; 8040 : 					::CGPShopAnsClose(lpObj->m_Index, 1);

  01054	6a 01		 push	 1
  01056	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01058	51		 push	 ecx
  01059	e8 00 00 00 00	 call	 ?CGPShopAnsClose@@YAXHE@Z ; CGPShopAnsClose
  0105e	83 c4 14	 add	 esp, 20			; 00000014H

; 8041 : #if (ENABLE_CUSTOM_OFFLINETRADE==1)
; 8042 : 					if( lpObj->bOffTrade && lpObj->OffTradeWaitItem == 0 )

  01061	80 bb 31 27 00
	00 00		 cmp	 BYTE PTR [ebx+10033], 0
  01068	74 14		 je	 SHORT $LN1@CGPShopReq@6
  0106a	80 bb 30 27 00
	00 00		 cmp	 BYTE PTR [ebx+10032], 0
  01071	75 0b		 jne	 SHORT $LN1@CGPShopReq@6

; 8043 : 					{
; 8044 : 						gObjDel(lpObj->m_Index);

  01073	8b 13		 mov	 edx, DWORD PTR [ebx]
  01075	52		 push	 edx
  01076	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0107b	83 c4 04	 add	 esp, 4
$LN1@CGPShopReq@6:

; 8051 : 				}
; 8052 : 
; 8053 : 			}
; 8054 : 		}
; 8055 : 		__finally

  0107e	9b		 fwait
  0107f	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  01086	e8 5b 00 00 00	 call	 $LN112@CGPShopReq@6
  0108b	e9 b4 00 00 00	 jmp	 $LN113@CGPShopReq@6
$LN3@CGPShopReq@6:

; 8045 : 					}
; 8046 : #endif
; 8047 : 				}
; 8048 : 				else
; 8049 : 				{
; 8050 : 					lpObj->m_bPShopItemChange = true;

  01090	c6 83 5e 12 00
	00 01		 mov	 BYTE PTR [ebx+4702], 1
  01097	eb e5		 jmp	 SHORT $LN1@CGPShopReq@6
$LN70@CGPShopReq@6:

; 7763 : 				{
; 7764 : 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did Not Choose Item Price",
; 7765 : 						lpSourceObj->AccountID, lpSourceObj->Name,
; 7766 : 						lpObj->AccountID, lpObj->Name);

  01099	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  0109c	50		 push	 eax
  0109d	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  010a0	50		 push	 eax
  010a1	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  010a7	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  010aa	51		 push	 ecx
  010ab	83 c0 52	 add	 eax, 82			; 00000052H
  010ae	50		 push	 eax
  010af	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  010b4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7767 : 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 6);

  010ba	6a 06		 push	 6
  010bc	6a 00		 push	 0
  010be	8b 13		 mov	 edx, DWORD PTR [ebx]
  010c0	52		 push	 edx
  010c1	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  010c4	50		 push	 eax
  010c5	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7768 : 
; 7769 : 					return;

  010ca	6a fe		 push	 -2			; fffffffeH
  010cc	9b		 fwait
  010cd	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  010d0	51		 push	 ecx
  010d1	68 00 00 00 00	 push	 OFFSET ___security_cookie
  010d6	e8 00 00 00 00	 call	 __local_unwind4
  010db	83 c4 30	 add	 esp, 48			; 00000030H
  010de	eb 64		 jmp	 SHORT $LN113@CGPShopReq@6
$LN110@CGPShopReq@6:
$LN149@CGPShopReq@6:

; 8051 : 				}
; 8052 : 
; 8053 : 			}
; 8054 : 		}
; 8055 : 		__finally

  010e0	8b 9d 4c ff ff
	ff		 mov	 ebx, DWORD PTR _lpObj$[ebp]
$LN112@CGPShopReq@6:

; 8056 : 		{
; 8057 : 			lpObj->m_bPShopTransaction = false;

  010e6	c6 83 5d 12 00
	00 00		 mov	 BYTE PTR [ebx+4701], 0
$LN111@CGPShopReq@6:
$LN135@CGPShopReq@6:
  010ed	c3		 ret	 0
$LN83@CGPShopReq@6:

; 7661 : 	{
; 7662 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",
; 7663 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  010ee	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  010f1	50		 push	 eax
  010f2	8d 53 52	 lea	 edx, DWORD PTR [ebx+82]
  010f5	52		 push	 edx
  010f6	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  010f9	50		 push	 eax
  010fa	83 c6 52	 add	 esi, 82			; 00000052H
  010fd	56		 push	 esi
  010fe	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  01103	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7664 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,9);

  01109	6a 09		 push	 9
  0110b	6a 00		 push	 0
  0110d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0110f	51		 push	 ecx
  01110	8b 55 8c	 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  01113	52		 push	 edx

; 7665 : 		return;

  01114	eb 26		 jmp	 SHORT $LN136@CGPShopReq@6
$LN85@CGPShopReq@6:

; 7652 : 	{
; 7653 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",
; 7654 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  01116	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  01119	50		 push	 eax
  0111a	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  0111d	50		 push	 eax
  0111e	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  01121	51		 push	 ecx
  01122	83 c6 52	 add	 esi, 82			; 00000052H
  01125	56		 push	 esi
  01126	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0112b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7655 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,9);

  01131	6a 09		 push	 9
$LN137@CGPShopReq@6:
  01133	6a 00		 push	 0
  01135	8b 13		 mov	 edx, DWORD PTR [ebx]
  01137	52		 push	 edx
  01138	8b 45 8c	 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0113b	50		 push	 eax
$LN136@CGPShopReq@6:
  0113c	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  01141	83 c4 24	 add	 esp, 36			; 00000024H
$LN113@CGPShopReq@6:

; 8058 : 		}
; 8059 : 	}
; 8060 : }

  01144	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  01147	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0114e	59		 pop	 ecx
  0114f	5f		 pop	 edi
  01150	5e		 pop	 esi
  01151	5b		 pop	 ebx
  01152	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01155	33 cd		 xor	 ecx, ebp
  01157	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0115c	8b e5		 mov	 esp, ebp
  0115e	5d		 pop	 ebp
  0115f	c3		 ret	 0
?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ENDP ; CGPShopReqBuyItem
_TEXT	ENDS
PUBLIC	_lpMsg$GSCopy$
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ; CGPartyRequestResultRecv
EXTRN	?Paint@PartyClass@@QAEXH@Z:PROC			; PartyClass::Paint
EXTRN	?Add@PartyClass@@QAEHHHHH@Z:PROC		; PartyClass::Add
EXTRN	?Create@PartyClass@@QAEHHHH@Z:PROC		; PartyClass::Create
; Function compile flags: /Ogtp
;	COMDAT ?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$ = -276					; size = 4
_pnumber$ = -272					; size = 4
_aIndex$GSCopy$ = -268					; size = 4
_result$ = -261						; size = 1
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z PROC ; CGPartyRequestResultRecv, COMDAT

; 8334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 8335 : 	int number;
; 8336 : 	BYTE result = false;
; 8337 : 	char szTemp[256];
; 8338 : 	int pnumber = -1;
; 8339 : 
; 8340 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  0001c	56		 push	 esi
  0001d	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00020	89 b5 f4 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  00026	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0002c	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0002f	51		 push	 ecx
  00030	89 9d ec fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], ebx
  00036	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  0003d	c7 85 f0 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _pnumber$[ebp], -1
  00047	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0004c	83 c4 04	 add	 esp, 4
  0004f	85 c0		 test	 eax, eax
  00051	0f 84 4b 04 00
	00		 je	 $LN25@CGPartyReq@2

; 8341 : 		return;
; 8342 : 
; 8343 : 	number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00057	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  0005b	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  0005f	66 c1 e2 08	 shl	 dx, 8
  00063	57		 push	 edi
  00064	0f b7 fa	 movzx	 edi, dx
  00067	0b f8		 or	 edi, eax

; 8344 : 
; 8345 : 	if ( number < 0 || number > OBJMAX-1)

  00069	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0006f	0f 87 2c 04 00
	00		 ja	 $LN50@CGPartyReq@2

; 8346 : 		return;
; 8347 : 
; 8348 : 	if ( !gObjIsConnected(&gObj[aIndex]))

  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007b	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00084	83 c4 04	 add	 esp, 4
  00087	85 c0		 test	 eax, eax
  00089	0f 84 12 04 00
	00		 je	 $LN50@CGPartyReq@2

; 8349 : 		return;
; 8350 : 
; 8351 : 	if ( !gObjIsConnected(&gObj[number]))

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00094	8b df		 mov	 ebx, edi
  00096	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  0009c	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000a5	83 c4 04	 add	 esp, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 15		 jne	 SHORT $LN23@CGPartyReq@2

; 8352 : 	{
; 8353 : 		GCResultSend(aIndex, 0x41, 0x04);

  000ac	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  000b2	6a 04		 push	 4
  000b4	6a 41		 push	 65			; 00000041H
  000b6	52		 push	 edx
  000b7	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8354 : 	}
; 8355 : 	else

  000bf	eb 07		 jmp	 SHORT $LN22@CGPartyReq@2
$LN23@CGPartyReq@2:

; 8356 : 	{
; 8357 : 		result = true;

  000c1	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR _result$[ebp], 1
$LN22@CGPartyReq@2:

; 8358 : 	}
; 8359 : 
; 8360 : 	if ( gObj[number].MapNumber != gObj[aIndex].MapNumber )

  000c8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cd	8a 8c 03 23 01
	00 00		 mov	 cl, BYTE PTR [ebx+eax+291]
  000d4	3a 8c 06 23 01
	00 00		 cmp	 cl, BYTE PTR [esi+eax+291]
  000db	74 19		 je	 SHORT $LN21@CGPartyReq@2

; 8361 : 	{
; 8362 : 		result = false;
; 8363 : 		GCResultSend(number, 0x41, 0x00);

  000dd	6a 00		 push	 0
  000df	6a 41		 push	 65			; 00000041H
  000e1	57		 push	 edi
  000e2	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  000e9	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  000ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@CGPartyReq@2:

; 8364 : 	}
; 8365 : 
; 8366 : 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  000f6	0f b6 8c 06 23
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+291]
  000fe	80 f9 35	 cmp	 cl, 53			; 00000035H
  00101	74 0e		 je	 SHORT $LN40@CGPartyReq@2
  00103	80 f9 12	 cmp	 cl, 18			; 00000012H
  00106	72 40		 jb	 SHORT $LN42@CGPartyReq@2
  00108	b2 17		 mov	 dl, 23			; 00000017H
  0010a	3a d1		 cmp	 dl, cl
  0010c	1b c9		 sbb	 ecx, ecx
  0010e	41		 inc	 ecx
  0010f	74 37		 je	 SHORT $LN42@CGPartyReq@2
$LN40@CGPartyReq@2:

; 8367 : 	{
; 8368 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 198)), aIndex, 1);

  00111	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00117	6a 01		 push	 1
  00119	50		 push	 eax
  0011a	68 c6 04 00 00	 push	 1222			; 000004c6H
  0011f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00124	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8369 : 		result = false;
; 8370 : 		::GCResultSend(number, 0x41, 0x00);

  0012f	6a 00		 push	 0
  00131	6a 41		 push	 65			; 00000041H
  00133	57		 push	 edi
  00134	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  0013b	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00140	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00145	83 c4 18	 add	 esp, 24			; 00000018H
$LN42@CGPartyReq@2:

; 8371 : 	}
; 8372 : 
; 8373 : 	if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) )

  00148	0f b6 8c 06 23
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+291]
  00150	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  00153	72 35		 jb	 SHORT $LN44@CGPartyReq@2
  00155	b2 32		 mov	 dl, 50			; 00000032H
  00157	3a d1		 cmp	 dl, cl
  00159	1b c9		 sbb	 ecx, ecx
  0015b	41		 inc	 ecx
  0015c	74 2c		 je	 SHORT $LN44@CGPartyReq@2

; 8374 : 	{
; 8375 : 		GCServerMsgStringSend("Party not allowed in Illusion Temple.", aIndex, 1);

  0015e	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00164	6a 01		 push	 1
  00166	50		 push	 eax
  00167	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@
  0016c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8376 : 		result = false;
; 8377 : 		::GCResultSend(number, 0x41, 0x00);

  00171	6a 00		 push	 0
  00173	6a 41		 push	 65			; 00000041H
  00175	57		 push	 edi
  00176	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  0017d	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00182	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00187	83 c4 18	 add	 esp, 24			; 00000018H
$LN44@CGPartyReq@2:

; 8378 : 	}
; 8379 : 
; 8380 : 	if ( DG_MAP_RANGE(gObj[aIndex].MapNumber) )

  0018a	0f b6 8c 06 23
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+291]
  00192	80 f9 41	 cmp	 cl, 65			; 00000041H
  00195	72 35		 jb	 SHORT $LN45@CGPartyReq@2
  00197	b2 44		 mov	 dl, 68			; 00000044H
  00199	3a d1		 cmp	 dl, cl
  0019b	1b c9		 sbb	 ecx, ecx
  0019d	41		 inc	 ecx
  0019e	74 2c		 je	 SHORT $LN45@CGPartyReq@2

; 8381 : 	{
; 8382 : 		GCServerMsgStringSend("Party not allowed in Doppelganger.", aIndex, 1);

  001a0	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  001a6	6a 01		 push	 1
  001a8	50		 push	 eax
  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@
  001ae	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8383 : 		result = false;
; 8384 : 		::GCResultSend(number, 0x41, 0x00);

  001b3	6a 00		 push	 0
  001b5	6a 41		 push	 65			; 00000041H
  001b7	57		 push	 edi
  001b8	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  001bf	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c9	83 c4 18	 add	 esp, 24			; 00000018H
$LN45@CGPartyReq@2:

; 8385 : 	}
; 8386 : 
; 8387 : 	if ( IF_MAP_RANGE(gObj[aIndex].MapNumber) )

  001cc	0f b6 8c 06 23
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+291]
  001d4	80 f9 45	 cmp	 cl, 69			; 00000045H
  001d7	72 35		 jb	 SHORT $LN46@CGPartyReq@2
  001d9	b2 48		 mov	 dl, 72			; 00000048H
  001db	3a d1		 cmp	 dl, cl
  001dd	1b c9		 sbb	 ecx, ecx
  001df	41		 inc	 ecx
  001e0	74 2c		 je	 SHORT $LN46@CGPartyReq@2

; 8388 : 	{
; 8389 : 		GCServerMsgStringSend("Party not allowed in Imperial Fort.", aIndex, 1);

  001e2	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  001e8	6a 01		 push	 1
  001ea	50		 push	 eax
  001eb	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@
  001f0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8390 : 		result = false;
; 8391 : 		::GCResultSend(number, 0x41, 0x00);

  001f5	6a 00		 push	 0
  001f7	6a 41		 push	 65			; 00000041H
  001f9	57		 push	 edi
  001fa	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  00201	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00206	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020b	83 c4 18	 add	 esp, 24			; 00000018H
$LN46@CGPartyReq@2:

; 8392 : 	}
; 8393 : 
; 8394 : 	if ( lpMsg->Result == 0 )

  0020e	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00214	80 79 03 00	 cmp	 BYTE PTR [ecx+3], 0
  00218	75 19		 jne	 SHORT $LN16@CGPartyReq@2

; 8395 : 	{
; 8396 : 		result = false;
; 8397 : 		::GCResultSend(number, 0x41, 0x01);

  0021a	6a 01		 push	 1
  0021c	6a 41		 push	 65			; 00000041H
  0021e	57		 push	 edi
  0021f	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  00226	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0022b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00230	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@CGPartyReq@2:

; 8398 : 	}
; 8399 : 
; 8400 : 	if ( gObj[number].m_IfState.use == 0 || gObj[number].m_IfState.type != 2)

  00233	8b 8c 03 b8 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4536]
  0023a	f6 c1 03	 test	 cl, 3
  0023d	74 0e		 je	 SHORT $LN14@CGPartyReq@2
  0023f	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00245	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0024b	74 19		 je	 SHORT $LN15@CGPartyReq@2
$LN14@CGPartyReq@2:

; 8401 : 	{
; 8402 : 		result = false;
; 8403 : 		::GCResultSend(number, 0x41, 0x00);

  0024d	6a 00		 push	 0
  0024f	6a 41		 push	 65			; 00000041H
  00251	57		 push	 edi
  00252	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  00259	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0025e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00263	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@CGPartyReq@2:

; 8404 : 	}	
; 8405 : 	
; 8406 : 	if ( gObj[aIndex].m_IfState.use == 0 || gObj[aIndex].m_IfState.type != 2)

  00266	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  0026d	f6 c1 03	 test	 cl, 3
  00270	74 0e		 je	 SHORT $LN12@CGPartyReq@2
  00272	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00278	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0027e	74 12		 je	 SHORT $LN13@CGPartyReq@2
$LN12@CGPartyReq@2:

; 8407 : 	{
; 8408 : 		result = false;
; 8409 : 		::GCResultSend(number, 0x41, 0x00);

  00280	6a 00		 push	 0
  00282	6a 41		 push	 65			; 00000041H
  00284	57		 push	 edi
  00285	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0028a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8410 : 	}
; 8411 : 
; 8412 : 	if ( result == 1 )

  0028d	e9 8a 01 00 00	 jmp	 $LN41@CGPartyReq@2
$LN13@CGPartyReq@2:
  00292	80 bd fb fe ff
	ff 01		 cmp	 BYTE PTR _result$[ebp], 1
  00299	0f 85 82 01 00
	00		 jne	 $LN47@CGPartyReq@2

; 8413 : 	{
; 8414 : 		if ( gObj[number].PartyNumber < 0 )

  0029f	83 bc 03 0c 06
	00 00 00	 cmp	 DWORD PTR [ebx+eax+1548], 0
  002a7	7d 39		 jge	 SHORT $LN52@CGPartyReq@2

; 8415 : 		{
; 8416 : 			gObj[number].PartyNumber = gParty.Create(number, gObj[number].DBNumber, gObj[number].Level);

  002a9	0f bf 94 03 96
	00 00 00	 movsx	 edx, WORD PTR [ebx+eax+150]
  002b1	8b 44 03 30	 mov	 eax, DWORD PTR [ebx+eax+48]
  002b5	52		 push	 edx
  002b6	50		 push	 eax
  002b7	57		 push	 edi
  002b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  002bd	e8 00 00 00 00	 call	 ?Create@PartyClass@@QAEHHHH@Z ; PartyClass::Create
  002c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c8	89 84 0b 0c 06
	00 00		 mov	 DWORD PTR [ebx+ecx+1548], eax
  002cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 8417 : 		}
; 8418 : 
; 8419 : 		if ( gObj[number].PartyNumber >= 0  )

  002d4	83 bc 03 0c 06
	00 00 00	 cmp	 DWORD PTR [ebx+eax+1548], 0
  002dc	0f 8c 3f 01 00
	00		 jl	 $LN47@CGPartyReq@2
$LN52@CGPartyReq@2:

; 8420 : 		{
; 8421 : 			pnumber = gObj[number].PartyNumber;
; 8422 : 			int iPartyPos = gParty.Add(gObj[number].PartyNumber, aIndex, gObj[aIndex].DBNumber, gObj[aIndex].Level);

  002e2	0f bf 94 06 96
	00 00 00	 movsx	 edx, WORD PTR [esi+eax+150]
  002ea	8b 8c 03 0c 06
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+1548]
  002f1	8b 44 06 30	 mov	 eax, DWORD PTR [esi+eax+48]
  002f5	52		 push	 edx
  002f6	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  002fc	50		 push	 eax
  002fd	52		 push	 edx
  002fe	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _pnumber$[ebp], ecx
  00304	51		 push	 ecx
  00305	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0030a	e8 00 00 00 00	 call	 ?Add@PartyClass@@QAEHHHHH@Z ; PartyClass::Add

; 8423 : 
; 8424 : 			if ( iPartyPos >= 0 )

  0030f	85 c0		 test	 eax, eax
  00311	0f 88 9f 00 00
	00		 js	 $LN8@CGPartyReq@2

; 8425 : 			{
; 8426 : 				gObj[aIndex].PartyNumber = gObj[number].PartyNumber;

  00317	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0031c	8b 8c 03 0c 06
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+1548]
  00323	89 8c 06 0c 06
	00 00		 mov	 DWORD PTR [esi+eax+1548], ecx

; 8427 : 				result = true;
; 8428 : 				wsprintf(szTemp, lMsg.Get(MSGGET(4, 83)), gObj[aIndex].Name);

  0032a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00330	8d 44 16 5d	 lea	 eax, DWORD PTR [esi+edx+93]
  00334	50		 push	 eax
  00335	68 53 04 00 00	 push	 1107			; 00000453H
  0033a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0033f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00344	50		 push	 eax
  00345	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0034b	51		 push	 ecx
  0034c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 8429 : 				::GCServerMsgStringSend(szTemp, number, 1);

  00352	6a 01		 push	 1
  00354	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  0035a	57		 push	 edi
  0035b	52		 push	 edx
  0035c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8430 : 				wsprintf(szTemp, lMsg.Get(MSGGET(4, 83)), gObj[number].Name);

  00361	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00366	83 c4 18	 add	 esp, 24			; 00000018H
  00369	8d 4c 03 5d	 lea	 ecx, DWORD PTR [ebx+eax+93]
  0036d	51		 push	 ecx
  0036e	68 53 04 00 00	 push	 1107			; 00000453H
  00373	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00378	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0037d	50		 push	 eax
  0037e	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00384	52		 push	 edx
  00385	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 8431 : 				::GCServerMsgStringSend(szTemp, aIndex, 1);

  0038b	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00391	6a 01		 push	 1
  00393	50		 push	 eax
  00394	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0039a	51		 push	 ecx
  0039b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8432 : 
; 8433 : 				gParty.Paint(pnumber);

  003a0	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _pnumber$[ebp]
  003a6	83 c4 18	 add	 esp, 24			; 00000018H
  003a9	52		 push	 edx
  003aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  003af	e8 00 00 00 00	 call	 ?Paint@PartyClass@@QAEXH@Z ; PartyClass::Paint
  003b4	eb 66		 jmp	 SHORT $LN41@CGPartyReq@2
$LN8@CGPartyReq@2:

; 8434 : 			}
; 8435 : 			else if ( iPartyPos == -1 )

  003b6	83 f8 ff	 cmp	 eax, -1
  003b9	75 1c		 jne	 SHORT $LN6@CGPartyReq@2

; 8436 : 			{
; 8437 : 				GCResultSend(number, 0x41, 2);

  003bb	6a 02		 push	 2
  003bd	6a 41		 push	 65			; 00000041H
  003bf	57		 push	 edi
  003c0	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 8438 : 				GCResultSend(aIndex, 0x41, 2);

  003c5	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  003cb	6a 02		 push	 2
  003cd	6a 41		 push	 65			; 00000041H
  003cf	50		 push	 eax
  003d0	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  003d5	eb 42		 jmp	 SHORT $LN53@CGPartyReq@2
$LN6@CGPartyReq@2:

; 8439 : 			}
; 8440 : 			else if ( iPartyPos == -2 )

  003d7	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  003da	75 40		 jne	 SHORT $LN41@CGPartyReq@2

; 8441 : 			{
; 8442 : 				result = 2;
; 8443 : 				wsprintf(szTemp, lMsg.Get(MSGGET(4, 84)), gObj[aIndex].Name);

  003dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003e2	8d 54 0e 5d	 lea	 edx, DWORD PTR [esi+ecx+93]
  003e6	52		 push	 edx
  003e7	68 54 04 00 00	 push	 1108			; 00000454H
  003ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003f1	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003f6	50		 push	 eax
  003f7	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  003fd	50		 push	 eax
  003fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 8444 : 				GCServerMsgStringSend(szTemp, aIndex, 1);

  00404	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0040a	6a 01		 push	 1
  0040c	51		 push	 ecx
  0040d	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00413	52		 push	 edx
  00414	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
$LN53@CGPartyReq@2:
  00419	83 c4 18	 add	 esp, 24			; 00000018H
$LN41@CGPartyReq@2:
  0041c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN47@CGPartyReq@2:

; 8445 : 			}
; 8446 : 		}
; 8447 : 	}
; 8448 : 
; 8449 : 	if ( gObj[aIndex].m_IfState.use !=  0 && gObj[aIndex].m_IfState.type == 2)

  00421	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  00428	ba fc ff ff ff	 mov	 edx, -4			; fffffffcH
  0042d	f6 c1 03	 test	 cl, 3
  00430	74 2a		 je	 SHORT $LN48@CGPartyReq@2
  00432	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00438	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0043e	75 1c		 jne	 SHORT $LN48@CGPartyReq@2

; 8450 : 	{
; 8451 : 		gObj[aIndex].m_IfState.use = 0;

  00440	21 94 06 b8 11
	00 00		 and	 DWORD PTR [esi+eax+4536], edx

; 8452 : 		gObj[aIndex].PartyTargetUser = -1;

  00447	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0044c	c7 84 06 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+eax+1552], -1
  00457	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN48@CGPartyReq@2:

; 8453 : 	}
; 8454 : 
; 8455 : 	if ( gObj[number].m_IfState.use !=  0 && gObj[number].m_IfState.type == 2)

  0045c	8b 8c 03 b8 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4536]
  00463	f6 c1 03	 test	 cl, 3
  00466	74 26		 je	 SHORT $LN2@CGPartyReq@2
  00468	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0046e	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00474	75 18		 jne	 SHORT $LN2@CGPartyReq@2

; 8456 : 	{
; 8457 : 		gObj[number].m_IfState.use = 0;

  00476	21 94 03 b8 11
	00 00		 and	 DWORD PTR [ebx+eax+4536], edx

; 8458 : 		gObj[number].PartyTargetUser = -1;

  0047d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00483	c7 84 0b 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ebx+ecx+1552], -1
$LN2@CGPartyReq@2:

; 8459 : 	}
; 8460 : 
; 8461 : 	if ( pnumber >= 0 )

  0048e	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _pnumber$[ebp]
  00494	85 c0		 test	 eax, eax
  00496	78 09		 js	 SHORT $LN50@CGPartyReq@2

; 8462 : 	{
; 8463 : 		CGPartyListAll(pnumber);

  00498	50		 push	 eax
  00499	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  0049e	83 c4 04	 add	 esp, 4
$LN50@CGPartyReq@2:
  004a1	5f		 pop	 edi
$LN25@CGPartyReq@2:

; 8464 : 	}
; 8465 : }

  004a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a5	5e		 pop	 esi
  004a6	33 cd		 xor	 ecx, ebp
  004a8	5b		 pop	 ebx
  004a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ae	8b e5		 mov	 esp, ebp
  004b0	5d		 pop	 ebp
  004b1	c3		 ret	 0
?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ENDP ; CGPartyRequestResultRecv
_TEXT	ENDS
PUBLIC	??_C@_0CG@IDLFABNI@PartyMember?$CI?$CFd?$CJ?5?3?5Party?5Out?4?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0P@GAPFACKC@User?5Not?5found?$AA@		; `string'
PUBLIC	??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z	; CGPartyDelUser
EXTRN	?Destroy@PartyClass@@QAEHH@Z:PROC		; PartyClass::Destroy
EXTRN	?ChangeLeader@PartyClass@@QAEXH@Z:PROC		; PartyClass::ChangeLeader
EXTRN	?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z:PROC	; PartyClass::UpdatePKPartyPanalty
EXTRN	?Delete@PartyClass@@QAEXHH@Z:PROC		; PartyClass::Delete
EXTRN	?TidyUpTempuserdate@@YAXHHE@Z:PROC		; TidyUpTempuserdate
;	COMDAT ??_C@_0CG@IDLFABNI@PartyMember?$CI?$CFd?$CJ?5?3?5Party?5Out?4?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0CG@IDLFABNI@PartyMember?$CI?$CFd?$CJ?5?3?5Party?5Out?4?5?$FL?$CFs@ DB 'P'
	DB	'artyMember(%d) : Party Out. [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@ DB '%s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GAPFACKC@User?5Not?5found?$AA@
CONST	SEGMENT
??_C@_0P@GAPFACKC@User?5Not?5found?$AA@ DB 'User Not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@ DB 'No Party %s %s', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z
_TEXT	SEGMENT
tv561 = -16						; size = 4
_dbnumber$ = -12					; size = 4
_count$ = -8						; size = 4
_usernumber$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
tv874 = 12						; size = 4
_aIndex$ = 12						; size = 4
tv564 = 15						; size = 1
?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z PROC	; CGPartyDelUser, COMDAT

; 8625 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8626 : 	int usernumber = -1;
; 8627 : 	int dbnumber = -1;
; 8628 : 
; 8629 : 	if ( gObj[aIndex].PartyNumber < 0 )

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	56		 push	 esi
  0000d	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00010	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00016	83 c8 ff	 or	 eax, -1
  00019	89 45 fc	 mov	 DWORD PTR _usernumber$[ebp], eax
  0001c	89 45 f4	 mov	 DWORD PTR _dbnumber$[ebp], eax
  0001f	8b 84 0e 0c 06
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1548]
  00026	85 c0		 test	 eax, eax
  00028	79 1d		 jns	 SHORT $LN41@CGPartyDel

; 8630 : 	{
; 8631 : 		LogAdd("No Party %s %s", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0002a	8d 44 0e 5d	 lea	 eax, DWORD PTR [esi+ecx+93]
  0002e	50		 push	 eax
  0002f	8d 4c 0e 52	 lea	 ecx, DWORD PTR [esi+ecx+82]
  00033	51		 push	 ecx
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	5e		 pop	 esi

; 8841 : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN41@CGPartyDel:

; 8632 : 		return;
; 8633 : 	}
; 8634 : 
; 8635 : 	if ( !gParty.GetIndexUser(gObj[aIndex].PartyNumber, lpMsg->Number, usernumber, dbnumber))

  00047	8d 55 f4	 lea	 edx, DWORD PTR _dbnumber$[ebp]
  0004a	52		 push	 edx
  0004b	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0004e	8d 4d fc	 lea	 ecx, DWORD PTR _usernumber$[ebp]
  00051	51		 push	 ecx
  00052	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  00056	51		 push	 ecx
  00057	50		 push	 eax
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0005d	e8 00 00 00 00	 call	 ?GetIndexUser@PartyClass@@QAEHHHAAH0@Z ; PartyClass::GetIndexUser
  00062	85 c0		 test	 eax, eax
  00064	75 13		 jne	 SHORT $LN40@CGPartyDel
$LN94@CGPartyDel:

; 8636 : 	{
; 8637 : 		LogAdd("User Not found");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAPFACKC@User?5Not?5found?$AA@
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00071	83 c4 04	 add	 esp, 4
  00074	5e		 pop	 esi

; 8841 : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN40@CGPartyDel:

; 8638 : 		return;
; 8639 : 	}
; 8640 : 
; 8641 : 	if ( usernumber < 0 )

  00079	83 7d fc 00	 cmp	 DWORD PTR _usernumber$[ebp], 0

; 8642 : 	{
; 8643 : 		LogAdd("User Not found");
; 8644 : 		return;

  0007d	7c e7		 jl	 SHORT $LN94@CGPartyDel

; 8645 : 	}
; 8646 : 
; 8647 : 	int count;
; 8648 : 	int number;
; 8649 : 	int pnumber = gObj[aIndex].PartyNumber;

  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00085	8b b4 16 0c 06
	00 00		 mov	 esi, DWORD PTR [esi+edx+1548]

; 8650 : 
; 8651 : 	if ( pnumber < 0 )

  0008c	85 f6		 test	 esi, esi
  0008e	79 1d		 jns	 SHORT $LN38@CGPartyDel

; 8652 : 	{
; 8653 : 		LogAdd("%s %d", __FILE__, __LINE__);

  00090	68 cd 21 00 00	 push	 8653			; 000021cdH
$LN95@CGPartyDel:
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	5e		 pop	 esi

; 8841 : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN38@CGPartyDel:

; 8654 : 		return;
; 8655 : 	}
; 8656 : 
; 8657 : 	count = gParty.GetCount(pnumber);

  000ad	56		 push	 esi
  000ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000b3	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  000b8	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 8658 : 
; 8659 : 	if ( count < 1 )

  000bb	83 f8 01	 cmp	 eax, 1
  000be	7d 07		 jge	 SHORT $LN37@CGPartyDel

; 8660 : 	{
; 8661 : 		LogAdd("%s %d", __FILE__, __LINE__);

  000c0	68 d5 21 00 00	 push	 8661			; 000021d5H

; 8662 : 		return;

  000c5	eb ce		 jmp	 SHORT $LN95@CGPartyDel
$LN37@CGPartyDel:
  000c7	53		 push	 ebx

; 8663 : 	}
; 8664 : 
; 8665 : 	if( !IF_MAP_RANGE(gObj[usernumber].MapNumber) &&
; 8666 : 		!IT_MAP_RANGE(gObj[usernumber].MapNumber) )

  000c8	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ce	57		 push	 edi
  000cf	8b 7d fc	 mov	 edi, DWORD PTR _usernumber$[ebp]
  000d2	8b c7		 mov	 eax, edi
  000d4	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  000da	8a 84 18 23 01
	00 00		 mov	 al, BYTE PTR [eax+ebx+291]
  000e1	3c 45		 cmp	 al, 69			; 00000045H
  000e3	72 0c		 jb	 SHORT $LN83@CGPartyDel
  000e5	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000ea	3a c8		 cmp	 cl, al
  000ec	1b c9		 sbb	 ecx, ecx
  000ee	41		 inc	 ecx
  000ef	75 25		 jne	 SHORT $LN36@CGPartyDel
$LN83@CGPartyDel:
  000f1	3c 2d		 cmp	 al, 45			; 0000002dH
  000f3	72 09		 jb	 SHORT $LN72@CGPartyDel
  000f5	b2 32		 mov	 dl, 50			; 00000032H
  000f7	3a d0		 cmp	 dl, al
  000f9	1b c0		 sbb	 eax, eax
  000fb	40		 inc	 eax
  000fc	75 18		 jne	 SHORT $LN36@CGPartyDel
$LN72@CGPartyDel:

; 8667 : 	{
; 8668 : 		TidyUpTempuserdate(usernumber,pnumber,lpMsg->Number);

  000fe	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00101	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00105	51		 push	 ecx
  00106	56		 push	 esi
  00107	57		 push	 edi
  00108	e8 00 00 00 00	 call	 ?TidyUpTempuserdate@@YAXHHE@Z ; TidyUpTempuserdate
  0010d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@CGPartyDel:

; 8669 : 	}
; 8670 : 
; 8671 : 	if( DG_MAP_RANGE(gObj[usernumber].MapNumber) )

  00116	8b 55 fc	 mov	 edx, DWORD PTR _usernumber$[ebp]
  00119	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  0011f	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  00122	8a 90 23 01 00
	00		 mov	 dl, BYTE PTR [eax+291]
  00128	89 45 f0	 mov	 DWORD PTR tv561[ebp], eax
  0012b	88 55 0f	 mov	 BYTE PTR tv564[ebp], dl
  0012e	80 fa 41	 cmp	 dl, 65			; 00000041H
  00131	72 10		 jb	 SHORT $LN84@CGPartyDel
  00133	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  00138	3a c2		 cmp	 al, dl
  0013a	1b c0		 sbb	 eax, eax
  0013c	40		 inc	 eax
  0013d	0f 85 55 04 00
	00		 jne	 $LN88@CGPartyDel
$LN84@CGPartyDel:

; 8672 : 		return;
; 8673 : 
; 8674 : 	if( lpMsg->Number == 0 )

  00143	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00146	80 79 03 00	 cmp	 BYTE PTR [ecx+3], 0
  0014a	75 4d		 jne	 SHORT $LN78@CGPartyDel

; 8675 : 	{
; 8676 : 		int bDPUser = FALSE;
; 8677 : 
; 8678 : 		for(int n = 1; n < MAX_USER_IN_PARTY; n++)

  0014c	8b c6		 mov	 eax, esi
  0014e	c1 e0 04	 shl	 eax, 4
  00151	2b c6		 sub	 eax, esi
  00153	b9 01 00 00 00	 mov	 ecx, 1
  00158	8d 3c 85 10 00
	00 00		 lea	 edi, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+16]
  0015f	90		 npad	 1
$LL33@CGPartyDel:

; 8679 : 		{
; 8680 : 			int nUserIndex = gParty.m_PartyS[pnumber].Number[n];

  00160	8b 07		 mov	 eax, DWORD PTR [edi]

; 8681 : 
; 8682 : 			if( nUserIndex != -1 )

  00162	83 f8 ff	 cmp	 eax, -1
  00165	74 1e		 je	 SHORT $LN32@CGPartyDel

; 8683 : 			{
; 8684 : 				if( DG_MAP_RANGE(gObj[nUserIndex].MapNumber) )

  00167	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0016d	0f b6 84 18 23
	01 00 00	 movzx	 eax, BYTE PTR [eax+ebx+291]
  00175	3c 41		 cmp	 al, 65			; 00000041H
  00177	72 0c		 jb	 SHORT $LN32@CGPartyDel
  00179	b2 44		 mov	 dl, 68			; 00000044H
  0017b	3a d0		 cmp	 dl, al
  0017d	1b c0		 sbb	 eax, eax
  0017f	40		 inc	 eax
  00180	75 0e		 jne	 SHORT $LN64@CGPartyDel
  00182	8a 55 0f	 mov	 dl, BYTE PTR tv564[ebp]
$LN32@CGPartyDel:

; 8675 : 	{
; 8676 : 		int bDPUser = FALSE;
; 8677 : 
; 8678 : 		for(int n = 1; n < MAX_USER_IN_PARTY; n++)

  00185	41		 inc	 ecx
  00186	83 c7 04	 add	 edi, 4
  00189	83 f9 05	 cmp	 ecx, 5
  0018c	7c d2		 jl	 SHORT $LL33@CGPartyDel

; 8763 : 				
; 8764 : 				if( number >= 0 &&
; 8765 : 					gObj[number].lpGuild != NULL &&
; 8766 : 					gObj[number].lpGuild->WarState == 1 &&
; 8767 : 					gObj[number].IsInBattleGround )

  0018e	eb 09		 jmp	 SHORT $LN78@CGPartyDel
$LN64@CGPartyDel:

; 8685 : 				{
; 8686 : 					bDPUser = TRUE;
; 8687 : 					break;
; 8688 : 				}
; 8689 : 			}
; 8690 : 		}
; 8691 : 
; 8692 : 		if( bDPUser == TRUE && count > 2 )

  00190	83 7d f8 02	 cmp	 DWORD PTR _count$[ebp], 2

; 8693 : 		{
; 8694 : 			gParty.Delete(pnumber,lpMsg->Number);
; 8695 : 			count = gParty.GetCount(pnumber);
; 8696 : 			gObj[usernumber].PartyNumber = -1;
; 8697 : 			gObj[usernumber].PartyTargetUser = -1;
; 8698 : 
; 8699 : 			gParty.UpdatePKPartyPanalty(pnumber);
; 8700 : 			gParty.ChangeLeader(pnumber);
; 8701 : 			GCPartyDelUserSend(usernumber);
; 8702 : 			CGPartyListAll(pnumber);
; 8703 : 
; 8704 : 			LogAddTD("PartyMember(%d) : Party Out. [%s][%s]",
; 8705 : 				usernumber,gObj[usernumber].AccountID,gObj[usernumber].Name);
; 8706 : 			return;

  00194	7f 77		 jg	 SHORT $LN93@CGPartyDel
  00196	8a 55 0f	 mov	 dl, BYTE PTR tv564[ebp]
$LN78@CGPartyDel:

; 8707 : 		}
; 8708 : 	}
; 8709 : 
; 8710 : 	if( IF_MAP_RANGE(gObj[usernumber].MapNumber) )

  00199	80 fa 45	 cmp	 dl, 69			; 00000045H
  0019c	72 10		 jb	 SHORT $LN75@CGPartyDel
  0019e	b8 48 00 00 00	 mov	 eax, 72			; 00000048H
  001a3	3a c2		 cmp	 al, dl
  001a5	1b c0		 sbb	 eax, eax
  001a7	40		 inc	 eax
  001a8	0f 85 ea 03 00
	00		 jne	 $LN88@CGPartyDel
$LN75@CGPartyDel:

; 8711 : 		return;
; 8712 : 
; 8713 : 	if( lpMsg->Number == 0 )

  001ae	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001b1	80 79 03 00	 cmp	 BYTE PTR [ecx+3], 0
  001b5	0f 85 f1 00 00
	00		 jne	 $LN20@CGPartyDel

; 8714 : 	{
; 8715 : 		int bDPUser = FALSE;
; 8716 : 
; 8717 : 		for(int n = 1; n < MAX_USER_IN_PARTY; n++)

  001bb	8b c6		 mov	 eax, esi
  001bd	c1 e0 04	 shl	 eax, 4
  001c0	2b c6		 sub	 eax, esi
  001c2	b9 01 00 00 00	 mov	 ecx, 1
  001c7	8d 3c 85 10 00
	00 00		 lea	 edi, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+16]
  001ce	8b ff		 npad	 2
$LL25@CGPartyDel:

; 8718 : 		{
; 8719 : 			int nUserIndex = gParty.m_PartyS[pnumber].Number[n];

  001d0	8b 07		 mov	 eax, DWORD PTR [edi]

; 8720 : 
; 8721 : 			if( nUserIndex != -1 )

  001d2	83 f8 ff	 cmp	 eax, -1
  001d5	74 1e		 je	 SHORT $LN24@CGPartyDel

; 8722 : 			{
; 8723 : 				if( IF_MAP_RANGE(gObj[nUserIndex].MapNumber) )

  001d7	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  001dd	0f b6 84 18 23
	01 00 00	 movzx	 eax, BYTE PTR [eax+ebx+291]
  001e5	3c 45		 cmp	 al, 69			; 00000045H
  001e7	72 0c		 jb	 SHORT $LN24@CGPartyDel
  001e9	b2 48		 mov	 dl, 72			; 00000048H
  001eb	3a d0		 cmp	 dl, al
  001ed	1b c0		 sbb	 eax, eax
  001ef	40		 inc	 eax
  001f0	75 11		 jne	 SHORT $LN65@CGPartyDel
  001f2	8a 55 0f	 mov	 dl, BYTE PTR tv564[ebp]
$LN24@CGPartyDel:

; 8714 : 	{
; 8715 : 		int bDPUser = FALSE;
; 8716 : 
; 8717 : 		for(int n = 1; n < MAX_USER_IN_PARTY; n++)

  001f5	41		 inc	 ecx
  001f6	83 c7 04	 add	 edi, 4
  001f9	83 f9 05	 cmp	 ecx, 5
  001fc	7c d2		 jl	 SHORT $LL25@CGPartyDel

; 8763 : 				
; 8764 : 				if( number >= 0 &&
; 8765 : 					gObj[number].lpGuild != NULL &&
; 8766 : 					gObj[number].lpGuild->WarState == 1 &&
; 8767 : 					gObj[number].IsInBattleGround )

  001fe	e9 a9 00 00 00	 jmp	 $LN20@CGPartyDel
$LN65@CGPartyDel:

; 8724 : 				{
; 8725 : 					bDPUser = TRUE;
; 8726 : 					break;
; 8727 : 				}
; 8728 : 			}
; 8729 : 		}
; 8730 : 
; 8731 : 		if( bDPUser == TRUE && count > 2 )

  00203	83 7d f8 02	 cmp	 DWORD PTR _count$[ebp], 2
  00207	0f 8e 9c 00 00
	00		 jle	 $LN79@CGPartyDel
$LN93@CGPartyDel:

; 8732 : 		{
; 8733 : 			gParty.Delete(pnumber,lpMsg->Number);

  0020d	6a 00		 push	 0
  0020f	56		 push	 esi
  00210	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00215	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8734 : 			count = gParty.GetCount(pnumber);

  0021a	56		 push	 esi
  0021b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00220	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 8735 : 			gObj[usernumber].PartyNumber = -1;

  00225	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  00228	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0022e	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00234	83 c8 ff	 or	 eax, -1
  00237	89 84 11 0c 06
	00 00		 mov	 DWORD PTR [ecx+edx+1548], eax

; 8736 : 			gObj[usernumber].PartyTargetUser = -1;

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  00241	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00247	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  0024d	89 84 11 10 06
	00 00		 mov	 DWORD PTR [ecx+edx+1552], eax

; 8737 : 
; 8738 : 			gParty.UpdatePKPartyPanalty(pnumber);

  00254	56		 push	 esi
  00255	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0025a	e8 00 00 00 00	 call	 ?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z ; PartyClass::UpdatePKPartyPanalty

; 8739 : 			gParty.ChangeLeader(pnumber);

  0025f	56		 push	 esi
  00260	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00265	e8 00 00 00 00	 call	 ?ChangeLeader@PartyClass@@QAEXH@Z ; PartyClass::ChangeLeader

; 8740 : 			GCPartyDelUserSend(usernumber);

  0026a	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend

; 8741 : 			CGPartyListAll(pnumber);

  00273	56		 push	 esi
  00274	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll

; 8742 : 
; 8743 : 			LogAddTD("PartyMember(%d) : Party Out. [%s][%s]",
; 8744 : 				usernumber,gObj[usernumber].AccountID,gObj[usernumber].Name);

  00279	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  0027c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00281	8b d1		 mov	 edx, ecx
  00283	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  00289	03 c2		 add	 eax, edx
  0028b	8d 50 5d	 lea	 edx, DWORD PTR [eax+93]
  0028e	52		 push	 edx
  0028f	83 c0 52	 add	 eax, 82			; 00000052H
  00292	50		 push	 eax
  00293	51		 push	 ecx
  00294	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IDLFABNI@PartyMember?$CI?$CFd?$CJ?5?3?5Party?5Out?4?5?$FL?$CFs@
  00299	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0029f	83 c4 18	 add	 esp, 24			; 00000018H
  002a2	5f		 pop	 edi
  002a3	5b		 pop	 ebx
  002a4	5e		 pop	 esi

; 8841 : }

  002a5	8b e5		 mov	 esp, ebp
  002a7	5d		 pop	 ebp
  002a8	c3		 ret	 0
$LN79@CGPartyDel:

; 8745 : 			return;

  002a9	8a 55 0f	 mov	 dl, BYTE PTR tv564[ebp]
$LN20@CGPartyDel:

; 8746 : 		}
; 8747 : 	}
; 8748 : 
; 8749 : 	if( gObj[usernumber].lpGuild != NULL )

  002ac	8b 4d f0	 mov	 ecx, DWORD PTR tv561[ebp]
  002af	8b 81 18 06 00
	00		 mov	 eax, DWORD PTR [ecx+1560]
  002b5	85 c0		 test	 eax, eax
  002b7	74 73		 je	 SHORT $LN81@CGPartyDel

; 8750 : 	{
; 8751 : 		if( gObj[usernumber].lpGuild->WarState == 1 &&
; 8752 : 			gObj[usernumber].IsInBattleGround )

  002b9	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  002c0	75 14		 jne	 SHORT $LN18@CGPartyDel
  002c2	80 b9 de 13 00
	00 00		 cmp	 BYTE PTR [ecx+5086], 0
  002c9	74 0b		 je	 SHORT $LN18@CGPartyDel

; 8753 : 		{
; 8754 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(13,216)),usernumber,1);

  002cb	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
  002ce	6a 01		 push	 1
  002d0	50		 push	 eax

; 8755 : 			return;

  002d1	e9 e3 00 00 00	 jmp	 $LN92@CGPartyDel
$LN18@CGPartyDel:

; 8756 : 		}
; 8757 : 
; 8758 : 		if( usernumber == gParty.m_PartyS[pnumber].Number[0] )

  002d6	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
  002d9	8b ce		 mov	 ecx, esi
  002db	c1 e1 04	 shl	 ecx, 4
  002de	2b ce		 sub	 ecx, esi
  002e0	3b 04 8d 0c 00
	00 00		 cmp	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[ecx*4+12]
  002e7	8d 3c 8d 0c 00
	00 00		 lea	 edi, DWORD PTR ?gParty@@3VPartyClass@@A[ecx*4+12]
  002ee	75 3c		 jne	 SHORT $LN81@CGPartyDel

; 8759 : 		{
; 8760 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  002f0	33 d2		 xor	 edx, edx
$LL87@CGPartyDel:

; 8761 : 			{
; 8762 : 				number = gParty.m_PartyS[pnumber].Number[n];

  002f2	8b 07		 mov	 eax, DWORD PTR [edi]

; 8763 : 				
; 8764 : 				if( number >= 0 &&
; 8765 : 					gObj[number].lpGuild != NULL &&
; 8766 : 					gObj[number].lpGuild->WarState == 1 &&
; 8767 : 					gObj[number].IsInBattleGround )

  002f4	85 c0		 test	 eax, eax
  002f6	78 28		 js	 SHORT $LN15@CGPartyDel
  002f8	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  002fe	8b 8c 18 18 06
	00 00		 mov	 ecx, DWORD PTR [eax+ebx+1560]
  00305	85 c9		 test	 ecx, ecx
  00307	74 17		 je	 SHORT $LN15@CGPartyDel
  00309	80 b9 91 05 00
	00 01		 cmp	 BYTE PTR [ecx+1425], 1
  00310	75 0e		 jne	 SHORT $LN15@CGPartyDel
  00312	80 bc 18 de 13
	00 00 00	 cmp	 BYTE PTR [eax+ebx+5086], 0
  0031a	0f 85 93 00 00
	00		 jne	 $LN66@CGPartyDel
$LN15@CGPartyDel:

; 8759 : 		{
; 8760 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00320	42		 inc	 edx
  00321	83 c7 04	 add	 edi, 4
  00324	83 fa 05	 cmp	 edx, 5
  00327	7c c9		 jl	 SHORT $LL87@CGPartyDel

; 8763 : 				
; 8764 : 				if( number >= 0 &&
; 8765 : 					gObj[number].lpGuild != NULL &&
; 8766 : 					gObj[number].lpGuild->WarState == 1 &&
; 8767 : 					gObj[number].IsInBattleGround )

  00329	8a 55 0f	 mov	 dl, BYTE PTR tv564[ebp]
$LN81@CGPartyDel:

; 8770 : 					return;
; 8771 : 				}
; 8772 : 			}
; 8773 : 		}
; 8774 : 	}
; 8775 : 
; 8776 : 	if( (lpMsg->Number == 0 || count <= 2) )

  0032c	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  0032f	8a 4b 03	 mov	 cl, BYTE PTR [ebx+3]
  00332	8b 7d f8	 mov	 edi, DWORD PTR _count$[ebp]
  00335	84 c9		 test	 cl, cl
  00337	0f 84 9b 00 00
	00		 je	 $LN11@CGPartyDel
  0033d	83 ff 02	 cmp	 edi, 2
  00340	0f 8e 92 00 00
	00		 jle	 $LN11@CGPartyDel

; 8831 : 		return;
; 8832 : 	}
; 8833 : 
; 8834 : 	gParty.Delete(pnumber,lpMsg->Number);

  00346	0f b6 d1	 movzx	 edx, cl
  00349	52		 push	 edx
  0034a	56		 push	 esi
  0034b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00350	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8835 : 	count = gParty.GetCount(pnumber);

  00355	56		 push	 esi
  00356	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0035b	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 8836 : 	gObj[usernumber].PartyNumber = -1;

  00360	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  00363	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00369	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  0036f	83 c8 ff	 or	 eax, -1
  00372	89 84 11 0c 06
	00 00		 mov	 DWORD PTR [ecx+edx+1548], eax

; 8837 : 	gObj[usernumber].PartyTargetUser = -1;

  00379	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  0037c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00382	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00388	89 84 11 10 06
	00 00		 mov	 DWORD PTR [ecx+edx+1552], eax

; 8838 : 	gParty.UpdatePKPartyPanalty(pnumber);

  0038f	56		 push	 esi
  00390	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00395	e8 00 00 00 00	 call	 ?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z ; PartyClass::UpdatePKPartyPanalty

; 8839 : 	GCPartyDelUserSend(usernumber);

  0039a	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
  0039d	50		 push	 eax
  0039e	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend

; 8840 : 	CGPartyListAll(pnumber);

  003a3	56		 push	 esi
  003a4	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  003a9	83 c4 08	 add	 esp, 8
  003ac	5f		 pop	 edi
  003ad	5b		 pop	 ebx
  003ae	5e		 pop	 esi

; 8841 : }

  003af	8b e5		 mov	 esp, ebp
  003b1	5d		 pop	 ebp
  003b2	c3		 ret	 0
$LN66@CGPartyDel:

; 8768 : 				{
; 8769 : 					GCServerMsgStringSend(lMsg.Get(MSGGET(13,216)),usernumber,1);

  003b3	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  003b6	6a 01		 push	 1
  003b8	51		 push	 ecx
$LN92@CGPartyDel:
  003b9	68 d8 0d 00 00	 push	 3544			; 00000dd8H
  003be	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003c3	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003c8	50		 push	 eax
  003c9	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  003d1	5f		 pop	 edi
  003d2	5b		 pop	 ebx
  003d3	5e		 pop	 esi

; 8841 : }

  003d4	8b e5		 mov	 esp, ebp
  003d6	5d		 pop	 ebp
  003d7	c3		 ret	 0
$LN11@CGPartyDel:

; 8777 : 	{
; 8778 : 		if( IT_MAP_RANGE(gObj[usernumber].MapNumber) )

  003d8	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  003db	0f 82 4c 01 00
	00		 jb	 $LN86@CGPartyDel
  003e1	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  003e6	3a c2		 cmp	 al, dl
  003e8	1b c0		 sbb	 eax, eax
  003ea	40		 inc	 eax
  003eb	0f 84 9c 00 00
	00		 je	 $LN85@CGPartyDel

; 8779 : 		{
; 8780 : 			if( lpMsg->Number == 0 && count > 2 )

  003f1	84 c9		 test	 cl, cl
  003f3	0f 85 94 00 00
	00		 jne	 $LN85@CGPartyDel
  003f9	83 ff 02	 cmp	 edi, 2
  003fc	0f 8e 8b 00 00
	00		 jle	 $LN85@CGPartyDel

; 8781 : 			{
; 8782 : 				gParty.Delete(pnumber,lpMsg->Number);

  00402	6a 00		 push	 0
  00404	56		 push	 esi
  00405	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0040a	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8783 : 				count = gParty.GetCount(pnumber);

  0040f	56		 push	 esi
  00410	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00415	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 8784 : 				gObj[usernumber].PartyNumber = -1;

  0041a	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  0041d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00423	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00429	8b f8		 mov	 edi, eax
  0042b	83 c8 ff	 or	 eax, -1
  0042e	89 84 11 0c 06
	00 00		 mov	 DWORD PTR [ecx+edx+1548], eax

; 8785 : 				gObj[usernumber].PartyTargetUser = -1;

  00435	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  00438	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0043e	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00444	89 84 11 10 06
	00 00		 mov	 DWORD PTR [ecx+edx+1552], eax

; 8786 : 				gParty.UpdatePKPartyPanalty(pnumber);

  0044b	56		 push	 esi
  0044c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00451	e8 00 00 00 00	 call	 ?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z ; PartyClass::UpdatePKPartyPanalty

; 8787 : 				gParty.ChangeLeader(pnumber);

  00456	56		 push	 esi
  00457	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0045c	e8 00 00 00 00	 call	 ?ChangeLeader@PartyClass@@QAEXH@Z ; PartyClass::ChangeLeader

; 8788 : 				GCPartyDelUserSend(usernumber);

  00461	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
  00464	50		 push	 eax
  00465	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend

; 8789 : 				CGPartyListAll(pnumber);

  0046a	56		 push	 esi
  0046b	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  00470	83 c4 08	 add	 esp, 8

; 8790 : 
; 8791 : 				if( count == 0 )

  00473	85 ff		 test	 edi, edi
  00475	0f 85 1d 01 00
	00		 jne	 $LN88@CGPartyDel

; 8827 : 			}
; 8828 : 		}
; 8829 : 
; 8830 : 		gParty.Destroy(pnumber);

  0047b	56		 push	 esi
  0047c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00481	e8 00 00 00 00	 call	 ?Destroy@PartyClass@@QAEHH@Z ; PartyClass::Destroy
  00486	5f		 pop	 edi
  00487	5b		 pop	 ebx
  00488	5e		 pop	 esi

; 8841 : }

  00489	8b e5		 mov	 esp, ebp
  0048b	5d		 pop	 ebp
  0048c	c3		 ret	 0
$LN85@CGPartyDel:

; 8792 : 					gParty.Destroy(pnumber);
; 8793 : 				return;
; 8794 : 			}
; 8795 : 		}
; 8796 : 		
; 8797 : 		if( IT_MAP_RANGE(gObj[usernumber].MapNumber) )

  0048d	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  00490	0f 82 97 00 00
	00		 jb	 $LN86@CGPartyDel
  00496	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  0049b	3a c2		 cmp	 al, dl
  0049d	1b c0		 sbb	 eax, eax
  0049f	40		 inc	 eax
  004a0	0f 84 87 00 00
	00		 je	 $LN86@CGPartyDel

; 8798 : 		{
; 8799 : 			if( count <= 2 )

  004a6	83 ff 02	 cmp	 edi, 2
  004a9	0f 8f 7e 00 00
	00		 jg	 $LN86@CGPartyDel

; 8800 : 			{
; 8801 : 				gParty.Delete(pnumber,lpMsg->Number);

  004af	0f b6 c9	 movzx	 ecx, cl
  004b2	51		 push	 ecx
  004b3	56		 push	 esi
  004b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  004b9	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8802 : 				count = gParty.GetCount(pnumber);

  004be	56		 push	 esi
  004bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  004c4	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 8803 : 				gObj[usernumber].PartyNumber = -1;

  004c9	8b 55 fc	 mov	 edx, DWORD PTR _usernumber$[ebp]
  004cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004d2	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  004d8	83 c8 ff	 or	 eax, -1
  004db	89 84 0a 0c 06
	00 00		 mov	 DWORD PTR [edx+ecx+1548], eax

; 8804 : 				gObj[usernumber].PartyTargetUser = -1;

  004e2	8b 55 fc	 mov	 edx, DWORD PTR _usernumber$[ebp]
  004e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004eb	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  004f1	89 84 0a 10 06
	00 00		 mov	 DWORD PTR [edx+ecx+1552], eax

; 8805 : 				gParty.UpdatePKPartyPanalty(pnumber);

  004f8	56		 push	 esi
  004f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  004fe	e8 00 00 00 00	 call	 ?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z ; PartyClass::UpdatePKPartyPanalty

; 8806 : 
; 8807 : 				if( lpMsg->Number == 0 )

  00503	80 7b 03 00	 cmp	 BYTE PTR [ebx+3], 0
  00507	75 0b		 jne	 SHORT $LN5@CGPartyDel

; 8808 : 					gParty.ChangeLeader(pnumber);

  00509	56		 push	 esi
  0050a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0050f	e8 00 00 00 00	 call	 ?ChangeLeader@PartyClass@@QAEXH@Z ; PartyClass::ChangeLeader
$LN5@CGPartyDel:

; 8809 : 
; 8810 : 				GCPartyDelUserSend(usernumber);

  00514	8b 55 fc	 mov	 edx, DWORD PTR _usernumber$[ebp]
  00517	52		 push	 edx
  00518	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend

; 8811 : 				CGPartyListAll(pnumber);

  0051d	56		 push	 esi
  0051e	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  00523	83 c4 08	 add	 esp, 8
  00526	5f		 pop	 edi
  00527	5b		 pop	 ebx
  00528	5e		 pop	 esi

; 8841 : }

  00529	8b e5		 mov	 esp, ebp
  0052b	5d		 pop	 ebp
  0052c	c3		 ret	 0
$LN86@CGPartyDel:

; 8812 : 				return;
; 8813 : 			}
; 8814 : 		}
; 8815 : 
; 8816 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  0052d	8b c6		 mov	 eax, esi
  0052f	c1 e0 04	 shl	 eax, 4
  00532	33 db		 xor	 ebx, ebx
  00534	2b c6		 sub	 eax, esi
  00536	8d 0c 85 0c 00
	00 00		 lea	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  0053d	89 4d 0c	 mov	 DWORD PTR tv874[ebp], ecx
$LL4@CGPartyDel:

; 8817 : 		{
; 8818 : 			number = gParty.m_PartyS[pnumber].Number[n];

  00540	8b 55 0c	 mov	 edx, DWORD PTR tv874[ebp]
  00543	8b 3a		 mov	 edi, DWORD PTR [edx]

; 8819 : 
; 8820 : 			if( number >= 0 )

  00545	85 ff		 test	 edi, edi
  00547	78 3a		 js	 SHORT $LN3@CGPartyDel

; 8821 : 			{
; 8822 : 				gParty.Delete(pnumber,n);

  00549	53		 push	 ebx
  0054a	56		 push	 esi
  0054b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00550	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8823 : 				gObj[number].PartyNumber = -1;

  00555	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0055b	8b c7		 mov	 eax, edi
  0055d	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00563	83 c9 ff	 or	 ecx, -1
  00566	89 8c 10 0c 06
	00 00		 mov	 DWORD PTR [eax+edx+1548], ecx

; 8824 : 				gObj[number].PartyTargetUser = -1;

  0056d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 8825 : 
; 8826 : 				GCPartyDelUserSend(number);

  00573	57		 push	 edi
  00574	89 8c 10 10 06
	00 00		 mov	 DWORD PTR [eax+edx+1552], ecx
  0057b	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend
  00580	83 c4 04	 add	 esp, 4
$LN3@CGPartyDel:

; 8812 : 				return;
; 8813 : 			}
; 8814 : 		}
; 8815 : 
; 8816 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00583	83 45 0c 04	 add	 DWORD PTR tv874[ebp], 4
  00587	43		 inc	 ebx
  00588	83 fb 05	 cmp	 ebx, 5
  0058b	7c b3		 jl	 SHORT $LL4@CGPartyDel

; 8827 : 			}
; 8828 : 		}
; 8829 : 
; 8830 : 		gParty.Destroy(pnumber);

  0058d	56		 push	 esi
  0058e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00593	e8 00 00 00 00	 call	 ?Destroy@PartyClass@@QAEHH@Z ; PartyClass::Destroy
$LN88@CGPartyDel:
  00598	5f		 pop	 edi
  00599	5b		 pop	 ebx
  0059a	5e		 pop	 esi

; 8841 : }

  0059b	8b e5		 mov	 esp, ebp
  0059d	5d		 pop	 ebp
  0059e	c3		 ret	 0
?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ENDP	; CGPartyDelUser
_TEXT	ENDS
PUBLIC	??_C@_0P@CPKIABHC@User?5not?5found?$AA@		; `string'
PUBLIC	??_C@_0P@IDGHFMPH@No?5party?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	?CGPartyDelUserAsExitGameByForce@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUserAsExitGameByForce
EXTRN	?SwitchLeader@PartyClass@@QAEXH@Z:PROC		; PartyClass::SwitchLeader
EXTRN	?GetReallyConnectPartyMemberCount@PartyClass@@QAEHH@Z:PROC ; PartyClass::GetReallyConnectPartyMemberCount
;	COMDAT ??_C@_0P@CPKIABHC@User?5not?5found?$AA@
CONST	SEGMENT
??_C@_0P@CPKIABHC@User?5not?5found?$AA@ DB 'User not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IDGHFMPH@No?5party?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@IDGHFMPH@No?5party?5?$CFs?5?$CFs?$AA@ DB 'No party %s %s', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPartyDelUserAsExitGameByForce@@YAXPAUPMSG_PARTYDELUSER@@H@Z
_TEXT	SEGMENT
_count$ = -12						; size = 4
_dbnumber$ = -8						; size = 4
_usernumber$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
tv456 = 12						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyDelUserAsExitGameByForce@@YAXPAUPMSG_PARTYDELUSER@@H@Z PROC ; CGPartyDelUserAsExitGameByForce, COMDAT

; 8845 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 8846 : 	int usernumber = -1;
; 8847 : 	int dbnumber = -1;
; 8848 : 	int count;
; 8849 : 	int number;
; 8850 : 	int pnumber;
; 8851 : 
; 8852 : 	if( gObj[aIndex].PartyNumber < 0 )

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	57		 push	 edi
  0000d	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00010	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00016	83 c8 ff	 or	 eax, -1
  00019	89 45 fc	 mov	 DWORD PTR _usernumber$[ebp], eax
  0001c	89 45 f8	 mov	 DWORD PTR _dbnumber$[ebp], eax
  0001f	8b 84 0f 0c 06
	00 00		 mov	 eax, DWORD PTR [edi+ecx+1548]
  00026	85 c0		 test	 eax, eax
  00028	79 1d		 jns	 SHORT $LN24@CGPartyDel@2

; 8853 : 	{
; 8854 : 		LogAdd("No party %s %s",gObj[aIndex].AccountID,gObj[aIndex].Name);

  0002a	8d 44 0f 5d	 lea	 eax, DWORD PTR [edi+ecx+93]
  0002e	50		 push	 eax
  0002f	8d 4c 0f 52	 lea	 ecx, DWORD PTR [edi+ecx+82]
  00033	51		 push	 ecx
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IDGHFMPH@No?5party?5?$CFs?5?$CFs?$AA@
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	5f		 pop	 edi

; 8953 : 		}
; 8954 : 	}
; 8955 : 
; 8956 : 
; 8957 : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN24@CGPartyDel@2:

; 8855 : 		return;
; 8856 : 	}
; 8857 : 
; 8858 : 	if( !gParty.GetIndexUser(gObj[aIndex].PartyNumber,lpMsg->Number,usernumber,dbnumber) )

  00047	8d 55 f8	 lea	 edx, DWORD PTR _dbnumber$[ebp]
  0004a	52		 push	 edx
  0004b	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0004e	8d 4d fc	 lea	 ecx, DWORD PTR _usernumber$[ebp]
  00051	51		 push	 ecx
  00052	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  00056	51		 push	 ecx
  00057	50		 push	 eax
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0005d	e8 00 00 00 00	 call	 ?GetIndexUser@PartyClass@@QAEHHHAAH0@Z ; PartyClass::GetIndexUser
  00062	85 c0		 test	 eax, eax
  00064	75 13		 jne	 SHORT $LN23@CGPartyDel@2
$LN39@CGPartyDel@2:

; 8859 : 	{
; 8860 : 		LogAdd("User not found");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CPKIABHC@User?5not?5found?$AA@
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00071	83 c4 04	 add	 esp, 4
  00074	5f		 pop	 edi

; 8953 : 		}
; 8954 : 	}
; 8955 : 
; 8956 : 
; 8957 : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN23@CGPartyDel@2:

; 8861 : 		return;
; 8862 : 	}
; 8863 : 
; 8864 : 	if( usernumber < 0 )

  00079	83 7d fc 00	 cmp	 DWORD PTR _usernumber$[ebp], 0

; 8865 : 	{
; 8866 : 		LogAdd("User not found");
; 8867 : 		return;

  0007d	7c e7		 jl	 SHORT $LN39@CGPartyDel@2

; 8868 : 	}
; 8869 : 
; 8870 : 	pnumber = gObj[aIndex].PartyNumber;

  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00085	53		 push	 ebx
  00086	8b 9c 17 0c 06
	00 00		 mov	 ebx, DWORD PTR [edi+edx+1548]

; 8871 : 
; 8872 : 	if( pnumber < 0 )

  0008d	85 db		 test	 ebx, ebx
  0008f	79 1e		 jns	 SHORT $LN21@CGPartyDel@2

; 8873 : 	{
; 8874 : 		LogAdd("%s %d",__FILE__,__LINE__);

  00091	68 aa 22 00 00	 push	 8874			; 000022aaH
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a9	5b		 pop	 ebx
  000aa	5f		 pop	 edi

; 8953 : 		}
; 8954 : 	}
; 8955 : 
; 8956 : 
; 8957 : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
$LN21@CGPartyDel@2:
  000af	56		 push	 esi

; 8875 : 		return;
; 8876 : 	}
; 8877 : 
; 8878 : 	count = gParty.GetCount(pnumber);

  000b0	53		 push	 ebx
  000b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000b6	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  000bb	8b f0		 mov	 esi, eax
  000bd	89 75 f4	 mov	 DWORD PTR _count$[ebp], esi

; 8879 : 
; 8880 : 	if( count < 1 )

  000c0	83 fe 01	 cmp	 esi, 1
  000c3	7d 1f		 jge	 SHORT $LN20@CGPartyDel@2

; 8881 : 	{
; 8882 : 		LogAdd("%s %d",__FILE__,__LINE__);

  000c5	68 b2 22 00 00	 push	 8882			; 000022b2H
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 8905 : 				{
; 8906 : 					GCServerMsgStringSend(lMsg.Get(MSGGET(13,216)),aIndex,1);

  000da	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dd	5e		 pop	 esi
  000de	5b		 pop	 ebx
  000df	5f		 pop	 edi

; 8953 : 		}
; 8954 : 	}
; 8955 : 
; 8956 : 
; 8957 : }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN20@CGPartyDel@2:

; 8883 : 		return;
; 8884 : 	}
; 8885 : 
; 8886 : 	if( gObj[aIndex].lpGuild != NULL )

  000e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ea	8b 8c 17 18 06
	00 00		 mov	 ecx, DWORD PTR [edi+edx+1560]
  000f1	85 c9		 test	 ecx, ecx
  000f3	74 7b		 je	 SHORT $LN14@CGPartyDel@2

; 8887 : 	{
; 8888 : 		if( gObj[aIndex].lpGuild->WarState == 1 &&
; 8889 : 			gObj[aIndex].IsInBattleGround )

  000f5	80 b9 91 05 00
	00 01		 cmp	 BYTE PTR [ecx+1425], 1
  000fc	75 15		 jne	 SHORT $LN18@CGPartyDel@2
  000fe	80 bc 17 de 13
	00 00 00	 cmp	 BYTE PTR [edi+edx+5086], 0
  00106	74 0b		 je	 SHORT $LN18@CGPartyDel@2

; 8890 : 		{
; 8891 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(13,216)),aIndex,1);

  00108	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0010b	6a 01		 push	 1
  0010d	50		 push	 eax

; 8892 : 			return;

  0010e	e9 d1 00 00 00	 jmp	 $LN37@CGPartyDel@2
$LN18@CGPartyDel@2:

; 8893 : 		}
; 8894 : 
; 8895 : 		if( usernumber == gParty.m_PartyS[pnumber].Number[0] )

  00113	8b cb		 mov	 ecx, ebx
  00115	c1 e1 04	 shl	 ecx, 4
  00118	2b cb		 sub	 ecx, ebx
  0011a	8d 04 8d 0c 00
	00 00		 lea	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[ecx*4+12]
  00121	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  00124	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00126	75 48		 jne	 SHORT $LN14@CGPartyDel@2

; 8896 : 		{
; 8897 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00128	33 f6		 xor	 esi, esi
  0012a	8d 9b 00 00 00
	00		 npad	 6
$LL16@CGPartyDel@2:

; 8898 : 			{
; 8899 : 				number = gParty.m_PartyS[pnumber].Number[n];

  00130	8b 08		 mov	 ecx, DWORD PTR [eax]

; 8900 : 
; 8901 : 				if( number >= 0 &&
; 8902 : 					gObj[number].lpGuild != NULL && 
; 8903 : 					gObj[number].lpGuild->WarState == 1 && 
; 8904 : 					gObj[number].IsInBattleGround )

  00132	85 c9		 test	 ecx, ecx
  00134	78 2e		 js	 SHORT $LN15@CGPartyDel@2
  00136	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  0013c	03 d1		 add	 edx, ecx
  0013e	8b 8a 18 06 00
	00		 mov	 ecx, DWORD PTR [edx+1560]
  00144	85 c9		 test	 ecx, ecx
  00146	74 16		 je	 SHORT $LN34@CGPartyDel@2
  00148	80 b9 91 05 00
	00 01		 cmp	 BYTE PTR [ecx+1425], 1
  0014f	75 0d		 jne	 SHORT $LN34@CGPartyDel@2
  00151	80 ba de 13 00
	00 00		 cmp	 BYTE PTR [edx+5086], 0
  00158	0f 85 80 00 00
	00		 jne	 $LN29@CGPartyDel@2
$LN34@CGPartyDel@2:
  0015e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN15@CGPartyDel@2:

; 8896 : 		{
; 8897 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00164	46		 inc	 esi
  00165	83 c0 04	 add	 eax, 4
  00168	83 fe 05	 cmp	 esi, 5
  0016b	7c c3		 jl	 SHORT $LL16@CGPartyDel@2

; 8900 : 
; 8901 : 				if( number >= 0 &&
; 8902 : 					gObj[number].lpGuild != NULL && 
; 8903 : 					gObj[number].lpGuild->WarState == 1 && 
; 8904 : 					gObj[number].IsInBattleGround )

  0016d	8b 75 f4	 mov	 esi, DWORD PTR _count$[ebp]
$LN14@CGPartyDel@2:

; 8907 : 					return;
; 8908 : 				}
; 8909 : 			}
; 8910 : 		}
; 8911 : 	}
; 8912 : 
; 8913 : 	if( lpMsg->Number == 0 || count <= 2 )

  00170	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00173	80 78 03 00	 cmp	 BYTE PTR [eax+3], 0
  00177	74 09		 je	 SHORT $LN11@CGPartyDel@2
  00179	83 fe 02	 cmp	 esi, 2
  0017c	0f 8f 03 01 00
	00		 jg	 $LN36@CGPartyDel@2
$LN11@CGPartyDel@2:

; 8914 : 	{
; 8915 : 		int nReallyConnectPartyMemberCount = gParty.GetReallyConnectPartyMemberCount(pnumber);

  00182	53		 push	 ebx
  00183	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00188	e8 00 00 00 00	 call	 ?GetReallyConnectPartyMemberCount@PartyClass@@QAEHH@Z ; PartyClass::GetReallyConnectPartyMemberCount

; 8916 : 
; 8917 : 		if( lpMsg->Number == 0 && 
; 8918 : 			nReallyConnectPartyMemberCount > 1 )

  0018d	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00190	80 79 03 00	 cmp	 BYTE PTR [ecx+3], 0
  00194	75 6d		 jne	 SHORT $LN10@CGPartyDel@2
  00196	83 f8 01	 cmp	 eax, 1
  00199	7e 6d		 jle	 SHORT $LN32@CGPartyDel@2

; 8919 : 		{
; 8920 : 			if( !gObj[aIndex].m_bIsMaintainParty )

  0019b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a1	80 bc 17 cc 26
	00 00 00	 cmp	 BYTE PTR [edi+edx+9932], 0
  001a9	75 0d		 jne	 SHORT $LN9@CGPartyDel@2

; 8921 : 			{
; 8922 : 				gParty.Delete(pnumber,lpMsg->Number);

  001ab	6a 00		 push	 0
  001ad	53		 push	 ebx
  001ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001b3	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete
$LN9@CGPartyDel@2:

; 8923 : 			}
; 8924 : 
; 8925 : 			gParty.UpdatePKPartyPanalty(pnumber);

  001b8	53		 push	 ebx
  001b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001be	e8 00 00 00 00	 call	 ?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z ; PartyClass::UpdatePKPartyPanalty

; 8926 : 			gParty.SwitchLeader(pnumber);

  001c3	53		 push	 ebx
  001c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001c9	e8 00 00 00 00	 call	 ?SwitchLeader@PartyClass@@QAEXH@Z ; PartyClass::SwitchLeader

; 8927 : 			CGPartyListAll(pnumber);

  001ce	53		 push	 ebx
  001cf	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  001d4	83 c4 04	 add	 esp, 4
  001d7	5e		 pop	 esi
  001d8	5b		 pop	 ebx
  001d9	5f		 pop	 edi

; 8953 : 		}
; 8954 : 	}
; 8955 : 
; 8956 : 
; 8957 : }

  001da	8b e5		 mov	 esp, ebp
  001dc	5d		 pop	 ebp
  001dd	c3		 ret	 0
$LN29@CGPartyDel@2:

; 8905 : 				{
; 8906 : 					GCServerMsgStringSend(lMsg.Get(MSGGET(13,216)),aIndex,1);

  001de	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001e1	6a 01		 push	 1
  001e3	52		 push	 edx
$LN37@CGPartyDel@2:
  001e4	68 d8 0d 00 00	 push	 3544			; 00000dd8H
  001e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001ee	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
  001fe	5f		 pop	 edi

; 8953 : 		}
; 8954 : 	}
; 8955 : 
; 8956 : 
; 8957 : }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c3		 ret	 0
$LN10@CGPartyDel@2:

; 8928 : 		}
; 8929 : 		else if( nReallyConnectPartyMemberCount > 1 )

  00203	83 f8 01	 cmp	 eax, 1
  00206	7f 7d		 jg	 SHORT $LN36@CGPartyDel@2
$LN32@CGPartyDel@2:

; 8930 : 		{
; 8931 : 
; 8932 : 		}
; 8933 : 		else
; 8934 : 		{
; 8935 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00208	8b c3		 mov	 eax, ebx
  0020a	c1 e0 04	 shl	 eax, 4
  0020d	33 f6		 xor	 esi, esi
  0020f	2b c3		 sub	 eax, ebx
  00211	8d 0c 85 0c 00
	00 00		 lea	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  00218	89 4d 0c	 mov	 DWORD PTR tv456[ebp], ecx
  0021b	eb 03 8d 49 00	 npad	 5
$LL5@CGPartyDel@2:

; 8936 : 			{
; 8937 : 				number = gParty.m_PartyS[pnumber].Number[n];

  00220	8b 55 0c	 mov	 edx, DWORD PTR tv456[ebp]
  00223	8b 3a		 mov	 edi, DWORD PTR [edx]

; 8938 : 
; 8939 : 				if( number >= 0 )

  00225	85 ff		 test	 edi, edi
  00227	78 47		 js	 SHORT $LN4@CGPartyDel@2

; 8940 : 				{
; 8941 : 					gParty.Delete(pnumber,n);

  00229	56		 push	 esi
  0022a	53		 push	 ebx
  0022b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00230	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8942 : 					gObj[number].PartyNumber = -1;

  00235	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0023b	8b c7		 mov	 eax, edi
  0023d	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00243	83 c9 ff	 or	 ecx, -1
  00246	89 8c 10 0c 06
	00 00		 mov	 DWORD PTR [eax+edx+1548], ecx

; 8943 : 					gObj[number].PartyTargetUser = -1;

  0024d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00253	89 8c 10 10 06
	00 00		 mov	 DWORD PTR [eax+edx+1552], ecx

; 8944 : 
; 8945 : 					if( gObj[number].Connected == PLAYER_PLAYING )

  0025a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00260	83 7c 08 04 03	 cmp	 DWORD PTR [eax+ecx+4], 3
  00265	75 09		 jne	 SHORT $LN4@CGPartyDel@2

; 8946 : 					{
; 8947 : 						GCPartyDelUserSend(number);

  00267	57		 push	 edi
  00268	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend
  0026d	83 c4 04	 add	 esp, 4
$LN4@CGPartyDel@2:

; 8930 : 		{
; 8931 : 
; 8932 : 		}
; 8933 : 		else
; 8934 : 		{
; 8935 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00270	83 45 0c 04	 add	 DWORD PTR tv456[ebp], 4
  00274	46		 inc	 esi
  00275	83 fe 05	 cmp	 esi, 5
  00278	7c a6		 jl	 SHORT $LL5@CGPartyDel@2

; 8948 : 					}
; 8949 : 				}
; 8950 : 			}
; 8951 : 
; 8952 : 			gParty.Destroy(pnumber);

  0027a	53		 push	 ebx
  0027b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00280	e8 00 00 00 00	 call	 ?Destroy@PartyClass@@QAEHH@Z ; PartyClass::Destroy
$LN36@CGPartyDel@2:
  00285	5e		 pop	 esi
  00286	5b		 pop	 ebx
  00287	5f		 pop	 edi

; 8953 : 		}
; 8954 : 	}
; 8955 : 
; 8956 : 
; 8957 : }

  00288	8b e5		 mov	 esp, ebp
  0028a	5d		 pop	 ebp
  0028b	c3		 ret	 0
?CGPartyDelUserAsExitGameByForce@@YAXPAUPMSG_PARTYDELUSER@@H@Z ENDP ; CGPartyDelUserAsExitGameByForce
_TEXT	ENDS
PUBLIC	?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ; CGGuildMasterAnswerRecv
EXTRN	?gObjGuildMasterCapacityTest@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjGuildMasterCapacityTest
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z PROC ; CGGuildMasterAnswerRecv, COMDAT

; 9438 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 9439 : 	if ( lpMsg->Result == 1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	80 78 03 01	 cmp	 BYTE PTR [eax+3], 1

; 9440 : 	{
; 9441 : 		if ( !gObjGuildMasterCapacityTest(&gObj[aIndex]))

  0000a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00010	75 53		 jne	 SHORT $LN4@CGGuildMas@3
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00017	8b f7		 mov	 esi, edi
  00019	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0001f	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ?gObjGuildMasterCapacityTest@@YAHPAUOBJECTSTRUCT@@@Z ; gObjGuildMasterCapacityTest
  00028	83 c4 04	 add	 esp, 4
  0002b	85 c0		 test	 eax, eax
  0002d	75 29		 jne	 SHORT $LN3@CGGuildMas@3

; 9442 : 		{
; 9443 : 			if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  0003c	a8 03		 test	 al, 3
  0003e	74 14		 je	 SHORT $LN7@CGGuildMas@3
  00040	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00045	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0004a	75 08		 jne	 SHORT $LN7@CGGuildMas@3

; 9444 : 			{
; 9445 : 				gObj[aIndex].m_IfState.use = 0;

  0004c	83 a4 0e b8 11
	00 00 fc	 and	 DWORD PTR [esi+ecx+4536], -4 ; fffffffcH
$LN7@CGGuildMas@3:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
$LN1@CGGuildMas@3:

; 9458 : 	}
; 9459 : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN3@CGGuildMas@3:

; 9446 : 			}
; 9447 : 
; 9448 : 			return;
; 9449 : 		}
; 9450 : 
; 9451 : 		GCGuildMasterManagerRun(aIndex);

  00058	57		 push	 edi
  00059	e8 00 00 00 00	 call	 ?GCGuildMasterManagerRun@@YAXH@Z ; GCGuildMasterManagerRun
  0005e	83 c4 04	 add	 esp, 4
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 9458 : 	}
; 9459 : }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN4@CGGuildMas@3:

; 9452 : 		return;
; 9453 : 	}
; 9454 : 
; 9455 : 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  00065	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00068	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0006e	8d 8c 08 b8 11
	00 00		 lea	 ecx, DWORD PTR [eax+ecx+4536]
  00075	8b 01		 mov	 eax, DWORD PTR [ecx]
  00077	a8 03		 test	 al, 3
  00079	74 db		 je	 SHORT $LN1@CGGuildMas@3
  0007b	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00080	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00085	75 cf		 jne	 SHORT $LN1@CGGuildMas@3

; 9456 : 	{
; 9457 : 		gObj[aIndex].m_IfState.use = 0;

  00087	83 21 fc	 and	 DWORD PTR [ecx], -4	; fffffffcH

; 9458 : 	}
; 9459 : }

  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ENDP ; CGGuildMasterAnswerRecv
_TEXT	ENDS
PUBLIC	??_C@_0DE@OPCGOEPD@Guild?5War?5cannot?5be?5started?5with@ ; `string'
PUBLIC	??_C@_0DB@IJAALLLN@Guild?5War?5cannot?5be?5started?5with@ ; `string'
PUBLIC	??_C@_0DC@ENCBPHMM@Guild?5War?5cannot?5be?5started?5with@ ; `string'
PUBLIC	??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@ ; `string'
PUBLIC	??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@ ; `string'
PUBLIC	??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildWarRequestResult@@YAXPADHH@Z		; GCGuildWarRequestResult
EXTRN	_strncmp:PROC
;	COMDAT ??_C@_0DE@OPCGOEPD@Guild?5War?5cannot?5be?5started?5with@
CONST	SEGMENT
??_C@_0DE@OPCGOEPD@Guild?5War?5cannot?5be?5started?5with@ DB 'Guild War c'
	DB	'annot be started within Illusion Temple.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IJAALLLN@Guild?5War?5cannot?5be?5started?5with@
CONST	SEGMENT
??_C@_0DB@IJAALLLN@Guild?5War?5cannot?5be?5started?5with@ DB 'Guild War c'
	DB	'annot be started within Doppelganger.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@ENCBPHMM@Guild?5War?5cannot?5be?5started?5with@
CONST	SEGMENT
??_C@_0DC@ENCBPHMM@Guild?5War?5cannot?5be?5started?5with@ DB 'Guild War c'
	DB	'annot be started within Imperial Fort.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@
CONST	SEGMENT
??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@ DB 'Error on '
	DB	'declaring war : Target GuildMaster Is Murderer 0x04 %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@
CONST	SEGMENT
??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@ DB '['
	DB	'U.System][Guildwar] Can''t declare guildwar between Same Unio'
	DB	'n (%s / %d) <-> (%s / %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@
CONST	SEGMENT
??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@ DB 'Error on d'
	DB	'eclaring war : GuildMaster Is Murderer 0x04 %s %s', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCGuildWarRequestResult@@YAXPADHH@Z
_TEXT	SEGMENT
tv569 = -40						; size = 4
_n$220908 = -36						; size = 4
tv544 = -32						; size = 4
_lpMyGuild$ = -28					; size = 4
_aIndex$GSCopy$ = -24					; size = 4
_pMsg$ = -20						; size = 4
__guildname$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_GuildName$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 4
?GCGuildWarRequestResult@@YAXPADHH@Z PROC		; GCGuildWarRequestResult, COMDAT

; 9771 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _GuildName$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 9772 : #if (GS_CASTLE == 1 && GS_SPEC != 1)
; 9773 : 	return;
; 9774 : #endif
; 9775 : 	PMSG_GUILDWARREQUEST_RESULT pMsg;
; 9776 : 
; 9777 : 	PHeadSetB((LPBYTE)&pMsg, 0x60, sizeof(pMsg));

  00019	6a 04		 push	 4
  0001b	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001e	6a 60		 push	 96			; 00000060H
  00020	50		 push	 eax

; 9778 : 	pMsg.Result = 3;
; 9779 : 
; 9780 : 	if ( gObj[aIndex].GuildNumber < 1)

  00021	89 7d e8	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], edi
  00024	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	8b f7		 mov	 esi, edi
  00030	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	c6 45 ef 03	 mov	 BYTE PTR _pMsg$[ebp+3], 3
  0003d	83 bc 06 14 06
	00 00 01	 cmp	 DWORD PTR [esi+eax+1556], 1
  00045	89 75 e0	 mov	 DWORD PTR tv544[ebp], esi
  00048	7d 23		 jge	 SHORT $LN32@GCGuildWar@2

; 9781 : 	{
; 9782 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0004a	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0004e	51		 push	 ecx
  0004f	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00052	52		 push	 edx
  00053	57		 push	 edi
  00054	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	33 cd		 xor	 ecx, ebp
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN32@GCGuildWar@2:

; 9783 : 		return;
; 9784 : 	}
; 9785 : 
; 9786 : 	_GUILD_INFO_STRUCT * lpMyGuild = gObj[aIndex].lpGuild;

  0006d	8b bc 06 18 06
	00 00		 mov	 edi, DWORD PTR [esi+eax+1560]
  00074	89 7d e4	 mov	 DWORD PTR _lpMyGuild$[ebp], edi

; 9787 : 
; 9788 : 	if ( !lpMyGuild )

  00077	85 ff		 test	 edi, edi
  00079	75 26		 jne	 SHORT $LN31@GCGuildWar@2

; 9789 : 	{
; 9790 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0007b	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0007f	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00082	50		 push	 eax
  00083	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00086	51		 push	 ecx
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	33 cd		 xor	 ecx, ebp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
$LN31@GCGuildWar@2:

; 9791 : 		return;
; 9792 : 	}
; 9793 : 
; 9794 : 	if ( lpMyGuild->WarState == 1 || lpMyGuild->WarDeclareState == 1 )

  000a1	80 bf 91 05 00
	00 01		 cmp	 BYTE PTR [edi+1425], 1
  000a8	0f 84 a9 04 00
	00		 je	 $LN29@GCGuildWar@2
  000ae	80 bf 90 05 00
	00 01		 cmp	 BYTE PTR [edi+1424], 1
  000b5	0f 84 9c 04 00
	00		 je	 $LN29@GCGuildWar@2

; 9802 : 
; 9803 : 		return;
; 9804 : 	}
; 9805 : 
; 9806 : 	if ( gPkLimitFree == FALSE && gObj[aIndex].m_PK_Level >= 6)

  000bb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  000c2	75 48		 jne	 SHORT $LN28@GCGuildWar@2
  000c4	80 bc 06 19 01
	00 00 06	 cmp	 BYTE PTR [esi+eax+281], 6
  000cc	7c 3e		 jl	 SHORT $LN28@GCGuildWar@2

; 9807 : 	{
; 9808 : 		pMsg.Result = 4;
; 9809 : 
; 9810 : 		LogAdd("Error on declaring war : GuildMaster Is Murderer 0x04 %s %s",
; 9811 : 			lpMyGuild->Names[0], gObj[aIndex].Name);

  000ce	8d 44 06 5d	 lea	 eax, DWORD PTR [esi+eax+93]
  000d2	50		 push	 eax
  000d3	83 c7 2f	 add	 edi, 47			; 0000002fH
  000d6	57		 push	 edi
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@
  000dc	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 9812 : 
; 9813 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000e6	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000ea	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  000ed	51		 push	 ecx
  000ee	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000f1	52		 push	 edx
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f8	83 c4 18	 add	 esp, 24			; 00000018H
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  000fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00101	33 cd		 xor	 ecx, ebp
  00103	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
$LN28@GCGuildWar@2:

; 9814 : 
; 9815 : 		return;
; 9816 : 	}
; 9817 : 
; 9818 : 	if ( strcmp(lpMyGuild->Names[0], gObj[aIndex].Name ) )

  0010c	8d 74 06 5d	 lea	 esi, DWORD PTR [esi+eax+93]
  00110	8d 47 2f	 lea	 eax, DWORD PTR [edi+47]
  00113	89 45 d8	 mov	 DWORD PTR tv569[ebp], eax
  00116	8b ce		 mov	 ecx, esi
$LL69@GCGuildWar@2:
  00118	8a 10		 mov	 dl, BYTE PTR [eax]
  0011a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0011c	75 1a		 jne	 SHORT $LN70@GCGuildWar@2
  0011e	84 d2		 test	 dl, dl
  00120	74 12		 je	 SHORT $LN71@GCGuildWar@2
  00122	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00125	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00128	75 0e		 jne	 SHORT $LN70@GCGuildWar@2
  0012a	83 c0 02	 add	 eax, 2
  0012d	83 c1 02	 add	 ecx, 2
  00130	84 d2		 test	 dl, dl
  00132	75 e4		 jne	 SHORT $LL69@GCGuildWar@2
$LN71@GCGuildWar@2:
  00134	33 c0		 xor	 eax, eax
  00136	eb 05		 jmp	 SHORT $LN72@GCGuildWar@2
$LN70@GCGuildWar@2:
  00138	1b c0		 sbb	 eax, eax
  0013a	83 d8 ff	 sbb	 eax, -1
$LN72@GCGuildWar@2:
  0013d	85 c0		 test	 eax, eax
  0013f	74 45		 je	 SHORT $LN27@GCGuildWar@2

; 9819 : 	{
; 9820 : 		pMsg.Result = 5;
; 9821 : 
; 9822 : 		LogAdd(lMsg.Get(MSGGET(1, 235)),
; 9823 : 			lpMyGuild->Names[0], gObj[aIndex].Name);

  00141	8b 4d d8	 mov	 ecx, DWORD PTR tv569[ebp]
  00144	56		 push	 esi
  00145	51		 push	 ecx
  00146	68 eb 01 00 00	 push	 491			; 000001ebH
  0014b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00150	c6 45 ef 05	 mov	 BYTE PTR _pMsg$[ebp+3], 5
  00154	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00159	50		 push	 eax
$LN82@GCGuildWar@2:
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 9824 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00160	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00164	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00167	52		 push	 edx
  00168	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0016b	50		 push	 eax
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00172	83 c4 18	 add	 esp, 24			; 00000018H
  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  00178	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017b	33 cd		 xor	 ecx, ebp
  0017d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
$LN27@GCGuildWar@2:

; 9825 : 
; 9826 : 		return;
; 9827 : 	}
; 9828 : 
; 9829 : 	char _guildname[MAX_GUILD_LEN+1];
; 9830 : 	memset(_guildname, 0, sizeof(_guildname));
; 9831 : 	memcpy(_guildname, GuildName, MAX_GUILD_LEN);

  00186	8b 13		 mov	 edx, DWORD PTR [ebx]
  00188	33 c0		 xor	 eax, eax

; 9832 : 
; 9833 : 	if ( !strncmp(lpMyGuild->Name, GuildName, MAX_GUILD_LEN))

  0018a	6a 08		 push	 8
  0018c	89 45 f0	 mov	 DWORD PTR __guildname$[ebp], eax
  0018f	89 45 f4	 mov	 DWORD PTR __guildname$[ebp+4], eax
  00192	88 45 f8	 mov	 BYTE PTR __guildname$[ebp+8], al
  00195	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00198	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0019b	53		 push	 ebx
  0019c	56		 push	 esi
  0019d	89 55 f0	 mov	 DWORD PTR __guildname$[ebp], edx
  001a0	89 45 f4	 mov	 DWORD PTR __guildname$[ebp+4], eax
  001a3	e8 00 00 00 00	 call	 _strncmp
  001a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ab	85 c0		 test	 eax, eax
  001ad	0f 84 e7 03 00
	00		 je	 $LN1@GCGuildWar@2

; 9834 : 		return;
; 9835 : 
; 9836 : 	_GUILD_INFO_STRUCT * lpNode = Guild.SearchGuild(_guildname);

  001b3	8d 4d f0	 lea	 ecx, DWORD PTR __guildname$[ebp]
  001b6	51		 push	 ecx
  001b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  001bc	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  001c1	8b f8		 mov	 edi, eax

; 9837 : 
; 9838 : 	if ( lpNode )

  001c3	85 ff		 test	 edi, edi
  001c5	0f 84 62 03 00
	00		 je	 $LN25@GCGuildWar@2

; 9839 : 	{
; 9840 : 		if ( lpNode->WarState == 1 || lpNode->WarDeclareState == 1 )

  001cb	80 bf 91 05 00
	00 01		 cmp	 BYTE PTR [edi+1425], 1
  001d2	0f 84 7f 03 00
	00		 je	 $LN29@GCGuildWar@2
  001d8	80 bf 90 05 00
	00 01		 cmp	 BYTE PTR [edi+1424], 1
  001df	0f 84 72 03 00
	00		 je	 $LN29@GCGuildWar@2

; 9850 : 		}
; 9851 : 
; 9852 : 		if ( lpMyGuild->iGuildUnion != 0 && lpMyGuild->iGuildUnion == lpNode->iGuildUnion )

  001e5	8b 55 e4	 mov	 edx, DWORD PTR _lpMyGuild$[ebp]
  001e8	8b 82 44 07 00
	00		 mov	 eax, DWORD PTR [edx+1860]
  001ee	85 c0		 test	 eax, eax
  001f0	74 2e		 je	 SHORT $LN22@GCGuildWar@2
  001f2	3b 87 44 07 00
	00		 cmp	 eax, DWORD PTR [edi+1860]
  001f8	75 26		 jne	 SHORT $LN22@GCGuildWar@2

; 9853 : 		{
; 9854 : 			LogAddTD("[U.System][Guildwar] Can't declare guildwar between Same Union (%s / %d) <-> (%s / %d)",
; 9855 : 				lpMyGuild->Name, lpMyGuild->iGuildUnion, lpNode->Name, lpMyGuild->iGuildUnion);

  001fa	50		 push	 eax
  001fb	83 c7 04	 add	 edi, 4
  001fe	57		 push	 edi
  001ff	50		 push	 eax
  00200	56		 push	 esi
  00201	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@
  00206	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0020c	83 c4 14	 add	 esp, 20			; 00000014H
  0020f	5f		 pop	 edi
  00210	5e		 pop	 esi
  00211	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  00212	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00215	33 cd		 xor	 ecx, ebp
  00217	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021c	8b e5		 mov	 esp, ebp
  0021e	5d		 pop	 ebp
  0021f	c3		 ret	 0
$LN22@GCGuildWar@2:

; 9856 : 
; 9857 : 			return;
; 9858 : 		}
; 9859 : 
; 9860 : 		int n=OBJ_STARTUSERINDEX;	// #warning Change this 0 to OBJ_STARTUSERINDEX

  00220	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00226	bb 04 29 00 00	 mov	 ebx, 10500		; 00002904H
  0022b	81 c6 5d dd 49
	06		 add	 esi, 105504093		; 0649dd5dH
$LL21@GCGuildWar@2:

; 9861 : 		int warmaster=-1;
; 9862 : 
; 9863 : 		while ( true )
; 9864 : 		{
; 9865 : 			if ( gObj[n].Type == OBJ_USER )

  00231	80 7e f3 01	 cmp	 BYTE PTR [esi-13], 1
  00235	75 42		 jne	 SHORT $LN16@GCGuildWar@2

; 9866 : 			{
; 9867 : 				if ( gObj[n].Connected > PLAYER_LOGGED )

  00237	83 7e a7 02	 cmp	 DWORD PTR [esi-89], 2
  0023b	7e 3c		 jle	 SHORT $LN16@GCGuildWar@2

; 9868 : 				{
; 9869 : 					if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  0023d	8a 06		 mov	 al, BYTE PTR [esi]
  0023f	3a 47 2f	 cmp	 al, BYTE PTR [edi+47]
  00242	8d 4f 2f	 lea	 ecx, DWORD PTR [edi+47]
  00245	75 32		 jne	 SHORT $LN16@GCGuildWar@2

; 9870 : 					{
; 9871 : 						if ( !strcmp(gObj[n].Name, lpNode->Names[0]))

  00247	8b c6		 mov	 eax, esi
  00249	8d a4 24 00 00
	00 00		 npad	 7
$LL73@GCGuildWar@2:
  00250	8a 10		 mov	 dl, BYTE PTR [eax]
  00252	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00254	75 1a		 jne	 SHORT $LN74@GCGuildWar@2
  00256	84 d2		 test	 dl, dl
  00258	74 12		 je	 SHORT $LN75@GCGuildWar@2
  0025a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0025d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00260	75 0e		 jne	 SHORT $LN74@GCGuildWar@2
  00262	83 c0 02	 add	 eax, 2
  00265	83 c1 02	 add	 ecx, 2
  00268	84 d2		 test	 dl, dl
  0026a	75 e4		 jne	 SHORT $LL73@GCGuildWar@2
$LN75@GCGuildWar@2:
  0026c	33 c0		 xor	 eax, eax
  0026e	eb 05		 jmp	 SHORT $LN76@GCGuildWar@2
$LN74@GCGuildWar@2:
  00270	1b c0		 sbb	 eax, eax
  00272	83 d8 ff	 sbb	 eax, -1
$LN76@GCGuildWar@2:
  00275	85 c0		 test	 eax, eax
  00277	74 15		 je	 SHORT $LN60@GCGuildWar@2
$LN16@GCGuildWar@2:

; 9883 : 							}
; 9884 : 
; 9885 : 							warmaster = n;
; 9886 : 							break;
; 9887 : 						}
; 9888 : 					}
; 9889 : 				}
; 9890 : 			}
; 9891 : 
; 9892 : 			if ( n < OBJMAX-1 )

  00279	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  0027f	0f 8d a2 02 00
	00		 jge	 $LN12@GCGuildWar@2

; 9893 : 				n++;

  00285	43		 inc	 ebx
  00286	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H

; 9894 : 			else
; 9895 : 				break;
; 9896 : 		}

  0028c	eb a3		 jmp	 SHORT $LL21@GCGuildWar@2
$LN60@GCGuildWar@2:

; 9872 : 						{
; 9873 : 							if ( gPkLimitFree == FALSE && gObj[n].m_PK_Level >= 6)

  0028e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00295	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 9893 : 				n++;

  0029b	89 5d dc	 mov	 DWORD PTR _n$220908[ebp], ebx
  0029e	75 2c		 jne	 SHORT $LN15@GCGuildWar@2

; 9872 : 						{
; 9873 : 							if ( gPkLimitFree == FALSE && gObj[n].m_PK_Level >= 6)

  002a0	8b cb		 mov	 ecx, ebx
  002a2	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  002a8	80 bc 31 19 01
	00 00 06	 cmp	 BYTE PTR [ecx+esi+281], 6
  002b0	7c 1a		 jl	 SHORT $LN15@GCGuildWar@2

; 9874 : 							{
; 9875 : 								pMsg.Result = 4;
; 9876 : 
; 9877 : 								LogAdd("Error on declaring war : Target GuildMaster Is Murderer 0x04 %s %s",
; 9878 : 									lpMyGuild->Names[0], gObj[aIndex].Name);

  002b2	8b 55 e0	 mov	 edx, DWORD PTR tv544[ebp]
  002b5	8b 4d d8	 mov	 ecx, DWORD PTR tv569[ebp]
  002b8	8d 44 32 5d	 lea	 eax, DWORD PTR [edx+esi+93]
  002bc	50		 push	 eax
  002bd	51		 push	 ecx
  002be	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  002c2	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@

; 9879 : 
; 9880 : 								DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 9881 : 
; 9882 : 								return;

  002c7	e9 8e fe ff ff	 jmp	 $LN82@GCGuildWar@2
$LN15@GCGuildWar@2:

; 9897 : 		
; 9898 : 		if ( warmaster >= 1 )

  002cc	83 fb 01	 cmp	 ebx, 1
  002cf	0f 8c 52 02 00
	00		 jl	 $LN12@GCGuildWar@2

; 9899 : 		{
; 9900 : 			if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) || CC_MAP_RANGE(gObj[warmaster].MapNumber) )

  002d5	8b 55 e0	 mov	 edx, DWORD PTR tv544[ebp]
  002d8	8a 84 32 23 01
	00 00		 mov	 al, BYTE PTR [edx+esi+291]
  002df	3c 35		 cmp	 al, 53			; 00000035H
  002e1	0f 84 11 02 00
	00		 je	 $LN78@GCGuildWar@2
  002e7	3c 12		 cmp	 al, 18			; 00000012H
  002e9	72 10		 jb	 SHORT $LN61@GCGuildWar@2
  002eb	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  002f0	3a c8		 cmp	 cl, al
  002f2	1b c9		 sbb	 ecx, ecx
  002f4	41		 inc	 ecx
  002f5	0f 85 fd 01 00
	00		 jne	 $LN78@GCGuildWar@2
$LN61@GCGuildWar@2:
  002fb	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00301	8a 8c 1e 23 01
	00 00		 mov	 cl, BYTE PTR [esi+ebx+291]
  00308	80 f9 35	 cmp	 cl, 53			; 00000035H
  0030b	0f 84 e7 01 00
	00		 je	 $LN78@GCGuildWar@2
  00311	80 f9 12	 cmp	 cl, 18			; 00000012H
  00314	72 10		 jb	 SHORT $LN62@GCGuildWar@2
  00316	ba 17 00 00 00	 mov	 edx, 23			; 00000017H
  0031b	3a d1		 cmp	 dl, cl
  0031d	1b d2		 sbb	 edx, edx
  0031f	42		 inc	 edx
  00320	0f 85 d2 01 00
	00		 jne	 $LN78@GCGuildWar@2
$LN62@GCGuildWar@2:

; 9903 : 				return;
; 9904 : 			}
; 9905 : 
; 9906 : 			if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) || IT_MAP_RANGE(gObj[warmaster].MapNumber) )

  00326	3c 2d		 cmp	 al, 45			; 0000002dH
  00328	72 10		 jb	 SHORT $LN63@GCGuildWar@2
  0032a	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  0032f	3a d0		 cmp	 dl, al
  00331	1b d2		 sbb	 edx, edx
  00333	42		 inc	 edx
  00334	0f 85 9a 01 00
	00		 jne	 $LN8@GCGuildWar@2
$LN63@GCGuildWar@2:
  0033a	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  0033d	72 10		 jb	 SHORT $LN64@GCGuildWar@2
  0033f	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  00344	3a d1		 cmp	 dl, cl
  00346	1b d2		 sbb	 edx, edx
  00348	42		 inc	 edx
  00349	0f 85 85 01 00
	00		 jne	 $LN8@GCGuildWar@2
$LN64@GCGuildWar@2:

; 9909 : 				return;
; 9910 : 			}
; 9911 : 
; 9912 : 			if ( DG_MAP_RANGE(gObj[aIndex].MapNumber) || DG_MAP_RANGE(gObj[warmaster].MapNumber) )

  0034f	3c 41		 cmp	 al, 65			; 00000041H
  00351	72 10		 jb	 SHORT $LN65@GCGuildWar@2
  00353	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  00358	3a d0		 cmp	 dl, al
  0035a	1b d2		 sbb	 edx, edx
  0035c	42		 inc	 edx
  0035d	0f 85 4d 01 00
	00		 jne	 $LN6@GCGuildWar@2
$LN65@GCGuildWar@2:
  00363	80 f9 41	 cmp	 cl, 65			; 00000041H
  00366	72 10		 jb	 SHORT $LN66@GCGuildWar@2
  00368	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  0036d	3a d1		 cmp	 dl, cl
  0036f	1b d2		 sbb	 edx, edx
  00371	42		 inc	 edx
  00372	0f 85 38 01 00
	00		 jne	 $LN6@GCGuildWar@2
$LN66@GCGuildWar@2:

; 9915 : 				return;
; 9916 : 			}
; 9917 : 
; 9918 : 			if ( IF_MAP_RANGE(gObj[aIndex].MapNumber) || IF_MAP_RANGE(gObj[warmaster].MapNumber) )

  00378	3c 45		 cmp	 al, 69			; 00000045H
  0037a	72 0d		 jb	 SHORT $LN79@GCGuildWar@2
  0037c	b2 48		 mov	 dl, 72			; 00000048H
  0037e	3a d0		 cmp	 dl, al
  00380	1b c0		 sbb	 eax, eax
  00382	40		 inc	 eax
  00383	0f 85 03 01 00
	00		 jne	 $LN4@GCGuildWar@2
$LN79@GCGuildWar@2:
  00389	80 f9 45	 cmp	 cl, 69			; 00000045H
  0038c	72 10		 jb	 SHORT $LN68@GCGuildWar@2
  0038e	b8 48 00 00 00	 mov	 eax, 72			; 00000048H
  00393	3a c1		 cmp	 al, cl
  00395	1b c0		 sbb	 eax, eax
  00397	40		 inc	 eax
  00398	0f 85 ee 00 00
	00		 jne	 $LN4@GCGuildWar@2
$LN68@GCGuildWar@2:

; 9921 : 				return;
; 9922 : 			}
; 9923 : 
; 9924 : 			if ( (gObj[warmaster].m_Option&1) != 1 )

  0039e	f6 84 1e 24 12
	00 00 01	 test	 BYTE PTR [esi+ebx+4644], 1

; 9925 : 			{
; 9926 : 				pMsg.Result = 4;
; 9927 : 				DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  003a6	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  003aa	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  003ad	51		 push	 ecx
  003ae	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  003b1	52		 push	 edx
  003b2	50		 push	 eax
  003b3	75 1d		 jne	 SHORT $LN3@GCGuildWar@2
  003b5	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  003b9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003be	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c1	5f		 pop	 edi
  003c2	5e		 pop	 esi
  003c3	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  003c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c7	33 cd		 xor	 ecx, ebp
  003c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ce	8b e5		 mov	 esp, ebp
  003d0	5d		 pop	 ebp
  003d1	c3		 ret	 0
$LN3@GCGuildWar@2:

; 9928 : 
; 9929 : 				return;
; 9930 : 			}
; 9931 : 
; 9932 : 			pMsg.Result = 1;

  003d2	c6 45 ef 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1

; 9933 : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  003d6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 9934 : 			GCGuildWarRequestSend(lpMyGuild->Name, warmaster, type);

  003db	8b 5d 10	 mov	 ebx, DWORD PTR _type$[ebp]
  003de	8b 4d dc	 mov	 ecx, DWORD PTR _n$220908[ebp]
  003e1	8b 45 e4	 mov	 eax, DWORD PTR _lpMyGuild$[ebp]
  003e4	53		 push	 ebx
  003e5	51		 push	 ecx
  003e6	83 c0 04	 add	 eax, 4
  003e9	50		 push	 eax
  003ea	e8 00 00 00 00	 call	 ?GCGuildWarRequestSend@@YAXPADHH@Z ; GCGuildWarRequestSend

; 9935 : 			lpMyGuild->WarDeclareState = 1;

  003ef	8b 4d e4	 mov	 ecx, DWORD PTR _lpMyGuild$[ebp]
  003f2	c6 81 90 05 00
	00 01		 mov	 BYTE PTR [ecx+1424], 1
  003f9	83 c4 18	 add	 esp, 24			; 00000018H

; 9936 : 			lpNode->WarDeclareState = 1;

  003fc	c6 87 90 05 00
	00 01		 mov	 BYTE PTR [edi+1424], 1

; 9937 : 			lpMyGuild->WarType = type;

  00403	88 99 92 05 00
	00		 mov	 BYTE PTR [ecx+1426], bl

; 9938 : 			lpNode->WarType = type;
; 9939 : 
; 9940 : 			// Declared guild war [%s][%s] sGuild:(%s) TargetGuild:(%s)
; 9941 : 			LogAddTD(lMsg.Get(MSGGET(1, 236)), gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9942 : 				lpMyGuild->Name, lpNode->Name);

  00409	83 c1 04	 add	 ecx, 4
  0040c	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0040f	56		 push	 esi
  00410	51		 push	 ecx
  00411	8b 4d e0	 mov	 ecx, DWORD PTR tv544[ebp]
  00414	88 9f 92 05 00
	00		 mov	 BYTE PTR [edi+1426], bl
  0041a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0041f	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  00423	52		 push	 edx
  00424	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  00428	50		 push	 eax
  00429	68 ec 01 00 00	 push	 492			; 000001ecH
  0042e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00433	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00438	50		 push	 eax
  00439	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9943 : 
; 9944 : 			strcpy(lpMyGuild->TargetGuildName, lpNode->Name);

  0043f	8b 5d e4	 mov	 ebx, DWORD PTR _lpMyGuild$[ebp]
  00442	8d 8b e0 04 00
	00		 lea	 ecx, DWORD PTR [ebx+1248]
  00448	83 c4 14	 add	 esp, 20			; 00000014H
  0044b	8b c6		 mov	 eax, esi
  0044d	2b ce		 sub	 ecx, esi
  0044f	90		 npad	 1
$LL55@GCGuildWar@2:
  00450	8a 10		 mov	 dl, BYTE PTR [eax]
  00452	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00455	40		 inc	 eax
  00456	84 d2		 test	 dl, dl
  00458	75 f6		 jne	 SHORT $LL55@GCGuildWar@2

; 9945 : 			strcpy(lpNode->TargetGuildName, lpMyGuild->Name);

  0045a	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0045d	8d 97 e0 04 00
	00		 lea	 edx, DWORD PTR [edi+1248]
  00463	2b d0		 sub	 edx, eax
$LL56@GCGuildWar@2:
  00465	8a 08		 mov	 cl, BYTE PTR [eax]
  00467	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0046a	40		 inc	 eax
  0046b	84 c9		 test	 cl, cl
  0046d	75 f6		 jne	 SHORT $LL56@GCGuildWar@2

; 9946 : 			lpMyGuild->lpTargetGuildNode = lpNode;

  0046f	89 bb 8c 05 00
	00		 mov	 DWORD PTR [ebx+1420], edi

; 9947 : 			lpNode->lpTargetGuildNode = lpMyGuild;

  00475	89 9f 8c 05 00
	00		 mov	 DWORD PTR [edi+1420], ebx
  0047b	5f		 pop	 edi
  0047c	5e		 pop	 esi
  0047d	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  0047e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00481	33 cd		 xor	 ecx, ebp
  00483	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00488	8b e5		 mov	 esp, ebp
  0048a	5d		 pop	 ebp
  0048b	c3		 ret	 0
$LN4@GCGuildWar@2:

; 9919 : 			{
; 9920 : 				GCServerMsgStringSend("Guild War cannot be started within Imperial Fort.", aIndex, 1);

  0048c	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0048f	6a 01		 push	 1
  00491	51		 push	 ecx
  00492	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@ENCBPHMM@Guild?5War?5cannot?5be?5started?5with@
  00497	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0049c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0049f	5f		 pop	 edi
  004a0	5e		 pop	 esi
  004a1	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  004a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a5	33 cd		 xor	 ecx, ebp
  004a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ac	8b e5		 mov	 esp, ebp
  004ae	5d		 pop	 ebp
  004af	c3		 ret	 0
$LN6@GCGuildWar@2:

; 9913 : 			{
; 9914 : 				GCServerMsgStringSend("Guild War cannot be started within Doppelganger.", aIndex, 1);

  004b0	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  004b3	6a 01		 push	 1
  004b5	52		 push	 edx
  004b6	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@IJAALLLN@Guild?5War?5cannot?5be?5started?5with@
  004bb	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c3	5f		 pop	 edi
  004c4	5e		 pop	 esi
  004c5	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  004c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004c9	33 cd		 xor	 ecx, ebp
  004cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004d0	8b e5		 mov	 esp, ebp
  004d2	5d		 pop	 ebp
  004d3	c3		 ret	 0
$LN8@GCGuildWar@2:

; 9907 : 			{
; 9908 : 				GCServerMsgStringSend("Guild War cannot be started within Illusion Temple.", aIndex, 1);

  004d4	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  004d7	6a 01		 push	 1
  004d9	50		 push	 eax
  004da	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@OPCGOEPD@Guild?5War?5cannot?5be?5started?5with@
  004df	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e7	5f		 pop	 edi
  004e8	5e		 pop	 esi
  004e9	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  004ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004ed	33 cd		 xor	 ecx, ebp
  004ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004f4	8b e5		 mov	 esp, ebp
  004f6	5d		 pop	 ebp
  004f7	c3		 ret	 0
$LN78@GCGuildWar@2:

; 9901 : 			{
; 9902 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(4, 199)), aIndex, 1);

  004f8	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  004fb	6a 01		 push	 1
  004fd	51		 push	 ecx
  004fe	68 c7 04 00 00	 push	 1223			; 000004c7H
  00503	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00508	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0050d	50		 push	 eax
  0050e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00513	83 c4 0c	 add	 esp, 12			; 0000000cH
  00516	5f		 pop	 edi
  00517	5e		 pop	 esi
  00518	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  00519	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0051c	33 cd		 xor	 ecx, ebp
  0051e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00523	8b e5		 mov	 esp, ebp
  00525	5d		 pop	 ebp
  00526	c3		 ret	 0
$LN12@GCGuildWar@2:

; 9948 : 		}
; 9949 : 		else
; 9950 : 		{
; 9951 : 			pMsg.Result = 2;

  00527	c6 45 ef 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2

; 9841 : 		{
; 9842 : 			pMsg.Result = 4;
; 9843 : 
; 9844 : 			//Error on declaring war : %d %d %s
; 9845 : 			LogAdd(lMsg.Get(MSGGET(1, 234)), lpNode->WarState,
; 9846 : 				lpNode->WarDeclareState, lpNode->Name);
; 9847 : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 9848 : 
; 9849 : 			return;

  0052b	eb 04		 jmp	 SHORT $LN81@GCGuildWar@2
$LN25@GCGuildWar@2:

; 9952 : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 9953 : 
; 9954 : 			//return;
; 9955 : 		}
; 9956 : 	}
; 9957 : 	else
; 9958 : 	{
; 9959 : 		pMsg.Result = 0;

  0052d	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
$LN81@GCGuildWar@2:

; 9960 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00531	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00535	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00538	52		 push	 edx
  00539	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0053c	50		 push	 eax
  0053d	51		 push	 ecx
  0053e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00543	83 c4 0c	 add	 esp, 12			; 0000000cH
  00546	5f		 pop	 edi
  00547	5e		 pop	 esi
  00548	5b		 pop	 ebx

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  00549	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0054c	33 cd		 xor	 ecx, ebp
  0054e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00553	8b e5		 mov	 esp, ebp
  00555	5d		 pop	 ebp
  00556	c3		 ret	 0
$LN29@GCGuildWar@2:

; 9795 : 	{
; 9796 : 		pMsg.Result = 4;

  00557	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4

; 9797 : 
; 9798 : 		//Error on declaring war : %d %d %s
; 9799 : 		LogAdd(lMsg.Get(MSGGET(1, 234)), lpMyGuild->WarState,
; 9800 : 			lpMyGuild->WarDeclareState, lpMyGuild->Name);

  0055b	0f b6 87 90 05
	00 00		 movzx	 eax, BYTE PTR [edi+1424]
  00562	0f b6 8f 91 05
	00 00		 movzx	 ecx, BYTE PTR [edi+1425]
  00569	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  0056c	52		 push	 edx
  0056d	50		 push	 eax
  0056e	51		 push	 ecx
  0056f	68 ea 01 00 00	 push	 490			; 000001eaH
  00574	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00579	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0057e	50		 push	 eax
  0057f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 9801 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00585	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00589	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0058c	52		 push	 edx
  0058d	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00590	50		 push	 eax
  00591	51		 push	 ecx
  00592	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00597	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@GCGuildWar@2:

; 9961 : 
; 9962 : 		return;
; 9963 : 	}
; 9964 : }

  0059a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0059d	5f		 pop	 edi
  0059e	5e		 pop	 esi
  0059f	33 cd		 xor	 ecx, ebp
  005a1	5b		 pop	 ebx
  005a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005a7	8b e5		 mov	 esp, ebp
  005a9	5d		 pop	 ebp
  005aa	c3		 ret	 0
?GCGuildWarRequestResult@@YAXPADHH@Z ENDP		; GCGuildWarRequestResult
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ; GCGuildWarRequestSendRecv
EXTRN	?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
EXTRN	?gObjTeleport@@YAXHHHH@Z:PROC			; gObjTeleport
EXTRN	?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z:PROC ; gSetBattleTeamMaster
EXTRN	?BattleSoccerGoalEnd@@YAXH@Z:PROC		; BattleSoccerGoalEnd
EXTRN	?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjMonsterRegen
EXTRN	?gBSGround@@3PAPAVCBattleSoccer@@A:DWORD	; gBSGround
EXTRN	?gCheckBlankBattleGround@@YAHXZ:PROC		; gCheckBlankBattleGround
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -300					; size = 4
_pResult$220992 = -300					; size = 4
tv672 = -296						; size = 4
_pResult$221007 = -296					; size = 4
_pResult$220981 = -296					; size = 4
_pNotice$220987 = -292					; size = 272
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z PROC ; GCGuildWarRequestSendRecv, COMDAT

; 10005: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 10006: #if (GS_CASTLE == 1 && GS_SPEC != 1)
; 10007: 	return;
; 10008: #endif
; 10009: 	PMSG_GUILDWAR_DECLARE pMsg;
; 10010: 	int count=0;
; 10011: 	int g_call=0;
; 10012: 	int n;
; 10013: 	
; 10014: 	PHeadSetB((LPBYTE)&pMsg, 0x62, sizeof(pMsg));

  0001c	6a 0d		 push	 13			; 0000000dH
  0001e	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00021	6a 62		 push	 98			; 00000062H
  00023	50		 push	 eax

; 10015: 	pMsg.Type = 0;
; 10016: 	
; 10017: 	_GUILD_INFO_STRUCT * lpMyNode = gObj[aIndex].lpGuild;

  00024	89 b5 d4 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0002a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0002f	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	33 db		 xor	 ebx, ebx
  0003d	88 5d f7	 mov	 BYTE PTR _pMsg$[ebp+11], bl
  00040	89 b5 d8 fe ff
	ff		 mov	 DWORD PTR tv672[ebp], esi
  00046	8b b4 0e 18 06
	00 00		 mov	 esi, DWORD PTR [esi+ecx+1560]
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10018: 
; 10019: 	if ( !lpMyNode )

  00050	3b f3		 cmp	 esi, ebx
  00052	75 3f		 jne	 SHORT $LN50@GCGuildWar@3

; 10020: 	{
; 10021: 		PMSG_GUILDWARREQUEST_RESULT pResult;
; 10022: 
; 10023: 		pResult.h.c = 0xC1;
; 10024: 		pResult.h.headcode = 0x60;
; 10025: 		pResult.h.size = sizeof(pResult);
; 10026: 		pResult.Result = 0;
; 10027: 
; 10028: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00054	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0005a	6a 04		 push	 4
  0005c	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$220981[ebp]
  00062	51		 push	 ecx
  00063	52		 push	 edx
  00064	c6 85 d8 fe ff
	ff c1		 mov	 BYTE PTR _pResult$220981[ebp], 193 ; 000000c1H
  0006b	66 c7 85 d9 fe
	ff ff 04 60	 mov	 WORD PTR _pResult$220981[ebp+1], 24580 ; 00006004H
  00074	88 9d db fe ff
	ff		 mov	 BYTE PTR _pResult$220981[ebp+3], bl
  0007a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10259: 						GCServerMsgStringSendGuild(lpMyNode,lMsg.Get(MSGGET(4, 130)), 1);

  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx

; 10260: 					}
; 10261: 				}
; 10262: 			}
; 10263: 		}
; 10264: 	}
; 10265: }

  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN50@GCGuildWar@3:

; 10029: 		return;
; 10030: 	}
; 10031: 
; 10032: 	if ( lpMyNode->lpTargetGuildNode && lpMsg->Result )

  00093	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  00099	3b c3		 cmp	 eax, ebx
  0009b	0f 84 c4 00 00
	00		 je	 $LN48@GCGuildWar@3
  000a1	38 5f 03	 cmp	 BYTE PTR [edi+3], bl
  000a4	0f 84 bb 00 00
	00		 je	 $LN48@GCGuildWar@3

; 10033: 	{
; 10034: 		int iTarGetIndex = lpMyNode->lpTargetGuildNode->Index[0];

  000aa	0f bf 80 a0 03
	00 00		 movsx	 eax, WORD PTR [eax+928]

; 10035: 
; 10036: 		if ( BC_MAP_RANGE(gObj[iTarGetIndex].MapNumber) ||
; 10037: 			 CC_MAP_RANGE(gObj[iTarGetIndex].MapNumber) ||
; 10038: 			 DS_MAP_RANGE(gObj[iTarGetIndex].MapNumber) ||
; 10039: 			 IT_MAP_RANGE(gObj[iTarGetIndex].MapNumber) ||
; 10040: 			 DG_MAP_RANGE(gObj[iTarGetIndex].MapNumber) ||
; 10041: 			 IF_MAP_RANGE(gObj[iTarGetIndex].MapNumber)
; 10042: 			 )

  000b1	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  000b7	8a 84 08 23 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+291]
  000be	3c 34		 cmp	 al, 52			; 00000034H
  000c0	74 64		 je	 SHORT $LN47@GCGuildWar@3
  000c2	3c 0b		 cmp	 al, 11			; 0000000bH
  000c4	72 0e		 jb	 SHORT $LN73@GCGuildWar@3
  000c6	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  000cb	3a c8		 cmp	 cl, al
  000cd	1b c9		 sbb	 ecx, ecx
  000cf	41		 inc	 ecx
  000d0	3b cb		 cmp	 ecx, ebx
  000d2	75 52		 jne	 SHORT $LN47@GCGuildWar@3
$LN73@GCGuildWar@3:
  000d4	3c 35		 cmp	 al, 53			; 00000035H
  000d6	74 4e		 je	 SHORT $LN47@GCGuildWar@3
  000d8	3c 12		 cmp	 al, 18			; 00000012H
  000da	72 0b		 jb	 SHORT $LN74@GCGuildWar@3
  000dc	b2 17		 mov	 dl, 23			; 00000017H
  000de	3a d0		 cmp	 dl, al
  000e0	1b c9		 sbb	 ecx, ecx
  000e2	41		 inc	 ecx
  000e3	3b cb		 cmp	 ecx, ebx
  000e5	75 3f		 jne	 SHORT $LN47@GCGuildWar@3
$LN74@GCGuildWar@3:
  000e7	3c 09		 cmp	 al, 9
  000e9	74 3b		 je	 SHORT $LN47@GCGuildWar@3
  000eb	33 c9		 xor	 ecx, ecx
  000ed	3c 20		 cmp	 al, 32			; 00000020H
  000ef	0f 94 c1	 sete	 cl
  000f2	3b cb		 cmp	 ecx, ebx
  000f4	75 30		 jne	 SHORT $LN47@GCGuildWar@3
  000f6	3c 2d		 cmp	 al, 45			; 0000002dH
  000f8	72 0e		 jb	 SHORT $LN75@GCGuildWar@3
  000fa	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  000ff	3a c8		 cmp	 cl, al
  00101	1b c9		 sbb	 ecx, ecx
  00103	41		 inc	 ecx
  00104	3b cb		 cmp	 ecx, ebx
  00106	75 1e		 jne	 SHORT $LN47@GCGuildWar@3
$LN75@GCGuildWar@3:
  00108	3c 41		 cmp	 al, 65			; 00000041H
  0010a	72 0b		 jb	 SHORT $LN76@GCGuildWar@3
  0010c	b2 44		 mov	 dl, 68			; 00000044H
  0010e	3a d0		 cmp	 dl, al
  00110	1b c9		 sbb	 ecx, ecx
  00112	41		 inc	 ecx
  00113	3b cb		 cmp	 ecx, ebx
  00115	75 0f		 jne	 SHORT $LN47@GCGuildWar@3
$LN76@GCGuildWar@3:
  00117	3c 45		 cmp	 al, 69			; 00000045H
  00119	72 4a		 jb	 SHORT $LN48@GCGuildWar@3
  0011b	b1 48		 mov	 cl, 72			; 00000048H
  0011d	3a c8		 cmp	 cl, al
  0011f	1b c0		 sbb	 eax, eax
  00121	40		 inc	 eax
  00122	3b c3		 cmp	 eax, ebx
  00124	74 3f		 je	 SHORT $LN48@GCGuildWar@3
$LN47@GCGuildWar@3:

; 10043: 		{
; 10044: 			PMSG_NOTICE pNotice;
; 10045: 
; 10046: 			TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 199)));

  00126	68 c7 04 00 00	 push	 1223			; 000004c7H
  0012b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00130	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00135	50		 push	 eax
  00136	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$220987[ebp]
  0013c	6a 01		 push	 1
  0013e	52		 push	 edx
  0013f	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 10047: 
; 10048: 			DataSend(aIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00144	0f b6 85 dd fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$220987[ebp+1]
  0014b	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00151	50		 push	 eax
  00152	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$220987[ebp]
  00158	51		 push	 ecx
  00159	52		 push	 edx
  0015a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0015f	83 c4 18	 add	 esp, 24			; 00000018H

; 10049: 
; 10050: 			lpMsg->Result = 0;

  00162	88 5f 03	 mov	 BYTE PTR [edi+3], bl
$LN48@GCGuildWar@3:

; 10051: 		}
; 10052: 	}
; 10053: 
; 10054: 	pMsg.Type = lpMyNode->WarType;

  00165	8a 86 92 05 00
	00		 mov	 al, BYTE PTR [esi+1426]
  0016b	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 10055: 
; 10056: 	if ( lpMsg->Result == 0 )

  0016e	38 5f 03	 cmp	 BYTE PTR [edi+3], bl
  00171	0f 85 81 00 00
	00		 jne	 $LN46@GCGuildWar@3

; 10057: 	{
; 10058: 		if ( lpMyNode->lpTargetGuildNode )

  00177	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  0017d	3b c3		 cmp	 eax, ebx
  0017f	0f 84 06 05 00
	00		 je	 $LN1@GCGuildWar@3

; 10059: 		{
; 10060: 			if ( lpMyNode->lpTargetGuildNode->WarDeclareState == 1 )

  00185	80 b8 90 05 00
	00 01		 cmp	 BYTE PTR [eax+1424], 1
  0018c	0f 85 f9 04 00
	00		 jne	 $LN1@GCGuildWar@3

; 10061: 			{
; 10062: 				lpMyNode->lpTargetGuildNode->WarDeclareState = 0;
; 10063: 				lpMyNode->WarDeclareState = 0;
; 10064: 
; 10065: 				PMSG_GUILDWARREQUEST_RESULT pResult;
; 10066: 
; 10067: 				PHeadSetB((LPBYTE)&pResult, 0x60, sizeof(pResult));

  00192	6a 04		 push	 4
  00194	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$220992[ebp]
  0019a	6a 60		 push	 96			; 00000060H
  0019c	88 98 90 05 00
	00		 mov	 BYTE PTR [eax+1424], bl
  001a2	51		 push	 ecx
  001a3	88 9e 90 05 00
	00		 mov	 BYTE PTR [esi+1424], bl
  001a9	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10068: 				pResult.Result = 6;
; 10069: 
; 10070: 				if ( lpMyNode->lpTargetGuildNode->Index[0] >= 0 )

  001ae	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  001b4	c6 85 d7 fe ff
	ff 06		 mov	 BYTE PTR _pResult$220992[ebp+3], 6
  001bb	0f b7 82 a0 03
	00 00		 movzx	 eax, WORD PTR [edx+928]
  001c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c5	66 3b c3	 cmp	 ax, bx
  001c8	0f 8c bd 04 00
	00		 jl	 $LN1@GCGuildWar@3

; 10071: 				{
; 10072: 					DataSend(lpMyNode->lpTargetGuildNode->Index[0], (LPBYTE)&pResult, pResult.h.size);

  001ce	0f b6 8d d5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$220992[ebp+1]
  001d5	51		 push	 ecx
  001d6	8d 95 d4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$220992[ebp]
  001dc	98		 cwde
  001dd	52		 push	 edx
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10259: 						GCServerMsgStringSendGuild(lpMyNode,lMsg.Get(MSGGET(4, 130)), 1);

  001e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx

; 10260: 					}
; 10261: 				}
; 10262: 			}
; 10263: 		}
; 10264: 	}
; 10265: }

  001ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ed	33 cd		 xor	 ecx, ebp
  001ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c3		 ret	 0
$LN46@GCGuildWar@3:

; 10073: 				}
; 10074: 			}
; 10075: 		}
; 10076: 	}
; 10077: 	else //if ( lpMsg->Result == 1 )
; 10078: 	{
; 10079: 		if ( lpMyNode->WarDeclareState == 1 )

  001f8	80 be 90 05 00
	00 01		 cmp	 BYTE PTR [esi+1424], 1
  001ff	0f 85 86 04 00
	00		 jne	 $LN1@GCGuildWar@3

; 10080: 		{
; 10081: 			if ( lpMyNode->lpTargetGuildNode )

  00205	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  0020b	3b c3		 cmp	 eax, ebx
  0020d	0f 84 78 04 00
	00		 je	 $LN1@GCGuildWar@3

; 10082: 			{
; 10083: 				if (lpMyNode->lpTargetGuildNode->WarDeclareState == 1 )

  00213	80 b8 90 05 00
	00 01		 cmp	 BYTE PTR [eax+1424], 1
  0021a	0f 85 6b 04 00
	00		 jne	 $LN1@GCGuildWar@3

; 10084: 				{
; 10085: 					PMSG_TELEPORT pTeleportMsg;
; 10086: 
; 10087: 					if ( lpMyNode->WarType == 1 )

  00220	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  00227	0f 85 98 00 00
	00		 jne	 $LN38@GCGuildWar@3

; 10088: 					{
; 10089: 						lpMyNode->BattleGroundIndex = gCheckBlankBattleGround();

  0022d	e8 00 00 00 00	 call	 ?gCheckBlankBattleGround@@YAHXZ ; gCheckBlankBattleGround
  00232	88 86 93 05 00
	00		 mov	 BYTE PTR [esi+1427], al

; 10090: 
; 10091: 						switch ( lpMyNode->BattleGroundIndex )

  00238	3c ff		 cmp	 al, 255			; 000000ffH
  0023a	0f 84 69 01 00
	00		 je	 $LN35@GCGuildWar@3

; 10105: 								return;
; 10106: 						}
; 10107: 	
; 10108: 						pTeleportMsg.MoveNumber = 51;
; 10109: 						lpMyNode->lpTargetGuildNode->BattleGroundIndex = lpMyNode->BattleGroundIndex;

  00240	8b 8e 8c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1420]
  00246	88 81 93 05 00
	00		 mov	 BYTE PTR [ecx+1427], al

; 10110: 
; 10111: 						if ( gBSGround[0]->m_BallIndex >= 0 )

  0024c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gBSGround@@3PAPAVCBattleSoccer@@A ; gBSGround
  00252	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00255	3b c3		 cmp	 eax, ebx
  00257	7c 15		 jl	 SHORT $LN34@GCGuildWar@3

; 10112: 							gObjMonsterRegen(&gObj[gBSGround[0]->m_BallIndex]);

  00259	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0025f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 ?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterRegen
  0026b	83 c4 04	 add	 esp, 4
$LN34@GCGuildWar@3:

; 10113: 
; 10114: 						BattleSoccerGoalEnd(0);

  0026e	53		 push	 ebx
  0026f	e8 00 00 00 00	 call	 ?BattleSoccerGoalEnd@@YAXH@Z ; BattleSoccerGoalEnd

; 10115: 						lpMyNode->PlayScore = 0;
; 10116: 						lpMyNode->lpTargetGuildNode->PlayScore = 0;

  00274	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  0027a	88 9e 95 05 00
	00		 mov	 BYTE PTR [esi+1429], bl
  00280	88 98 95 05 00
	00		 mov	 BYTE PTR [eax+1429], bl

; 10117: 						gBattleGroundEnable(lpMyNode->BattleGroundIndex, TRUE);

  00286	0f b6 8e 93 05
	00 00		 movzx	 ecx, BYTE PTR [esi+1427]
  0028d	6a 01		 push	 1
  0028f	51		 push	 ecx
  00290	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable

; 10118: 						gSetBattleTeamMaster(lpMyNode->BattleGroundIndex, 0, lpMyNode->Name, lpMyNode);

  00295	0f b6 86 93 05
	00 00		 movzx	 eax, BYTE PTR [esi+1427]
  0029c	56		 push	 esi
  0029d	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  002a0	52		 push	 edx
  002a1	53		 push	 ebx
  002a2	50		 push	 eax
  002a3	e8 00 00 00 00	 call	 ?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z ; gSetBattleTeamMaster

; 10119: 						gSetBattleTeamMaster(lpMyNode->BattleGroundIndex, 1, lpMyNode->lpTargetGuildNode->Name, lpMyNode->lpTargetGuildNode);

  002a8	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  002ae	0f b6 8e 93 05
	00 00		 movzx	 ecx, BYTE PTR [esi+1427]
  002b5	50		 push	 eax
  002b6	83 c0 04	 add	 eax, 4
  002b9	50		 push	 eax
  002ba	6a 01		 push	 1
  002bc	51		 push	 ecx
  002bd	e8 00 00 00 00	 call	 ?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z ; gSetBattleTeamMaster
  002c2	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN38@GCGuildWar@3:

; 10120: 					}
; 10121: 
; 10122: 					lpMyNode->WarDeclareState = 2;
; 10123: 					lpMyNode->WarState = 1;
; 10124: 					lpMyNode->lpTargetGuildNode->WarDeclareState = 2;

  002c5	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  002cb	66 c7 86 90 05
	00 00 02 01	 mov	 WORD PTR [esi+1424], 258 ; 00000102H
  002d4	b0 02		 mov	 al, 2
  002d6	88 82 90 05 00
	00		 mov	 BYTE PTR [edx+1424], al

; 10125: 					lpMyNode->lpTargetGuildNode->WarState = 1;

  002dc	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  002e2	c6 80 91 05 00
	00 01		 mov	 BYTE PTR [eax+1425], 1

; 10126: 					lpMyNode->PlayScore = 0;
; 10127: 					lpMyNode->lpTargetGuildNode->PlayScore = 0;

  002e9	8b 8e 8c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1420]
  002ef	88 9e 95 05 00
	00		 mov	 BYTE PTR [esi+1429], bl
  002f5	88 99 95 05 00
	00		 mov	 BYTE PTR [ecx+1429], bl

; 10128: 					lpMyNode->BattleTeamCode = 0;
; 10129: 					lpMyNode->lpTargetGuildNode->BattleTeamCode = 1;

  002fb	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  00301	88 9e 94 05 00
	00		 mov	 BYTE PTR [esi+1428], bl
  00307	c6 82 94 05 00
	00 01		 mov	 BYTE PTR [edx+1428], 1

; 10130: 					memset(pMsg.GuildName, 0, sizeof(pMsg.GuildName));

  0030e	33 c0		 xor	 eax, eax
  00310	89 45 ef	 mov	 DWORD PTR _pMsg$[ebp+3], eax
  00313	89 45 f3	 mov	 DWORD PTR _pMsg$[ebp+7], eax

; 10131: 					memcpy(pMsg.GuildName, lpMyNode->lpTargetGuildNode->Name, sizeof(pMsg.GuildName));

  00316	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  0031c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0031f	89 4d ef	 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  00322	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 10132: 					pMsg.TeamCode = lpMyNode->BattleTeamCode;
; 10133: 					count = 0;
; 10134: 
; 10135: 					for ( n=0;n<MAX_USER_GUILD;n++)

  00325	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0032b	89 55 f3	 mov	 DWORD PTR _pMsg$[ebp+7], edx
  0032e	8a 86 94 05 00
	00		 mov	 al, BYTE PTR [esi+1428]
  00334	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  00337	33 ff		 xor	 edi, edi
  00339	8d a4 24 00 00
	00 00		 npad	 7
$LL33@GCGuildWar@3:

; 10136: 					{
; 10137: 						if ( lpMyNode->Use[n] )

  00340	38 9c 3e 40 04
	00 00		 cmp	 BYTE PTR [esi+edi+1088], bl
  00347	0f 84 74 01 00
	00		 je	 $LN32@GCGuildWar@3

; 10138: 						{
; 10139: 							if ( lpMyNode->Index[n] >= 0 )

  0034d	0f b7 84 7e a0
	03 00 00	 movzx	 eax, WORD PTR [esi+edi*2+928]
  00355	66 3b c3	 cmp	 ax, bx
  00358	0f 8c 63 01 00
	00		 jl	 $LN32@GCGuildWar@3

; 10140: 							{
; 10141: 								g_call = 0;
; 10142: 
; 10143: 								if ( n > 0 )

  0035e	3b fb		 cmp	 edi, ebx
  00360	0f 8e a8 00 00
	00		 jle	 $LN84@GCGuildWar@3

; 10144: 								{
; 10145: 									if ( lpMyNode->WarType == 1 )

  00366	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  0036d	0f 85 a1 00 00
	00		 jne	 $LN77@GCGuildWar@3

; 10146: 									{
; 10147: 										if ( gObj[lpMyNode->Index[0]].PartyNumber  >= 0 )

  00373	0f bf 96 a0 03
	00 00		 movsx	 edx, WORD PTR [esi+928]
  0037a	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  00380	8b 94 0a 0c 06
	00 00		 mov	 edx, DWORD PTR [edx+ecx+1548]
  00387	3b d3		 cmp	 edx, ebx
  00389	0f 8c 32 01 00
	00		 jl	 $LN32@GCGuildWar@3

; 10148: 										{
; 10149: 											if ( gObj[lpMyNode->Index[0]].PartyNumber == gObj[lpMyNode->Index[n]].PartyNumber )

  0038f	0f bf d8	 movsx	 ebx, ax
  00392	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00398	3b 94 0b 0c 06
	00 00		 cmp	 edx, DWORD PTR [ebx+ecx+1548]
  0039f	0f 85 1a 01 00
	00		 jne	 $LN82@GCGuildWar@3

; 10150: 											{
; 10151: 												g_call = 1;
; 10152: 											}
; 10153: 										}
; 10154: 									}
; 10155: 									else 

  003a5	33 db		 xor	 ebx, ebx
  003a7	eb 6b		 jmp	 SHORT $LN77@GCGuildWar@3
$LN35@GCGuildWar@3:

; 10092: 						{
; 10093: 							case 0xFF:
; 10094: 								lpMyNode->WarDeclareState = 0;
; 10095: 								lpMyNode->WarState = 0;
; 10096: 								lpMyNode->lpTargetGuildNode->WarDeclareState = 0;

  003a9	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  003af	66 89 9e 90 05
	00 00		 mov	 WORD PTR [esi+1424], bx

; 10097: 								lpMyNode->lpTargetGuildNode->WarState = 0;
; 10098: 
; 10099: 								PMSG_GUILDWARREQUEST_RESULT pResult;
; 10100: 
; 10101: 								PHeadSetB((LPBYTE)&pResult, 0x60, sizeof(pResult));

  003b6	6a 04		 push	 4
  003b8	88 9a 90 05 00
	00		 mov	 BYTE PTR [edx+1424], bl
  003be	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  003c4	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$221007[ebp]
  003ca	6a 60		 push	 96			; 00000060H
  003cc	51		 push	 ecx
  003cd	88 98 91 05 00
	00		 mov	 BYTE PTR [eax+1425], bl
  003d3	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10102: 								pResult.Result = 4;
; 10103: 
; 10104: 								DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  003d8	0f b6 95 d9 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$221007[ebp+1]
  003df	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  003e5	52		 push	 edx
  003e6	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$221007[ebp]
  003ec	50		 push	 eax
  003ed	51		 push	 ecx
  003ee	c6 85 db fe ff
	ff 04		 mov	 BYTE PTR _pResult$221007[ebp+3], 4
  003f5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003fa	83 c4 18	 add	 esp, 24			; 00000018H
  003fd	5f		 pop	 edi
  003fe	5e		 pop	 esi
  003ff	5b		 pop	 ebx

; 10260: 					}
; 10261: 				}
; 10262: 			}
; 10263: 		}
; 10264: 	}
; 10265: }

  00400	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00403	33 cd		 xor	 ecx, ebp
  00405	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040a	8b e5		 mov	 esp, ebp
  0040c	5d		 pop	 ebp
  0040d	c3		 ret	 0
$LN84@GCGuildWar@3:

; 10156: 									{
; 10157: 										g_call = 1;
; 10158: 									}
; 10159: 								}
; 10160: 								else if ( n== 0 )

  0040e	0f 85 ad 00 00
	00		 jne	 $LN32@GCGuildWar@3
$LN77@GCGuildWar@3:

; 10161: 								{
; 10162: 									g_call = 1;
; 10163: 								}
; 10164: 
; 10165: 								if ( g_call )
; 10166: 								{
; 10167: 									DataSend(lpMyNode->Index[n], (LPBYTE)&pMsg, pMsg.h.size);

  00414	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00418	51		 push	 ecx
  00419	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0041c	98		 cwde
  0041d	52		 push	 edx
  0041e	50		 push	 eax
  0041f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00424	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10168: 
; 10169: 									// Declared guild war against (%s)
; 10170: 									LogAddTD(lMsg.Get(MSGGET(1, 238)), lpMyNode->Name);

  00427	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0042a	51		 push	 ecx
  0042b	68 ee 01 00 00	 push	 494			; 000001eeH
  00430	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00435	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0043a	50		 push	 eax
  0043b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 10171: 									GCGuildWarScore(lpMyNode->Index[n]);

  00441	0f bf 94 7e a0
	03 00 00	 movsx	 edx, WORD PTR [esi+edi*2+928]
  00449	52		 push	 edx
  0044a	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore

; 10172: 									int x = 60;
; 10173: 
; 10174: 									if ( lpMyNode->WarType == 1 )
; 10175: 									{
; 10176: 										gObj[lpMyNode->Index[n]].IsInBattleGround = true;

  0044f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00455	83 c4 0c	 add	 esp, 12			; 0000000cH
  00458	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  0045f	75 60		 jne	 SHORT $LN32@GCGuildWar@3
  00461	0f bf 84 7e a0
	03 00 00	 movsx	 eax, WORD PTR [esi+edi*2+928]
  00469	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0046f	c6 84 08 de 13
	00 00 01	 mov	 BYTE PTR [eax+ecx+5086], 1

; 10177: 										pTeleportMsg.MoveNumber = 51;
; 10178: 
; 10179: 										if ( gPkLimitFree || gObj[lpMyNode->Index[n]].m_PK_Level < 6 )

  00477	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, ebx ; gPkLimitFree
  0047d	75 1e		 jne	 SHORT $LN18@GCGuildWar@3
  0047f	0f bf 94 7e a0
	03 00 00	 movsx	 edx, WORD PTR [esi+edi*2+928]
  00487	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0048d	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  00493	80 bc 0a 19 01
	00 00 06	 cmp	 BYTE PTR [edx+ecx+281], 6
  0049b	7d 24		 jge	 SHORT $LN32@GCGuildWar@3
$LN18@GCGuildWar@3:

; 10180: 										{
; 10181: 											gObjTeleport(lpMyNode->Index[n], 6, x++, 153);

  0049d	0f bf 84 7e a0
	03 00 00	 movsx	 eax, WORD PTR [esi+edi*2+928]
  004a5	68 99 00 00 00	 push	 153			; 00000099H
  004aa	6a 3c		 push	 60			; 0000003cH
  004ac	6a 06		 push	 6
  004ae	50		 push	 eax
  004af	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  004b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004ba	83 c4 10	 add	 esp, 16			; 00000010H
  004bd	eb 02		 jmp	 SHORT $LN32@GCGuildWar@3
$LN82@GCGuildWar@3:
  004bf	33 db		 xor	 ebx, ebx
$LN32@GCGuildWar@3:

; 10132: 					pMsg.TeamCode = lpMyNode->BattleTeamCode;
; 10133: 					count = 0;
; 10134: 
; 10135: 					for ( n=0;n<MAX_USER_GUILD;n++)

  004c1	47		 inc	 edi
  004c2	83 ff 50	 cmp	 edi, 80			; 00000050H
  004c5	0f 8c 75 fe ff
	ff		 jl	 $LL33@GCGuildWar@3

; 10182: 											count++;
; 10183: 										}
; 10184: 									}
; 10185: 								}
; 10186: 							}
; 10187: 						}
; 10188: 					}
; 10189: 
; 10190: 					memset(pMsg.GuildName, 0, sizeof(pMsg.GuildName));

  004cb	33 c0		 xor	 eax, eax
  004cd	89 45 ef	 mov	 DWORD PTR _pMsg$[ebp+3], eax
  004d0	89 45 f3	 mov	 DWORD PTR _pMsg$[ebp+7], eax

; 10191: 					memcpy(pMsg.GuildName, lpMyNode->Name, sizeof(pMsg.GuildName));

  004d3	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  004d6	89 55 ef	 mov	 DWORD PTR _pMsg$[ebp+3], edx
  004d9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  004dc	89 45 f3	 mov	 DWORD PTR _pMsg$[ebp+7], eax

; 10192: 
; 10193: 					pMsg.TeamCode = lpMyNode->lpTargetGuildNode->BattleTeamCode;

  004df	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  004e5	8a 82 94 05 00
	00		 mov	 al, BYTE PTR [edx+1428]
  004eb	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 10194: 					count = 0;
; 10195: 
; 10196: 					for ( n=0;n<MAX_USER_GUILD;n++)

  004ee	33 ff		 xor	 edi, edi
$LL17@GCGuildWar@3:

; 10197: 					{
; 10198: 						if ( lpMyNode->lpTargetGuildNode->Use[n] )

  004f0	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  004f6	38 9c 3a 40 04
	00 00		 cmp	 BYTE PTR [edx+edi+1088], bl
  004fd	0f 84 19 01 00
	00		 je	 $LN16@GCGuildWar@3

; 10199: 						{
; 10200: 							if ( lpMyNode->lpTargetGuildNode->Index[n] >= 0 )

  00503	0f b7 84 7a a0
	03 00 00	 movzx	 eax, WORD PTR [edx+edi*2+928]
  0050b	66 3b c3	 cmp	 ax, bx
  0050e	0f 8c 08 01 00
	00		 jl	 $LN16@GCGuildWar@3

; 10201: 							{
; 10202: 								g_call = 0;
; 10203: 
; 10204: 								if ( n > 0 )

  00514	3b fb		 cmp	 edi, ebx
  00516	7e 3f		 jle	 SHORT $LN85@GCGuildWar@3

; 10205: 								{
; 10206: 									if ( lpMyNode->WarType == 1 )

  00518	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  0051f	75 3c		 jne	 SHORT $LN78@GCGuildWar@3

; 10207: 									{
; 10208: 										if ( gObj[lpMyNode->lpTargetGuildNode->Index[0]].PartyNumber  >= 0 )

  00521	0f bf 92 a0 03
	00 00		 movsx	 edx, WORD PTR [edx+928]
  00528	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  0052e	8b 94 0a 0c 06
	00 00		 mov	 edx, DWORD PTR [edx+ecx+1548]
  00535	3b d3		 cmp	 edx, ebx
  00537	0f 8c df 00 00
	00		 jl	 $LN16@GCGuildWar@3

; 10209: 										{
; 10210: 											if ( gObj[lpMyNode->lpTargetGuildNode->Index[0]].PartyNumber == gObj[lpMyNode->lpTargetGuildNode->Index[n]].PartyNumber )

  0053d	0f bf d8	 movsx	 ebx, ax
  00540	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00546	3b 94 0b 0c 06
	00 00		 cmp	 edx, DWORD PTR [ebx+ecx+1548]
  0054d	0f 85 c7 00 00
	00		 jne	 $LN81@GCGuildWar@3

; 10211: 											{
; 10212: 												g_call = 1;
; 10213: 											}
; 10214: 										}
; 10215: 									}
; 10216: 									else 

  00553	33 db		 xor	 ebx, ebx
  00555	eb 06		 jmp	 SHORT $LN78@GCGuildWar@3
$LN85@GCGuildWar@3:

; 10217: 									{
; 10218: 										g_call = 1;
; 10219: 									}
; 10220: 								}
; 10221: 								else if ( n== 0 )

  00557	0f 85 bf 00 00
	00		 jne	 $LN16@GCGuildWar@3
$LN78@GCGuildWar@3:

; 10222: 								{
; 10223: 									g_call = 1;
; 10224: 								}
; 10225: 
; 10226: 								if ( g_call )
; 10227: 								{
; 10228: 									DataSend(lpMyNode->lpTargetGuildNode->Index[n], (LPBYTE)&pMsg, pMsg.h.size);

  0055d	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00561	51		 push	 ecx
  00562	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00565	98		 cwde
  00566	52		 push	 edx
  00567	50		 push	 eax
  00568	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10229: 
; 10230: 									// Declared guild war against (%s)
; 10231: 									LogAddTD(lMsg.Get(MSGGET(1, 238)), lpMyNode->lpTargetGuildNode->Name);

  0056d	8b 8e 8c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1420]
  00573	83 c4 0c	 add	 esp, 12			; 0000000cH
  00576	83 c1 04	 add	 ecx, 4
  00579	51		 push	 ecx
  0057a	68 ee 01 00 00	 push	 494			; 000001eeH
  0057f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00584	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00589	50		 push	 eax
  0058a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 10232: 									GCGuildWarScore(lpMyNode->lpTargetGuildNode->Index[n]);

  00590	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  00596	0f bf 84 7a a0
	03 00 00	 movsx	 eax, WORD PTR [edx+edi*2+928]
  0059e	50		 push	 eax
  0059f	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore

; 10233: 									int x = 59;
; 10234: 
; 10235: 									if ( lpMyNode->lpTargetGuildNode->WarType == 1 )

  005a4	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]

; 10236: 									{
; 10237: 
; 10238: 										if ( gPkLimitFree != 0 || gObj[lpMyNode->lpTargetGuildNode->Index[n]].m_PK_Level < 6 )

  005aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  005b3	80 b8 92 05 00
	00 01		 cmp	 BYTE PTR [eax+1426], 1
  005ba	75 60		 jne	 SHORT $LN16@GCGuildWar@3
  005bc	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, ebx ; gPkLimitFree
  005c2	75 18		 jne	 SHORT $LN2@GCGuildWar@3
  005c4	0f bf 94 78 a0
	03 00 00	 movsx	 edx, WORD PTR [eax+edi*2+928]
  005cc	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  005d2	80 bc 0a 19 01
	00 00 06	 cmp	 BYTE PTR [edx+ecx+281], 6
  005da	7d 40		 jge	 SHORT $LN16@GCGuildWar@3
$LN2@GCGuildWar@3:

; 10239: 										{
; 10240: 											gObj[lpMyNode->lpTargetGuildNode->Index[n]].IsInBattleGround = true;

  005dc	0f bf 84 78 a0
	03 00 00	 movsx	 eax, WORD PTR [eax+edi*2+928]
  005e4	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  005ea	c6 84 08 de 13
	00 00 01	 mov	 BYTE PTR [eax+ecx+5086], 1

; 10241: 											gObjTeleport(lpMyNode->lpTargetGuildNode->Index[n], 6, x++, 164);

  005f2	8b 8e 8c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1420]
  005f8	0f bf 94 79 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+edi*2+928]
  00600	68 a4 00 00 00	 push	 164			; 000000a4H
  00605	6a 3b		 push	 59			; 0000003bH
  00607	6a 06		 push	 6
  00609	52		 push	 edx
  0060a	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  0060f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00615	83 c4 10	 add	 esp, 16			; 00000010H
  00618	eb 02		 jmp	 SHORT $LN16@GCGuildWar@3
$LN81@GCGuildWar@3:
  0061a	33 db		 xor	 ebx, ebx
$LN16@GCGuildWar@3:

; 10194: 					count = 0;
; 10195: 
; 10196: 					for ( n=0;n<MAX_USER_GUILD;n++)

  0061c	47		 inc	 edi
  0061d	83 ff 50	 cmp	 edi, 80			; 00000050H
  00620	0f 8c ca fe ff
	ff		 jl	 $LL17@GCGuildWar@3

; 10242: 											count++;
; 10243: 										}
; 10244: 									}
; 10245: 								}
; 10246: 							}
; 10247: 						}
; 10248: 					}
; 10249: 
; 10250: //					cManager.BattleInfoSend(GetBattleTeamName(0,0),
; 10251: //											GetBattleTeamScore(0,0),
; 10252: //											GetBattleTeamName(0, 1),
; 10253: //											GetBattleTeamScore(0,1));
; 10254: 
; 10255: 					if ( lpMyNode->WarType == 1 )

  00626	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  0062d	75 5c		 jne	 SHORT $LN1@GCGuildWar@3

; 10256: 					{
; 10257: 						gObjAddMsgSendDelay(&gObj[aIndex], 5, aIndex, 10000, 0);

  0062f	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00635	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv672[ebp]
  0063b	53		 push	 ebx
  0063c	68 10 27 00 00	 push	 10000			; 00002710H
  00641	50		 push	 eax
  00642	03 d1		 add	 edx, ecx
  00644	6a 05		 push	 5
  00646	52		 push	 edx
  00647	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  0064c	83 c4 14	 add	 esp, 20			; 00000014H

; 10258: 						GCServerMsgStringSendGuild(lpMyNode->lpTargetGuildNode,lMsg.Get(MSGGET(4, 130)), 1);

  0064f	6a 01		 push	 1
  00651	68 82 04 00 00	 push	 1154			; 00000482H
  00656	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0065b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00660	50		 push	 eax
  00661	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  00667	50		 push	 eax
  00668	e8 00 00 00 00	 call	 ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
  0066d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10259: 						GCServerMsgStringSendGuild(lpMyNode,lMsg.Get(MSGGET(4, 130)), 1);

  00670	6a 01		 push	 1
  00672	68 82 04 00 00	 push	 1154			; 00000482H
  00677	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0067c	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00681	50		 push	 eax
  00682	56		 push	 esi
  00683	e8 00 00 00 00	 call	 ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
  00688	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCGuildWar@3:

; 10260: 					}
; 10261: 				}
; 10262: 			}
; 10263: 		}
; 10264: 	}
; 10265: }

  0068b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0068e	5f		 pop	 edi
  0068f	5e		 pop	 esi
  00690	33 cd		 xor	 ecx, ebp
  00692	5b		 pop	 ebx
  00693	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00698	8b e5		 mov	 esp, ebp
  0069a	5d		 pop	 ebp
  0069b	c3		 ret	 0
?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ENDP ; GCGuildWarRequestSendRecv
_TEXT	ENDS
PUBLIC	??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@ ; `string'
PUBLIC	??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@ ; `string'
PUBLIC	??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ; CGWarehouseMoneyInOut
EXTRN	?GetWarehouseUsedHowMuch@@YAHHHH@Z:PROC		; GetWarehouseUsedHowMuch
;	COMDAT ??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@
CONST	SEGMENT
??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@ DB '['
	DB	'%s][%s] error-L1 : used not Warehouse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@
CONST	SEGMENT
??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@ DB 'Get WareHo'
	DB	'use Money(In WareHouse) : %d - %d = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@
CONST	SEGMENT
??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@ DB 'Get WareHo'
	DB	'use Money(In Inventory) : %d - %d = %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z
_TEXT	SEGMENT
_rZen$221122 = -268					; size = 4
_aIndex$GSCopy$ = -264					; size = 4
_msg$221131 = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z PROC ; CGWarehouseMoneyInOut, COMDAT

; 10351: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 10352: 	int money = 0;
; 10353: 
; 10354: 	if ( !gObjIsConnected(aIndex))

  00017	53		 push	 ebx

; 10449: 				}
; 10450: 				else
; 10451: 				{
; 10452: 					lpObj->WarehouseMoney +=money;

  00018	89 9d f8 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0001e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	75 35		 jne	 SHORT $LN22@CGWarehous@2

; 10355: 	{
; 10356: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  0002a	68 74 28 00 00	 push	 10356			; 00002874H
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00039	6a 02		 push	 2
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 10357: 		GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  00041	6a 00		 push	 0
  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	53		 push	 ebx
  00048	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  0004d	83 c4 20	 add	 esp, 32			; 00000020H
  00050	5b		 pop	 ebx

; 10471: }

  00051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	33 cd		 xor	 ecx, ebp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN22@CGWarehous@2:

; 10358: 		return;
; 10359: 	}
; 10360: 
; 10361: 	LPOBJ lpObj = &gObj[aIndex];

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H

; 10362: 	money = lpMsg->Money;

  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0006d	56		 push	 esi
  0006e	8d 34 03	 lea	 esi, DWORD PTR [ebx+eax]

; 10363: 	
; 10364: 	if ( lpObj->m_IfState.state == 0 )

  00071	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  00077	57		 push	 edi
  00078	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0007b	a8 3c		 test	 al, 60			; 0000003cH

; 10365: 	{
; 10366: 		GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 10367: 		return;

  0007d	0f 84 e6 01 00
	00		 je	 $LN7@CGWarehous@2

; 10368: 	}
; 10369: 
; 10370: 	if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 6 )

  00083	8b d0		 mov	 edx, eax
  00085	80 e2 03	 and	 dl, 3
  00088	80 fa 01	 cmp	 dl, 1
  0008b	0f 82 98 02 00
	00		 jb	 $LN19@CGWarehous@2
  00091	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00096	3d 80 01 00 00	 cmp	 eax, 384		; 00000180H
  0009b	0f 85 88 02 00
	00		 jne	 $LN19@CGWarehous@2

; 10375: 
; 10376: 		return;
; 10377: 	}
; 10378: 
; 10379: 	switch ( lpMsg->Type )

  000a1	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  000a5	83 e8 00	 sub	 eax, 0
  000a8	0f 84 9c 01 00
	00		 je	 $LN16@CGWarehous@2
  000ae	48		 dec	 eax

; 10463: 
; 10464: 		default:
; 10465: 			GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 10466: 			return;

  000af	0f 85 4e 02 00
	00		 jne	 $LN14@CGWarehous@2

; 10402: 			break;
; 10403: 		case 0x01:
; 10404: 			{
; 10405: 				if ( bCanWarehouseLock == TRUE)

  000b5	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 1 ; bCanWarehouseLock
  000bc	75 49		 jne	 SHORT $LN9@CGWarehous@2

; 10406: 				{
; 10407: 					if ( lpObj->WarehouseLock == 1)

  000be	80 be 04 12 00
	00 01		 cmp	 BYTE PTR [esi+4612], 1
  000c5	75 40		 jne	 SHORT $LN9@CGWarehous@2

; 10408: 					{
; 10409: 						GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  000c7	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  000cd	50		 push	 eax
  000ce	50		 push	 eax
  000cf	50		 push	 eax
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend

; 10410: 						GCServerMsgStringSend(lMsg.Get(MSGGET(6, 70)), lpObj->m_Index,1);

  000d6	8b 16		 mov	 edx, DWORD PTR [esi]
  000d8	83 c4 10	 add	 esp, 16			; 00000010H
  000db	6a 01		 push	 1
  000dd	52		 push	 edx
  000de	68 46 06 00 00	 push	 1606			; 00000646H
  000e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000e8	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx

; 10471: }

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fc	33 cd		 xor	 ecx, ebp
  000fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
$LN9@CGWarehous@2:

; 10411: 						return;
; 10412: 					}
; 10413: 				}
; 10414: 
; 10415: 				if ( money <= 0 || money > MAX_WAREHOUSE_ZEN )

  00107	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0010a	3d ff 93 35 77	 cmp	 eax, 1999999999		; 773593ffH
  0010f	0f 87 54 01 00
	00		 ja	 $LN7@CGWarehous@2

; 10416: 				{
; 10417: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 10418: 					return;
; 10419: 				}
; 10420: 				
; 10421: 				if ( money > lpObj->WarehouseMoney )

  00115	8b 86 08 12 00
	00		 mov	 eax, DWORD PTR [esi+4616]
  0011b	3b f8		 cmp	 edi, eax

; 10422: 				{
; 10423: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 10424: 					return;

  0011d	0f 8f 46 01 00
	00		 jg	 $LN7@CGWarehous@2

; 10425: 				}
; 10426: 
; 10427: 				lpObj->WarehouseMoney -= money;
; 10428: 				lpObj->Money += money;
; 10429: 				int rZen = GetWarehouseUsedHowMuch(lpObj->Level,lpObj->MasterLevel, lpObj->WarehousePW);

  00123	0f bf 96 02 12
	00 00		 movsx	 edx, WORD PTR [esi+4610]
  0012a	0f bf 8e 96 00
	00 00		 movsx	 ecx, WORD PTR [esi+150]
  00131	01 be cc 00 00
	00		 add	 DWORD PTR [esi+204], edi
  00137	2b c7		 sub	 eax, edi
  00139	89 86 08 12 00
	00		 mov	 DWORD PTR [esi+4616], eax
  0013f	0f bf 86 a8 00
	00 00		 movsx	 eax, WORD PTR [esi+168]
  00146	52		 push	 edx
  00147	50		 push	 eax
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHHH@Z ; GetWarehouseUsedHowMuch

; 10430: 
; 10431: 				if ( (lpObj->Money-rZen) > 0 )

  0014e	8b 9e cc 00 00
	00		 mov	 ebx, DWORD PTR [esi+204]
  00154	8b cb		 mov	 ecx, ebx
  00156	2b c8		 sub	 ecx, eax
  00158	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015b	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _rZen$221122[ebp], eax
  00161	85 c9		 test	 ecx, ecx
  00163	7e 31		 jle	 SHORT $LN5@CGWarehous@2

; 10432: 				{
; 10433: 					int oldmoney = lpObj->Money;
; 10434: 					lpObj->Money -= rZen;
; 10435: 					GCMoneySend(lpObj->m_Index, lpObj->Money);

  00165	8b 16		 mov	 edx, DWORD PTR [esi]
  00167	51		 push	 ecx
  00168	52		 push	 edx
  00169	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx
  0016f	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 10436: 					
; 10437: 					LogAdd("Get WareHouse Money(In Inventory) : %d - %d = %d",
; 10438: 						oldmoney, rZen, lpObj->Money);

  00174	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  0017a	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _rZen$221122[ebp]
  00180	50		 push	 eax
  00181	51		 push	 ecx
  00182	53		 push	 ebx
  00183	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0018e	83 c4 18	 add	 esp, 24			; 00000018H
  00191	e9 37 01 00 00	 jmp	 $LN17@CGWarehous@2
$LN5@CGWarehous@2:

; 10439: 				}
; 10440: 				else if ( (lpObj->WarehouseMoney-rZen) > 0 )

  00196	8b 96 08 12 00
	00		 mov	 edx, DWORD PTR [esi+4616]
  0019c	8b ca		 mov	 ecx, edx
  0019e	2b c8		 sub	 ecx, eax
  001a0	85 c9		 test	 ecx, ecx
  001a2	7e 38		 jle	 SHORT $LN3@CGWarehous@2

; 10441: 				{
; 10442: 					int oldmoney = lpObj->WarehouseMoney;
; 10443: 					lpObj->WarehouseMoney -= rZen;
; 10444: 
; 10445: 					LogAdd("Get WareHouse Money(In WareHouse) : %d - %d = %d",
; 10446: 						oldmoney, rZen, lpObj->WarehouseMoney);

  001a4	51		 push	 ecx
  001a5	50		 push	 eax
  001a6	52		 push	 edx
  001a7	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@
  001ac	89 8e 08 12 00
	00		 mov	 DWORD PTR [esi+4616], ecx
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 10447: 
; 10448: 					GCWarehouseInventoryMoneySend(aIndex, 1, lpObj->Money, lpObj->WarehouseMoney);

  001b8	8b 96 08 12 00
	00		 mov	 edx, DWORD PTR [esi+4616]
  001be	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  001c4	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  001ca	52		 push	 edx
  001cb	50		 push	 eax
  001cc	6a 01		 push	 1
  001ce	51		 push	 ecx
  001cf	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  001d4	83 c4 20	 add	 esp, 32			; 00000020H

; 10459: 					return;
; 10460: 				}
; 10461: 			}
; 10462: 			break;

  001d7	e9 f1 00 00 00	 jmp	 $LN17@CGWarehous@2
$LN3@CGWarehous@2:

; 10453: 					lpObj->Money -= money;
; 10454: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  001dc	6a 00		 push	 0
  001de	03 d7		 add	 edx, edi
  001e0	6a 00		 push	 0
  001e2	89 96 08 12 00
	00		 mov	 DWORD PTR [esi+4616], edx
  001e8	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  001ee	6a 00		 push	 0
  001f0	2b df		 sub	 ebx, edi
  001f2	52		 push	 edx
  001f3	89 9e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ebx
  001f9	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend

; 10455: 					char msg[255];
; 10456: 
; 10457: 					wsprintf(msg, lMsg.Get(MSGGET(6, 69)), rZen);

  001fe	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _rZen$221122[ebp]
  00204	83 c4 10	 add	 esp, 16			; 00000010H
  00207	50		 push	 eax
  00208	68 45 06 00 00	 push	 1605			; 00000645H
  0020d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00212	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00217	50		 push	 eax
  00218	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$221131[ebp]
  0021e	51		 push	 ecx
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 10458: 					GCServerMsgStringSend(msg, lpObj->m_Index, 1);

  00225	8b 16		 mov	 edx, DWORD PTR [esi]
  00227	6a 01		 push	 1
  00229	52		 push	 edx
  0022a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$221131[ebp]
  00230	50		 push	 eax
  00231	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00236	83 c4 18	 add	 esp, 24			; 00000018H
  00239	5f		 pop	 edi
  0023a	5e		 pop	 esi
  0023b	5b		 pop	 ebx

; 10471: }

  0023c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023f	33 cd		 xor	 ecx, ebp
  00241	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c3		 ret	 0
$LN16@CGWarehous@2:

; 10380: 	{
; 10381: 		case 0x00:
; 10382: 			if ( money <= 0 || money > MAX_WAREHOUSE_ZEN )

  0024a	8d 57 ff	 lea	 edx, DWORD PTR [edi-1]
  0024d	81 fa ff 93 35
	77		 cmp	 edx, 1999999999		; 773593ffH
  00253	0f 87 aa 00 00
	00		 ja	 $LN14@CGWarehous@2

; 10385: 				return;
; 10386: 			}
; 10387: 
; 10388: 			if ( (DWORD)(lpObj->WarehouseMoney+money) > MAX_WAREHOUSE_ZEN )

  00259	8b 8e 08 12 00
	00		 mov	 ecx, DWORD PTR [esi+4616]
  0025f	03 cf		 add	 ecx, edi
  00261	81 f9 00 94 35
	77		 cmp	 ecx, 2000000000		; 77359400H
  00267	76 26		 jbe	 SHORT $LN13@CGWarehous@2
$LN7@CGWarehous@2:

; 10389: 			{
; 10390: 				GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  00269	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0026f	6a 00		 push	 0
  00271	6a 00		 push	 0
  00273	6a 00		 push	 0
  00275	51		 push	 ecx
  00276	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  0027b	83 c4 10	 add	 esp, 16			; 00000010H
  0027e	5f		 pop	 edi
  0027f	5e		 pop	 esi
  00280	5b		 pop	 ebx

; 10471: }

  00281	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00284	33 cd		 xor	 ecx, ebp
  00286	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028b	8b e5		 mov	 esp, ebp
  0028d	5d		 pop	 ebp
  0028e	c3		 ret	 0
$LN13@CGWarehous@2:

; 10391: 				return;
; 10392: 			}
; 10393: 
; 10394: 			if ( money > lpObj->Money )

  0028f	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  00295	3b f8		 cmp	 edi, eax
  00297	7e 26		 jle	 SHORT $LN12@CGWarehous@2

; 10395: 			{
; 10396: 				GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  00299	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0029f	6a 00		 push	 0
  002a1	6a 00		 push	 0
  002a3	6a 00		 push	 0
  002a5	52		 push	 edx
  002a6	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  002ab	83 c4 10	 add	 esp, 16			; 00000010H
  002ae	5f		 pop	 edi
  002af	5e		 pop	 esi
  002b0	5b		 pop	 ebx

; 10471: }

  002b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b4	33 cd		 xor	 ecx, ebp
  002b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bb	8b e5		 mov	 esp, ebp
  002bd	5d		 pop	 ebp
  002be	c3		 ret	 0
$LN12@CGWarehous@2:

; 10397: 				return;
; 10398: 			}
; 10399: 
; 10400: 			lpObj->Money-=money;

  002bf	2b c7		 sub	 eax, edi
  002c1	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax

; 10401: 			lpObj->WarehouseMoney+=money;

  002c7	89 8e 08 12 00
	00		 mov	 DWORD PTR [esi+4616], ecx
$LN17@CGWarehous@2:

; 10467: 	}
; 10468: 
; 10469: 	lpObj->WarehouseCount++;
; 10470: 	GCWarehouseInventoryMoneySend(aIndex, 1, lpObj->Money, lpObj->WarehouseMoney);

  002cd	8b 86 08 12 00
	00		 mov	 eax, DWORD PTR [esi+4616]
  002d3	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  002d9	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  002df	fe 86 01 12 00
	00		 inc	 BYTE PTR [esi+4609]
  002e5	50		 push	 eax
  002e6	51		 push	 ecx
  002e7	6a 01		 push	 1
  002e9	52		 push	 edx
  002ea	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  002ef	83 c4 10	 add	 esp, 16			; 00000010H
  002f2	5f		 pop	 edi
  002f3	5e		 pop	 esi
  002f4	5b		 pop	 ebx

; 10471: }

  002f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f8	33 cd		 xor	 ecx, ebp
  002fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ff	8b e5		 mov	 esp, ebp
  00301	5d		 pop	 ebp
  00302	c3		 ret	 0
$LN14@CGWarehous@2:

; 10383: 			{
; 10384: 				GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  00303	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00309	6a 00		 push	 0
  0030b	6a 00		 push	 0
  0030d	6a 00		 push	 0
  0030f	50		 push	 eax
  00310	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00315	83 c4 10	 add	 esp, 16			; 00000010H
  00318	5f		 pop	 edi
  00319	5e		 pop	 esi
  0031a	5b		 pop	 ebx

; 10471: }

  0031b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0031e	33 cd		 xor	 ecx, ebp
  00320	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00325	8b e5		 mov	 esp, ebp
  00327	5d		 pop	 ebp
  00328	c3		 ret	 0
$LN19@CGWarehous@2:

; 10371: 	{
; 10372: 		GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  00329	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0032f	6a 00		 push	 0
  00331	6a 00		 push	 0
  00333	6a 00		 push	 0
  00335	51		 push	 ecx
  00336	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend

; 10373: 		LogAdd("[%s][%s] error-L1 : used not Warehouse",
; 10374: 			gObj[aIndex].AccountID, gObj[aIndex].Name);

  0033b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00340	8d 54 03 5d	 lea	 edx, DWORD PTR [ebx+eax+93]
  00344	52		 push	 edx
  00345	8d 44 03 52	 lea	 eax, DWORD PTR [ebx+eax+82]
  00349	50		 push	 eax
  0034a	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@
  0034f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 10471: }

  00355	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00358	83 c4 1c	 add	 esp, 28			; 0000001cH
  0035b	5f		 pop	 edi
  0035c	5e		 pop	 esi
  0035d	33 cd		 xor	 ecx, ebp
  0035f	5b		 pop	 ebx
  00360	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00365	8b e5		 mov	 esp, ebp
  00367	5d		 pop	 ebp
  00368	c3		 ret	 0
?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ENDP ; CGWarehouseMoneyInOut
_TEXT	ENDS
PUBLIC	??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@ ; `string'
PUBLIC	??_C@_0DF@LECGNCFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@ ; `string'
PUBLIC	??_C@_0EB@PGHIAIFO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ ; `string'
PUBLIC	??_C@_0DI@CILMICFP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@ ; `string'
PUBLIC	?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z		; CGAttack
EXTRN	?CheckCombo@CComboAttack@@QAEHHH@Z:PROC		; CComboAttack::CheckCombo
EXTRN	?gComboAttack@@3VCComboAttack@@A:DWORD		; gComboAttack
EXTRN	?gSpeedHackPenalty@@3HA:DWORD			; gSpeedHackPenalty
;	COMDAT ??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@
CONST	SEGMENT
??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@ DB '['
	DB	'CGAttack] [UserIndex Error] :%s %d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LECGNCFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@
CONST	SEGMENT
??_C@_0DF@LECGNCFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@ DB '['
	DB	'%s][%s] %s Apply Attack Speed Penalty (%d left) @%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@PGHIAIFO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
CONST	SEGMENT
??_C@_0EB@PGHIAIFO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ DB '['
	DB	'%s][%s] %s Attack Speed Is Wrong Normal (%d)(%d) Penalty %d @'
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CILMICFP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@
CONST	SEGMENT
??_C@_0DI@CILMICFP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@ DB '['
	DB	'%s][%s] %s Kick DetecHackCountLimit Over User (%d) @%d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z
_TEXT	SEGMENT
_usernumber$ = -8					; size = 4
tv301 = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z PROC			; CGAttack, COMDAT

; 11530: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 11531: 	LPOBJ lpObj;
; 11532: 	LPOBJ lpTargetObj;
; 11533: 	int usernumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00009	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0000d	0f b6 49 04	 movzx	 ecx, BYTE PTR [ecx+4]
  00011	66 c1 e0 08	 shl	 ax, 8
  00015	0f b7 c0	 movzx	 eax, ax
  00018	0b c1		 or	 eax, ecx
  0001a	89 45 f8	 mov	 DWORD PTR _usernumber$[ebp], eax

; 11534: 
; 11535: 	if ( usernumber < 0 || usernumber > OBJMAX-1)

  0001d	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00022	0f 87 00 02 00
	00		 ja	 $LN9@CGAttack

; 11538: 		return;
; 11539: 	}
; 11540: 
; 11541: 	if ( !gObj[usernumber].Live )

  00028	57		 push	 edi
  00029	8b f8		 mov	 edi, eax
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00036	80 7c 07 51 00	 cmp	 BYTE PTR [edi+eax+81], 0
  0003b	89 7d fc	 mov	 DWORD PTR tv301[ebp], edi
  0003e	0f 84 bd 00 00
	00		 je	 $LN14@CGAttack

; 11542: 		return;
; 11543: 
; 11544: 	lpObj = &gObj[aIndex];

  00044	53		 push	 ebx
  00045	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00048	56		 push	 esi
  00049	8b f3		 mov	 esi, ebx
  0004b	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00051	03 f0		 add	 esi, eax

; 11545: 	int iTimeCalc = GetTickCount() - lpObj->m_LastAttackTime;

  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00059	2b 86 5c 05 00
	00		 sub	 eax, DWORD PTR [esi+1372]

; 11546: 
; 11547: 	if ( iTimeCalc < lpObj->m_DetectSpeedHackTime )

  0005f	8b 8e 64 05 00
	00		 mov	 ecx, DWORD PTR [esi+1380]
  00065	3b c1		 cmp	 eax, ecx
  00067	0f 8d ee 00 00
	00		 jge	 $LN7@CGAttack

; 11548: 	{
; 11549: 		lpObj->m_DetectCount++;
; 11550: 		lpObj->m_SumLastAttackTime += iTimeCalc;

  0006d	01 86 68 05 00
	00		 add	 DWORD PTR [esi+1384], eax
  00073	ba 01 00 00 00	 mov	 edx, 1
  00078	01 96 6c 05 00
	00		 add	 DWORD PTR [esi+1388], edx
  0007e	8b be 6c 05 00
	00		 mov	 edi, DWORD PTR [esi+1388]

; 11551: 
; 11552: 		if ( lpObj->m_DetectCount > gHackCheckCount && lpObj->Type == OBJ_USER )

  00084	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?gHackCheckCount@@3KA ; gHackCheckCount
  0008a	0f 86 ba 00 00
	00		 jbe	 $LN13@CGAttack
  00090	38 56 50	 cmp	 BYTE PTR [esi+80], dl
  00093	0f 85 b1 00 00
	00		 jne	 $LN13@CGAttack

; 11553: 		{
; 11554: 			lpObj->m_DetectedHackKickCount++;

  00099	01 96 70 05 00
	00		 add	 DWORD PTR [esi+1392], edx

; 11555: 			lpObj->m_SpeedHackPenalty = gSpeedHackPenalty;

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gSpeedHackPenalty@@3HA ; gSpeedHackPenalty
  000a4	8b 96 70 05 00
	00		 mov	 edx, DWORD PTR [esi+1392]
  000aa	89 86 74 05 00
	00		 mov	 DWORD PTR [esi+1396], eax

; 11556: 			
; 11557: 			if ( gIsKickDetecHackCountLimit )

  000b0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsKickDetecHackCountLimit@@3HA, 0 ; gIsKickDetecHackCountLimit
  000b7	74 4d		 je	 SHORT $LN4@CGAttack

; 11558: 			{
; 11559: 				if ( lpObj->m_DetectedHackKickCount > gDetectedHackKickCount )

  000b9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gDetectedHackKickCount@@3HA ; gDetectedHackKickCount
  000bf	7e 45		 jle	 SHORT $LN4@CGAttack

; 11560: 				{
; 11561: 					LogAddTD("[%s][%s] %s Kick DetecHackCountLimit Over User (%d) @%d",
; 11562: 						lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 11563: 						lpObj->m_DetectedHackKickCount,lpObj->MapNumber);

  000c1	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  000c8	51		 push	 ecx
  000c9	52		 push	 edx
  000ca	0f b7 96 90 00
	00 00		 movzx	 edx, WORD PTR [esi+144]
  000d1	81 c2 6c 07 00
	00		 add	 edx, 1900		; 0000076cH
  000d7	52		 push	 edx
  000d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000dd	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000e2	50		 push	 eax
  000e3	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000e6	50		 push	 eax
  000e7	83 c6 52	 add	 esi, 82			; 00000052H
  000ea	56		 push	 esi
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@CILMICFP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 11564: 
; 11565: 					CloseClient(aIndex);

  000f6	53		 push	 ebx
  000f7	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000fc	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
$LN14@CGAttack:
  00101	5f		 pop	 edi

; 11605: }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
$LN4@CGAttack:

; 11566: 					return;
; 11567: 				}
; 11568: 			}
; 11569: 
; 11570: 			LogAddTD("[%s][%s] %s Attack Speed Is Wrong Normal (%d)(%d) Penalty %d @%d",
; 11571: 				lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 11572: 				lpObj->m_DetectSpeedHackTime, lpObj->m_SumLastAttackTime/lpObj->m_DetectCount, lpObj->m_SpeedHackPenalty,lpObj->MapNumber);

  00106	0f b6 96 23 01
	00 00		 movzx	 edx, BYTE PTR [esi+291]
  0010d	52		 push	 edx
  0010e	50		 push	 eax
  0010f	8b 86 68 05 00
	00		 mov	 eax, DWORD PTR [esi+1384]
  00115	33 d2		 xor	 edx, edx
  00117	f7 f7		 div	 edi
  00119	50		 push	 eax
  0011a	51		 push	 ecx
  0011b	0f b7 8e 90 00
	00 00		 movzx	 ecx, WORD PTR [esi+144]
  00122	81 c1 6c 07 00
	00		 add	 ecx, 1900		; 0000076cH
  00128	51		 push	 ecx
  00129	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0012e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00133	50		 push	 eax
  00134	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  00137	52		 push	 edx
  00138	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0013b	50		 push	 eax
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@PGHIAIFO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00147	83 c4 20	 add	 esp, 32			; 00000020H
$LN13@CGAttack:

; 11573: 		}
; 11574: 
; 11575: 		lpObj->m_LastAttackTime = GetTickCount();

  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 11576: 	}
; 11577: 	else

  00150	8b 7d fc	 mov	 edi, DWORD PTR tv301[ebp]
  00153	89 86 5c 05 00
	00		 mov	 DWORD PTR [esi+1372], eax
  00159	eb 0e		 jmp	 SHORT $LN3@CGAttack
$LN7@CGAttack:

; 11578: 	{
; 11579: 		lpObj->m_SumLastAttackTime = 0;

  0015b	33 c0		 xor	 eax, eax
  0015d	89 86 68 05 00
	00		 mov	 DWORD PTR [esi+1384], eax

; 11580: 		lpObj->m_DetectCount = 0;

  00163	89 86 6c 05 00
	00		 mov	 DWORD PTR [esi+1388], eax
$LN3@CGAttack:

; 11581: 	}
; 11582: 
; 11583: 	lpObj->m_LastAttackTime = GetTickCount();

  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0016f	89 86 5c 05 00
	00		 mov	 DWORD PTR [esi+1372], eax

; 11584: 
; 11585: 	if ( bIsIgnorePacketSpeedHackDetect )

  00175	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  0017c	74 50		 je	 SHORT $LN1@CGAttack

; 11586: 	{
; 11587: 		if ( lpObj->m_SpeedHackPenalty > 0 )

  0017e	8b 86 74 05 00
	00		 mov	 eax, DWORD PTR [esi+1396]
  00184	85 c0		 test	 eax, eax
  00186	7e 46		 jle	 SHORT $LN1@CGAttack

; 11588: 		{
; 11589: 			lpObj->m_SpeedHackPenalty--;
; 11590: 			
; 11591: 			LogAddTD("[%s][%s] %s Apply Attack Speed Penalty (%d left) @%d",
; 11592: 				lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 11593: 				lpObj->m_SpeedHackPenalty,lpObj->MapNumber);

  00188	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  0018f	0f b7 96 90 00
	00 00		 movzx	 edx, WORD PTR [esi+144]
  00196	51		 push	 ecx
  00197	48		 dec	 eax
  00198	50		 push	 eax
  00199	81 c2 6c 07 00
	00		 add	 edx, 1900		; 0000076cH
  0019f	52		 push	 edx
  001a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001a5	89 86 74 05 00
	00		 mov	 DWORD PTR [esi+1396], eax
  001ab	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001b0	50		 push	 eax
  001b1	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  001b4	50		 push	 eax
  001b5	83 c6 52	 add	 esi, 82			; 00000052H
  001b8	56		 push	 esi
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LECGNCFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c4	83 c4 18	 add	 esp, 24			; 00000018H
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx
  001c9	5f		 pop	 edi

; 11605: }

  001ca	8b e5		 mov	 esp, ebp
  001cc	5d		 pop	 ebp
  001cd	c3		 ret	 0
$LN1@CGAttack:

; 11594: 
; 11595: 			return;
; 11596: 		}
; 11597: 	}
; 11598: 	
; 11599: 	lpTargetObj = &gObj[usernumber];
; 11600: 	lpObj->Dir = lpMsg->DirDis;

  001ce	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001d1	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  001d4	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11601: 	GCActionSend(lpObj, lpMsg->AttackAction, aIndex, usernumber);

  001da	8b 4d f8	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  001dd	51		 push	 ecx
  001de	88 96 22 01 00
	00		 mov	 BYTE PTR [esi+290], dl
  001e4	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  001e8	53		 push	 ebx
  001e9	52		 push	 edx
  001ea	56		 push	 esi
  001eb	e8 00 00 00 00	 call	 ?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z ; GCActionSend
  001f0	83 c4 10	 add	 esp, 16			; 00000010H

; 11602: 	gComboAttack.CheckCombo(aIndex, 0);

  001f3	6a 00		 push	 0
  001f5	53		 push	 ebx
  001f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gComboAttack@@3VCComboAttack@@A ; gComboAttack
  001fb	e8 00 00 00 00	 call	 ?CheckCombo@CComboAttack@@QAEHHH@Z ; CComboAttack::CheckCombo

; 11603: 	gObjAttack(lpObj, lpTargetObj, NULL, FALSE, FALSE, 0, FALSE,0,0);

  00200	6a 00		 push	 0
  00202	6a 00		 push	 0
  00204	6a 00		 push	 0
  00206	6a 00		 push	 0
  00208	6a 00		 push	 0
  0020a	6a 00		 push	 0
  0020c	6a 00		 push	 0
  0020e	57		 push	 edi
  0020f	56		 push	 esi
  00210	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00215	83 c4 24	 add	 esp, 36			; 00000024H

; 11604: 	lpObj->UseMagicNumber = 0;

  00218	33 c0		 xor	 eax, eax
  0021a	66 89 86 ae 06
	00 00		 mov	 WORD PTR [esi+1710], ax
  00221	5e		 pop	 esi
  00222	5b		 pop	 ebx
  00223	5f		 pop	 edi

; 11605: }

  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
$LN9@CGAttack:

; 11536: 	{
; 11537: 		LogAdd("[CGAttack] [UserIndex Error] :%s %d %d", __FILE__, __LINE__, usernumber);

  00228	50		 push	 eax
  00229	68 11 2d 00 00	 push	 11537			; 00002d11H
  0022e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00233	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@
  00238	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0023e	83 c4 10	 add	 esp, 16			; 00000010H

; 11605: }

  00241	8b e5		 mov	 esp, ebp
  00243	5d		 pop	 ebp
  00244	c3		 ret	 0
?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z ENDP			; CGAttack
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCDamageSend@@YAXHHHE@Z			; GCDamageSend
; Function compile flags: /Ogtp
;	COMDAT ?GCDamageSend@@YAXHHHE@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_AttackDamage$ = 16					; size = 4
_Element$ = 20						; size = 1
?GCDamageSend@@YAXHHHE@Z PROC				; GCDamageSend, COMDAT

; 11692: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 11693: 	PMSG_ATTACKRESULT_ELEMENTAL pMsg;
; 11694: 	PHeadSetB((LPBYTE)&pMsg,0xD8,sizeof(pMsg));

  00019	6a 0c		 push	 12			; 0000000cH
  0001b	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001e	68 d8 00 00 00	 push	 216			; 000000d8H
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11695: 
; 11696: 	pMsg.NumberH = SET_NUMBERH(aTargetIndex);
; 11697: 	pMsg.NumberL = SET_NUMBERL(aTargetIndex);
; 11698: 	pMsg.btElement = Element;

  00029	8a 55 14	 mov	 dl, BYTE PTR _Element$[ebp]

; 11699: 	pMsg.dwDamage = AttackDamage;

  0002c	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]

; 11700: 
; 11701: 	if ( gObj[aTargetIndex].Type == OBJ_USER )

  0002f	8b f3		 mov	 esi, ebx
  00031	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00037	8b cb		 mov	 ecx, ebx
  00039	c1 e9 08	 shr	 ecx, 8
  0003c	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	88 5d f4	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  0004b	88 55 f5	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  0004e	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00051	80 7c 0e 50 01	 cmp	 BYTE PTR [esi+ecx+80], 1
  00056	75 1e		 jne	 SHORT $LN2@GCDamageSe@3

; 11702: 	{
; 11703: 		DataSend(aTargetIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00058	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0005c	52		 push	 edx
  0005d	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00060	50		 push	 eax
  00061	53		 push	 ebx
  00062	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11704: 		GCLifeSendAll(&gObj[aTargetIndex]); //temp fix

  00067	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006d	56		 push	 esi
  0006e	e8 00 00 00 00	 call	 ?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z ; GCLifeSendAll
  00073	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@GCDamageSe@3:

; 11705: 	}
; 11706: 
; 11707: //	if ( cManager.WatchTargetIndex == aTargetIndex || cManager.WatchTargetIndex == aIndex )
; 11708: //	{
; 11709: //		cManager.DataSend((LPBYTE)&pMsg, pMsg.h.size);
; 11710: //	}
; 11711: 
; 11712: 	if ( gObj[aIndex].Type == OBJ_USER )

  00076	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007c	8b f7		 mov	 esi, edi
  0007e	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00084	80 7c 16 50 01	 cmp	 BYTE PTR [esi+edx+80], 1
  00089	75 1e		 jne	 SHORT $LN1@GCDamageSe@3

; 11713: 	{
; 11714: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0008b	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0008f	50		 push	 eax
  00090	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00093	51		 push	 ecx
  00094	57		 push	 edi
  00095	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11715: 		GCLifeSendAll(&gObj[aIndex]); //temp fix

  0009a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a0	56		 push	 esi
  000a1	e8 00 00 00 00	 call	 ?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z ; GCLifeSendAll
  000a6	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@GCDamageSe@3:

; 11716: 	}
; 11717: }

  000a9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	33 cd		 xor	 ecx, ebp
  000b0	5b		 pop	 ebx
  000b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?GCDamageSend@@YAXHHHE@Z ENDP				; GCDamageSend
_TEXT	ENDS
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1617 : 		{	// look for [_Ptr, _Ptr + _Count) beginnng at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1618 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1619 : 		if (_Count != 0)
; 1620 : 			_DEBUG_POINTER(_Ptr);
; 1621 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1622 : 
; 1623 : 		if (_Count == 0 && _Off <= this->_Mysize)

  00004	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	85 d2		 test	 edx, edx
  0000f	75 05		 jne	 SHORT $LN6@find
  00011	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]

; 1624 : 			return (_Off);	// null string always matches (if inside string)

  00014	76 76		 jbe	 SHORT $LN7@find
$LN6@find:
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi

; 1625 : 
; 1626 : 		size_type _Nm;
; 1627 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))

  00019	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 66		 jae	 SHORT $LN2@find
  00020	2b f8		 sub	 edi, eax
  00022	3b d7		 cmp	 edx, edi
  00024	77 60		 ja	 SHORT $LN2@find

; 1628 : 			{	// room for match, look for it
; 1629 : 			const _Elem *_Uptr, *_Vptr;
; 1630 : 			for (_Nm -= _Count - 1, _Vptr = _Myptr() + _Off;

  00026	be 01 00 00 00	 mov	 esi, 1
  0002b	2b f2		 sub	 esi, edx
  0002d	03 fe		 add	 edi, esi
  0002f	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00033	72 02		 jb	 SHORT $LN11@find
  00035	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN11@find:
  00037	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]

; 1631 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1632 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00040	57		 push	 edi
  00041	51		 push	 ecx
  00042	53		 push	 ebx
  00043	e8 00 00 00 00	 call	 _memchr
  00048	8b f0		 mov	 esi, eax
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	85 f6		 test	 esi, esi
  0004f	74 35		 je	 SHORT $LN2@find
$LL4@find:

; 1633 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

  00051	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00054	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00057	52		 push	 edx
  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	85 c0		 test	 eax, eax
  00064	74 2c		 je	 SHORT $LN20@find

; 1631 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1632 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  00066	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00069	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0006c	2b de		 sub	 ebx, esi
  0006e	8d 7c 1f ff	 lea	 edi, DWORD PTR [edi+ebx-1]
  00072	57		 push	 edi
  00073	52		 push	 edx
  00074	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  00077	53		 push	 ebx
  00078	e8 00 00 00 00	 call	 _memchr
  0007d	8b f0		 mov	 esi, eax
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	85 f6		 test	 esi, esi
  00084	75 cb		 jne	 SHORT $LL4@find
$LN2@find:
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi

; 1635 : 			}
; 1636 : 
; 1637 : 		return (npos);	// no match

  00088	83 c8 ff	 or	 eax, -1
  0008b	5b		 pop	 ebx
$LN7@find:

; 1638 : 		}

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 0c 00	 ret	 12			; 0000000cH
$LN20@find:

; 1634 : 					return (_Uptr - _Myptr());	// found a match

  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00099	72 02		 jb	 SHORT $LN17@find
  0009b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN17@find:
  0009d	5f		 pop	 edi
  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi
  000a1	2b c1		 sub	 eax, ecx
  000a3	5b		 pop	 ebx

; 1638 : 		}

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 0c 00	 ret	 12			; 0000000cH
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
PUBLIC	??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ ; `string'
PUBLIC	??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ ; `string'
PUBLIC	??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ ; `string'
PUBLIC	?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z	; CGMagicAttack
EXTRN	?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z:PROC ; CObjUseSkill::UseSkill
;	COMDAT ??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	SEGMENT
??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ DB '['
	DB	'0x19] CGMagicAttack() - Invalid KillCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
CONST	SEGMENT
??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ DB '['
	DB	'0x19] CGMagicAttack() - Invalid Status', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
CONST	SEGMENT
??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ DB '['
	DB	'%s][%s] Try Attack In Not Attack Area [Protocol] (%s:%d,%d) e'
	DB	'rrortype = %d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z
_TEXT	SEGMENT
_usernumber$ = -8					; size = 4
_lpTargetObj$ = -4					; size = 4
_MagicNumber$ = 8					; size = 2
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z PROC	; CGMagicAttack, COMDAT

; 11943: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 11944: 	LPOBJ lpObj;
; 11945: 	LPOBJ lpTargetObj;
; 11946: 	int usernumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00006	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00009	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0000d	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  00011	66 c1 e1 08	 shl	 cx, 8
  00015	53		 push	 ebx
  00016	0f b7 d9	 movzx	 ebx, cx

; 11947: 	CMagicInf * lpMagic;
; 11948: 	WORD MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH,lpMsg->MagicNumberL);

  00019	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0001d	0b da		 or	 ebx, edx
  0001f	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  00023	66 c1 e1 08	 shl	 cx, 8
  00027	66 0b ca	 or	 cx, dx
  0002a	0f b7 c1	 movzx	 eax, cx
  0002d	89 5d f8	 mov	 DWORD PTR _usernumber$[ebp], ebx
  00030	89 45 08	 mov	 DWORD PTR _MagicNumber$[ebp], eax

; 11949: 
; 11950: 	if ( usernumber < 0 || usernumber > OBJMAX-1 )

  00033	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00039	0f 87 14 03 00
	00		 ja	 $LN27@CGMagicAtt@2

; 11953: 		return;
; 11954: 	}
; 11955: 
; 11956: 	if ( gObj[usernumber].Live == 0 || gObj[usernumber].Connected  < PLAYER_LOGGED )

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00044	57		 push	 edi
  00045	8b fb		 mov	 edi, ebx
  00047	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  0004d	80 7c 07 51 00	 cmp	 BYTE PTR [edi+eax+81], 0
  00052	0f 84 cb 01 00
	00		 je	 $LN34@CGMagicAtt@2
  00058	83 7c 07 04 02	 cmp	 DWORD PTR [edi+eax+4], 2
  0005d	0f 8c c0 01 00
	00		 jl	 $LN34@CGMagicAtt@2

; 11957: 		return;
; 11958: 
; 11959: 	if ( gObj[aIndex].CloseCount >= 0 )

  00063	56		 push	 esi
  00064	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00067	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0006d	80 7c 06 0c 00	 cmp	 BYTE PTR [esi+eax+12], 0
  00072	0f 8d aa 01 00
	00		 jge	 $LN35@CGMagicAtt@2

; 11960: 		return;
; 11961: 
; 11962: 	BYTE MapAttr = MapC[gObj[aIndex].MapNumber].GetAttr(gObj[aIndex].X,gObj[aIndex].Y);
; 11963: 
; 11964: 	if ( (MapAttr&1)==TRUE && MagicNumber == 58 )

  00078	0f b6 8c 06 21
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+289]
  00080	0f b6 94 06 20
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+288]
  00088	51		 push	 ecx
  00089	0f b6 8c 06 23
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+291]
  00091	69 c9 28 38 05
	00		 imul	 ecx, 342056		; 00053828H
  00097	52		 push	 edx
  00098	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0009e	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000a3	a8 01		 test	 al, 1
  000a5	74 44		 je	 SHORT $LN23@CGMagicAtt@2
  000a7	66 83 7d 08 3a	 cmp	 WORD PTR _MagicNumber$[ebp], 58 ; 0000003aH
  000ac	75 3d		 jne	 SHORT $LN23@CGMagicAtt@2

; 11965: 	{
; 11966: 		GCMagicAttackNumberSend(&gObj[aIndex],40,aIndex,TRUE);

  000ae	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b6	6a 01		 push	 1
  000b8	57		 push	 edi
  000b9	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000bc	6a 28		 push	 40			; 00000028H
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 11967: 		gObjSetPosition(aIndex,gObj[aIndex].X,gObj[aIndex].Y);

  000c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c9	0f b6 94 06 21
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+289]
  000d1	0f b6 84 06 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+288]
  000d9	52		 push	 edx
  000da	50		 push	 eax
  000db	57		 push	 edi
  000dc	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  000e1	83 c4 1c	 add	 esp, 28			; 0000001cH
  000e4	5e		 pop	 esi
  000e5	5f		 pop	 edi
  000e6	5b		 pop	 ebx

; 12085: }

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
$LN23@CGMagicAtt@2:

; 11968: 		return;
; 11969: 	}
; 11970: 
; 11971: 	lpObj = &gObj[aIndex];

  000eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11972: 	lpTargetObj = &gObj[usernumber];
; 11973: 	
; 11974: 	int attackret = gObjCheckAttackArea(aIndex, usernumber);

  000f0	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000f3	03 f8		 add	 edi, eax
  000f5	53		 push	 ebx
  000f6	51		 push	 ecx
  000f7	03 f0		 add	 esi, eax
  000f9	89 7d fc	 mov	 DWORD PTR _lpTargetObj$[ebp], edi
  000fc	e8 00 00 00 00	 call	 ?gObjCheckAttackArea@@YAHHH@Z ; gObjCheckAttackArea
  00101	83 c4 08	 add	 esp, 8

; 11975: 
; 11976: 	if ( attackret )

  00104	85 c0		 test	 eax, eax
  00106	74 65		 je	 SHORT $LN20@CGMagicAtt@2

; 11977: 	{
; 11978: 		LogAddTD("[%s][%s] Try Attack In Not Attack Area [Protocol] (%s:%d,%d) errortype = %d",
; 11979: 			lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 208)+lpObj->MapNumber), lpObj->X, lpObj->Y,
; 11980: 			attackret);

  00108	0f b6 96 21 01
	00 00		 movzx	 edx, BYTE PTR [esi+289]
  0010f	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  00116	50		 push	 eax
  00117	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0011e	52		 push	 edx
  0011f	81 c1 d0 07 00
	00		 add	 ecx, 2000		; 000007d0H
  00125	50		 push	 eax
  00126	51		 push	 ecx
  00127	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0012c	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00131	50		 push	 eax
  00132	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  00135	52		 push	 edx
  00136	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00139	50		 push	 eax
  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 11981: 
; 11982: 		if ( lpObj->Class == 275 )	// Kundun

  00145	b9 13 01 00 00	 mov	 ecx, 275		; 00000113H
  0014a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0014d	66 39 8e 90 00
	00 00		 cmp	 WORD PTR [esi+144], cx
  00154	75 0a		 jne	 SHORT $LN21@CGMagicAtt@2

; 11983: 			lpObj->TargetNumber = -1;

  00156	83 ca ff	 or	 edx, -1
  00159	66 89 96 38 06
	00 00		 mov	 WORD PTR [esi+1592], dx
$LN21@CGMagicAtt@2:

; 11984: 
; 11985: 		if ( bIsIgnorePacketSpeedHackDetect )

  00160	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  00167	0f 85 b5 00 00
	00		 jne	 $LN35@CGMagicAtt@2
$LN20@CGMagicAtt@2:

; 11986: 			return;
; 11987: 	}
; 11988: 
; 11989: 	if ( lpObj->Type == OBJ_USER )

  0016d	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00171	0f 85 e3 00 00
	00		 jne	 $LN19@CGMagicAtt@2

; 11990: 	{
; 11991: 		lpMagic = gObjGetMagicSearch(lpObj, MagicNumber);

  00177	0f b7 5d 08	 movzx	 ebx, WORD PTR _MagicNumber$[ebp]
  0017b	53		 push	 ebx
  0017c	56		 push	 esi
  0017d	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00182	83 c4 08	 add	 esp, 8
  00185	8b f8		 mov	 edi, eax

; 11997: #else
; 11998: 		short Energy = lpObj->Energy+ lpObj->AddEnergy;
; 11999: 		short Strength = lpObj->Strength + lpObj->AddStrength;
; 12000: 		short Dexterity = lpObj->Dexterity + lpObj->AddDexterity;
; 12001: #endif
; 12002: 
; 12003: 		switch( MagicNumber )

  00187	83 fb 33	 cmp	 ebx, 51			; 00000033H
  0018a	75 18		 jne	 SHORT $LN15@CGMagicAtt@2

; 11992: 
; 11993: #if( FIX_MAXSTAT == 1 )
; 11994: 		WORD Energy = lpObj->Energy+ lpObj->AddEnergy;
; 11995: 		WORD Strength = lpObj->Strength + lpObj->AddStrength;
; 11996: 		WORD Dexterity = lpObj->Dexterity + lpObj->AddDexterity;

  0018c	66 8b 86 fe 00
	00 00		 mov	 ax, WORD PTR [esi+254]
  00193	66 03 86 d2 00
	00 00		 add	 ax, WORD PTR [esi+210]

; 12004: 		{
; 12005: 		case 0x33:
; 12006: 			if( Dexterity < 646 )

  0019a	b9 86 02 00 00	 mov	 ecx, 646		; 00000286H
  0019f	66 3b c1	 cmp	 ax, cx
  001a2	72 7e		 jb	 SHORT $LN35@CGMagicAtt@2
$LN15@CGMagicAtt@2:

; 12007: 			{
; 12008: 				return;
; 12009: 			}
; 12010: 			break;
; 12011: 		}
; 12012: 
; 12013: 		if ( !lpMagic )

  001a4	85 ff		 test	 edi, edi
  001a6	74 7a		 je	 SHORT $LN35@CGMagicAtt@2

; 12014: 			return;
; 12015: 
; 12016: 		if ( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP,lpObj->ChangeUP2, lpMagic->m_Skill) < 1 )

  001a8	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  001ab	0f b6 86 94 00
	00 00		 movzx	 eax, BYTE PTR [esi+148]
  001b2	0f b6 8e 93 00
	00 00		 movzx	 ecx, BYTE PTR [esi+147]
  001b9	52		 push	 edx
  001ba	0f b7 96 90 00
	00 00		 movzx	 edx, WORD PTR [esi+144]
  001c1	50		 push	 eax
  001c2	51		 push	 ecx
  001c3	52		 push	 edx
  001c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  001c9	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z ; CMagicDamage::SkillGetRequireClass
  001ce	83 f8 01	 cmp	 eax, 1
  001d1	7c 4f		 jl	 SHORT $LN35@CGMagicAtt@2

; 12017: 			return;
; 12018: 
; 12019: #if (ENABLETEST_NEWPVP == 1)
; 12020: 		if (lpMagic->m_Skill == 63 && (g_NewPVP.IsDuel(*lpObj) || g_NewPVP.IsDuel(*lpTargetObj))) {

  001d3	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  001d6	83 fb 3f	 cmp	 ebx, 63			; 0000003fH
  001d9	75 21		 jne	 SHORT $LN12@CGMagicAtt@2
  001db	56		 push	 esi
  001dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  001e1	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  001e6	85 c0		 test	 eax, eax
  001e8	75 38		 jne	 SHORT $LN35@CGMagicAtt@2
  001ea	8b 45 fc	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001ed	50		 push	 eax
  001ee	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  001f3	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  001f8	85 c0		 test	 eax, eax

; 12021: 			return;

  001fa	75 26		 jne	 SHORT $LN35@CGMagicAtt@2
$LN12@CGMagicAtt@2:

; 12022: 		}
; 12023: #endif
; 12024: 
; 12025: 		if ( MagicDamageC.CheckStatus(lpMagic->m_Skill, lpObj->GuildStatus) == 0 )

  001fc	8b 8e 28 06 00
	00		 mov	 ecx, DWORD PTR [esi+1576]
  00202	51		 push	 ecx
  00203	53		 push	 ebx
  00204	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00209	e8 00 00 00 00	 call	 ?CheckStatus@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckStatus
  0020e	85 c0		 test	 eax, eax
  00210	75 17		 jne	 SHORT $LN10@CGMagicAtt@2

; 12026: 		{
; 12027: 			LogAddC(2, "[0x19] CGMagicAttack() - Invalid Status");

  00212	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
  00217	6a 02		 push	 2
  00219	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0021f	83 c4 08	 add	 esp, 8
$LN35@CGMagicAtt@2:
  00222	5e		 pop	 esi
$LN34@CGMagicAtt@2:
  00223	5f		 pop	 edi
  00224	5b		 pop	 ebx

; 12085: }

  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c3		 ret	 0
$LN10@CGMagicAtt@2:

; 12028: 			return;
; 12029: 		}
; 12030: 
; 12031: 		if ( MagicDamageC.CheckKillCount(lpMagic->m_Skill, lpObj->m_btKillCount) < 0 )

  00229	0f b6 96 64 20
	00 00		 movzx	 edx, BYTE PTR [esi+8292]
  00230	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00233	52		 push	 edx
  00234	50		 push	 eax
  00235	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0023a	e8 00 00 00 00	 call	 ?CheckKillCount@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckKillCount
  0023f	85 c0		 test	 eax, eax
  00241	79 2d		 jns	 SHORT $LN31@CGMagicAtt@2

; 12032: 		{
; 12033: 			LogAddC(2, "[0x19] CGMagicAttack() - Invalid KillCount");

  00243	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
  00248	6a 02		 push	 2
  0024a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00250	83 c4 08	 add	 esp, 8
  00253	5e		 pop	 esi
  00254	5f		 pop	 edi
  00255	5b		 pop	 ebx

; 12085: }

  00256	8b e5		 mov	 esp, ebp
  00258	5d		 pop	 ebp
  00259	c3		 ret	 0
$LN19@CGMagicAtt@2:

; 12034: 			return;
; 12035: 		}
; 12036: 	}
; 12037: 	else
; 12038: 	{
; 12039: 		lpMagic = gObjGetMagic(lpObj, MagicNumber);

  0025a	0f b7 4d 08	 movzx	 ecx, WORD PTR _MagicNumber$[ebp]
  0025e	51		 push	 ecx
  0025f	56		 push	 esi
  00260	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
  00265	8b f8		 mov	 edi, eax
  00267	83 c4 08	 add	 esp, 8

; 12040: 
; 12041: 		if ( !lpMagic )

  0026a	85 ff		 test	 edi, edi
  0026c	74 b4		 je	 SHORT $LN35@CGMagicAtt@2
  0026e	eb 03		 jmp	 SHORT $LN32@CGMagicAtt@2
$LN31@CGMagicAtt@2:
  00270	8b 5d f8	 mov	 ebx, DWORD PTR _usernumber$[ebp]
$LN32@CGMagicAtt@2:

; 12042: 			return;
; 12043: 	}
; 12044: 
; 12045: 	if ( lpMagic->m_Skill != AT_SKILL_CROSSBOW && 
; 12046: 		 lpMagic->m_Skill != AT_MSKILL_FE_TRIPLESHOT1 &&
; 12047: 		 lpMagic->m_Skill != AT_MSKILL_FE_TRIPLESHOT2 )

  00273	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00276	83 f8 18	 cmp	 eax, 24			; 00000018H
  00279	74 20		 je	 SHORT $LN5@CGMagicAtt@2
  0027b	3d 9e 01 00 00	 cmp	 eax, 414		; 0000019eH
  00280	74 19		 je	 SHORT $LN5@CGMagicAtt@2
  00282	3d a2 01 00 00	 cmp	 eax, 418		; 000001a2H
  00287	74 12		 je	 SHORT $LN5@CGMagicAtt@2

; 12048: 	{
; 12049: 		if( gObjUseSkill.SpeedHackCheck(aIndex) == FALSE )

  00289	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0028c	52		 push	 edx
  0028d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00292	e8 00 00 00 00	 call	 ?SpeedHackCheck@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SpeedHackCheck
  00297	85 c0		 test	 eax, eax
  00299	74 87		 je	 SHORT $LN35@CGMagicAtt@2
$LN5@CGMagicAtt@2:

; 12050: 		{
; 12051: 			return;
; 12052: 		}
; 12053: 	}
; 12054: 
; 12055: 	if ( !gCheckSkillDistance(aIndex, usernumber, lpMagic->m_Skill))

  0029b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0029e	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  002a1	50		 push	 eax
  002a2	53		 push	 ebx
  002a3	51		 push	 ecx
  002a4	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  002a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ac	85 c0		 test	 eax, eax
  002ae	0f 85 88 00 00
	00		 jne	 $LN4@CGMagicAtt@2

; 12056: 	{
; 12057: 		DWORD dwTick = GetTickCount() - lpObj->m_dwSkillDistanceErrorTick;

  002b4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  002ba	ff d7		 call	 edi

; 12058: 		
; 12059: 		if ( dwTick > (g_iSkillDiatanceKickCheckTime*1000) )

  002bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_iSkillDiatanceKickCheckTime@@3KA ; g_iSkillDiatanceKickCheckTime
  002c2	2b 86 28 24 00
	00		 sub	 eax, DWORD PTR [esi+9256]
  002c8	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  002ce	3b c2		 cmp	 eax, edx
  002d0	76 12		 jbe	 SHORT $LN33@CGMagicAtt@2

; 12060: 		{
; 12061: 			lpObj->m_iSkillDistanceErrorCount = 0;

  002d2	c7 86 24 24 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9252], 0

; 12062: 			lpObj->m_dwSkillDistanceErrorTick = GetTickCount();

  002dc	ff d7		 call	 edi
  002de	89 86 28 24 00
	00		 mov	 DWORD PTR [esi+9256], eax
$LN33@CGMagicAtt@2:

; 12063: 		}
; 12064: 
; 12065: 		lpObj->m_iSkillDistanceErrorCount++;

  002e4	ff 86 24 24 00
	00		 inc	 DWORD PTR [esi+9252]
  002ea	8b 86 24 24 00
	00		 mov	 eax, DWORD PTR [esi+9252]

; 12066: 
; 12067: 		if ( lpObj->m_iSkillDistanceErrorCount > g_iSkillDistanceKickCount )

  002f0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iSkillDistanceKickCount@@3HA ; g_iSkillDistanceKickCount
  002f6	0f 8e 26 ff ff
	ff		 jle	 $LN35@CGMagicAtt@2

; 12068: 		{
; 12069: 			if ( g_iSkillDistanceKick )

  002fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iSkillDistanceKick@@3HA, 0 ; g_iSkillDistanceKick
  00303	74 26		 je	 SHORT $LN1@CGMagicAtt@2

; 12070: 			{
; 12071: 				LogAddTD("[SKILL DISTANCE CHECK] [%s][%s] Kick Invalid Skill Area User. count(%d)",
; 12072: 					lpObj->AccountID, lpObj->Name, lpObj->m_iSkillDistanceErrorCount);

  00305	50		 push	 eax
  00306	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00309	50		 push	 eax
  0030a	8d 4e 52	 lea	 ecx, DWORD PTR [esi+82]
  0030d	51		 push	 ecx
  0030e	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  00313	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12073: 
; 12074: 				CloseClient(lpObj->m_Index);

  00319	8b 16		 mov	 edx, DWORD PTR [esi]
  0031b	52		 push	 edx
  0031c	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00321	83 c4 14	 add	 esp, 20			; 00000014H
  00324	5e		 pop	 esi
  00325	5f		 pop	 edi
  00326	5b		 pop	 ebx

; 12085: }

  00327	8b e5		 mov	 esp, ebp
  00329	5d		 pop	 ebp
  0032a	c3		 ret	 0
$LN1@CGMagicAtt@2:

; 12075: 				return;
; 12076: 			}
; 12077: 
; 12078: 			lpObj->m_iSkillDistanceErrorCount=0;

  0032b	c7 86 24 24 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9252], 0
  00335	5e		 pop	 esi
  00336	5f		 pop	 edi
  00337	5b		 pop	 ebx

; 12085: }

  00338	8b e5		 mov	 esp, ebp
  0033a	5d		 pop	 ebp
  0033b	c3		 ret	 0
$LN4@CGMagicAtt@2:

; 12079: 		}
; 12080: 
; 12081: 		return;
; 12082: 	}
; 12083: 	
; 12084: 	gObjUseSkill.UseSkill(aIndex, usernumber, lpMagic);

  0033c	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0033f	57		 push	 edi
  00340	53		 push	 ebx
  00341	50		 push	 eax
  00342	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00347	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
  0034c	5e		 pop	 esi
  0034d	5f		 pop	 edi
  0034e	5b		 pop	 ebx

; 12085: }

  0034f	8b e5		 mov	 esp, ebp
  00351	5d		 pop	 ebp
  00352	c3		 ret	 0
$LN27@CGMagicAtt@2:

; 11951: 	{
; 11952: 		LogAdd("error :%s %d %d", __FILE__, __LINE__, usernumber);

  00353	53		 push	 ebx
  00354	68 b0 2e 00 00	 push	 11952			; 00002eb0H
  00359	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0035e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@
  00363	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00369	83 c4 10	 add	 esp, 16			; 00000010H
  0036c	5b		 pop	 ebx

; 12085: }

  0036d	8b e5		 mov	 esp, ebp
  0036f	5d		 pop	 ebp
  00370	c3		 ret	 0
?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ENDP	; CGMagicAttack
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 454  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 455  : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z	; CGTeleportRecv
EXTRN	?NotifyCsSelfLeftTime@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::NotifyCsSelfLeftTime
EXTRN	?NotifySelfCsJoinSide@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::NotifySelfCsJoinSide
EXTRN	?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjClearViewport
EXTRN	?IsInGate@CGate@@QAEHHH@Z:PROC			; CGate::IsInGate
EXTRN	?gGateC@@3VCGate@@A:BYTE			; gGateC
EXTRN	?GetCurrentZoneIndex@CImperialGuardian@@QAEHH@Z:PROC ; CImperialGuardian::GetCurrentZoneIndex
EXTRN	?gObjTeleportMagicUse@@YAXHEE@Z:PROC		; gObjTeleportMagicUse
EXTRN	?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z:PROC ; gObjMagicBPUse
EXTRN	?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z:PROC ; gObjMagicManaUse
EXTRN	?CheckTeleportMagicAxisY@CCastleSiege@@QAEHHHH@Z:PROC ; CCastleSiege::CheckTeleportMagicAxisY
EXTRN	?gObjCheckTeleportArea@@YAHHEE@Z:PROC		; gObjCheckTeleportArea
EXTRN	?Is2ndSkillActive@CIllusionTempleEvent@@QAEHHE@Z:PROC ; CIllusionTempleEvent::Is2ndSkillActive
EXTRN	?TeleportLock@CIllusionTempleEvent@@QAEHH@Z:PROC ; CIllusionTempleEvent::TeleportLock
EXTRN	?GetState@CIllusionTempleEvent@@QAEEE@Z:PROC	; CIllusionTempleEvent::GetState
;	COMDAT ??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	SEGMENT
??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@ DB '['
	DB	'%s][%s] Try Teleport Not Move Area [%d,%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z
_TEXT	SEGMENT
_usemana$222017 = -40					; size = 4
_y$221992 = -36						; size = 1
_x$221991 = -32						; size = 1
_lpMsg$GSCopy$ = -32					; size = 4
_pTeleportResult$222012 = -28				; size = 10
_pTeleportResult$221976 = -28				; size = 10
_pAttack$221993 = -16					; size = 9
_pTeleportResult$221983 = -16				; size = 10
_pTeleportResult$221980 = -16				; size = 10
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z PROC		; CGTeleportRecv, COMDAT

; 12300: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 12431: 			{
; 12432: 				int usebp = gObjMagicBPUse(&gObj[aIndex], lpMagic);

  00018	89 7d e0	 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], edi
  0001b	85 db		 test	 ebx, ebx
  0001d	0f 88 e6 04 00
	00		 js	 $LN1@CGTeleport

; 12301: 	if ( !OBJMAX_RANGE(aIndex))

  00023	33 c0		 xor	 eax, eax
  00025	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  0002b	0f 9e c0	 setle	 al
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 d3 04 00
	00		 je	 $LN1@CGTeleport

; 12302: 		return;
; 12303: 
; 12304: 	if ( gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_STUN) == TRUE ||
; 12305: 		 gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_SLEEP) == TRUE ||
; 12306: 		 gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_EARTHBINDS) == TRUE ||
; 12307: 		 gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_FREEZE) == TRUE )

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	56		 push	 esi
  0003c	8b f3		 mov	 esi, ebx
  0003e	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00044	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00047	6a 3d		 push	 61			; 0000003dH
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0004f	83 c4 08	 add	 esp, 8
  00052	3c 01		 cmp	 al, 1
  00054	0f 84 60 04 00
	00		 je	 $LN21@CGTeleport
  0005a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00063	6a 48		 push	 72			; 00000048H
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0006b	83 c4 08	 add	 esp, 8
  0006e	3c 01		 cmp	 al, 1
  00070	0f 84 44 04 00
	00		 je	 $LN21@CGTeleport
  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007c	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0007f	68 93 00 00 00	 push	 147			; 00000093H
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0008a	83 c4 08	 add	 esp, 8
  0008d	3c 01		 cmp	 al, 1
  0008f	0f 84 25 04 00
	00		 je	 $LN21@CGTeleport
  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009a	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0009d	68 92 00 00 00	 push	 146			; 00000092H
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000a8	83 c4 08	 add	 esp, 8
  000ab	3c 01		 cmp	 al, 1
  000ad	0f 84 07 04 00
	00		 je	 $LN21@CGTeleport

; 12319: 		return;
; 12320: 	}
; 12321: 
; 12322: 	if ( IT_MAP_RANGE( gObj[aIndex].MapNumber ) &&
; 12323: 		 g_IllusionTemple.GetState(gObj[aIndex].MapNumber) == 2 )

  000b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b9	8a 84 16 23 01
	00 00		 mov	 al, BYTE PTR [esi+edx+291]
  000c0	3c 2d		 cmp	 al, 45			; 0000002dH
  000c2	0f 82 aa 00 00
	00		 jb	 $LN34@CGTeleport
  000c8	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  000cd	3a c8		 cmp	 cl, al
  000cf	1b c9		 sbb	 ecx, ecx
  000d1	41		 inc	 ecx
  000d2	0f 84 9a 00 00
	00		 je	 $LN34@CGTeleport
  000d8	50		 push	 eax
  000d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  000de	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleEvent@@QAEEE@Z ; CIllusionTempleEvent::GetState
  000e3	3c 02		 cmp	 al, 2
  000e5	0f 85 87 00 00
	00		 jne	 $LN34@CGTeleport

; 12324: 	{
; 12325: 		if(  g_IllusionTemple.TeleportLock(aIndex) )

  000eb	53		 push	 ebx
  000ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  000f1	e8 00 00 00 00	 call	 ?TeleportLock@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::TeleportLock
  000f6	85 c0		 test	 eax, eax

; 12332: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  000f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fd	74 47		 je	 SHORT $LN19@CGTeleport

; 12329: 			pTeleportResult.h.size = sizeof(pTeleportResult);
; 12330: 			pTeleportResult.h.headcode = 0x1C;
; 12331: 			pTeleportResult.MoveNumber = 0;

  000ff	33 d2		 xor	 edx, edx
  00101	66 89 55 f4	 mov	 WORD PTR _pTeleportResult$221980[ebp+4], dx
$LN42@CGTeleport:

; 12326: 		{
; 12327: 			PMSG_TELEPORT_RESULT pTeleportResult;
; 12328: 			pTeleportResult.h.c = 0xC3;

  00105	c6 45 f2 1c	 mov	 BYTE PTR _pTeleportResult$221980[ebp+2], 28 ; 0000001cH
  00109	66 c7 45 f0 c3
	0a		 mov	 WORD PTR _pTeleportResult$221980[ebp], 2755 ; 00000ac3H

; 12332: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  0010f	0f b6 8c 06 23
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+291]
  00117	88 4d f6	 mov	 BYTE PTR _pTeleportResult$221980[ebp+6], cl

; 12333: 			pTeleportResult.MapX = gObj[aIndex].X;

  0011a	0f b6 94 06 20
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+288]
  00122	88 55 f7	 mov	 BYTE PTR _pTeleportResult$221980[ebp+7], dl

; 12334: 			pTeleportResult.MapY = gObj[aIndex].Y;

  00125	0f b6 8c 06 21
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+289]
  0012d	88 4d f8	 mov	 BYTE PTR _pTeleportResult$221980[ebp+8], cl

; 12335: 			pTeleportResult.Dir = gObj[aIndex].Dir;

  00130	0f b6 94 06 22
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+290]

; 12336: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);

  00138	6a 0a		 push	 10			; 0000000aH
  0013a	8d 45 f0	 lea	 eax, DWORD PTR _pTeleportResult$221980[ebp]
  0013d	88 55 f9	 mov	 BYTE PTR _pTeleportResult$221980[ebp+9], dl
  00140	50		 push	 eax

; 12337: 			return;

  00141	e9 b9 03 00 00	 jmp	 $LN39@CGTeleport
$LN19@CGTeleport:

; 12338: 		}
; 12339: 
; 12340: 		if( g_IllusionTemple.Is2ndSkillActive(gObj[aIndex].iTempleIndex,gObj[aIndex].MapNumber) )

  00146	0f b6 8c 06 23
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+291]
  0014e	8b 94 06 78 24
	00 00		 mov	 edx, DWORD PTR [esi+eax+9336]
  00155	51		 push	 ecx
  00156	52		 push	 edx
  00157	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  0015c	e8 00 00 00 00	 call	 ?Is2ndSkillActive@CIllusionTempleEvent@@QAEHHE@Z ; CIllusionTempleEvent::Is2ndSkillActive
  00161	85 c0		 test	 eax, eax
  00163	74 0d		 je	 SHORT $LN34@CGTeleport
$LN41@CGTeleport:

; 12341: 		{
; 12342: 			PMSG_TELEPORT_RESULT pTeleportResult;
; 12343: 			pTeleportResult.h.c = 0xC3;
; 12344: 			pTeleportResult.h.size = sizeof(pTeleportResult);
; 12345: 			pTeleportResult.h.headcode = 0x1C;
; 12346: 			pTeleportResult.MoveNumber = 0;

  00165	33 c0		 xor	 eax, eax
  00167	66 89 45 f4	 mov	 WORD PTR _pTeleportResult$221983[ebp+4], ax

; 12347: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  0016b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 12348: 			pTeleportResult.MapX = gObj[aIndex].X;
; 12349: 			pTeleportResult.MapY = gObj[aIndex].Y;
; 12350: 			pTeleportResult.Dir = gObj[aIndex].Dir;
; 12351: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);
; 12352: 			return;

  00170	eb 93		 jmp	 SHORT $LN42@CGTeleport
$LN34@CGTeleport:

; 12353: 		}
; 12354: 	}
; 12355: 
; 12356: 	if( IT_MAP_RANGE( gObj[aIndex].MapNumber ) )

  00172	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00178	8a 8c 0e 23 01
	00 00		 mov	 cl, BYTE PTR [esi+ecx+291]
  0017f	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  00182	72 18		 jb	 SHORT $LN35@CGTeleport
  00184	b2 32		 mov	 dl, 50			; 00000032H
  00186	3a d1		 cmp	 dl, cl
  00188	1b c0		 sbb	 eax, eax
  0018a	40		 inc	 eax
  0018b	74 0f		 je	 SHORT $LN35@CGTeleport

; 12357: 	{
; 12358: 		if( g_IllusionTemple.GetState(gObj[aIndex].MapNumber) == 1 )

  0018d	51		 push	 ecx
  0018e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  00193	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleEvent@@QAEEE@Z ; CIllusionTempleEvent::GetState
  00198	3c 01		 cmp	 al, 1

; 12359: 		{
; 12360: 			PMSG_TELEPORT_RESULT pTeleportResult;
; 12361: 			pTeleportResult.h.c = 0xC3;
; 12362: 			pTeleportResult.h.size = sizeof(pTeleportResult);
; 12363: 			pTeleportResult.h.headcode = 0x1C;
; 12364: 			pTeleportResult.MoveNumber = 0;
; 12365: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;
; 12366: 			pTeleportResult.MapX = gObj[aIndex].X;
; 12367: 			pTeleportResult.MapY = gObj[aIndex].Y;
; 12368: 			pTeleportResult.Dir = gObj[aIndex].Dir;
; 12369: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);
; 12370: 			return;

  0019a	74 c9		 je	 SHORT $LN41@CGTeleport
$LN35@CGTeleport:

; 12371: 		}
; 12372: 	}
; 12373: 
; 12374: 	if ( lpMsg->MoveNumber == 0 )

  0019c	0f b7 7f 04	 movzx	 edi, WORD PTR [edi+4]
  001a0	66 85 ff	 test	 di, di
  001a3	0f 85 01 02 00
	00		 jne	 $LN15@CGTeleport

; 12375: 	{
; 12376: 		CMagicInf * lpMagic;
; 12377: 		BYTE x;
; 12378: 		BYTE y;
; 12379: 		PMSG_MAGICATTACK_RESULT pAttack;
; 12380: 
; 12381: 		PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof(pAttack));

  001a9	6a 09		 push	 9
  001ab	8d 4d f0	 lea	 ecx, DWORD PTR _pAttack$221993[ebp]
  001ae	6a 19		 push	 25			; 00000019H
  001b0	51		 push	 ecx
  001b1	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 12382: 
; 12383: 		pAttack.MagicNumberH = SET_NUMBERH(AT_SKILL_TELEPORT);
; 12384: 		pAttack.MagicNumberL = SET_NUMBERL(AT_SKILL_TELEPORT);
; 12385: 
; 12386: 		pAttack.SourceNumberH = SET_NUMBERH(aIndex);
; 12387: 		pAttack.SourceNumberL = SET_NUMBERL(aIndex);
; 12388: 		pAttack.TargetNumberH = SET_NUMBERH(aIndex);
; 12389: 		pAttack.TargetNumberL = SET_NUMBERL(aIndex);
; 12390: 
; 12391: 		lpMagic = gObjGetMagicSearch(&gObj[aIndex], AT_SKILL_TELEPORT);

  001b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001bc	8b c3		 mov	 eax, ebx
  001be	c1 e8 08	 shr	 eax, 8
  001c1	88 45 f3	 mov	 BYTE PTR _pAttack$221993[ebp+3], al
  001c4	88 45 f7	 mov	 BYTE PTR _pAttack$221993[ebp+7], al
  001c7	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  001ca	6a 06		 push	 6
  001cc	50		 push	 eax
  001cd	66 c7 45 f5 00
	06		 mov	 WORD PTR _pAttack$221993[ebp+5], 1536 ; 00000600H
  001d3	88 5d f4	 mov	 BYTE PTR _pAttack$221993[ebp+4], bl
  001d6	88 5d f8	 mov	 BYTE PTR _pAttack$221993[ebp+8], bl
  001d9	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  001de	8b f8		 mov	 edi, eax

; 12392: 		x = lpMsg->MapX;

  001e0	8b 45 e0	 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]

; 12393: 		y = lpMsg->MapY;

  001e3	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  001e6	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  001e9	88 55 dc	 mov	 BYTE PTR _y$221992[ebp], dl

; 12394: 
; 12395: 		if ( gObjCheckTeleportArea(aIndex, x, y) == FALSE )

  001ec	8b 45 dc	 mov	 eax, DWORD PTR _y$221992[ebp]
  001ef	88 4d e0	 mov	 BYTE PTR _x$221991[ebp], cl
  001f2	8b 4d e0	 mov	 ecx, DWORD PTR _x$221991[ebp]
  001f5	50		 push	 eax
  001f6	51		 push	 ecx
  001f7	53		 push	 ebx
  001f8	e8 00 00 00 00	 call	 ?gObjCheckTeleportArea@@YAHHEE@Z ; gObjCheckTeleportArea
  001fd	83 c4 20	 add	 esp, 32			; 00000020H
  00200	85 c0		 test	 eax, eax

; 12396: 		{
; 12397: 			LogAddC(2, "[%s][%s] Try Teleport Not Move Area [%d,%d]",
; 12398: 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 12399: 				x, y);

  00202	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00207	0f 85 80 00 00
	00		 jne	 $LN14@CGTeleport
  0020d	0f b6 55 dc	 movzx	 edx, BYTE PTR _y$221992[ebp]
  00211	0f b6 4d e0	 movzx	 ecx, BYTE PTR _x$221991[ebp]
  00215	52		 push	 edx
  00216	51		 push	 ecx
  00217	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  0021b	52		 push	 edx
  0021c	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00220	50		 push	 eax
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@
  00226	6a 02		 push	 2
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 12400: 
; 12401: 			PMSG_TELEPORT_RESULT pTeleportResult;
; 12402: 
; 12403: 			pTeleportResult.h.c = 0xC3;
; 12404: 			pTeleportResult.h.size = sizeof(pTeleportResult);
; 12405: 			pTeleportResult.h.headcode = 0x1C;
; 12406: 			pTeleportResult.MoveNumber = 0;
; 12407: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  0022e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00233	33 c9		 xor	 ecx, ecx
  00235	66 89 4d e8	 mov	 WORD PTR _pTeleportResult$222012[ebp+4], cx
  00239	66 c7 45 e4 c3
	0a		 mov	 WORD PTR _pTeleportResult$222012[ebp], 2755 ; 00000ac3H
  0023f	c6 45 e6 1c	 mov	 BYTE PTR _pTeleportResult$222012[ebp+2], 28 ; 0000001cH
  00243	0f b6 94 06 23
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+291]
  0024b	88 55 ea	 mov	 BYTE PTR _pTeleportResult$222012[ebp+6], dl

; 12408: 			pTeleportResult.MapX = gObj[aIndex].X;

  0024e	8a 8c 06 20 01
	00 00		 mov	 cl, BYTE PTR [esi+eax+288]
  00255	88 4d eb	 mov	 BYTE PTR _pTeleportResult$222012[ebp+7], cl

; 12409: 			pTeleportResult.MapY = gObj[aIndex].Y;

  00258	0f b6 94 06 21
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+289]

; 12410: 			pTeleportResult.Dir = gObj[aIndex].Dir;
; 12411: 
; 12412: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);

  00260	6a 0a		 push	 10			; 0000000aH
  00262	8d 4d e4	 lea	 ecx, DWORD PTR _pTeleportResult$222012[ebp]
  00265	88 55 ec	 mov	 BYTE PTR _pTeleportResult$222012[ebp+8], dl
  00268	8a 84 06 22 01
	00 00		 mov	 al, BYTE PTR [esi+eax+290]
  0026f	51		 push	 ecx
  00270	53		 push	 ebx
  00271	88 45 ed	 mov	 BYTE PTR _pTeleportResult$222012[ebp+9], al
  00274	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00279	83 c4 24	 add	 esp, 36			; 00000024H
  0027c	5e		 pop	 esi
  0027d	5f		 pop	 edi
  0027e	5b		 pop	 ebx

; 12473: 		}
; 12474: #endif
; 12475: 	}
; 12476: }

  0027f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00282	33 cd		 xor	 ecx, ebp
  00284	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c3		 ret	 0
$LN14@CGTeleport:

; 12413: 			return;
; 12414: 		}
; 12415: #if (GS_CASTLE == 1)
; 12416: 
; 12417: 		if ( gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE )

  0028d	80 bc 06 23 01
	00 00 1e	 cmp	 BYTE PTR [esi+eax+291], 30 ; 0000001eH
  00295	75 30		 jne	 SHORT $LN12@CGTeleport

; 12418: 		{
; 12419: 			if( g_CastleSiege.CheckTeleportMagicAxisY(gObj[aIndex].Y,x,y) == FALSE )

  00297	0f b6 55 dc	 movzx	 edx, BYTE PTR _y$221992[ebp]
  0029b	0f b6 4d e0	 movzx	 ecx, BYTE PTR _x$221991[ebp]
  0029f	52		 push	 edx
  002a0	0f b6 94 06 21
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+289]
  002a8	51		 push	 ecx
  002a9	52		 push	 edx
  002aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002af	e8 00 00 00 00	 call	 ?CheckTeleportMagicAxisY@CCastleSiege@@QAEHHHH@Z ; CCastleSiege::CheckTeleportMagicAxisY
  002b4	85 c0		 test	 eax, eax

; 12420: 			{
; 12421: 				y = gObj[aIndex].Y;

  002b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002bb	75 0a		 jne	 SHORT $LN12@CGTeleport
  002bd	8a 8c 06 21 01
	00 00		 mov	 cl, BYTE PTR [esi+eax+289]
  002c4	88 4d dc	 mov	 BYTE PTR _y$221992[ebp], cl
$LN12@CGTeleport:

; 12422: 			}
; 12423: 		}
; 12424: #endif
; 12425: 
; 12426: 		if ( lpMagic )

  002c7	85 ff		 test	 edi, edi
  002c9	0f 84 39 02 00
	00		 je	 $LN38@CGTeleport

; 12427: 		{
; 12428: 			int usemana = gObjMagicManaUse(&gObj[aIndex], lpMagic);

  002cf	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]
  002d2	57		 push	 edi
  002d3	52		 push	 edx
  002d4	e8 00 00 00 00	 call	 ?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicManaUse
  002d9	83 c4 08	 add	 esp, 8
  002dc	89 45 d8	 mov	 DWORD PTR _usemana$222017[ebp], eax

; 12429: 
; 12430: 			if ( usemana >= 0 )

  002df	85 c0		 test	 eax, eax
  002e1	0f 88 21 02 00
	00		 js	 $LN38@CGTeleport

; 12431: 			{
; 12432: 				int usebp = gObjMagicBPUse(&gObj[aIndex], lpMagic);

  002e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ec	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  002ef	57		 push	 edi
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 ?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
  002f6	8b f8		 mov	 edi, eax
  002f8	83 c4 08	 add	 esp, 8

; 12433: 				
; 12434: 				if ( usebp >= 0 )

  002fb	85 ff		 test	 edi, edi
  002fd	0f 88 05 02 00
	00		 js	 $LN38@CGTeleport

; 12435: 				{
; 12436: 					if ( gObj[aIndex].Type == OBJ_USER )

  00303	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00309	80 7c 16 50 01	 cmp	 BYTE PTR [esi+edx+80], 1
  0030e	75 12		 jne	 SHORT $LN8@CGTeleport

; 12437: 						DataSend(aIndex, (LPBYTE)&pAttack, pAttack.h.size);

  00310	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$221993[ebp+1]
  00314	50		 push	 eax
  00315	8d 4d f0	 lea	 ecx, DWORD PTR _pAttack$221993[ebp]
  00318	51		 push	 ecx
  00319	53		 push	 ebx
  0031a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0031f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@CGTeleport:

; 12438: 
; 12439: 					MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);

  00322	0f b6 55 f1	 movzx	 edx, BYTE PTR _pAttack$221993[ebp+1]
  00326	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0032c	52		 push	 edx
  0032d	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$221993[ebp]
  00330	50		 push	 eax
  00331	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00334	52		 push	 edx
  00335	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 12440: 					gObjTeleportMagicUse(aIndex, x, y);

  0033a	8b 45 dc	 mov	 eax, DWORD PTR _y$221992[ebp]
  0033d	8b 4d e0	 mov	 ecx, DWORD PTR _x$221991[ebp]
  00340	50		 push	 eax
  00341	51		 push	 ecx
  00342	53		 push	 ebx
  00343	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse

; 12441: 					gObj[aIndex].Mana = (float)usemana;

  00348	db 45 d8	 fild	 DWORD PTR _usemana$222017[ebp]
  0034b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00351	83 c4 18	 add	 esp, 24			; 00000018H
  00354	d9 9c 16 ec 00
	00 00		 fstp	 DWORD PTR [esi+edx+236]

; 12442: 					gObj[aIndex].BP = usebp;

  0035b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00360	89 bc 06 04 01
	00 00		 mov	 DWORD PTR [esi+eax+260], edi

; 12443: 					GCManaSend(gObj[aIndex].m_Index, (WORD)gObj[aIndex].Mana, -1, 0, gObj[aIndex].BP);

  00367	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0036d	0f b7 8c 3e 04
	01 00 00	 movzx	 ecx, WORD PTR [esi+edi+260]
  00375	d9 84 3e ec 00
	00 00		 fld	 DWORD PTR [esi+edi+236]
  0037c	51		 push	 ecx
  0037d	6a 00		 push	 0
  0037f	68 ff 00 00 00	 push	 255			; 000000ffH
  00384	e8 00 00 00 00	 call	 __ftol2_sse
  00389	0f b7 d0	 movzx	 edx, ax
  0038c	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  0038f	52		 push	 edx
  00390	50		 push	 eax
  00391	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  00396	83 c4 14	 add	 esp, 20			; 00000014H
  00399	5e		 pop	 esi
  0039a	5f		 pop	 edi
  0039b	5b		 pop	 ebx

; 12473: 		}
; 12474: #endif
; 12475: 	}
; 12476: }

  0039c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039f	33 cd		 xor	 ecx, ebp
  003a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a6	8b e5		 mov	 esp, ebp
  003a8	5d		 pop	 ebp
  003a9	c3		 ret	 0
$LN15@CGTeleport:

; 12444: 				}
; 12445: 			}
; 12446: 		}
; 12447: 	}
; 12448: 	else if ( IF_MAP_RANGE(gObj[aIndex].MapNumber) )

  003aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003b0	0f b6 84 0e 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+291]
  003b8	3c 45		 cmp	 al, 69			; 00000045H
  003ba	72 3a		 jb	 SHORT $LN6@CGTeleport
  003bc	b2 48		 mov	 dl, 72			; 00000048H
  003be	3a d0		 cmp	 dl, al
  003c0	1b c0		 sbb	 eax, eax
  003c2	40		 inc	 eax
  003c3	74 31		 je	 SHORT $LN6@CGTeleport

; 12449: 	{
; 12450: 		int nZoneIndex = g_ImperialGuardian.GetCurrentZoneIndex(aIndex);

  003c5	53		 push	 ebx
  003c6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  003cb	e8 00 00 00 00	 call	 ?GetCurrentZoneIndex@CImperialGuardian@@QAEHH@Z ; CImperialGuardian::GetCurrentZoneIndex

; 12451: 
; 12452: 		if( nZoneIndex >= 0 )

  003d0	85 c0		 test	 eax, eax
  003d2	0f 88 30 01 00
	00		 js	 $LN38@CGTeleport

; 12453: 		{
; 12454: 			g_ImperialGuardian.CGEnterPortal(aIndex,nZoneIndex+1);

  003d8	40		 inc	 eax
  003d9	50		 push	 eax
  003da	53		 push	 ebx
  003db	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  003e0	e8 00 00 00 00	 call	 ?CGEnterPortal@CImperialGuardian@@QAEXHH@Z ; CImperialGuardian::CGEnterPortal
  003e5	5e		 pop	 esi
  003e6	5f		 pop	 edi
  003e7	5b		 pop	 ebx

; 12473: 		}
; 12474: #endif
; 12475: 	}
; 12476: }

  003e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003eb	33 cd		 xor	 ecx, ebp
  003ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f2	8b e5		 mov	 esp, ebp
  003f4	5d		 pop	 ebp
  003f5	c3		 ret	 0
$LN6@CGTeleport:

; 12455: 		}
; 12456: 	}
; 12457: 	else if ( gGateC.IsInGate(aIndex, lpMsg->MoveNumber) )

  003f6	57		 push	 edi
  003f7	53		 push	 ebx
  003f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  003fd	e8 00 00 00 00	 call	 ?IsInGate@CGate@@QAEHHH@Z ; CGate::IsInGate
  00402	85 c0		 test	 eax, eax
  00404	74 22		 je	 SHORT $LN3@CGTeleport

; 12458: 	{
; 12459: 		gObjMoveGate(aIndex, lpMsg->MoveNumber);

  00406	8b 4d e0	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00409	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  0040d	52		 push	 edx
  0040e	53		 push	 ebx
  0040f	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00414	83 c4 08	 add	 esp, 8
  00417	5e		 pop	 esi
  00418	5f		 pop	 edi
  00419	5b		 pop	 ebx

; 12473: 		}
; 12474: #endif
; 12475: 	}
; 12476: }

  0041a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041d	33 cd		 xor	 ecx, ebp
  0041f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00424	8b e5		 mov	 esp, ebp
  00426	5d		 pop	 ebp
  00427	c3		 ret	 0
$LN3@CGTeleport:

; 12460: 	}
; 12461: 	else
; 12462: 	{
; 12463: 		gObjClearViewport(&gObj[aIndex]);

  00428	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0042d	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00430	51		 push	 ecx
  00431	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 12464: 		GCTeleportSend(&gObj[aIndex], lpMsg->MoveNumber, 
; 12465: 			gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y, gObj[aIndex].Dir);

  00436	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0043c	0f b6 8c 16 22
	01 00 00	 movzx	 ecx, BYTE PTR [esi+edx+290]
  00444	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00447	0f b6 90 21 01
	00 00		 movzx	 edx, BYTE PTR [eax+289]
  0044e	51		 push	 ecx
  0044f	0f b6 88 20 01
	00 00		 movzx	 ecx, BYTE PTR [eax+288]
  00456	52		 push	 edx
  00457	0f b6 90 23 01
	00 00		 movzx	 edx, BYTE PTR [eax+291]
  0045e	51		 push	 ecx
  0045f	8b 4d e0	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00462	52		 push	 edx
  00463	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  00467	52		 push	 edx
  00468	50		 push	 eax
  00469	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend

; 12466: 
; 12467: #if (GS_CASTLE == 1)
; 12468: 		if( gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE 
; 12469: 			&& g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)

  0046e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00473	83 c4 1c	 add	 esp, 28			; 0000001cH
  00476	80 bc 06 23 01
	00 00 1e	 cmp	 BYTE PTR [esi+eax+291], 30 ; 0000001eH
  0047e	0f 85 84 00 00
	00		 jne	 $LN38@CGTeleport
  00484	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00489	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  0048e	83 f8 07	 cmp	 eax, 7
  00491	75 75		 jne	 SHORT $LN38@CGTeleport

; 12470: 		{
; 12471: 			g_CastleSiege.NotifySelfCsJoinSide(aIndex);

  00493	53		 push	 ebx
  00494	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00499	e8 00 00 00 00	 call	 ?NotifySelfCsJoinSide@CCastleSiege@@QAEXH@Z ; CCastleSiege::NotifySelfCsJoinSide

; 12472: 			g_CastleSiege.NotifyCsSelfLeftTime(aIndex);

  0049e	53		 push	 ebx
  0049f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  004a4	e8 00 00 00 00	 call	 ?NotifyCsSelfLeftTime@CCastleSiege@@QAEXH@Z ; CCastleSiege::NotifyCsSelfLeftTime
  004a9	5e		 pop	 esi
  004aa	5f		 pop	 edi
  004ab	5b		 pop	 ebx

; 12473: 		}
; 12474: #endif
; 12475: 	}
; 12476: }

  004ac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004af	33 cd		 xor	 ecx, ebp
  004b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004b6	8b e5		 mov	 esp, ebp
  004b8	5d		 pop	 ebp
  004b9	c3		 ret	 0
$LN21@CGTeleport:

; 12308: 	{
; 12309: 		PMSG_TELEPORT_RESULT pTeleportResult;
; 12310: 		pTeleportResult.h.c = 0xC3;
; 12311: 		pTeleportResult.h.size = sizeof(pTeleportResult);
; 12312: 		pTeleportResult.h.headcode = 0x1C;
; 12313: 		pTeleportResult.MoveNumber = 0;
; 12314: 		pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  004ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004bf	33 c9		 xor	 ecx, ecx
  004c1	66 89 4d e8	 mov	 WORD PTR _pTeleportResult$221976[ebp+4], cx
  004c5	66 c7 45 e4 c3
	0a		 mov	 WORD PTR _pTeleportResult$221976[ebp], 2755 ; 00000ac3H
  004cb	c6 45 e6 1c	 mov	 BYTE PTR _pTeleportResult$221976[ebp+2], 28 ; 0000001cH
  004cf	0f b6 94 06 23
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+291]
  004d7	88 55 ea	 mov	 BYTE PTR _pTeleportResult$221976[ebp+6], dl

; 12315: 		pTeleportResult.MapX = gObj[aIndex].X;

  004da	8a 8c 06 20 01
	00 00		 mov	 cl, BYTE PTR [esi+eax+288]
  004e1	88 4d eb	 mov	 BYTE PTR _pTeleportResult$221976[ebp+7], cl

; 12316: 		pTeleportResult.MapY = gObj[aIndex].Y;

  004e4	0f b6 94 06 21
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+289]
  004ec	88 55 ec	 mov	 BYTE PTR _pTeleportResult$221976[ebp+8], dl

; 12317: 		pTeleportResult.Dir = gObj[aIndex].Dir;

  004ef	8a 84 06 22 01
	00 00		 mov	 al, BYTE PTR [esi+eax+290]

; 12318: 		DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);

  004f6	6a 0a		 push	 10			; 0000000aH
  004f8	8d 4d e4	 lea	 ecx, DWORD PTR _pTeleportResult$221976[ebp]
  004fb	88 45 ed	 mov	 BYTE PTR _pTeleportResult$221976[ebp+9], al
  004fe	51		 push	 ecx
$LN39@CGTeleport:
  004ff	53		 push	 ebx
  00500	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00505	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN38@CGTeleport:
  00508	5e		 pop	 esi
$LN1@CGTeleport:

; 12473: 		}
; 12474: #endif
; 12475: 	}
; 12476: }

  00509	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0050c	5f		 pop	 edi
  0050d	33 cd		 xor	 ecx, ebp
  0050f	5b		 pop	 ebx
  00510	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00515	8b e5		 mov	 esp, ebp
  00517	5d		 pop	 ebp
  00518	c3		 ret	 0
?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z ENDP		; CGTeleportRecv
_TEXT	ENDS
PUBLIC	??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ; CGTargetTeleportRecv
;	COMDAT ??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@
CONST	SEGMENT
??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@ DB '['
	DB	'%s][%s] Try Target Teleport Not Move Area [%d,%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -32					; size = 4
_usemana$222073 = -28					; size = 4
_lpMagic$ = -28						; size = 4
_y$ = -24						; size = 1
_x$ = -20						; size = 1
_pAttack$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z PROC ; CGTargetTeleportRecv, COMDAT

; 12482: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 12555: 
; 12556: 				MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);

  00018	89 5d e0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0001b	85 db		 test	 ebx, ebx
  0001d	0f 88 a4 02 00
	00		 js	 $LN6@CGTargetTe

; 12483: 	if ( !OBJMAX_RANGE(aIndex))

  00023	33 c0		 xor	 eax, eax
  00025	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  0002b	0f 9e c0	 setle	 al
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 91 02 00
	00		 je	 $LN6@CGTargetTe

; 12484: 		return;
; 12485: 
; 12486: 	if( gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_STUN) == TRUE ||
; 12487: 		gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_SLEEP) == TRUE ||
; 12488: 		gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_EARTHBINDS) == TRUE ||
; 12489: 		gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_FREEZE) == TRUE)

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	56		 push	 esi
  0003c	8b f3		 mov	 esi, ebx
  0003e	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00044	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00047	6a 3d		 push	 61			; 0000003dH
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0004f	83 c4 08	 add	 esp, 8
  00052	3c 01		 cmp	 al, 1
  00054	0f 84 6c 02 00
	00		 je	 $LN21@CGTargetTe
  0005a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00063	6a 48		 push	 72			; 00000048H
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0006b	83 c4 08	 add	 esp, 8
  0006e	3c 01		 cmp	 al, 1
  00070	0f 84 50 02 00
	00		 je	 $LN21@CGTargetTe
  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007c	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0007f	68 93 00 00 00	 push	 147			; 00000093H
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0008a	83 c4 08	 add	 esp, 8
  0008d	3c 01		 cmp	 al, 1
  0008f	0f 84 31 02 00
	00		 je	 $LN21@CGTargetTe
  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009a	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0009d	68 92 00 00 00	 push	 146			; 00000092H
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000a8	83 c4 08	 add	 esp, 8
  000ab	3c 01		 cmp	 al, 1
  000ad	0f 84 13 02 00
	00		 je	 $LN21@CGTargetTe

; 12490: 		return;
; 12491: 
; 12492: 	CMagicInf * lpMagic;
; 12493: 	BYTE x;
; 12494: 	BYTE y;
; 12495: 	PMSG_MAGICATTACK_RESULT pAttack;
; 12496: 
; 12497: 	PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof(pAttack));

  000b3	6a 09		 push	 9
  000b5	8d 55 f0	 lea	 edx, DWORD PTR _pAttack$[ebp]
  000b8	6a 19		 push	 25			; 00000019H
  000ba	52		 push	 edx
  000bb	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 12498: 
; 12499: 	pAttack.MagicNumberH = SET_NUMBERH(AT_SKILL_TARGET_TELEPORT);
; 12500: 	pAttack.MagicNumberL = SET_NUMBERL(AT_SKILL_TARGET_TELEPORT);
; 12501: 
; 12502: 	pAttack.SourceNumberH = SET_NUMBERH(aIndex);
; 12503: 	pAttack.SourceNumberL = SET_NUMBERL(aIndex);
; 12504: 	int iTargetIndex = MAKE_NUMBERW(lpMsg->NumberL, lpMsg->NumberH);

  000c0	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  000c4	0f b6 57 03	 movzx	 edx, BYTE PTR [edi+3]
  000c8	66 c1 e1 08	 shl	 cx, 8
  000cc	8b c3		 mov	 eax, ebx
  000ce	88 5d f4	 mov	 BYTE PTR _pAttack$[ebp+4], bl
  000d1	0f b7 d9	 movzx	 ebx, cx

; 12505: 
; 12506: 	pAttack.TargetNumberH = SET_NUMBERH(iTargetIndex);
; 12507: 	pAttack.TargetNumberL = SET_NUMBERL(iTargetIndex);
; 12508: 	lpMagic = gObjGetMagicSearch(&gObj[aIndex], AT_SKILL_TARGET_TELEPORT);

  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000da	c1 e8 08	 shr	 eax, 8
  000dd	0b da		 or	 ebx, edx
  000df	88 45 f3	 mov	 BYTE PTR _pAttack$[ebp+3], al
  000e2	8b c3		 mov	 eax, ebx
  000e4	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  000e7	c1 e8 08	 shr	 eax, 8
  000ea	6a 0f		 push	 15			; 0000000fH
  000ec	52		 push	 edx
  000ed	66 c7 45 f5 00
	0f		 mov	 WORD PTR _pAttack$[ebp+5], 3840 ; 00000f00H
  000f3	88 45 f7	 mov	 BYTE PTR _pAttack$[ebp+7], al
  000f6	88 5d f8	 mov	 BYTE PTR _pAttack$[ebp+8], bl
  000f9	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch

; 12509: 	x = lpMsg->MapX;
; 12510: 	y = lpMsg->MapY;

  000fe	8a 4f 06	 mov	 cl, BYTE PTR [edi+6]
  00101	89 45 e4	 mov	 DWORD PTR _lpMagic$[ebp], eax
  00104	8a 47 05	 mov	 al, BYTE PTR [edi+5]

; 12511: 
; 12512: 	if ( !gObjIsConnectedGP(iTargetIndex) )

  00107	53		 push	 ebx
  00108	88 45 ec	 mov	 BYTE PTR _x$[ebp], al
  0010b	88 4d e8	 mov	 BYTE PTR _y$[ebp], cl
  0010e	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00113	83 c4 18	 add	 esp, 24			; 00000018H
  00116	85 c0		 test	 eax, eax

; 12513: 	{
; 12514: 		LogAddC(2, "[%s][%s] Try Target Teleport Not Move Area [%d,%d]",
; 12515: 			gObj[aIndex].AccountID, gObj[aIndex].Name, x, y);

  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011d	75 19		 jne	 SHORT $LN10@CGTargetTe
  0011f	0f b6 55 e8	 movzx	 edx, BYTE PTR _y$[ebp]
  00123	0f b6 4d ec	 movzx	 ecx, BYTE PTR _x$[ebp]
  00127	52		 push	 edx
  00128	51		 push	 ecx
  00129	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  0012d	52		 push	 edx
  0012e	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00132	50		 push	 eax

; 12516: 
; 12517: 		return;

  00133	e9 8f 00 00 00	 jmp	 $LN22@CGTargetTe
$LN10@CGTargetTe:

; 12518: 	}
; 12519: 
; 12520: 	if ( IT_MAP_RANGE( gObj[iTargetIndex].MapNumber ) )

  00138	8b fb		 mov	 edi, ebx
  0013a	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00140	0f b6 8c 07 23
	01 00 00	 movzx	 ecx, BYTE PTR [edi+eax+291]
  00148	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  0014b	72 24		 jb	 SHORT $LN20@CGTargetTe
  0014d	b2 32		 mov	 dl, 50			; 00000032H
  0014f	3a d1		 cmp	 dl, cl
  00151	1b c9		 sbb	 ecx, ecx
  00153	41		 inc	 ecx
  00154	74 1b		 je	 SHORT $LN20@CGTargetTe

; 12521: 	{
; 12522: 		if( g_IllusionTemple.TeleportLock(gObj[iTargetIndex].m_Index) )

  00156	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  00159	50		 push	 eax
  0015a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  0015f	e8 00 00 00 00	 call	 ?TeleportLock@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::TeleportLock
  00164	85 c0		 test	 eax, eax
  00166	0f 85 5a 01 00
	00		 jne	 $LN21@CGTargetTe
  0016c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN20@CGTargetTe:

; 12523: 		{
; 12524: 			return;
; 12525: 		}
; 12526: 	}
; 12527: 
; 12528: 	if ( gObj[aIndex].PartyNumber != gObj[iTargetIndex].PartyNumber ||
; 12529: 		 gObj[aIndex].PartyNumber == -1 ||
; 12530: 		 gObj[iTargetIndex].PartyNumber == -1)

  00171	8b 8c 06 0c 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1548]
  00178	8b 84 07 0c 06
	00 00		 mov	 eax, DWORD PTR [edi+eax+1548]
  0017f	3b c8		 cmp	 ecx, eax
  00181	0f 85 3f 01 00
	00		 jne	 $LN21@CGTargetTe
  00187	83 f9 ff	 cmp	 ecx, -1
  0018a	0f 84 36 01 00
	00		 je	 $LN21@CGTargetTe
  00190	83 f8 ff	 cmp	 eax, -1
  00193	0f 84 2d 01 00
	00		 je	 $LN21@CGTargetTe

; 12531: 	{
; 12532: 		return;
; 12533: 	}
; 12534: 
; 12535: 	if ( !gObjCheckTeleportArea(iTargetIndex, x, y))

  00199	8b 4d e8	 mov	 ecx, DWORD PTR _y$[ebp]
  0019c	8b 55 ec	 mov	 edx, DWORD PTR _x$[ebp]
  0019f	51		 push	 ecx
  001a0	52		 push	 edx
  001a1	53		 push	 ebx
  001a2	e8 00 00 00 00	 call	 ?gObjCheckTeleportArea@@YAHHEE@Z ; gObjCheckTeleportArea
  001a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001aa	85 c0		 test	 eax, eax
  001ac	75 3a		 jne	 SHORT $LN5@CGTargetTe

; 12536: 	{
; 12537: 		LogAddC(2, "[%s][%s] Try Target Teleport Not Move Area [%d,%d]",
; 12538: 			gObj[aIndex].AccountID, gObj[aIndex].Name, x, y);

  001ae	0f b6 4d e8	 movzx	 ecx, BYTE PTR _y$[ebp]
  001b2	0f b6 55 ec	 movzx	 edx, BYTE PTR _x$[ebp]
  001b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001bb	51		 push	 ecx
  001bc	52		 push	 edx
  001bd	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  001c1	51		 push	 ecx
  001c2	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  001c6	52		 push	 edx
$LN22@CGTargetTe:
  001c7	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@
  001cc	6a 02		 push	 2
  001ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001d4	83 c4 18	 add	 esp, 24			; 00000018H
  001d7	5e		 pop	 esi
  001d8	5f		 pop	 edi
  001d9	5b		 pop	 ebx

; 12561: 
; 12562: 				return;
; 12563: 			}
; 12564: 		}
; 12565: 	}
; 12566: }

  001da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001dd	33 cd		 xor	 ecx, ebp
  001df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e4	8b e5		 mov	 esp, ebp
  001e6	5d		 pop	 ebp
  001e7	c3		 ret	 0
$LN5@CGTargetTe:

; 12539: 
; 12540: 		return;
; 12541: 	}
; 12542: 
; 12543: 	if ( lpMagic )

  001e8	8b 7d e4	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  001eb	85 ff		 test	 edi, edi
  001ed	0f 84 d3 00 00
	00		 je	 $LN21@CGTargetTe

; 12544: 	{
; 12545: 		int usemana = gObjMagicManaUse(&gObj[aIndex], lpMagic);

  001f3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f8	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  001fb	57		 push	 edi
  001fc	51		 push	 ecx
  001fd	e8 00 00 00 00	 call	 ?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicManaUse
  00202	83 c4 08	 add	 esp, 8
  00205	89 45 e4	 mov	 DWORD PTR _usemana$222073[ebp], eax

; 12546: 
; 12547: 		if ( usemana >= 0 )

  00208	85 c0		 test	 eax, eax
  0020a	0f 88 b6 00 00
	00		 js	 $LN21@CGTargetTe

; 12548: 		{
; 12549: 			int usebp = gObjMagicBPUse(&gObj[aIndex], lpMagic);

  00210	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00216	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00219	57		 push	 edi
  0021a	50		 push	 eax
  0021b	e8 00 00 00 00	 call	 ?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
  00220	8b f8		 mov	 edi, eax
  00222	83 c4 08	 add	 esp, 8

; 12550: 			
; 12551: 			if ( usebp >= 0 )

  00225	85 ff		 test	 edi, edi
  00227	0f 88 99 00 00
	00		 js	 $LN21@CGTargetTe

; 12552: 			{
; 12553: 				if ( gObj[aIndex].Type == OBJ_USER )

  0022d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00233	80 7c 0e 50 01	 cmp	 BYTE PTR [esi+ecx+80], 1
  00238	75 15		 jne	 SHORT $LN1@CGTargetTe

; 12554: 					DataSend(aIndex, (LPBYTE)&pAttack, pAttack.h.size);

  0023a	0f b6 55 f1	 movzx	 edx, BYTE PTR _pAttack$[ebp+1]
  0023e	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00241	52		 push	 edx
  00242	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  00245	50		 push	 eax
  00246	51		 push	 ecx
  00247	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0024c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGTargetTe:

; 12555: 
; 12556: 				MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);

  0024f	0f b6 55 f1	 movzx	 edx, BYTE PTR _pAttack$[ebp+1]
  00253	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00259	52		 push	 edx
  0025a	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  0025d	50		 push	 eax
  0025e	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00261	52		 push	 edx
  00262	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 12557: 				gObjTeleportMagicUse(iTargetIndex, x, y);

  00267	8b 45 e8	 mov	 eax, DWORD PTR _y$[ebp]
  0026a	8b 4d ec	 mov	 ecx, DWORD PTR _x$[ebp]
  0026d	50		 push	 eax
  0026e	51		 push	 ecx
  0026f	53		 push	 ebx
  00270	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse

; 12558: 				gObj[aIndex].Mana = (float)usemana;

  00275	db 45 e4	 fild	 DWORD PTR _usemana$222073[ebp]
  00278	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0027e	83 c4 18	 add	 esp, 24			; 00000018H
  00281	d9 9c 16 ec 00
	00 00		 fstp	 DWORD PTR [esi+edx+236]

; 12559: 				gObj[aIndex].BP = usebp;

  00288	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0028d	89 bc 06 04 01
	00 00		 mov	 DWORD PTR [esi+eax+260], edi

; 12560: 				GCManaSend(gObj[aIndex].m_Index, (WORD)gObj[aIndex].Mana, -1, 0, gObj[aIndex].BP);

  00294	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029a	0f b7 8c 3e 04
	01 00 00	 movzx	 ecx, WORD PTR [esi+edi+260]
  002a2	d9 84 3e ec 00
	00 00		 fld	 DWORD PTR [esi+edi+236]
  002a9	51		 push	 ecx
  002aa	6a 00		 push	 0
  002ac	68 ff 00 00 00	 push	 255			; 000000ffH
  002b1	e8 00 00 00 00	 call	 __ftol2_sse
  002b6	0f b7 d0	 movzx	 edx, ax
  002b9	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  002bc	52		 push	 edx
  002bd	50		 push	 eax
  002be	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  002c3	83 c4 14	 add	 esp, 20			; 00000014H
$LN21@CGTargetTe:
  002c6	5e		 pop	 esi
$LN6@CGTargetTe:

; 12561: 
; 12562: 				return;
; 12563: 			}
; 12564: 		}
; 12565: 	}
; 12566: }

  002c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ca	5f		 pop	 edi
  002cb	33 cd		 xor	 ecx, ebp
  002cd	5b		 pop	 ebx
  002ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d3	8b e5		 mov	 esp, ebp
  002d5	5d		 pop	 ebp
  002d6	c3		 ret	 0
?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ENDP ; CGTargetTeleportRecv
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1952 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1953 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0000a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000d	72 02		 jb	 SHORT $LN5@Eos
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@Eos:
  00011	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1954 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CN@HEGKGIOI@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ ; `string'
PUBLIC	??_C@_0BI@IGJGPHCH@Master?5Skill?5Reset?5Fail?$AA@ ; `string'
PUBLIC	??_C@_0DG@CEAHPFGG@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ ; `string'
PUBLIC	??_C@_0EB@LLBOIAD@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ ; `string'
PUBLIC	??_C@_0CJ@HAOMGPEH@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ ; `string'
PUBLIC	??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@ ; `string'
PUBLIC	??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@ ; `string'
PUBLIC	??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@ ; `string'
PUBLIC	??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@ ; `string'
PUBLIC	??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ ; `string'
PUBLIC	??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ ; `string'
PUBLIC	__real@3fe4cccccccccccd
PUBLIC	??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@ ; `string'
PUBLIC	__real@4046800000000000
PUBLIC	??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@ ; `string'
PUBLIC	__real@4039000000000000
PUBLIC	??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@ ; `string'
PUBLIC	__real@4059000000000000
PUBLIC	__real@4024000000000000
PUBLIC	??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@ ; `string'
PUBLIC	??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@ ; `string'
PUBLIC	??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@ ; `string'
PUBLIC	??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@ ; `string'
PUBLIC	??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@ ; `string'
PUBLIC	??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z		; CGUseItemRecv
EXTRN	?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EEEAAG@Z:PROC ; gObjMagicAdd
EXTRN	?IsClass@CItem@@QAEHDHH@Z:PROC			; CItem::IsClass
EXTRN	?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::GetQuestState
EXTRN	?ExMinusStatFruit@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; ExMinusStatFruit
EXTRN	?UseCashItems@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; UseCashItems
EXTRN	?UseExCashPotions@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; UseExCashPotions
EXTRN	?ResetMasterSkill@CMasterLevelSkillTreeSystem@@QAEDHH@Z:PROC ; CMasterLevelSkillTreeSystem::ResetMasterSkill
EXTRN	?CheckMasterSkillPoint@CMasterLevelSkillTreeSystem@@QAEDHH@Z:PROC ; CMasterLevelSkillTreeSystem::CheckMasterSkillPoint
EXTRN	?GDExpandWarehouseSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GDExpandWarehouseSend
EXTRN	?GDExpandInventorySend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GDExpandInventorySend
EXTRN	?gObjItemStrenghtenUp@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjItemStrenghtenUp
EXTRN	?gObjItemDurUp@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC	; gObjItemDurUp
EXTRN	?GDReqPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z:PROC ; CCashItemPeriodSystem::GDReqPeriodItemInsert
EXTRN	?gObjCheckMapBind@@YAHH@Z:PROC			; gObjCheckMapBind
EXTRN	?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMoveCommand::CheckEquipmentToMove
EXTRN	?GetKalimaGateLevel2@CKalimaGate@@QAEHH@Z:PROC	; CKalimaGate::GetKalimaGateLevel2
EXTRN	?gObjUseBlessAndSoulPotion@@YAXHH@Z:PROC	; gObjUseBlessAndSoulPotion
EXTRN	?UseMediumElitePotion@@YAXPAUOBJECTSTRUCT@@HN@Z:PROC ; UseMediumElitePotion
EXTRN	?UsePKRemoveItem@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; UsePKRemoveItem
EXTRN	?gObjUseMinusStatFruit@@YAXHH@Z:PROC		; gObjUseMinusStatFruit
EXTRN	?gObjUsePlusStatFruit@@YAXHH@Z:PROC		; gObjUsePlusStatFruit
EXTRN	?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; gObjUseDrink
EXTRN	?Reset@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z:PROC	; CNewPVP::Reset
EXTRN	?DropRelic@CIllusionTempleEvent@@QAEXEH@Z:PROC	; CIllusionTempleEvent::DropRelic
EXTRN	?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDropQuestItem
EXTRN	?ProcInsert@ItemUpgradeJewels@@QAEXPAUOBJECTSTRUCT@@HH@Z:PROC ; ItemUpgradeJewels::ProcInsert
EXTRN	?IsJewel@ItemUpgradeJewels@@QAE_NH@Z:PROC	; ItemUpgradeJewels::IsJewel
EXTRN	?g_ItemUpgradeJewels@@3VItemUpgradeJewels@@A:BYTE ; g_ItemUpgradeJewels
EXTRN	?gObjItemLevelUpPickAxe@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjItemLevelUpPickAxe
EXTRN	?SmeltItemBySmeltingStone@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z:PROC ; CJewelOfHarmonySystem::SmeltItemBySmeltingStone
EXTRN	?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjAddBuffEffect
EXTRN	?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjSearchItemMinus
;	COMDAT ??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.h
CONST	SEGMENT
??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@ DB 'e'
	DB	'rror-L3 : %s return %s %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HEGKGIOI@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
CONST	SEGMENT
??_C@_0CN@HEGKGIOI@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ DB '['
	DB	'%s] [%s] [MasterLevelSkill Reset] - Passive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IGJGPHCH@Master?5Skill?5Reset?5Fail?$AA@
CONST	SEGMENT
??_C@_0BI@IGJGPHCH@Master?5Skill?5Reset?5Fail?$AA@ DB 'Master Skill Reset'
	DB	' Fail', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@CEAHPFGG@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
CONST	SEGMENT
??_C@_0DG@CEAHPFGG@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ DB '['
	DB	'%s] [%s] [MasterLevelSkill Reset] - Strengthen Skill', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@LLBOIAD@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
CONST	SEGMENT
??_C@_0EB@LLBOIAD@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ DB '['
	DB	'%s] [%s] [MasterLevelSkill Reset] - Enhance Attack/Defense (%'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HAOMGPEH@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
CONST	SEGMENT
??_C@_0CJ@HAOMGPEH@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ DB '['
	DB	'%s] [%s] [MasterLevelSkill Reset] - All', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@
CONST	SEGMENT
??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@ DB 'e'
	DB	'rror-L3 : %s return %s %d %d %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@
CONST	SEGMENT
??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@ DB '['
	DB	'Using Item] [Charm of Move - SavePosition] [%s][%s] Map:[%d] '
	DB	'X:[%d] Y:[%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@ DB '['
	DB	'Using Item] [Charm of Move] [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@
CONST	SEGMENT
??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@ DB '['
	DB	'Using Item] [Charm of Raise] [%s][%s] Die Position Map:[%d] X'
	DB	':[%d] Y:[%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@
CONST	SEGMENT
??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@ DB '[PCS]'
	DB	' Use Free Kalima Ticket Failed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@
CONST	SEGMENT
??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@ DB '[PCS]'
	DB	' Use Free Kalima Ticket Success', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
CONST	SEGMENT
??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ DB '[Castle'
	DB	'Siege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s]['
	DB	'%s]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
CONST	SEGMENT
??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ DB '[Castle'
	DB	'Siege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s]['
	DB	'%s] - (Guild : %s)', 00H			; `string'
CONST	ENDS
;	COMDAT __real@3fe4cccccccccccd
CONST	SEGMENT
__real@3fe4cccccccccccd DQ 03fe4cccccccccccdr	; 0.65
CONST	ENDS
;	COMDAT ??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@ DB '['
	DB	'Using Item] [Return Scroll] [%s][%s] - Current Map:[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@
CONST	SEGMENT
??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@ DB '['
	DB	'%s][%s]Use Compound Potion Lv3 - SD[%d] HP[%f] -> SD[%d] HP[%'
	DB	'f]', 00H					; `string'
CONST	ENDS
;	COMDAT __real@4046800000000000
CONST	SEGMENT
__real@4046800000000000 DQ 04046800000000000r	; 45
CONST	ENDS
;	COMDAT ??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@
CONST	SEGMENT
??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@ DB '['
	DB	'%s][%s]Use Compound Potion Lv2 - SD[%d] HP[%f] -> SD[%d] HP[%'
	DB	'f]', 00H					; `string'
CONST	ENDS
;	COMDAT __real@4039000000000000
CONST	SEGMENT
__real@4039000000000000 DQ 04039000000000000r	; 25
CONST	ENDS
;	COMDAT ??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@
CONST	SEGMENT
??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@ DB '['
	DB	'%s][%s]Use Compound Potion Lv1 - SD[%d] HP[%f] -> SD[%d] HP[%'
	DB	'f]', 00H					; `string'
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT ??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@
CONST	SEGMENT
??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [UseItem] (%s)(%s) Item(%s) Pos(%d)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@
CONST	SEGMENT
??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@ DB 'e'
	DB	'rror-L1 : [%s][%s] CGUseItemRecv()_Pos return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@
CONST	SEGMENT
??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@ DB '['
	DB	'%s][%s] CGUseItemRecv()_Inventory return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@
CONST	SEGMENT
??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@ DB '['
	DB	'%s][%s] CGUseItemRecv() Failed : Transaction == 1, IF_TYPE : '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@
CONST	SEGMENT
??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@ DB '['
	DB	'%s][%s] CGUseItemRecv()_CloseType return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@
CONST	SEGMENT
??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@ DB '['
	DB	'%s][%s] CGUseItemRecv()_If return %s %d', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z
_TEXT	SEGMENT
tv4235 = -280						; size = 4
_iShieldGage$222389 = -276				; size = 4
_iShieldGage$222373 = -276				; size = 4
_iShieldGage$222357 = -276				; size = 4
_tMana$222340 = -276					; size = 4
_citem$ = -276						; size = 4
tv4361 = -272						; size = 4
tv4337 = -272						; size = 4
tv4305 = -272						; size = 4
tv4197 = -272						; size = 4
_skillnumber$222483 = -272				; size = 2
_pMsg$222650 = -272					; size = 4
_pMsg$222642 = -272					; size = 4
_iLevel$222591 = -272					; size = 4
_iDur$222577 = -272					; size = 4
_BuffNumber$222566 = -272				; size = 4
_iShieldGage$222419 = -272				; size = 4
_tLife$222312 = -272					; size = 4
_iItemUseType$ = -272					; size = 4
_lpMsg$GSCopy$ = -268					; size = 4
_iSerial$222576 = -268					; size = 4
_nAddRate$222314 = -268					; size = 4
tv4532 = -266						; size = 2
tv4521 = -266						; size = 2
tv4505 = -266						; size = 2
tv4494 = -266						; size = 2
tv4476 = -266						; size = 2
tv4462 = -266						; size = 2
tv4450 = -266						; size = 2
tv4314 = -266						; size = 2
tv4300 = -266						; size = 2
tv4234 = -266						; size = 2
tv4154 = -266						; size = 2
tv3049 = -266						; size = 2
tv2886 = -266						; size = 2
tv2728 = -266						; size = 2
tv2173 = -266						; size = 2
tv2130 = -266						; size = 2
tv1989 = -266						; size = 2
tv621 = -266						; size = 2
tv539 = -266						; size = 2
tv512 = -266						; size = 2
tv480 = -266						; size = 2
tv435 = -266						; size = 2
tv4891 = -264						; size = 4
tv4784 = -264						; size = 4
tv4529 = -264						; size = 4
tv4527 = -264						; size = 4
tv4518 = -264						; size = 4
tv4515 = -264						; size = 4
tv4502 = -264						; size = 4
tv4500 = -264						; size = 4
tv4491 = -264						; size = 4
tv4489 = -264						; size = 4
tv4473 = -264						; size = 4
tv4471 = -264						; size = 4
tv4459 = -264						; size = 4
tv4457 = -264						; size = 4
tv4447 = -264						; size = 4
tv4445 = -264						; size = 4
tv4311 = -264						; size = 4
tv4309 = -264						; size = 4
tv4296 = -264						; size = 4
tv4294 = -264						; size = 4
tv4231 = -264						; size = 4
tv4228 = -264						; size = 4
tv4150 = -264						; size = 4
tv4138 = -264						; size = 4
tv4119 = -264						; size = 4
tv3957 = -264						; size = 4
tv3516 = -264						; size = 4
tv3513 = -264						; size = 4
tv2994 = -264						; size = 4
tv2865 = -264						; size = 4
tv2856 = -264						; size = 4
_bMove$222613 = -264					; size = 4
_bMove$222606 = -264					; size = 4
_iKalimaGateX$222596 = -264				; size = 4
tv2590 = -264						; size = 4
tv2369 = -264						; size = 4
tv2366 = -264						; size = 4
tv2297 = -264						; size = 4
tv2180 = -264						; size = 4
tv2120 = -264						; size = 4
tv2114 = -264						; size = 4
tv595 = -264						; size = 4
tv582 = -264						; size = 4
tv556 = -264						; size = 4
tv503 = -264						; size = 4
tv497 = -264						; size = 4
tv476 = -264						; size = 4
tv472 = -264						; size = 4
tv368 = -264						; size = 4
_iLevel$222575 = -264					; size = 4
_level$222540 = -264					; size = 4
_addskill$222487 = -264					; size = 4
_iHPGage$222390 = -264					; size = 4
_iHPGage$222374 = -264					; size = 4
_iHPGage$222358 = -264					; size = 4
_szMsg$222620 = -260					; size = 256
_szMsg$222610 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z PROC		; CGUseItemRecv, COMDAT

; 13112: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]

; 13113: 	int pos;
; 13114: 	CItem * citem;
; 13115: 	int iItemUseType = lpMsg->btItemUseType;
; 13116: 
; 13117: 
; 13118: 	// Check User States
; 13119: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type != 3 )

  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00021	8b f7		 mov	 esi, edi
  00023	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00029	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax
  0002f	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00033	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iItemUseType$[ebp], eax
  00039	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  00040	a8 03		 test	 al, 3
  00042	0f 84 99 00 00
	00		 je	 $LN286@CGUseItemR
  00048	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0004d	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00052	0f 84 89 00 00
	00		 je	 $LN286@CGUseItemR

; 13120: 	{
; 13121: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, TRUE, gObj[aIndex].iShield);

  00058	d9 84 0e d8 00
	00 00		 fld	 DWORD PTR [esi+ecx+216]
  0005f	0f b7 94 0e 2c
	01 00 00	 movzx	 edx, WORD PTR [esi+ecx+300]
  00067	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv4532[ebp]
  0006d	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv4532[ebp]
  00074	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00079	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4529[ebp], eax
  0007f	52		 push	 edx
  00080	6a 01		 push	 1
  00082	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4529[ebp]
  00088	68 fd 00 00 00	 push	 253			; 000000fdH
  0008d	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv4527[ebp]
  00093	66 8b 85 f8 fe
	ff ff		 mov	 ax, WORD PTR tv4527[ebp]
  0009a	0f b7 c8	 movzx	 ecx, ax
  0009d	51		 push	 ecx
  0009e	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv4532[ebp]
  000a4	57		 push	 edi
  000a5	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13122: 
; 13123: 		LogAdd("[%s][%s] CGUseItemRecv()_If return %s %d",
; 13124: 			gObj[aIndex].AccountID,
; 13125: 			gObj[aIndex].Name,
; 13126: 			__FILE__, __LINE__);

  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000af	68 46 33 00 00	 push	 13126			; 00003346H
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000b9	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  000bd	52		 push	 edx
  000be	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  000c2	50		 push	 eax
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000ce	83 c4 28	 add	 esp, 40			; 00000028H
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi

; 14467: 	}
; 14468: }

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	33 cd		 xor	 ecx, ebp
  000d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
$LN286@CGUseItemR:

; 13127: 
; 13128: 		return;
; 13129: 	}
; 13130: 
; 13131: 	// Check if User is exiting
; 13132: 	if ( gObj[aIndex].CloseType != -1 )

  000e1	80 7c 0e 0d ff	 cmp	 BYTE PTR [esi+ecx+13], -1
  000e6	0f 84 89 00 00
	00		 je	 $LN285@CGUseItemR

; 13133: 	{
; 13134: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, TRUE, gObj[aIndex].iShield);

  000ec	d9 84 0e d8 00
	00 00		 fld	 DWORD PTR [esi+ecx+216]
  000f3	0f b7 94 0e 2c
	01 00 00	 movzx	 edx, WORD PTR [esi+ecx+300]
  000fb	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv4521[ebp]
  00101	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv4521[ebp]
  00108	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0010d	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4518[ebp], eax
  00113	52		 push	 edx
  00114	6a 01		 push	 1
  00116	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4518[ebp]
  0011c	68 fd 00 00 00	 push	 253			; 000000fdH
  00121	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv4515[ebp]
  00127	66 8b 85 f8 fe
	ff ff		 mov	 ax, WORD PTR tv4515[ebp]
  0012e	0f b7 c8	 movzx	 ecx, ax
  00131	51		 push	 ecx
  00132	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv4521[ebp]
  00138	57		 push	 edi
  00139	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13135: 
; 13136: 		LogAdd("[%s][%s] CGUseItemRecv()_CloseType return %s %d",
; 13137: 			gObj[aIndex].AccountID, 
; 13138: 			gObj[aIndex].Name,
; 13139: 			__FILE__, __LINE__);

  0013e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00143	68 53 33 00 00	 push	 13139			; 00003353H
  00148	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0014d	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  00151	52		 push	 edx
  00152	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00156	50		 push	 eax
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00162	83 c4 28	 add	 esp, 40			; 00000028H
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi

; 14467: 	}
; 14468: }

  00167	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016a	33 cd		 xor	 ecx, ebp
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c3		 ret	 0
$LN285@CGUseItemR:

; 13140: 
; 13141: 		return;
; 13142: 	}
; 13143: 
; 13144: 	// Fix Inventory Pointer
; 13145: 	if ( gObjFixInventoryPointer(aIndex) == false )

  00175	57		 push	 edi
  00176	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0017b	83 c4 04	 add	 esp, 4
  0017e	84 c0		 test	 al, al
  00180	75 18		 jne	 SHORT $LN284@CGUseItemR

; 13146: 	{
; 13147: 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d",
; 13148: 			__FILE__, __LINE__);

  00182	68 5c 33 00 00	 push	 13148			; 0000335cH
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00197	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN284@CGUseItemR:

; 13149: 		//return;
; 13150: 	}
; 13151: 
; 13152: 	// Check if there is a Transaction
; 13153: 	// Dupe
; 13154: 	if ( gObj[aIndex].pTransaction == 1 )

  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a0	80 bc 0e cc 11
	00 00 01	 cmp	 BYTE PTR [esi+ecx+4556], 1
  001a8	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  001ab	75 36		 jne	 SHORT $LN283@CGUseItemR

; 13155: 	{
; 13156: 		LogAddTD("[%s][%s] CGUseItemRecv() Failed : Transaction == 1, IF_TYPE : %d",
; 13157: 			gObj[aIndex].AccountID,
; 13158: 			gObj[aIndex].Name,
; 13159: 			gObj[aIndex].m_IfState.type);

  001ad	8b 90 b8 11 00
	00		 mov	 edx, DWORD PTR [eax+4536]
  001b3	c1 ea 06	 shr	 edx, 6
  001b6	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  001bc	52		 push	 edx
  001bd	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  001c0	51		 push	 ecx
  001c1	83 c0 52	 add	 eax, 82			; 00000052H
  001c4	50		 push	 eax
  001c5	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@
  001ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001d0	83 c4 10	 add	 esp, 16			; 00000010H
  001d3	5f		 pop	 edi
  001d4	5e		 pop	 esi

; 14467: 	}
; 14468: }

  001d5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d8	33 cd		 xor	 ecx, ebp
  001da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c3		 ret	 0
$LN283@CGUseItemR:

; 13160: 
; 13161: 		return;
; 13162: 	}
; 13163: 
; 13164: #if (ENABLETEST_NEWPVP == 1)
; 13165: 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  001e3	50		 push	 eax
  001e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  001e9	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  001ee	85 c0		 test	 eax, eax
  001f0	74 2b		 je	 SHORT $LN282@CGUseItemR

; 13166: 		 GCServerMsgStringSend(lMsg.Get(3428), aIndex, 1);

  001f2	6a 01		 push	 1
  001f4	57		 push	 edi
  001f5	68 64 0d 00 00	 push	 3428			; 00000d64H
  001fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001ff	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00204	50		 push	 eax
  00205	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0020a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020d	5f		 pop	 edi
  0020e	5e		 pop	 esi

; 14467: 	}
; 14468: }

  0020f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00212	33 cd		 xor	 ecx, ebp
  00214	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00219	8b e5		 mov	 esp, ebp
  0021b	5d		 pop	 ebp
  0021c	c3		 ret	 0
$LN282@CGUseItemR:

; 13167: 		 return;
; 13168: 	}
; 13169: #endif
; 13170: 
; 13171: 	// Set Var Pos
; 13172: 	pos = lpMsg->inventoryPos;

  0021d	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00223	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00226	53		 push	 ebx
  00227	0f b6 d8	 movzx	 ebx, al

; 13173: 
; 13174: 	// Check if the pos is in bounds
; 13175: 	if ( pos > MAIN_INVENTORY_SIZE-1 )

  0022a	81 fb cb 00 00
	00		 cmp	 ebx, 203		; 000000cbH
  00230	0f 8e af 00 00
	00		 jle	 $LN281@CGUseItemR

; 13176: 	{
; 13177: 		// error : Location is over the range. %s/%d
; 13178: 		LogAdd(lMsg.Get(MSGGET(1, 241)), __FILE__, __LINE__);

  00236	68 7a 33 00 00	 push	 13178			; 0000337aH
  0023b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00240	68 f1 01 00 00	 push	 497			; 000001f1H
  00245	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0024a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0024f	50		 push	 eax
  00250	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 13179: 
; 13180: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  00256	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv4505[ebp]
  0025c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00261	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  00268	0f b7 94 06 2c
	01 00 00	 movzx	 edx, WORD PTR [esi+eax+300]
  00270	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv4505[ebp]
  00277	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0027c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4502[ebp], eax
  00282	52		 push	 edx
  00283	6a 01		 push	 1
  00285	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4502[ebp]
  0028b	68 fd 00 00 00	 push	 253			; 000000fdH
  00290	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv4500[ebp]
  00296	66 8b 85 f8 fe
	ff ff		 mov	 ax, WORD PTR tv4500[ebp]
  0029d	0f b7 c8	 movzx	 ecx, ax
  002a0	51		 push	 ecx
  002a1	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv4505[ebp]
  002a7	57		 push	 edi
  002a8	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13181: 
; 13182: 		LogAdd("[%s][%s] CGUseItemRecv()_Inventory return %s %d",
; 13183: 			gObj[aIndex].AccountID,
; 13184: 			gObj[aIndex].Name,
; 13185: 			__FILE__, __LINE__);

  002ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b2	68 81 33 00 00	 push	 13185			; 00003381H
  002b7	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  002bc	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  002c0	52		 push	 edx
  002c1	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  002c5	50		 push	 eax
  002c6	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@
  002cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002d1	83 c4 34	 add	 esp, 52			; 00000034H
  002d4	5b		 pop	 ebx
  002d5	5f		 pop	 edi
  002d6	5e		 pop	 esi

; 14467: 	}
; 14468: }

  002d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002da	33 cd		 xor	 ecx, ebp
  002dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e1	8b e5		 mov	 esp, ebp
  002e3	5d		 pop	 ebp
  002e4	c3		 ret	 0
$LN281@CGUseItemR:

; 13186: 
; 13187: 		return;
; 13188: 	}
; 13189: 
; 13190: 
; 13191: 	// check if the item
; 13192: 	// have the same position
; 13193: 	// as the new position
; 13194: 	if ( lpMsg->inventoryPos == lpMsg->invenrotyTarget )

  002e5	3a 41 04	 cmp	 al, BYTE PTR [ecx+4]
  002e8	75 7a		 jne	 SHORT $LN280@CGUseItemR

; 13195: 	{
; 13196: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  002ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ef	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv4494[ebp]
  002f5	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  002fc	0f b7 8c 06 2c
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+300]
  00304	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv4494[ebp]
  0030b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00310	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4491[ebp], eax
  00316	51		 push	 ecx
  00317	6a 01		 push	 1
  00319	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4491[ebp]
  0031f	68 fd 00 00 00	 push	 253			; 000000fdH
  00324	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv4489[ebp]
  0032a	66 8b 95 f8 fe
	ff ff		 mov	 dx, WORD PTR tv4489[ebp]
  00331	0f b7 c2	 movzx	 eax, dx
  00334	50		 push	 eax
  00335	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv4494[ebp]
  0033b	57		 push	 edi
  0033c	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13197: 
; 13198: 		LogAdd("error-L1 : [%s][%s] CGUseItemRecv()_Pos return %s %d",
; 13199: 			gObj[aIndex].AccountID,
; 13200: 			gObj[aIndex].Name,
; 13201: 			__FILE__, __LINE__);

  00341	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00346	68 91 33 00 00	 push	 13201			; 00003391H
  0034b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00350	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00354	51		 push	 ecx
  00355	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00359	52		 push	 edx
  0035a	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@

; 13202: 
; 13203: 		return;

  0035f	e9 7b 2e 00 00	 jmp	 $LN378@CGUseItemR
$LN280@CGUseItemR:

; 13204: 	}
; 13205: 
; 13206: 	// Set Pointer
; 13207: 	citem = &gObj[aIndex].pInventory[pos];

  00364	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0036a	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  00371	8b c3		 mov	 eax, ebx
  00373	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00379	03 c8		 add	 ecx, eax
  0037b	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv4235[ebp], eax
  00381	89 8d ec fe ff
	ff		 mov	 DWORD PTR _citem$[ebp], ecx

; 13208: 
; 13209: 
; 13210: 	// The item is ITEM
; 13211: 	if ( citem->IsItem() )

  00387	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0038c	85 c0		 test	 eax, eax
  0038e	0f 84 d9 2d 00
	00		 je	 $LN279@CGUseItemR

; 13212: 	{
; 13213: 		// Check if item have 0 as Serial
; 13214: 		if ( gObjCheckSerial0ItemList(citem) )

  00394	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  0039a	52		 push	 edx
  0039b	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  003a0	83 c4 04	 add	 esp, 4
  003a3	85 c0		 test	 eax, eax
  003a5	0f 84 aa 00 00
	00		 je	 $LN278@CGUseItemR

; 13215: 		{
; 13216: 			MsgOutput(aIndex, lMsg.Get(MSGGET(13, 26)));

  003ab	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  003b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003b5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003ba	50		 push	 eax
  003bb	57		 push	 edi
  003bc	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 13217: 
; 13218: 			GCReFillSend(aIndex,
; 13219: 					(WORD)gObj[aIndex].Life,
; 13220: 					0xFD,
; 13221: 					1,
; 13222: 					gObj[aIndex].iShield);

  003c1	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv4476[ebp]
  003c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003cc	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  003d3	0f b7 8c 06 2c
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+300]
  003db	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv4476[ebp]
  003e2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003e7	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4473[ebp], eax
  003ed	51		 push	 ecx
  003ee	6a 01		 push	 1
  003f0	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4473[ebp]
  003f6	68 fd 00 00 00	 push	 253			; 000000fdH
  003fb	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv4471[ebp]
  00401	66 8b 95 f8 fe
	ff ff		 mov	 dx, WORD PTR tv4471[ebp]
  00408	0f b7 c2	 movzx	 eax, dx
  0040b	50		 push	 eax
  0040c	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv4476[ebp]
  00412	57		 push	 edi
  00413	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13223: 
; 13224: 
; 13225: 			LogAddTD("[ANTI-HACK][Serial 0 Item] [UseItem] (%s)(%s) Item(%s) Pos(%d)",
; 13226: 				gObj[aIndex].AccountID,
; 13227: 				gObj[aIndex].Name,
; 13228: 				citem->GetName(),
; 13229: 				pos);

  00418	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  0041e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00424	83 c4 1c	 add	 esp, 28			; 0000001cH
  00427	53		 push	 ebx
  00428	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0042d	50		 push	 eax
  0042e	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  00431	52		 push	 edx
  00432	83 c6 52	 add	 esi, 82			; 00000052H
  00435	56		 push	 esi
  00436	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@
  0043b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14268: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00441	83 c4 14	 add	 esp, 20			; 00000014H
  00444	5b		 pop	 ebx
  00445	5f		 pop	 edi
  00446	5e		 pop	 esi

; 14467: 	}
; 14468: }

  00447	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044a	33 cd		 xor	 ecx, ebp
  0044c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00451	8b e5		 mov	 esp, ebp
  00453	5d		 pop	 ebp
  00454	c3		 ret	 0
$LN278@CGUseItemR:

; 13230: 
; 13231: 			return;
; 13232: 		}
; 13233: 
; 13234: 		// Check the item Serial
; 13235: 		if ( gObjInventorySearchSerialNumber(&gObj[aIndex],
; 13236: 												citem->GetNumber()) == FALSE )

  00455	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  0045b	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00460	50		 push	 eax
  00461	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00466	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00469	51		 push	 ecx
  0046a	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  0046f	83 c4 08	 add	 esp, 8
  00472	85 c0		 test	 eax, eax
  00474	75 7a		 jne	 SHORT $LN277@CGUseItemR

; 13237: 		{
; 13238: 			GCReFillSend(aIndex,
; 13239: 					(WORD)gObj[aIndex].Life,
; 13240: 					0xFD,
; 13241: 					1,
; 13242: 					gObj[aIndex].iShield);

  00476	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0047b	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv4462[ebp]
  00481	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  00488	0f b7 94 06 2c
	01 00 00	 movzx	 edx, WORD PTR [esi+eax+300]
  00490	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv4462[ebp]
  00497	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0049c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4459[ebp], eax
  004a2	52		 push	 edx
  004a3	6a 01		 push	 1
  004a5	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4459[ebp]
  004ab	68 fd 00 00 00	 push	 253			; 000000fdH
  004b0	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv4457[ebp]
  004b6	66 8b 85 f8 fe
	ff ff		 mov	 ax, WORD PTR tv4457[ebp]
  004bd	0f b7 c8	 movzx	 ecx, ax
  004c0	51		 push	 ecx
  004c1	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv4462[ebp]
  004c7	57		 push	 edi
  004c8	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13243: 		
; 13244: 			
; 13245: 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d",
; 13246: 				gObj[aIndex].AccountID,
; 13247: 				gObj[aIndex].Name,
; 13248: 				__FILE__, __LINE__);

  004cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004d2	68 c0 33 00 00	 push	 13248			; 000033c0H
  004d7	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  004dc	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  004e0	52		 push	 edx
  004e1	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  004e5	50		 push	 eax
  004e6	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@

; 13249: 
; 13250: 			return;

  004eb	e9 ef 2c 00 00	 jmp	 $LN378@CGUseItemR
$LN277@CGUseItemR:

; 13251: 		}
; 13252: 
; 13253: 		if ( citem->m_serial && !gObjCanItemTouch(&gObj[aIndex], 1) )

  004f0	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  004f6	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  004fa	0f 84 89 00 00
	00		 je	 $LN276@CGUseItemR
  00500	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00506	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00509	6a 01		 push	 1
  0050b	52		 push	 edx
  0050c	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  00511	83 c4 08	 add	 esp, 8
  00514	85 c0		 test	 eax, eax
  00516	75 6b		 jne	 SHORT $LN342@CGUseItemR

; 13254: 		{
; 13255: 			GCReFillSend(aIndex, (WORD)
; 13256: 				gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  00518	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0051d	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv4450[ebp]
  00523	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  0052a	0f b7 8c 06 2c
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+300]
  00532	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv4450[ebp]
  00539	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0053e	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4447[ebp], eax
  00544	51		 push	 ecx
  00545	6a 01		 push	 1
  00547	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4447[ebp]
  0054d	68 fd 00 00 00	 push	 253			; 000000fdH
  00552	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv4445[ebp]
  00558	66 8b 95 f8 fe
	ff ff		 mov	 dx, WORD PTR tv4445[ebp]
  0055f	0f b7 c2	 movzx	 eax, dx
  00562	50		 push	 eax
  00563	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv4450[ebp]
  00569	57		 push	 edi
  0056a	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 14268: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  0056f	83 c4 14	 add	 esp, 20			; 00000014H
  00572	5b		 pop	 ebx
  00573	5f		 pop	 edi
  00574	5e		 pop	 esi

; 14467: 	}
; 14468: }

  00575	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00578	33 cd		 xor	 ecx, ebp
  0057a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0057f	8b e5		 mov	 esp, ebp
  00581	5d		 pop	 ebp
  00582	c3		 ret	 0
$LN342@CGUseItemR:

; 13257: 			return;

  00583	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
$LN276@CGUseItemR:

; 13258: 		}
; 13259: 
; 13260: 		if ( citem->m_Type == ITEMGET(14,0) || // Apple
; 13261: 			 citem->m_Type == ITEMGET(14,1) ||
; 13262: 			 citem->m_Type == ITEMGET(14,2) ||
; 13263: 			 citem->m_Type == ITEMGET(14,3) )

  00589	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  0058d	ba 00 1c 00 00	 mov	 edx, 7168		; 00001c00H
  00592	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4891[ebp], eax
  00598	66 3b c2	 cmp	 ax, dx
  0059b	0f 84 34 29 00
	00		 je	 $LN274@CGUseItemR
  005a1	ba 01 1c 00 00	 mov	 edx, 7169		; 00001c01H
  005a6	66 3b c2	 cmp	 ax, dx
  005a9	0f 84 26 29 00
	00		 je	 $LN274@CGUseItemR
  005af	ba 02 1c 00 00	 mov	 edx, 7170		; 00001c02H
  005b4	66 3b c2	 cmp	 ax, dx
  005b7	0f 84 18 29 00
	00		 je	 $LN274@CGUseItemR
  005bd	ba 03 1c 00 00	 mov	 edx, 7171		; 00001c03H
  005c2	66 3b c2	 cmp	 ax, dx
  005c5	0f 84 0a 29 00
	00		 je	 $LN274@CGUseItemR

; 13340: 			}
; 13341: 		}
; 13342: 		else if (citem->m_Type == ITEMGET(14,4) ||	// Small Mana Potion
; 13343: 				 citem->m_Type == ITEMGET(14,5) ||
; 13344: 				 citem->m_Type == ITEMGET(14,6)  )

  005cb	ba 04 1c 00 00	 mov	 edx, 7172		; 00001c04H
  005d0	66 3b c2	 cmp	 ax, dx
  005d3	0f 84 5a 27 00
	00		 je	 $LN254@CGUseItemR
  005d9	ba 05 1c 00 00	 mov	 edx, 7173		; 00001c05H
  005de	66 3b c2	 cmp	 ax, dx
  005e1	0f 84 4c 27 00
	00		 je	 $LN254@CGUseItemR
  005e7	ba 06 1c 00 00	 mov	 edx, 7174		; 00001c06H
  005ec	66 3b c2	 cmp	 ax, dx
  005ef	0f 84 3e 27 00
	00		 je	 $LN254@CGUseItemR

; 13378: 			}
; 13379: 		}
; 13380: 		else if ( citem->m_Type == ITEMGET(14,38) )	// Small Compound Potion 

  005f5	b9 26 1c 00 00	 mov	 ecx, 7206		; 00001c26H
  005fa	66 3b c1	 cmp	 ax, cx
  005fd	0f 85 25 02 00
	00		 jne	 $LN244@CGUseItemR

; 13381: 		{
; 13382: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 5/100;	// #formula

  00603	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13383: 			int iHPGage = (int)((gObj[aIndex].MaxLife + gObj[aIndex].AddLife) * 10.0f / 100.0f );	// #formula

  00609	db 84 0e 24 01
	00 00		 fild	 DWORD PTR [esi+ecx+292]
  00610	8b 84 0e 34 01
	00 00		 mov	 eax, DWORD PTR [esi+ecx+308]
  00617	03 84 0e 30 01
	00 00		 add	 eax, DWORD PTR [esi+ecx+304]
  0061e	d8 84 0e dc 00
	00 00		 fadd	 DWORD PTR [esi+ecx+220]
  00625	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00628	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0062d	f7 ea		 imul	 edx
  0062f	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4024000000000000
  00635	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  0063b	c1 fa 05	 sar	 edx, 5
  0063e	8b c2		 mov	 eax, edx
  00640	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00643	03 c2		 add	 eax, edx
  00645	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iShieldGage$222357[ebp], eax
  0064b	e8 00 00 00 00	 call	 __ftol2_sse

; 13384: 
; 13385: 			if ( gObj[aIndex].iShield < 0 )

  00650	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00656	83 bc 16 2c 01
	00 00 00	 cmp	 DWORD PTR [esi+edx+300], 0
  0065e	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iHPGage$222358[ebp], eax
  00664	8d 84 16 2c 01
	00 00		 lea	 eax, DWORD PTR [esi+edx+300]
  0066b	7d 06		 jge	 SHORT $LN343@CGUseItemR

; 13386: 				gObj[aIndex].iShield = 0;

  0066d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN343@CGUseItemR:
  00673	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13387: 
; 13388: 			if ( gObj[aIndex].FillLife > 0.0f )

  00679	d9 ee		 fldz
  0067b	d8 9c 0e e4 00
	00 00		 fcomp	 DWORD PTR [esi+ecx+228]
  00682	8d 94 0e e4 00
	00 00		 lea	 edx, DWORD PTR [esi+ecx+228]
  00689	df e0		 fnstsw	 ax
  0068b	f6 c4 05	 test	 ah, 5
  0068e	7a 44		 jp	 SHORT $LN241@CGUseItemR

; 13389: 			{
; 13390: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  00690	d9 84 0e d8 00
	00 00		 fld	 DWORD PTR [esi+ecx+216]
  00697	8d 84 0e d8 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+216]
  0069e	d8 02		 fadd	 DWORD PTR [edx]
  006a0	d9 18		 fstp	 DWORD PTR [eax]

; 13391: 
; 13392: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )

  006a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006a8	db 84 0e 24 01
	00 00		 fild	 DWORD PTR [esi+ecx+292]
  006af	8d 94 0e d8 00
	00 00		 lea	 edx, DWORD PTR [esi+ecx+216]
  006b6	d8 84 0e dc 00
	00 00		 fadd	 DWORD PTR [esi+ecx+220]
  006bd	d9 02		 fld	 DWORD PTR [edx]
  006bf	d8 d9		 fcomp	 ST(1)
  006c1	df e0		 fnstsw	 ax
  006c3	f6 c4 41	 test	 ah, 65			; 00000041H
  006c6	75 0a		 jne	 SHORT $LN360@CGUseItemR

; 13393: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  006c8	d9 1a		 fstp	 DWORD PTR [edx]
  006ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006d0	eb 02		 jmp	 SHORT $LN241@CGUseItemR
$LN360@CGUseItemR:
  006d2	dd d8		 fstp	 ST(0)
$LN241@CGUseItemR:

; 13394: 			}
; 13395: 
; 13396: 			if ( gObj[aIndex].iFillShield > 0 )

  006d4	8b 94 0e 3c 01
	00 00		 mov	 edx, DWORD PTR [esi+ecx+316]
  006db	85 d2		 test	 edx, edx
  006dd	7e 2e		 jle	 SHORT $LN239@CGUseItemR

; 13397: 			{
; 13398: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  006df	01 94 0e 2c 01
	00 00		 add	 DWORD PTR [esi+ecx+300], edx
  006e6	8d 84 0e 2c 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+300]

; 13399: 
; 13400: 				if (  gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield )  )

  006ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006f2	8b 8c 06 34 01
	00 00		 mov	 ecx, DWORD PTR [esi+eax+308]
  006f9	03 8c 06 30 01
	00 00		 add	 ecx, DWORD PTR [esi+eax+304]
  00700	8d 84 06 2c 01
	00 00		 lea	 eax, DWORD PTR [esi+eax+300]
  00707	39 08		 cmp	 DWORD PTR [eax], ecx
  00709	7e 02		 jle	 SHORT $LN239@CGUseItemR

; 13401: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  0070b	89 08		 mov	 DWORD PTR [eax], ecx
$LN239@CGUseItemR:

; 13402: 			}
; 13403: 
; 13404: 			gObj[aIndex].FillLife = (float)iHPGage;

  0070d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00712	db 85 f8 fe ff
	ff		 fild	 DWORD PTR _iHPGage$222358[ebp]

; 13405: 			gObj[aIndex].FillLifeMax = (float)iHPGage;
; 13406: 			gObj[aIndex].FillLifeCount = 4;
; 13407: 			gObj[aIndex].iFillShield = iShieldGage;
; 13408: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 13409: 			gObj[aIndex].iFillShieldCount = 4;
; 13410: 
; 13411: 			GCSendEffectInfo(aIndex, 3);

  00718	6a 03		 push	 3
  0071a	57		 push	 edi
  0071b	d9 9d f0 fe ff
	ff		 fstp	 DWORD PTR tv4305[ebp]
  00721	d9 85 f0 fe ff
	ff		 fld	 DWORD PTR tv4305[ebp]
  00727	d9 94 06 e4 00
	00 00		 fst	 DWORD PTR [esi+eax+228]
  0072e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00734	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iShieldGage$222357[ebp]
  0073a	d9 9c 0e e8 00
	00 00		 fstp	 DWORD PTR [esi+ecx+232]
  00741	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00747	c6 84 16 fb 00
	00 00 04	 mov	 BYTE PTR [esi+edx+251], 4
  0074f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00755	89 84 0e 3c 01
	00 00		 mov	 DWORD PTR [esi+ecx+316], eax
  0075c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00762	89 84 16 38 01
	00 00		 mov	 DWORD PTR [esi+edx+312], eax
  00769	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0076e	c7 84 06 40 01
	00 00 04 00 00
	00		 mov	 DWORD PTR [esi+eax+320], 4
  00779	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 13412: 
; 13413: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  0077e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00784	6a 01		 push	 1
  00786	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00789	53		 push	 ebx
  0078a	52		 push	 edx
  0078b	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00790	83 c4 14	 add	 esp, 20			; 00000014H
  00793	85 c0		 test	 eax, eax
  00795	75 32		 jne	 SHORT $LN238@CGUseItemR

; 13414: 			{
; 13415: 				gObjInventoryItemSet(aIndex, pos, -1);

  00797	68 ff 00 00 00	 push	 255			; 000000ffH
  0079c	53		 push	 ebx
  0079d	57		 push	 edi
  0079e	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13416: 				gObj[aIndex].pInventory[pos].Clear();

  007a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007a8	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  007af	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  007b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  007b8	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13417: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  007bd	6a 01		 push	 1
  007bf	53		 push	 ebx
  007c0	57		 push	 edi
  007c1	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  007c6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN238@CGUseItemR:

; 13418: 			}
; 13419: 
; 13420: 			LogAddTD("[%s][%s]Use Compound Potion Lv1 - SD[%d] HP[%f] -> SD[%d] HP[%f]",
; 13421: 				gObj[aIndex].AccountID, gObj[aIndex].Name, 
; 13422: 				gObj[aIndex].iShield, gObj[aIndex].Life,
; 13423: 				gObj[aIndex].iShield+iShieldGage, (double)(gObj[aIndex].Life+(float)iHPGage));

  007c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007ce	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  007d5	8b 8c 06 2c 01
	00 00		 mov	 ecx, DWORD PTR [esi+eax+300]
  007dc	d8 85 f0 fe ff
	ff		 fadd	 DWORD PTR tv4305[ebp]
  007e2	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iShieldGage$222357[ebp]
  007e8	83 ec 08	 sub	 esp, 8
  007eb	03 d1		 add	 edx, ecx
  007ed	dd 1c 24	 fstp	 QWORD PTR [esp]
  007f0	52		 push	 edx
  007f1	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  007f8	83 ec 08	 sub	 esp, 8
  007fb	dd 1c 24	 fstp	 QWORD PTR [esp]
  007fe	51		 push	 ecx
  007ff	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00803	51		 push	 ecx
  00804	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00808	52		 push	 edx
  00809	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@
  0080e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00814	83 c4 24	 add	 esp, 36			; 00000024H
  00817	5b		 pop	 ebx
  00818	5f		 pop	 edi
  00819	5e		 pop	 esi

; 14467: 	}
; 14468: }

  0081a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081d	33 cd		 xor	 ecx, ebp
  0081f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00824	8b e5		 mov	 esp, ebp
  00826	5d		 pop	 ebp
  00827	c3		 ret	 0
$LN244@CGUseItemR:

; 13424: 		}
; 13425: 		else if ( citem->m_Type == ITEMGET(14,39) )	// Compound Potion 

  00828	b9 27 1c 00 00	 mov	 ecx, 7207		; 00001c27H
  0082d	66 3b c1	 cmp	 ax, cx
  00830	0f 85 27 02 00
	00		 jne	 $LN236@CGUseItemR

; 13426: 		{
; 13427: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 10/100;	// #formula

  00836	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13428: 			int iHPGage = (int)((gObj[aIndex].MaxLife + gObj[aIndex].AddLife) * 25.0f / 100.0f );	// #formula

  0083c	db 84 0e 24 01
	00 00		 fild	 DWORD PTR [esi+ecx+292]
  00843	8b 84 0e 34 01
	00 00		 mov	 eax, DWORD PTR [esi+ecx+308]
  0084a	03 84 0e 30 01
	00 00		 add	 eax, DWORD PTR [esi+ecx+304]
  00851	d8 84 0e dc 00
	00 00		 fadd	 DWORD PTR [esi+ecx+220]
  00858	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  0085b	03 d2		 add	 edx, edx
  0085d	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00862	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4039000000000000
  00868	f7 ea		 imul	 edx
  0086a	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  00870	c1 fa 05	 sar	 edx, 5
  00873	8b c2		 mov	 eax, edx
  00875	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00878	03 c2		 add	 eax, edx
  0087a	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iShieldGage$222373[ebp], eax
  00880	e8 00 00 00 00	 call	 __ftol2_sse

; 13429: 
; 13430: 			if ( gObj[aIndex].iShield < 0 )

  00885	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0088b	83 bc 16 2c 01
	00 00 00	 cmp	 DWORD PTR [esi+edx+300], 0
  00893	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iHPGage$222374[ebp], eax
  00899	8d 84 16 2c 01
	00 00		 lea	 eax, DWORD PTR [esi+edx+300]
  008a0	7d 06		 jge	 SHORT $LN344@CGUseItemR

; 13431: 				gObj[aIndex].iShield = 0;

  008a2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN344@CGUseItemR:
  008a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13432: 
; 13433: 			if ( gObj[aIndex].FillLife > 0.0f )

  008ae	d9 ee		 fldz
  008b0	d8 9c 0e e4 00
	00 00		 fcomp	 DWORD PTR [esi+ecx+228]
  008b7	8d 94 0e e4 00
	00 00		 lea	 edx, DWORD PTR [esi+ecx+228]
  008be	df e0		 fnstsw	 ax
  008c0	f6 c4 05	 test	 ah, 5
  008c3	7a 44		 jp	 SHORT $LN233@CGUseItemR

; 13434: 			{
; 13435: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  008c5	d9 84 0e d8 00
	00 00		 fld	 DWORD PTR [esi+ecx+216]
  008cc	8d 84 0e d8 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+216]
  008d3	d8 02		 fadd	 DWORD PTR [edx]
  008d5	d9 18		 fstp	 DWORD PTR [eax]

; 13436: 
; 13437: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )

  008d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008dd	db 84 0e 24 01
	00 00		 fild	 DWORD PTR [esi+ecx+292]
  008e4	8d 94 0e d8 00
	00 00		 lea	 edx, DWORD PTR [esi+ecx+216]
  008eb	d8 84 0e dc 00
	00 00		 fadd	 DWORD PTR [esi+ecx+220]
  008f2	d9 02		 fld	 DWORD PTR [edx]
  008f4	d8 d9		 fcomp	 ST(1)
  008f6	df e0		 fnstsw	 ax
  008f8	f6 c4 41	 test	 ah, 65			; 00000041H
  008fb	75 0a		 jne	 SHORT $LN363@CGUseItemR

; 13438: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  008fd	d9 1a		 fstp	 DWORD PTR [edx]
  008ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00905	eb 02		 jmp	 SHORT $LN233@CGUseItemR
$LN363@CGUseItemR:
  00907	dd d8		 fstp	 ST(0)
$LN233@CGUseItemR:

; 13439: 			}
; 13440: 
; 13441: 			if ( gObj[aIndex].iFillShield > 0 )

  00909	8b 94 0e 3c 01
	00 00		 mov	 edx, DWORD PTR [esi+ecx+316]
  00910	85 d2		 test	 edx, edx
  00912	7e 2e		 jle	 SHORT $LN231@CGUseItemR

; 13442: 			{
; 13443: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  00914	01 94 0e 2c 01
	00 00		 add	 DWORD PTR [esi+ecx+300], edx
  0091b	8d 84 0e 2c 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+300]

; 13444: 
; 13445: 				if (  gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield )  )

  00922	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00927	8b 8c 06 34 01
	00 00		 mov	 ecx, DWORD PTR [esi+eax+308]
  0092e	03 8c 06 30 01
	00 00		 add	 ecx, DWORD PTR [esi+eax+304]
  00935	8d 84 06 2c 01
	00 00		 lea	 eax, DWORD PTR [esi+eax+300]
  0093c	39 08		 cmp	 DWORD PTR [eax], ecx
  0093e	7e 02		 jle	 SHORT $LN231@CGUseItemR

; 13446: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  00940	89 08		 mov	 DWORD PTR [eax], ecx
$LN231@CGUseItemR:

; 13447: 			}
; 13448: 
; 13449: 			gObj[aIndex].FillLife = (float)iHPGage;

  00942	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00947	db 85 f8 fe ff
	ff		 fild	 DWORD PTR _iHPGage$222374[ebp]

; 13450: 			gObj[aIndex].FillLifeMax = (float)iHPGage;
; 13451: 			gObj[aIndex].FillLifeCount = 4;
; 13452: 			gObj[aIndex].iFillShield = iShieldGage;
; 13453: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 13454: 			gObj[aIndex].iFillShieldCount = 4;
; 13455: 
; 13456: 			GCSendEffectInfo(aIndex, 3);

  0094d	6a 03		 push	 3
  0094f	57		 push	 edi
  00950	d9 9d f0 fe ff
	ff		 fstp	 DWORD PTR tv4337[ebp]
  00956	d9 85 f0 fe ff
	ff		 fld	 DWORD PTR tv4337[ebp]
  0095c	d9 94 06 e4 00
	00 00		 fst	 DWORD PTR [esi+eax+228]
  00963	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00969	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iShieldGage$222373[ebp]
  0096f	d9 9c 0e e8 00
	00 00		 fstp	 DWORD PTR [esi+ecx+232]
  00976	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0097c	c6 84 16 fb 00
	00 00 04	 mov	 BYTE PTR [esi+edx+251], 4
  00984	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0098a	89 84 0e 3c 01
	00 00		 mov	 DWORD PTR [esi+ecx+316], eax
  00991	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00997	89 84 16 38 01
	00 00		 mov	 DWORD PTR [esi+edx+312], eax
  0099e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009a3	c7 84 06 40 01
	00 00 04 00 00
	00		 mov	 DWORD PTR [esi+eax+320], 4
  009ae	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 13457: 
; 13458: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  009b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009b9	6a 01		 push	 1
  009bb	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  009be	53		 push	 ebx
  009bf	52		 push	 edx
  009c0	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  009c5	83 c4 14	 add	 esp, 20			; 00000014H
  009c8	85 c0		 test	 eax, eax
  009ca	75 32		 jne	 SHORT $LN230@CGUseItemR

; 13459: 			{
; 13460: 				gObjInventoryItemSet(aIndex, pos, -1);

  009cc	68 ff 00 00 00	 push	 255			; 000000ffH
  009d1	53		 push	 ebx
  009d2	57		 push	 edi
  009d3	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13461: 				gObj[aIndex].pInventory[pos].Clear();

  009d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009dd	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  009e4	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  009ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  009ed	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13462: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  009f2	6a 01		 push	 1
  009f4	53		 push	 ebx
  009f5	57		 push	 edi
  009f6	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  009fb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN230@CGUseItemR:

; 13463: 			}
; 13464: 
; 13465: 			LogAddTD("[%s][%s]Use Compound Potion Lv2 - SD[%d] HP[%f] -> SD[%d] HP[%f]",
; 13466: 				gObj[aIndex].AccountID, gObj[aIndex].Name, 
; 13467: 				gObj[aIndex].iShield, gObj[aIndex].Life,
; 13468: 				gObj[aIndex].iShield+iShieldGage, (double)(gObj[aIndex].Life+(float)iHPGage));

  009fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a03	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  00a0a	8b 8c 06 2c 01
	00 00		 mov	 ecx, DWORD PTR [esi+eax+300]
  00a11	d8 85 f0 fe ff
	ff		 fadd	 DWORD PTR tv4337[ebp]
  00a17	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iShieldGage$222373[ebp]
  00a1d	83 ec 08	 sub	 esp, 8
  00a20	03 d1		 add	 edx, ecx
  00a22	dd 1c 24	 fstp	 QWORD PTR [esp]
  00a25	52		 push	 edx
  00a26	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  00a2d	83 ec 08	 sub	 esp, 8
  00a30	dd 1c 24	 fstp	 QWORD PTR [esp]
  00a33	51		 push	 ecx
  00a34	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00a38	51		 push	 ecx
  00a39	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00a3d	52		 push	 edx
  00a3e	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@
  00a43	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00a49	83 c4 24	 add	 esp, 36			; 00000024H
  00a4c	5b		 pop	 ebx
  00a4d	5f		 pop	 edi
  00a4e	5e		 pop	 esi

; 14467: 	}
; 14468: }

  00a4f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a52	33 cd		 xor	 ecx, ebp
  00a54	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a59	8b e5		 mov	 esp, ebp
  00a5b	5d		 pop	 ebp
  00a5c	c3		 ret	 0
$LN236@CGUseItemR:

; 13469: 		}
; 13470: 		else if ( citem->m_Type == ITEMGET(14,40) )	// Large Compound Potion 

  00a5d	b9 28 1c 00 00	 mov	 ecx, 7208		; 00001c28H
  00a62	66 3b c1	 cmp	 ax, cx
  00a65	0f 85 29 02 00
	00		 jne	 $LN228@CGUseItemR

; 13471: 		{
; 13472: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 20/100;	// #formula

  00a6b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13473: 			int iHPGage = (int)((gObj[aIndex].MaxLife + gObj[aIndex].AddLife) * 45.0f / 100.0f );	// #formula

  00a71	db 84 0e 24 01
	00 00		 fild	 DWORD PTR [esi+ecx+292]
  00a78	8b 84 0e 34 01
	00 00		 mov	 eax, DWORD PTR [esi+ecx+308]
  00a7f	03 84 0e 30 01
	00 00		 add	 eax, DWORD PTR [esi+ecx+304]
  00a86	d8 84 0e dc 00
	00 00		 fadd	 DWORD PTR [esi+ecx+220]
  00a8d	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00a90	03 d2		 add	 edx, edx
  00a92	03 d2		 add	 edx, edx
  00a94	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4046800000000000
  00a9a	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00a9f	f7 ea		 imul	 edx
  00aa1	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  00aa7	c1 fa 05	 sar	 edx, 5
  00aaa	8b c2		 mov	 eax, edx
  00aac	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00aaf	03 c2		 add	 eax, edx
  00ab1	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iShieldGage$222389[ebp], eax
  00ab7	e8 00 00 00 00	 call	 __ftol2_sse

; 13474: 
; 13475: 			if ( gObj[aIndex].iShield < 0 )

  00abc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ac2	83 bc 16 2c 01
	00 00 00	 cmp	 DWORD PTR [esi+edx+300], 0
  00aca	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iHPGage$222390[ebp], eax
  00ad0	8d 84 16 2c 01
	00 00		 lea	 eax, DWORD PTR [esi+edx+300]
  00ad7	7d 06		 jge	 SHORT $LN345@CGUseItemR

; 13476: 				gObj[aIndex].iShield = 0;

  00ad9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN345@CGUseItemR:
  00adf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13477: 
; 13478: 			if ( gObj[aIndex].FillLife > 0.0f )

  00ae5	d9 ee		 fldz
  00ae7	d8 9c 0e e4 00
	00 00		 fcomp	 DWORD PTR [esi+ecx+228]
  00aee	8d 94 0e e4 00
	00 00		 lea	 edx, DWORD PTR [esi+ecx+228]
  00af5	df e0		 fnstsw	 ax
  00af7	f6 c4 05	 test	 ah, 5
  00afa	7a 44		 jp	 SHORT $LN225@CGUseItemR

; 13479: 			{
; 13480: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  00afc	d9 84 0e d8 00
	00 00		 fld	 DWORD PTR [esi+ecx+216]
  00b03	8d 84 0e d8 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+216]
  00b0a	d8 02		 fadd	 DWORD PTR [edx]
  00b0c	d9 18		 fstp	 DWORD PTR [eax]

; 13481: 
; 13482: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )

  00b0e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b14	db 84 0e 24 01
	00 00		 fild	 DWORD PTR [esi+ecx+292]
  00b1b	8d 94 0e d8 00
	00 00		 lea	 edx, DWORD PTR [esi+ecx+216]
  00b22	d8 84 0e dc 00
	00 00		 fadd	 DWORD PTR [esi+ecx+220]
  00b29	d9 02		 fld	 DWORD PTR [edx]
  00b2b	d8 d9		 fcomp	 ST(1)
  00b2d	df e0		 fnstsw	 ax
  00b2f	f6 c4 41	 test	 ah, 65			; 00000041H
  00b32	75 0a		 jne	 SHORT $LN366@CGUseItemR

; 13483: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  00b34	d9 1a		 fstp	 DWORD PTR [edx]
  00b36	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b3c	eb 02		 jmp	 SHORT $LN225@CGUseItemR
$LN366@CGUseItemR:
  00b3e	dd d8		 fstp	 ST(0)
$LN225@CGUseItemR:

; 13484: 			}
; 13485: 
; 13486: 			if ( gObj[aIndex].iFillShield > 0 )

  00b40	8b 94 0e 3c 01
	00 00		 mov	 edx, DWORD PTR [esi+ecx+316]
  00b47	85 d2		 test	 edx, edx
  00b49	7e 2e		 jle	 SHORT $LN223@CGUseItemR

; 13487: 			{
; 13488: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  00b4b	01 94 0e 2c 01
	00 00		 add	 DWORD PTR [esi+ecx+300], edx
  00b52	8d 84 0e 2c 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+300]

; 13489: 
; 13490: 				if (  gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield )  )

  00b59	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b5e	8b 8c 06 34 01
	00 00		 mov	 ecx, DWORD PTR [esi+eax+308]
  00b65	03 8c 06 30 01
	00 00		 add	 ecx, DWORD PTR [esi+eax+304]
  00b6c	8d 84 06 2c 01
	00 00		 lea	 eax, DWORD PTR [esi+eax+300]
  00b73	39 08		 cmp	 DWORD PTR [eax], ecx
  00b75	7e 02		 jle	 SHORT $LN223@CGUseItemR

; 13491: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  00b77	89 08		 mov	 DWORD PTR [eax], ecx
$LN223@CGUseItemR:

; 13492: 			}
; 13493: 
; 13494: 			gObj[aIndex].FillLife = (float)iHPGage;

  00b79	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b7e	db 85 f8 fe ff
	ff		 fild	 DWORD PTR _iHPGage$222390[ebp]

; 13495: 			gObj[aIndex].FillLifeMax = (float)iHPGage;
; 13496: 			gObj[aIndex].FillLifeCount = 4;
; 13497: 			gObj[aIndex].iFillShield = iShieldGage;
; 13498: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 13499: 			gObj[aIndex].iFillShieldCount = 4;
; 13500: 
; 13501: 			GCSendEffectInfo(aIndex, 3);

  00b84	6a 03		 push	 3
  00b86	57		 push	 edi
  00b87	d9 9d f0 fe ff
	ff		 fstp	 DWORD PTR tv4361[ebp]
  00b8d	d9 85 f0 fe ff
	ff		 fld	 DWORD PTR tv4361[ebp]
  00b93	d9 94 06 e4 00
	00 00		 fst	 DWORD PTR [esi+eax+228]
  00b9a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ba0	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iShieldGage$222389[ebp]
  00ba6	d9 9c 0e e8 00
	00 00		 fstp	 DWORD PTR [esi+ecx+232]
  00bad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bb3	c6 84 16 fb 00
	00 00 04	 mov	 BYTE PTR [esi+edx+251], 4
  00bbb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bc1	89 84 0e 3c 01
	00 00		 mov	 DWORD PTR [esi+ecx+316], eax
  00bc8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bce	89 84 16 38 01
	00 00		 mov	 DWORD PTR [esi+edx+312], eax
  00bd5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bda	c7 84 06 40 01
	00 00 04 00 00
	00		 mov	 DWORD PTR [esi+eax+320], 4
  00be5	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 13502: 
; 13503: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00bea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bf0	6a 01		 push	 1
  00bf2	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00bf5	53		 push	 ebx
  00bf6	52		 push	 edx
  00bf7	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00bfc	83 c4 14	 add	 esp, 20			; 00000014H
  00bff	85 c0		 test	 eax, eax
  00c01	75 32		 jne	 SHORT $LN222@CGUseItemR

; 13504: 			{
; 13505: 				gObjInventoryItemSet(aIndex, pos, -1);

  00c03	68 ff 00 00 00	 push	 255			; 000000ffH
  00c08	53		 push	 ebx
  00c09	57		 push	 edi
  00c0a	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13506: 				gObj[aIndex].pInventory[pos].Clear();

  00c0f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c14	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  00c1b	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  00c21	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c24	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13507: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00c29	6a 01		 push	 1
  00c2b	53		 push	 ebx
  00c2c	57		 push	 edi
  00c2d	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00c32	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN222@CGUseItemR:

; 13508: 			}
; 13509: 
; 13510: 			LogAddTD("[%s][%s]Use Compound Potion Lv3 - SD[%d] HP[%f] -> SD[%d] HP[%f]",
; 13511: 				gObj[aIndex].AccountID, gObj[aIndex].Name, 
; 13512: 				gObj[aIndex].iShield, gObj[aIndex].Life,
; 13513: 				gObj[aIndex].iShield+iShieldGage, (double)(gObj[aIndex].Life+(float)iHPGage));

  00c35	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c3a	d9 85 f0 fe ff
	ff		 fld	 DWORD PTR tv4361[ebp]
  00c40	d8 84 06 d8 00
	00 00		 fadd	 DWORD PTR [esi+eax+216]
  00c47	8b 8c 06 2c 01
	00 00		 mov	 ecx, DWORD PTR [esi+eax+300]
  00c4e	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iShieldGage$222389[ebp]
  00c54	83 ec 08	 sub	 esp, 8
  00c57	dd 1c 24	 fstp	 QWORD PTR [esp]
  00c5a	03 d1		 add	 edx, ecx
  00c5c	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  00c63	52		 push	 edx
  00c64	83 ec 08	 sub	 esp, 8
  00c67	dd 1c 24	 fstp	 QWORD PTR [esp]
  00c6a	51		 push	 ecx
  00c6b	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00c6f	51		 push	 ecx
  00c70	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00c74	52		 push	 edx
  00c75	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@
  00c7a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00c80	83 c4 24	 add	 esp, 36			; 00000024H
  00c83	5b		 pop	 ebx
  00c84	5f		 pop	 edi
  00c85	5e		 pop	 esi

; 14467: 	}
; 14468: }

  00c86	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c89	33 cd		 xor	 ecx, ebp
  00c8b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c90	8b e5		 mov	 esp, ebp
  00c92	5d		 pop	 ebp
  00c93	c3		 ret	 0
$LN228@CGUseItemR:

; 13514: 		}
; 13515: 		else if ( citem->m_Type == ITEMGET(14,35) )

  00c94	b9 23 1c 00 00	 mov	 ecx, 7203		; 00001c23H
  00c99	66 3b c1	 cmp	 ax, cx
  00c9c	75 19		 jne	 SHORT $LN220@CGUseItemR

; 13516: 		{
; 13517: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 25 / 100;	// #formula

  00c9e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ca4	8b 94 0e 34 01
	00 00		 mov	 edx, DWORD PTR [esi+ecx+308]
  00cab	03 94 0e 30 01
	00 00		 add	 edx, DWORD PTR [esi+ecx+304]
  00cb2	6b d2 19	 imul	 edx, 25			; 00000019H

; 13518: 
; 13519: 			if ( gObj[aIndex].iShield < 0 )
; 13520: 				gObj[aIndex].iShield = 0;
; 13521: 
; 13522: 			if ( gObj[aIndex].iFillShield > 0 )
; 13523: 			{
; 13524: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;
; 13525: 
; 13526: 				if ( gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )
; 13527: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 13528: 			}
; 13529: 
; 13530: 			gObj[aIndex].iFillShieldCount = 2;
; 13531: 			gObj[aIndex].iFillShield = iShieldGage;
; 13532: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 13533: 
; 13534: 			GCSendEffectInfo(aIndex, 3);
; 13535: 
; 13536: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )
; 13537: 			{
; 13538: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13539: 				gObj[aIndex].pInventory[pos].Clear();
; 13540: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13541: 			}
; 13542: 		}

  00cb5	eb 48		 jmp	 SHORT $LN398@CGUseItemR
$LN220@CGUseItemR:

; 13543: 		else if ( citem->m_Type == ITEMGET(14,36) )

  00cb7	b9 24 1c 00 00	 mov	 ecx, 7204		; 00001c24H
  00cbc	66 3b c1	 cmp	 ax, cx
  00cbf	75 19		 jne	 SHORT $LN214@CGUseItemR

; 13544: 		{
; 13545: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 35 / 100;	// #formula

  00cc1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cc7	8b 94 0e 34 01
	00 00		 mov	 edx, DWORD PTR [esi+ecx+308]
  00cce	03 94 0e 30 01
	00 00		 add	 edx, DWORD PTR [esi+ecx+304]
  00cd5	6b d2 23	 imul	 edx, 35			; 00000023H

; 13546: 
; 13547: 			if ( gObj[aIndex].iShield < 0 )
; 13548: 				gObj[aIndex].iShield = 0;
; 13549: 
; 13550: 			if ( gObj[aIndex].iFillShield > 0 )
; 13551: 			{
; 13552: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;
; 13553: 
; 13554: 				if ( gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )
; 13555: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 13556: 			}
; 13557: 
; 13558: 			gObj[aIndex].iFillShieldCount = 2;
; 13559: 			gObj[aIndex].iFillShield = iShieldGage;
; 13560: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 13561: 
; 13562: 			GCSendEffectInfo(aIndex, 3);
; 13563: 
; 13564: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )
; 13565: 			{
; 13566: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13567: 				gObj[aIndex].pInventory[pos].Clear();
; 13568: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13569: 			}
; 13570: 		}

  00cd8	eb 25		 jmp	 SHORT $LN398@CGUseItemR
$LN214@CGUseItemR:

; 13571: 		else if ( citem->m_Type == ITEMGET(14,37) )

  00cda	b9 25 1c 00 00	 mov	 ecx, 7205		; 00001c25H
  00cdf	66 3b c1	 cmp	 ax, cx
  00ce2	0f 85 df 00 00
	00		 jne	 $LN208@CGUseItemR

; 13572: 		{
; 13573: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 45 / 100; // #formula

  00ce8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cee	8b 94 0e 34 01
	00 00		 mov	 edx, DWORD PTR [esi+ecx+308]
  00cf5	03 94 0e 30 01
	00 00		 add	 edx, DWORD PTR [esi+ecx+304]
  00cfc	6b d2 2d	 imul	 edx, 45			; 0000002dH
$LN398@CGUseItemR:
  00cff	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00d04	f7 ea		 imul	 edx
  00d06	c1 fa 05	 sar	 edx, 5
  00d09	8b c2		 mov	 eax, edx
  00d0b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00d0e	03 c2		 add	 eax, edx

; 13574: 
; 13575: 			if ( gObj[aIndex].iShield < 0 )

  00d10	83 bc 0e 2c 01
	00 00 00	 cmp	 DWORD PTR [esi+ecx+300], 0
  00d18	8d 94 0e 2c 01
	00 00		 lea	 edx, DWORD PTR [esi+ecx+300]
  00d1f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iShieldGage$222419[ebp], eax
  00d25	7d 0c		 jge	 SHORT $LN207@CGUseItemR

; 13576: 				gObj[aIndex].iShield = 0;

  00d27	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00d2d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN207@CGUseItemR:

; 13577: 
; 13578: 			if ( gObj[aIndex].iFillShield > 0 )

  00d33	8b 94 0e 3c 01
	00 00		 mov	 edx, DWORD PTR [esi+ecx+316]
  00d3a	85 d2		 test	 edx, edx
  00d3c	7e 3b		 jle	 SHORT $LN205@CGUseItemR

; 13579: 			{
; 13580: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  00d3e	01 94 0e 2c 01
	00 00		 add	 DWORD PTR [esi+ecx+300], edx
  00d45	8d 84 0e 2c 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+300]

; 13581: 
; 13582: 				if ( gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )

  00d4c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d52	8b 84 0e 30 01
	00 00		 mov	 eax, DWORD PTR [esi+ecx+304]
  00d59	03 84 0e 34 01
	00 00		 add	 eax, DWORD PTR [esi+ecx+308]
  00d60	8d 94 0e 2c 01
	00 00		 lea	 edx, DWORD PTR [esi+ecx+300]
  00d67	39 02		 cmp	 DWORD PTR [edx], eax
  00d69	7e 08		 jle	 SHORT $LN352@CGUseItemR

; 13583: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  00d6b	89 02		 mov	 DWORD PTR [edx], eax
  00d6d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN352@CGUseItemR:
  00d73	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iShieldGage$222419[ebp]
$LN205@CGUseItemR:

; 13584: 			}
; 13585: 
; 13586: 			gObj[aIndex].iFillShieldCount = 2;

  00d79	c7 84 0e 40 01
	00 00 02 00 00
	00		 mov	 DWORD PTR [esi+ecx+320], 2

; 13587: 			gObj[aIndex].iFillShield = iShieldGage;

  00d84	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d8a	89 84 0e 3c 01
	00 00		 mov	 DWORD PTR [esi+ecx+316], eax

; 13588: 			gObj[aIndex].iFillShieldMax = iShieldGage;

  00d91	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13589: 
; 13590: 			GCSendEffectInfo(aIndex, 3);

  00d97	6a 03		 push	 3
  00d99	57		 push	 edi
  00d9a	89 84 16 38 01
	00 00		 mov	 DWORD PTR [esi+edx+312], eax
  00da1	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 13591: 
; 13592: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00da6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00dab	6a 01		 push	 1
  00dad	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00db0	53		 push	 ebx
  00db1	51		 push	 ecx
  00db2	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00db7	83 c4 14	 add	 esp, 20			; 00000014H
  00dba	85 c0		 test	 eax, eax
  00dbc	0f 85 26 24 00
	00		 jne	 $LN358@CGUseItemR

; 13593: 			{
; 13594: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13595: 				gObj[aIndex].pInventory[pos].Clear();
; 13596: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13597: 			}
; 13598: 		}

  00dc2	e9 5c 13 00 00	 jmp	 $LN391@CGUseItemR
$LN208@CGUseItemR:

; 13599: 		else if ( citem->m_Type == ITEMGET(14,8) ) // Antidote

  00dc7	b9 08 1c 00 00	 mov	 ecx, 7176		; 00001c08H
  00dcc	66 3b c1	 cmp	 ax, cx
  00dcf	0f 85 1f 01 00
	00		 jne	 $LN202@CGUseItemR

; 13600: 		{
; 13601: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00dd5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ddb	6a 01		 push	 1
  00ddd	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00de0	53		 push	 ebx
  00de1	50		 push	 eax
  00de2	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00de7	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dea	85 c0		 test	 eax, eax
  00dec	75 33		 jne	 SHORT $LN201@CGUseItemR

; 13602: 			{
; 13603: 				gObjInventoryItemSet(aIndex, pos, -1);

  00dee	68 ff 00 00 00	 push	 255			; 000000ffH
  00df3	53		 push	 ebx
  00df4	57		 push	 edi
  00df5	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13604: 				gObj[aIndex].pInventory[pos].Clear();

  00dfa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e00	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  00e07	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  00e0d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e10	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13605: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00e15	6a 01		 push	 1
  00e17	53		 push	 ebx
  00e18	57		 push	 edi
  00e19	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00e1e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN201@CGUseItemR:

; 13606: 			}
; 13607: 			
; 13608: 			if ( gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_POISON) == TRUE )

  00e21	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e27	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00e2a	6a 37		 push	 55			; 00000037H
  00e2c	50		 push	 eax
  00e2d	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00e32	83 c4 08	 add	 esp, 8
  00e35	3c 01		 cmp	 al, 1
  00e37	75 43		 jne	 SHORT $LN200@CGUseItemR

; 13609: 			{
; 13610: 				gObjRemoveBuffEffect(&gObj[aIndex],BUFF_POISON);

  00e39	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e3f	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00e42	6a 37		 push	 55			; 00000037H
  00e44	52		 push	 edx
  00e45	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 13611: 				gObj[aIndex].lpAttackObj = NULL;

  00e4a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e4f	c7 84 06 b4 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+1460], 0

; 13612: 				GCMagicCancelSend(&gObj[aIndex],1);

  00e5a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e60	6a 01		 push	 1
  00e62	56		 push	 esi
  00e63	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCMagicCancelSend
  00e68	83 c4 10	 add	 esp, 16			; 00000010H
  00e6b	5b		 pop	 ebx
  00e6c	5f		 pop	 edi
  00e6d	5e		 pop	 esi

; 14467: 	}
; 14468: }

  00e6e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e71	33 cd		 xor	 ecx, ebp
  00e73	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e78	8b e5		 mov	 esp, ebp
  00e7a	5d		 pop	 ebp
  00e7b	c3		 ret	 0
$LN200@CGUseItemR:

; 13613: 			}
; 13614: 			else if ( gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_DEFENSEDOWN) == TRUE )

  00e7c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e82	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00e85	6a 3a		 push	 58			; 0000003aH
  00e87	50		 push	 eax
  00e88	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00e8d	83 c4 08	 add	 esp, 8
  00e90	3c 01		 cmp	 al, 1
  00e92	0f 85 50 23 00
	00		 jne	 $LN358@CGUseItemR

; 13615: 			{
; 13616: 				gObjRemoveBuffEffect(&gObj[aIndex],BUFF_DEFENSEDOWN);

  00e98	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e9e	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00ea1	6a 3a		 push	 58			; 0000003aH
  00ea3	52		 push	 edx
  00ea4	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 13617: 				gObj[aIndex].DelayActionTime = 0;

  00ea9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00eaf	33 c0		 xor	 eax, eax
  00eb1	89 84 0e a4 05
	00 00		 mov	 DWORD PTR [esi+ecx+1444], eax

; 13618: 				gObj[aIndex].DelayLevel = 0;

  00eb8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ebe	88 84 16 a8 05
	00 00		 mov	 BYTE PTR [esi+edx+1448], al

; 13619: 				gObj[aIndex].lpAttackObj = NULL;

  00ec5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ecb	89 84 0e b4 05
	00 00		 mov	 DWORD PTR [esi+ecx+1460], eax

; 13620: 				GCMagicCancelSend(&gObj[aIndex], 7);

  00ed2	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ed8	6a 07		 push	 7
  00eda	56		 push	 esi
  00edb	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCMagicCancelSend
  00ee0	83 c4 10	 add	 esp, 16			; 00000010H
  00ee3	5b		 pop	 ebx
  00ee4	5f		 pop	 edi
  00ee5	5e		 pop	 esi

; 14467: 	}
; 14468: }

  00ee6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ee9	33 cd		 xor	 ecx, ebp
  00eeb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ef0	8b e5		 mov	 esp, ebp
  00ef2	5d		 pop	 ebp
  00ef3	c3		 ret	 0
$LN202@CGUseItemR:

; 13621: 			}
; 13622: 		}
; 13623: 		else if ( citem->m_Type == ITEMGET(14,46) )

  00ef4	b9 2e 1c 00 00	 mov	 ecx, 7214		; 00001c2eH
  00ef9	66 3b c1	 cmp	 ax, cx
  00efc	75 6e		 jne	 SHORT $LN196@CGUseItemR

; 13624: 		{
; 13625: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00efe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f04	6a 01		 push	 1
  00f06	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00f09	53		 push	 ebx
  00f0a	50		 push	 eax
  00f0b	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00f10	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f13	85 c0		 test	 eax, eax
  00f15	75 33		 jne	 SHORT $LN195@CGUseItemR

; 13626: 			{
; 13627: 				gObjInventoryItemSet(aIndex, pos, -1);

  00f17	68 ff 00 00 00	 push	 255			; 000000ffH
  00f1c	53		 push	 ebx
  00f1d	57		 push	 edi
  00f1e	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13628: 				gObj[aIndex].pInventory[pos].Clear();

  00f23	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f29	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  00f30	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  00f36	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f39	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13629: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00f3e	6a 01		 push	 1
  00f40	53		 push	 ebx
  00f41	57		 push	 edi
  00f42	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00f47	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN195@CGUseItemR:

; 13630: 			}
; 13631: 
; 13632: 			gObjAddBuffEffect(&gObj[aIndex],BUFF_JACK_BLESSING);

  00f4a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f50	6a 23		 push	 35			; 00000023H
  00f52	56		 push	 esi
  00f53	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjAddBuffEffect
  00f58	83 c4 08	 add	 esp, 8
  00f5b	5b		 pop	 ebx
  00f5c	5f		 pop	 edi
  00f5d	5e		 pop	 esi

; 14467: 	}
; 14468: }

  00f5e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f61	33 cd		 xor	 ecx, ebp
  00f63	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f68	8b e5		 mov	 esp, ebp
  00f6a	5d		 pop	 ebp
  00f6b	c3		 ret	 0
$LN196@CGUseItemR:

; 13633: 		}
; 13634: 		else if ( citem->m_Type == ITEMGET(14,47) )

  00f6c	b9 2f 1c 00 00	 mov	 ecx, 7215		; 00001c2fH
  00f71	66 3b c1	 cmp	 ax, cx
  00f74	75 6e		 jne	 SHORT $LN193@CGUseItemR

; 13635: 		{
; 13636: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00f76	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f7c	6a 01		 push	 1
  00f7e	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00f81	53		 push	 ebx
  00f82	50		 push	 eax
  00f83	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00f88	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f8b	85 c0		 test	 eax, eax
  00f8d	75 33		 jne	 SHORT $LN192@CGUseItemR

; 13637: 			{
; 13638: 				gObjInventoryItemSet(aIndex, pos, -1);

  00f8f	68 ff 00 00 00	 push	 255			; 000000ffH
  00f94	53		 push	 ebx
  00f95	57		 push	 edi
  00f96	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13639: 				gObj[aIndex].pInventory[pos].Clear();

  00f9b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fa1	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  00fa8	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  00fae	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fb1	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13640: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00fb6	6a 01		 push	 1
  00fb8	53		 push	 ebx
  00fb9	57		 push	 edi
  00fba	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00fbf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN192@CGUseItemR:

; 13641: 			}
; 13642: 
; 13643: 			gObjAddBuffEffect(&gObj[aIndex],BUFF_JACK_WRATH);

  00fc2	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fc8	6a 24		 push	 36			; 00000024H
  00fca	56		 push	 esi
  00fcb	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjAddBuffEffect
  00fd0	83 c4 08	 add	 esp, 8
  00fd3	5b		 pop	 ebx
  00fd4	5f		 pop	 edi
  00fd5	5e		 pop	 esi

; 14467: 	}
; 14468: }

  00fd6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00fd9	33 cd		 xor	 ecx, ebp
  00fdb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fe0	8b e5		 mov	 esp, ebp
  00fe2	5d		 pop	 ebp
  00fe3	c3		 ret	 0
$LN193@CGUseItemR:

; 13644: 		}
; 13645: 		else if ( citem->m_Type == ITEMGET(14,48) )

  00fe4	b9 30 1c 00 00	 mov	 ecx, 7216		; 00001c30H
  00fe9	66 3b c1	 cmp	 ax, cx
  00fec	75 6e		 jne	 SHORT $LN190@CGUseItemR

; 13646: 		{
; 13647: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00fee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ff4	6a 01		 push	 1
  00ff6	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00ff9	53		 push	 ebx
  00ffa	50		 push	 eax
  00ffb	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  01000	83 c4 0c	 add	 esp, 12			; 0000000cH
  01003	85 c0		 test	 eax, eax
  01005	75 33		 jne	 SHORT $LN189@CGUseItemR

; 13648: 			{
; 13649: 				gObjInventoryItemSet(aIndex, pos, -1);

  01007	68 ff 00 00 00	 push	 255			; 000000ffH
  0100c	53		 push	 ebx
  0100d	57		 push	 edi
  0100e	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13650: 				gObj[aIndex].pInventory[pos].Clear();

  01013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01019	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  01020	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  01026	83 c4 0c	 add	 esp, 12			; 0000000cH
  01029	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13651: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  0102e	6a 01		 push	 1
  01030	53		 push	 ebx
  01031	57		 push	 edi
  01032	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN189@CGUseItemR:

; 13652: 			}
; 13653: 
; 13654: 			gObjAddBuffEffect(&gObj[aIndex],BUFF_JACK_CRY);

  0103a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01040	6a 25		 push	 37			; 00000025H
  01042	56		 push	 esi
  01043	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjAddBuffEffect
  01048	83 c4 08	 add	 esp, 8
  0104b	5b		 pop	 ebx
  0104c	5f		 pop	 edi
  0104d	5e		 pop	 esi

; 14467: 	}
; 14468: }

  0104e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01051	33 cd		 xor	 ecx, ebp
  01053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01058	8b e5		 mov	 esp, ebp
  0105a	5d		 pop	 ebp
  0105b	c3		 ret	 0
$LN190@CGUseItemR:

; 13655: 		}
; 13656: 		else if ( citem->m_Type == ITEMGET(14,49) )

  0105c	b9 31 1c 00 00	 mov	 ecx, 7217		; 00001c31H
  01061	66 3b c1	 cmp	 ax, cx
  01064	75 6e		 jne	 SHORT $LN187@CGUseItemR

; 13657: 		{
; 13658: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  01066	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0106c	6a 01		 push	 1
  0106e	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  01071	53		 push	 ebx
  01072	50		 push	 eax
  01073	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  01078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0107b	85 c0		 test	 eax, eax
  0107d	75 33		 jne	 SHORT $LN186@CGUseItemR

; 13659: 			{
; 13660: 				gObjInventoryItemSet(aIndex, pos, -1);

  0107f	68 ff 00 00 00	 push	 255			; 000000ffH
  01084	53		 push	 ebx
  01085	57		 push	 edi
  01086	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13661: 				gObj[aIndex].pInventory[pos].Clear();

  0108b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01091	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  01098	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  0109e	83 c4 0c	 add	 esp, 12			; 0000000cH
  010a1	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13662: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  010a6	6a 01		 push	 1
  010a8	53		 push	 ebx
  010a9	57		 push	 edi
  010aa	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  010af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN186@CGUseItemR:

; 13663: 			}
; 13664: 
; 13665: 			gObjAddBuffEffect(&gObj[aIndex],BUFF_JACK_FOOD);

  010b2	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010b8	6a 26		 push	 38			; 00000026H
  010ba	56		 push	 esi
  010bb	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjAddBuffEffect
  010c0	83 c4 08	 add	 esp, 8
  010c3	5b		 pop	 ebx
  010c4	5f		 pop	 edi
  010c5	5e		 pop	 esi

; 14467: 	}
; 14468: }

  010c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010c9	33 cd		 xor	 ecx, ebp
  010cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010d0	8b e5		 mov	 esp, ebp
  010d2	5d		 pop	 ebp
  010d3	c3		 ret	 0
$LN187@CGUseItemR:

; 13666: 		}
; 13667: 		else if ( citem->m_Type == ITEMGET(14,50) )

  010d4	b9 32 1c 00 00	 mov	 ecx, 7218		; 00001c32H
  010d9	66 3b c1	 cmp	 ax, cx
  010dc	75 6e		 jne	 SHORT $LN184@CGUseItemR

; 13668: 		{
; 13669: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  010de	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010e4	6a 01		 push	 1
  010e6	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  010e9	53		 push	 ebx
  010ea	50		 push	 eax
  010eb	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  010f0	83 c4 0c	 add	 esp, 12			; 0000000cH
  010f3	85 c0		 test	 eax, eax
  010f5	75 33		 jne	 SHORT $LN183@CGUseItemR

; 13670: 			{
; 13671: 				gObjInventoryItemSet(aIndex, pos, -1);

  010f7	68 ff 00 00 00	 push	 255			; 000000ffH
  010fc	53		 push	 ebx
  010fd	57		 push	 edi
  010fe	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13672: 				gObj[aIndex].pInventory[pos].Clear();

  01103	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01109	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  01110	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  01116	83 c4 0c	 add	 esp, 12			; 0000000cH
  01119	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13673: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  0111e	6a 01		 push	 1
  01120	53		 push	 ebx
  01121	57		 push	 edi
  01122	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01127	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN183@CGUseItemR:

; 13674: 			}
; 13675: 
; 13676: 			gObjAddBuffEffect(&gObj[aIndex],BUFF_JACK_DRINK);

  0112a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01130	6a 27		 push	 39			; 00000027H
  01132	56		 push	 esi
  01133	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjAddBuffEffect
  01138	83 c4 08	 add	 esp, 8
  0113b	5b		 pop	 ebx
  0113c	5f		 pop	 edi
  0113d	5e		 pop	 esi

; 14467: 	}
; 14468: }

  0113e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01141	33 cd		 xor	 ecx, ebp
  01143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01148	8b e5		 mov	 esp, ebp
  0114a	5d		 pop	 ebp
  0114b	c3		 ret	 0
$LN184@CGUseItemR:

; 13677: 		}
; 13678: 		else if ( citem->m_Type == ITEMGET(14,63) || citem->m_Type == ITEMGET(14,64) )

  0114c	b9 3f 1c 00 00	 mov	 ecx, 7231		; 00001c3fH
  01151	66 3b c1	 cmp	 ax, cx
  01154	0f 84 af 1a 00
	00		 je	 $LN180@CGUseItemR
  0115a	ba 40 1c 00 00	 mov	 edx, 7232		; 00001c40H
  0115f	66 3b c2	 cmp	 ax, dx
  01162	0f 84 a1 1a 00
	00		 je	 $LN180@CGUseItemR

; 13697: 			}
; 13698: 		}
; 13699: 		else if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonySmeltingItems(citem->m_Type) == TRUE )

  01168	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv4891[ebp]
  0116e	50		 push	 eax
  0116f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  01174	e8 00 00 00 00	 call	 ?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
  01179	83 f8 01	 cmp	 eax, 1
  0117c	0f 85 ca 00 00
	00		 jne	 $LN173@CGUseItemR

; 13700: 		{
; 13701: 			if ( g_kJewelOfHarmonySystem.SmeltItemBySmeltingStone(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  01182	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  01188	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0118c	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  01190	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01195	51		 push	 ecx
  01196	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  01199	52		 push	 edx
  0119a	51		 push	 ecx
  0119b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  011a0	e8 00 00 00 00	 call	 ?SmeltItemBySmeltingStone@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z ; CJewelOfHarmonySystem::SmeltItemBySmeltingStone
  011a5	83 f8 01	 cmp	 eax, 1
  011a8	75 37		 jne	 SHORT $LN172@CGUseItemR

; 13702: 			{
; 13703: 				gObjInventoryItemSet(aIndex, pos, -1);

  011aa	68 ff 00 00 00	 push	 255			; 000000ffH
  011af	53		 push	 ebx
  011b0	57		 push	 edi
  011b1	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13704: 				gObj[aIndex].pInventory[pos].Clear();

  011b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  011bc	8b 8c 16 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4544]
  011c3	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  011c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  011cc	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13705: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);

  011d1	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  011d7	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  011db	51		 push	 ecx

; 13706: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13707: 			}
; 13708: 			else

  011dc	e9 6d 10 00 00	 jmp	 $LN388@CGUseItemR
$LN172@CGUseItemR:

; 13709: 			{
; 13710: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  011e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  011e6	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv4314[ebp]
  011ec	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  011f3	0f b7 94 06 2c
	01 00 00	 movzx	 edx, WORD PTR [esi+eax+300]
  011fb	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv4314[ebp]
  01202	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01207	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4311[ebp], eax
  0120d	52		 push	 edx
  0120e	6a 01		 push	 1
  01210	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4311[ebp]
  01216	68 fd 00 00 00	 push	 253			; 000000fdH
  0121b	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv4309[ebp]
  01221	66 8b 85 f8 fe
	ff ff		 mov	 ax, WORD PTR tv4309[ebp]
  01228	0f b7 c8	 movzx	 ecx, ax
  0122b	51		 push	 ecx
  0122c	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv4314[ebp]
  01232	57		 push	 edi
  01233	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  01238	83 c4 14	 add	 esp, 20			; 00000014H
  0123b	5b		 pop	 ebx
  0123c	5f		 pop	 edi
  0123d	5e		 pop	 esi

; 14467: 	}
; 14468: }

  0123e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01241	33 cd		 xor	 ecx, ebp
  01243	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01248	8b e5		 mov	 esp, ebp
  0124a	5d		 pop	 ebp
  0124b	c3		 ret	 0
$LN173@CGUseItemR:

; 13711: 			}
; 13712: 		}
; 13713: 		else if ( citem->m_Type == ITEMGET(12,30) ) // Pack of Bless

  0124c	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  01252	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  01256	b9 1e 18 00 00	 mov	 ecx, 6174		; 0000181eH
  0125b	66 3b c1	 cmp	 ax, cx
  0125e	0f 85 96 00 00
	00		 jne	 $LN169@CGUseItemR

; 13714: 		{
; 13715: 			if ( gObjItemLevelUpPickAxe(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  01264	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  0126a	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  0126e	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  01272	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01278	52		 push	 edx
  01279	50		 push	 eax
  0127a	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0127d	52		 push	 edx
  0127e	e8 00 00 00 00	 call	 ?gObjItemLevelUpPickAxe@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemLevelUpPickAxe
  01283	83 c4 0c	 add	 esp, 12			; 0000000cH
  01286	83 f8 01	 cmp	 eax, 1

; 13716: 			{
; 13717: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13718: 				gObj[aIndex].pInventory[pos].Clear();
; 13719: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 13720: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13721: 			}
; 13722: 			else

  01289	0f 84 8e 0f 00
	00		 je	 $LN387@CGUseItemR

; 13723: 			{
; 13724: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  0128f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01294	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv4300[ebp]
  0129a	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  012a1	0f b7 8c 06 2c
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+300]
  012a9	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv4300[ebp]
  012b0	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  012b5	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4296[ebp], eax
  012bb	51		 push	 ecx
  012bc	6a 01		 push	 1
  012be	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4296[ebp]
  012c4	68 fd 00 00 00	 push	 253			; 000000fdH
  012c9	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv4294[ebp]
  012cf	66 8b 95 f8 fe
	ff ff		 mov	 dx, WORD PTR tv4294[ebp]
  012d6	0f b7 c2	 movzx	 eax, dx
  012d9	50		 push	 eax
  012da	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv4300[ebp]
  012e0	57		 push	 edi
  012e1	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  012e6	83 c4 14	 add	 esp, 20			; 00000014H
  012e9	5b		 pop	 ebx
  012ea	5f		 pop	 edi
  012eb	5e		 pop	 esi

; 14467: 	}
; 14468: }

  012ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012ef	33 cd		 xor	 ecx, ebp
  012f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012f6	8b e5		 mov	 esp, ebp
  012f8	5d		 pop	 ebp
  012f9	c3		 ret	 0
$LN169@CGUseItemR:

; 13725: 			}
; 13726: 		}
; 13727: #if( ENABLETEST_ITEMUPGRADEJEWELS == 1 )
; 13728: 		else if( g_ItemUpgradeJewels.IsJewel(citem->m_Type) )

  012fa	0f bf c8	 movsx	 ecx, ax
  012fd	51		 push	 ecx
  012fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemUpgradeJewels@@3VItemUpgradeJewels@@A ; g_ItemUpgradeJewels
  01303	e8 00 00 00 00	 call	 ?IsJewel@ItemUpgradeJewels@@QAE_NH@Z ; ItemUpgradeJewels::IsJewel
  01308	84 c0		 test	 al, al
  0130a	74 32		 je	 SHORT $LN165@CGUseItemR

; 13729: 		{
; 13730: 			g_ItemUpgradeJewels.ProcInsert(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget);

  0130c	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  01312	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  01316	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  0131a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01320	52		 push	 edx
  01321	50		 push	 eax
  01322	56		 push	 esi
  01323	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemUpgradeJewels@@3VItemUpgradeJewels@@A ; g_ItemUpgradeJewels
  01328	e8 00 00 00 00	 call	 ?ProcInsert@ItemUpgradeJewels@@QAEXPAUOBJECTSTRUCT@@HH@Z ; ItemUpgradeJewels::ProcInsert
  0132d	5b		 pop	 ebx
  0132e	5f		 pop	 edi
  0132f	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01330	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01333	33 cd		 xor	 ecx, ebp
  01335	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0133a	8b e5		 mov	 esp, ebp
  0133c	5d		 pop	 ebp
  0133d	c3		 ret	 0
$LN165@CGUseItemR:

; 13731: 		}
; 13732: #else
; 13733: 		else if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonyPurity(citem->m_Type) == TRUE )
; 13734: 		{
; 13735: 			if ( g_kJewelOfHarmonySystem.StrengthenItemByJewelOfHarmony(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 13736: 			{
; 13737: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13738: 				gObj[aIndex].pInventory[pos].Clear();
; 13739: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 13740: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13741: 			}
; 13742: 			else
; 13743: 			{
; 13744: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13745: 			}
; 13746: 		}
; 13747: 		else if ( citem->m_Type == ITEMGET(14,13) ) // Jewel Of Bless
; 13748: 		{
; 13749: 			if ( gObjItemLevelUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 13750: 			{
; 13751: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13752: 				gObj[aIndex].pInventory[pos].Clear();
; 13753: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 13754: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13755: 			}
; 13756: 			else
; 13757: 			{
; 13758: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13759: 			}
; 13760: 		}
; 13761: 		else if ( citem->m_Type == ITEMGET(14,14) ) // Jewel Of Soul
; 13762: 		{
; 13763: 			if ( gObjItemRandomLevelUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 13764: 			{
; 13765: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13766: 				gObj[aIndex].pInventory[pos].Clear();
; 13767: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 13768: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13769: 			}
; 13770: 			else
; 13771: 			{
; 13772: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13773: 			}
; 13774: 		}
; 13775: 		else if ( citem->m_Type == ITEMGET(14,16) ) // Jewel Of Life
; 13776: 		{
; 13777: 			if ( gObjItemRandomOption3Up(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 13778: 			{
; 13779: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13780: 				gObj[aIndex].pInventory[pos].Clear();
; 13781: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 13782: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13783: 			}
; 13784: 			else
; 13785: 			{
; 13786: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13787: 			}
; 13788: 		}
; 13789: #endif
; 13790: 		else if ( citem->m_Type >= ITEMGET(15,0) ||
; 13791: 				  citem->m_Type == ITEMGET(12,7) ||
; 13792: 				 (citem->m_Type >= ITEMGET(12,8) && citem->m_Type <= ITEMGET(12,24) ) ||	// Orbs
; 13793: 				  citem->m_Type == ITEMGET(12,35) ||
; 13794: 				  citem->m_Type == ITEMGET(12,44) ||
; 13795: 				  citem->m_Type == ITEMGET(12,45) ||
; 13796: 				  citem->m_Type == ITEMGET(12,46) ||
; 13797: 				  citem->m_Type == ITEMGET(12,47) ||
; 13798: 				  citem->m_Type == ITEMGET(12,48) )

  0133e	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  01344	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  01348	ba 00 1e 00 00	 mov	 edx, 7680		; 00001e00H
  0134d	66 3b c2	 cmp	 ax, dx
  01350	0f 8d 6a 15 00
	00		 jge	 $LN162@CGUseItemR
  01356	ba 07 18 00 00	 mov	 edx, 6151		; 00001807H
  0135b	66 3b c2	 cmp	 ax, dx
  0135e	0f 84 5c 15 00
	00		 je	 $LN162@CGUseItemR
  01364	ba 08 18 00 00	 mov	 edx, 6152		; 00001808H
  01369	66 3b c2	 cmp	 ax, dx
  0136c	7c 0e		 jl	 SHORT $LN161@CGUseItemR
  0136e	ba 18 18 00 00	 mov	 edx, 6168		; 00001818H
  01373	66 3b c2	 cmp	 ax, dx
  01376	0f 8e 44 15 00
	00		 jle	 $LN162@CGUseItemR
$LN161@CGUseItemR:
  0137c	ba 23 18 00 00	 mov	 edx, 6179		; 00001823H
  01381	66 3b c2	 cmp	 ax, dx
  01384	0f 84 36 15 00
	00		 je	 $LN162@CGUseItemR
  0138a	ba 2c 18 00 00	 mov	 edx, 6188		; 0000182cH
  0138f	66 3b c2	 cmp	 ax, dx
  01392	0f 84 28 15 00
	00		 je	 $LN162@CGUseItemR
  01398	ba 2d 18 00 00	 mov	 edx, 6189		; 0000182dH
  0139d	66 3b c2	 cmp	 ax, dx
  013a0	0f 84 1a 15 00
	00		 je	 $LN162@CGUseItemR
  013a6	ba 2e 18 00 00	 mov	 edx, 6190		; 0000182eH
  013ab	66 3b c2	 cmp	 ax, dx
  013ae	0f 84 0c 15 00
	00		 je	 $LN162@CGUseItemR
  013b4	ba 2f 18 00 00	 mov	 edx, 6191		; 0000182fH
  013b9	66 3b c2	 cmp	 ax, dx
  013bc	0f 84 fe 14 00
	00		 je	 $LN162@CGUseItemR
  013c2	ba 30 18 00 00	 mov	 edx, 6192		; 00001830H
  013c7	66 3b c2	 cmp	 ax, dx
  013ca	0f 84 f0 14 00
	00		 je	 $LN162@CGUseItemR

; 13850: 				}
; 13851: 			}
; 13852: 		}
; 13853: 		else if ( citem->m_Type == ITEMGET(14,10) ) // Town Portal Scroll

  013d0	ba 0a 1c 00 00	 mov	 edx, 7178		; 00001c0aH
  013d5	66 3b c2	 cmp	 ax, dx
  013d8	0f 85 3f 03 00
	00		 jne	 $LN149@CGUseItemR

; 13854: 		{
; 13855: 			LogAddTD("[Using Item] [Return Scroll] [%s][%s] - Current Map:[%d]",
; 13856: 				gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].MapNumber);

  013de	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  013e3	0f b6 8c 06 23
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+291]
  013eb	51		 push	 ecx
  013ec	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  013f0	52		 push	 edx
  013f1	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  013f5	50		 push	 eax
  013f6	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@
  013fb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 13857: 
; 13858: 			if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) )

  01401	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01407	8a 84 0e 23 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+291]
  0140e	83 c4 10	 add	 esp, 16			; 00000010H
  01411	3c 34		 cmp	 al, 52			; 00000034H
  01413	74 0d		 je	 SHORT $LN331@CGUseItemR
  01415	3c 0b		 cmp	 al, 11			; 0000000bH
  01417	72 39		 jb	 SHORT $LN346@CGUseItemR
  01419	b2 11		 mov	 dl, 17			; 00000011H
  0141b	3a d0		 cmp	 dl, al
  0141d	1b c9		 sbb	 ecx, ecx
  0141f	41		 inc	 ecx
  01420	74 30		 je	 SHORT $LN346@CGUseItemR
$LN331@CGUseItemR:

; 13859: 			{
; 13860: 				int iBridge = g_BloodCastle.GetBridgeLevel(gObj[aIndex].MapNumber);

  01422	0f b6 c0	 movzx	 eax, al
  01425	50		 push	 eax
  01426	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0142b	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel

; 13861: 				if ( g_BloodCastle.GetCurrentState(iBridge) == 2 )

  01430	50		 push	 eax
  01431	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01436	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState

; 13862: 				{
; 13863: 					g_BloodCastle.SearchUserDropQuestItem(aIndex);

  0143b	57		 push	 edi
  0143c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01441	83 f8 02	 cmp	 eax, 2
  01444	75 07		 jne	 SHORT $LN147@CGUseItemR
  01446	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem

; 13864: 				}
; 13865: 				else

  0144b	eb 05		 jmp	 SHORT $LN346@CGUseItemR
$LN147@CGUseItemR:

; 13866: 				{
; 13867: 					g_BloodCastle.SearchUserDeleteQuestItem(aIndex);

  0144d	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN346@CGUseItemR:

; 13868: 				}
; 13869: 			}
; 13870: 
; 13871: 			if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) )

  01452	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01458	8a 8c 0e 23 01
	00 00		 mov	 cl, BYTE PTR [esi+ecx+291]
  0145f	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  01462	72 15		 jb	 SHORT $LN145@CGUseItemR
  01464	b2 32		 mov	 dl, 50			; 00000032H
  01466	3a d1		 cmp	 dl, cl
  01468	1b c0		 sbb	 eax, eax
  0146a	40		 inc	 eax
  0146b	74 0c		 je	 SHORT $LN145@CGUseItemR

; 13872: 			{
; 13873: 				g_IllusionTemple.DropRelic(gObj[aIndex].MapNumber,aIndex);

  0146d	57		 push	 edi
  0146e	51		 push	 ecx
  0146f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  01474	e8 00 00 00 00	 call	 ?DropRelic@CIllusionTempleEvent@@QAEXEH@Z ; CIllusionTempleEvent::DropRelic
$LN145@CGUseItemR:

; 13874: 			}
; 13875: 
; 13876: 			if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 3 )

  01479	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0147f	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  01486	a8 03		 test	 al, 3
  01488	74 34		 je	 SHORT $LN144@CGUseItemR
  0148a	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0148f	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  01494	75 28		 jne	 SHORT $LN144@CGUseItemR

; 13877: 			{
; 13878: 				gObj[aIndex].TargetShopNumber = -1;

  01496	83 c8 ff	 or	 eax, -1
  01499	66 89 84 0e 3a
	06 00 00	 mov	 WORD PTR [esi+ecx+1594], ax

; 13879: 				gObj[aIndex].m_IfState.type = 0;

  014a1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014a6	81 a4 06 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [esi+eax+4536], -65473 ; ffff003fH

; 13880: 				gObj[aIndex].m_IfState.use = 0;

  014b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014b6	83 a4 06 b8 11
	00 00 fc	 and	 DWORD PTR [esi+eax+4536], -4 ; fffffffcH
$LN144@CGUseItemR:

; 13881: 			}
; 13882: 
; 13883: 			gObjInventoryItemSet(aIndex, pos, -1);

  014be	68 ff 00 00 00	 push	 255			; 000000ffH
  014c3	53		 push	 ebx
  014c4	57		 push	 edi
  014c5	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13884: 			gObj[aIndex].pInventory[pos].Clear();

  014ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014d0	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  014d7	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  014dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  014e0	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13885: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  014e5	6a 01		 push	 1
  014e7	53		 push	 ebx
  014e8	57		 push	 edi
  014e9	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 13886: 
; 13887: 			if ( gObj[aIndex].MapNumber == MAP_INDEX_DEVIAS )

  014ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014f4	8a 84 32 23 01
	00 00		 mov	 al, BYTE PTR [edx+esi+291]
  014fb	03 d6		 add	 edx, esi
  014fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  01500	3c 02		 cmp	 al, 2

; 13888: 			{
; 13889: 				gObjMoveGate(aIndex, 22);

  01502	0f 84 a3 00 00
	00		 je	 $LN334@CGUseItemR

; 13890: 			}
; 13891: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_NORIA )

  01508	3c 03		 cmp	 al, 3

; 13892: 			{
; 13893: 				gObjMoveGate(aIndex, 27);

  0150a	0f 84 bf 00 00
	00		 je	 $LN390@CGUseItemR

; 13894: 			}
; 13895: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_LOSTTOWER )

  01510	3c 04		 cmp	 al, 4
  01512	75 1c		 jne	 SHORT $LN139@CGUseItemR

; 13896: 			{
; 13897: 				gObjMoveGate(aIndex, 42);

  01514	6a 2a		 push	 42			; 0000002aH
  01516	57		 push	 edi
  01517	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0151c	83 c4 08	 add	 esp, 8
  0151f	5b		 pop	 ebx
  01520	5f		 pop	 edi
  01521	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01522	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01525	33 cd		 xor	 ecx, ebp
  01527	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0152c	8b e5		 mov	 esp, ebp
  0152e	5d		 pop	 ebp
  0152f	c3		 ret	 0
$LN139@CGUseItemR:

; 13898: 			}
; 13899: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_ATHLANSE )

  01530	3c 07		 cmp	 al, 7
  01532	75 1c		 jne	 SHORT $LN137@CGUseItemR

; 13900: 			{
; 13901: 				gObjMoveGate(aIndex, 49);

  01534	6a 31		 push	 49			; 00000031H
  01536	57		 push	 edi
  01537	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0153c	83 c4 08	 add	 esp, 8
  0153f	5b		 pop	 ebx
  01540	5f		 pop	 edi
  01541	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01542	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01545	33 cd		 xor	 ecx, ebp
  01547	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0154c	8b e5		 mov	 esp, ebp
  0154e	5d		 pop	 ebp
  0154f	c3		 ret	 0
$LN137@CGUseItemR:

; 13902: 			}
; 13903: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_TARKAN )

  01550	3c 08		 cmp	 al, 8
  01552	75 1c		 jne	 SHORT $LN135@CGUseItemR

; 13904: 			{
; 13905: 				gObjMoveGate(aIndex, 57);

  01554	6a 39		 push	 57			; 00000039H
  01556	57		 push	 edi
  01557	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0155c	83 c4 08	 add	 esp, 8
  0155f	5b		 pop	 ebx
  01560	5f		 pop	 edi
  01561	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01562	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01565	33 cd		 xor	 ecx, ebp
  01567	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0156c	8b e5		 mov	 esp, ebp
  0156e	5d		 pop	 ebp
  0156f	c3		 ret	 0
$LN135@CGUseItemR:

; 13906: 			}
; 13907: 			else if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  01570	3c 34		 cmp	 al, 52			; 00000034H
  01572	74 37		 je	 SHORT $LN334@CGUseItemR
  01574	3c 0b		 cmp	 al, 11			; 0000000bH
  01576	72 0c		 jb	 SHORT $LN347@CGUseItemR
  01578	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  0157d	3a c8		 cmp	 cl, al
  0157f	1b c9		 sbb	 ecx, ecx
  01581	41		 inc	 ecx

; 13908: 			{
; 13909: 				gObjMoveGate(aIndex, 22);

  01582	75 27		 jne	 SHORT $LN334@CGUseItemR
$LN347@CGUseItemR:

; 13910: 			}
; 13911: 			else if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  01584	3c 35		 cmp	 al, 53			; 00000035H
  01586	74 23		 je	 SHORT $LN334@CGUseItemR
  01588	3c 12		 cmp	 al, 18			; 00000012H
  0158a	72 0c		 jb	 SHORT $LN357@CGUseItemR
  0158c	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  01591	3a c8		 cmp	 cl, al
  01593	1b c9		 sbb	 ecx, ecx
  01595	41		 inc	 ecx

; 13912: 			{
; 13913: 				gObjMoveGate(aIndex, 22);

  01596	75 13		 jne	 SHORT $LN334@CGUseItemR
$LN357@CGUseItemR:

; 13914: 			}
; 13915: 			else if ( KALIMA_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  01598	3c 18		 cmp	 al, 24			; 00000018H
  0159a	72 2b		 jb	 SHORT $LN129@CGUseItemR
  0159c	3c 1d		 cmp	 al, 29			; 0000001dH
  0159e	76 0b		 jbe	 SHORT $LN334@CGUseItemR
  015a0	33 c9		 xor	 ecx, ecx
  015a2	3c 24		 cmp	 al, 36			; 00000024H
  015a4	0f 94 c1	 sete	 cl
  015a7	85 c9		 test	 ecx, ecx
  015a9	74 1c		 je	 SHORT $LN129@CGUseItemR
$LN334@CGUseItemR:

; 13916: 			{
; 13917: 				gObjMoveGate(aIndex, 22);

  015ab	6a 16		 push	 22			; 00000016H
  015ad	57		 push	 edi
  015ae	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  015b3	83 c4 08	 add	 esp, 8
  015b6	5b		 pop	 ebx
  015b7	5f		 pop	 edi
  015b8	5e		 pop	 esi

; 14467: 	}
; 14468: }

  015b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015bc	33 cd		 xor	 ecx, ebp
  015be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015c3	8b e5		 mov	 esp, ebp
  015c5	5d		 pop	 ebp
  015c6	c3		 ret	 0
$LN129@CGUseItemR:

; 13918: 			}
; 13919: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_AIDA )

  015c7	3c 21		 cmp	 al, 33			; 00000021H

; 13920: 			{
; 13921: 				gObjMoveGate(aIndex, 27);

  015c9	74 04		 je	 SHORT $LN390@CGUseItemR

; 13922: 			}
; 13923: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE )

  015cb	3c 22		 cmp	 al, 34			; 00000022H
  015cd	75 1c		 jne	 SHORT $LN125@CGUseItemR
$LN390@CGUseItemR:

; 13924: 			{
; 13925: 				gObjMoveGate(aIndex, 27);

  015cf	6a 1b		 push	 27			; 0000001bH
  015d1	57		 push	 edi
  015d2	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  015d7	83 c4 08	 add	 esp, 8
  015da	5b		 pop	 ebx
  015db	5f		 pop	 edi
  015dc	5e		 pop	 esi

; 14467: 	}
; 14468: }

  015dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015e0	33 cd		 xor	 ecx, ebp
  015e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015e7	8b e5		 mov	 esp, ebp
  015e9	5d		 pop	 ebp
  015ea	c3		 ret	 0
$LN125@CGUseItemR:

; 13926: 			}
; 13927: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_ELBELAND )

  015eb	3c 33		 cmp	 al, 51			; 00000033H
  015ed	75 1f		 jne	 SHORT $LN123@CGUseItemR

; 13928: 			{
; 13929: 				gObjMoveGate(aIndex,267);

  015ef	68 0b 01 00 00	 push	 267			; 0000010bH
  015f4	57		 push	 edi
  015f5	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  015fa	83 c4 08	 add	 esp, 8
  015fd	5b		 pop	 ebx
  015fe	5f		 pop	 edi
  015ff	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01600	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01603	33 cd		 xor	 ecx, ebp
  01605	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0160a	8b e5		 mov	 esp, ebp
  0160c	5d		 pop	 ebp
  0160d	c3		 ret	 0
$LN123@CGUseItemR:

; 13930: 			}
; 13931: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_SWAMPOFCALMNESS )

  0160e	3c 38		 cmp	 al, 56			; 00000038H
  01610	75 1f		 jne	 SHORT $LN121@CGUseItemR

; 13932: 			{
; 13933: 				gObjMoveGate(aIndex,273);

  01612	68 11 01 00 00	 push	 273			; 00000111H
  01617	57		 push	 edi
  01618	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0161d	83 c4 08	 add	 esp, 8
  01620	5b		 pop	 ebx
  01621	5f		 pop	 edi
  01622	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01623	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01626	33 cd		 xor	 ecx, ebp
  01628	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0162d	8b e5		 mov	 esp, ebp
  0162f	5d		 pop	 ebp
  01630	c3		 ret	 0
$LN121@CGUseItemR:

; 13934: 			}
; 13935: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_RAKLION )

  01631	3c 39		 cmp	 al, 57			; 00000039H
  01633	75 1f		 jne	 SHORT $LN119@CGUseItemR

; 13936: 			{
; 13937: 				gObjMoveGate(aIndex,286);

  01635	68 1e 01 00 00	 push	 286			; 0000011eH
  0163a	57		 push	 edi
  0163b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  01640	83 c4 08	 add	 esp, 8
  01643	5b		 pop	 ebx
  01644	5f		 pop	 edi
  01645	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01646	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01649	33 cd		 xor	 ecx, ebp
  0164b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01650	8b e5		 mov	 esp, ebp
  01652	5d		 pop	 ebp
  01653	c3		 ret	 0
$LN119@CGUseItemR:

; 13938: 			}
; 13939: #if (ENABLETEST_NEWPVP == 1)
; 13940: 			else if (g_NewPVP.IsVulcanusMap(gObj[aIndex].MapNumber))

  01654	3c 3f		 cmp	 al, 63			; 0000003fH
  01656	75 1f		 jne	 SHORT $LN117@CGUseItemR

; 13941: 			{
; 13942: 				gObjMoveGate(aIndex, 294);

  01658	68 26 01 00 00	 push	 294			; 00000126H
  0165d	57		 push	 edi
  0165e	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  01663	83 c4 08	 add	 esp, 8
  01666	5b		 pop	 ebx
  01667	5f		 pop	 edi
  01668	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01669	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0166c	33 cd		 xor	 ecx, ebp
  0166e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01673	8b e5		 mov	 esp, ebp
  01675	5d		 pop	 ebp
  01676	c3		 ret	 0
$LN117@CGUseItemR:

; 13943: 			}
; 13944: 			else if (g_NewPVP.IsPKFieldMap(gObj[aIndex].MapNumber))

  01677	3c 40		 cmp	 al, 64			; 00000040H
  01679	75 27		 jne	 SHORT $LN115@CGUseItemR

; 13945: 			{
; 13946: 				g_NewPVP.Reset(gObj[aIndex]);

  0167b	52		 push	 edx
  0167c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  01681	e8 00 00 00 00	 call	 ?Reset@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z ; CNewPVP::Reset
$LN113@CGUseItemR:

; 13947: 				gObjMoveGate(aIndex, 17);

  01686	6a 11		 push	 17			; 00000011H
  01688	57		 push	 edi
  01689	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0168e	83 c4 08	 add	 esp, 8
  01691	5b		 pop	 ebx
  01692	5f		 pop	 edi
  01693	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01694	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01697	33 cd		 xor	 ecx, ebp
  01699	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0169e	8b e5		 mov	 esp, ebp
  016a0	5d		 pop	 ebp
  016a1	c3		 ret	 0
$LN115@CGUseItemR:

; 13948: 			}
; 13949: #endif
; 13950: #if (GS_CASTLE == 1)
; 13951: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE )

  016a2	3c 1e		 cmp	 al, 30			; 0000001eH
  016a4	75 e0		 jne	 SHORT $LN113@CGUseItemR

; 13952: 			{
; 13953: 				if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)

  016a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  016ab	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  016b0	83 f8 07	 cmp	 eax, 7
  016b3	75 2c		 jne	 SHORT $LN112@CGUseItemR

; 13954: 				{
; 13955: 					if( gObj[aIndex].m_btCsJoinSide == 1 )

  016b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016bb	80 bc 16 5a 20
	00 00 01	 cmp	 BYTE PTR [esi+edx+8282], 1
  016c3	75 3c		 jne	 SHORT $LN111@CGUseItemR
$LN107@CGUseItemR:

; 13967: 					{
; 13968: 						gObjMoveGate(aIndex,101);

  016c5	6a 65		 push	 101			; 00000065H
  016c7	57		 push	 edi
  016c8	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  016cd	83 c4 08	 add	 esp, 8
  016d0	5b		 pop	 ebx
  016d1	5f		 pop	 edi
  016d2	5e		 pop	 esi

; 14467: 	}
; 14468: }

  016d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016d6	33 cd		 xor	 ecx, ebp
  016d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  016dd	8b e5		 mov	 esp, ebp
  016df	5d		 pop	 ebp
  016e0	c3		 ret	 0
$LN112@CGUseItemR:

; 13956: 					{
; 13957: 						gObjMoveGate(aIndex,101);
; 13958: 					}
; 13959: 					else
; 13960: 					{
; 13961: 						gObjMoveGate(aIndex,100);
; 13962: 					}
; 13963: 				}
; 13964: 				else
; 13965: 				{
; 13966: 					if( g_CastleSiege.CheckCastleOwnerMember(aIndex) == TRUE || g_CastleSiege.CheckCastleOwnerUnionMember(aIndex) == TRUE)

  016e1	57		 push	 edi
  016e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  016e7	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  016ec	83 f8 01	 cmp	 eax, 1
  016ef	74 d4		 je	 SHORT $LN107@CGUseItemR
  016f1	57		 push	 edi
  016f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  016f7	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
  016fc	83 f8 01	 cmp	 eax, 1
  016ff	74 c4		 je	 SHORT $LN107@CGUseItemR
$LN111@CGUseItemR:

; 13969: 					}
; 13970: 					else
; 13971: 					{
; 13972: 						gObjMoveGate(aIndex,100);

  01701	6a 64		 push	 100			; 00000064H
  01703	57		 push	 edi
  01704	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  01709	83 c4 08	 add	 esp, 8
  0170c	5b		 pop	 ebx
  0170d	5f		 pop	 edi
  0170e	5e		 pop	 esi

; 14467: 	}
; 14468: }

  0170f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01712	33 cd		 xor	 ecx, ebp
  01714	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01719	8b e5		 mov	 esp, ebp
  0171b	5d		 pop	 ebp
  0171c	c3		 ret	 0
$LN149@CGUseItemR:

; 13973: 					}
; 13974: 				}
; 13975: 			}
; 13976: #endif
; 13977: 			else
; 13978: 			{
; 13979: 				gObjMoveGate(aIndex, 17);
; 13980: 			}
; 13981: 		}
; 13982: 		else if ( citem->m_Type == ITEMGET(14,9) ) // Ale

  0171d	ba 09 1c 00 00	 mov	 edx, 7177		; 00001c09H
  01722	66 3b c2	 cmp	 ax, dx
  01725	75 63		 jne	 SHORT $LN103@CGUseItemR

; 13983: 		{
; 13984: 			int level = citem->m_Level;

  01727	8b c1		 mov	 eax, ecx
  01729	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]

; 13985: 
; 13986: 			gObjInventoryItemSet(aIndex, pos, -1);

  0172d	68 ff 00 00 00	 push	 255			; 000000ffH
  01732	53		 push	 ebx
  01733	57		 push	 edi
  01734	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _level$222540[ebp], ecx
  0173a	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13987: 			gObj[aIndex].pInventory[pos].Clear();

  0173f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01745	8b 8c 16 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4544]
  0174c	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  01752	83 c4 0c	 add	 esp, 12			; 0000000cH
  01755	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13988: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  0175a	6a 01		 push	 1
  0175c	53		 push	 ebx
  0175d	57		 push	 edi
  0175e	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 13989: 			gObjUseDrink(&gObj[aIndex], level);

  01763	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _level$222540[ebp]
  01769	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0176f	50		 push	 eax
  01770	56		 push	 esi
  01771	e8 00 00 00 00	 call	 ?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjUseDrink
  01776	83 c4 14	 add	 esp, 20			; 00000014H
  01779	5b		 pop	 ebx
  0177a	5f		 pop	 edi
  0177b	5e		 pop	 esi

; 14467: 	}
; 14468: }

  0177c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0177f	33 cd		 xor	 ecx, ebp
  01781	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01786	8b e5		 mov	 esp, ebp
  01788	5d		 pop	 ebp
  01789	c3		 ret	 0
$LN103@CGUseItemR:

; 13990: 		}
; 13991: 		else if ( citem->m_Type == ITEMGET(14,20) ) // Remedy of Love

  0178a	ba 14 1c 00 00	 mov	 edx, 7188		; 00001c14H
  0178f	66 3b c2	 cmp	 ax, dx
  01792	75 5c		 jne	 SHORT $LN101@CGUseItemR

; 13992: 		{
; 13993: 			if( citem->m_Level == 0 )

  01794	66 83 79 08 00	 cmp	 WORD PTR [ecx+8], 0
  01799	0f 85 49 1a 00
	00		 jne	 $LN358@CGUseItemR

; 13994: 			{
; 13995: 				gObjInventoryItemSet(aIndex, pos, -1);

  0179f	68 ff 00 00 00	 push	 255			; 000000ffH
  017a4	53		 push	 ebx
  017a5	57		 push	 edi
  017a6	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13996: 				gObj[aIndex].pInventory[pos].Clear();

  017ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  017b0	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  017b7	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  017bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  017c0	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13997: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  017c5	6a 01		 push	 1
  017c7	53		 push	 ebx
  017c8	57		 push	 edi
  017c9	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 13998: 				gObjUseDrink(&gObj[aIndex], 2);

  017ce	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  017d4	6a 02		 push	 2
  017d6	56		 push	 esi
  017d7	e8 00 00 00 00	 call	 ?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjUseDrink
  017dc	83 c4 14	 add	 esp, 20			; 00000014H
  017df	5b		 pop	 ebx
  017e0	5f		 pop	 edi
  017e1	5e		 pop	 esi

; 14467: 	}
; 14468: }

  017e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017e5	33 cd		 xor	 ecx, ebp
  017e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017ec	8b e5		 mov	 esp, ebp
  017ee	5d		 pop	 ebp
  017ef	c3		 ret	 0
$LN101@CGUseItemR:

; 13999: 			}
; 14000: 		}
; 14001: 		else if ( citem->m_Type == ITEMGET(13,15) ) // Fruits

  017f0	ba 0f 1a 00 00	 mov	 edx, 6671		; 00001a0fH
  017f5	66 3b c2	 cmp	 ax, dx
  017f8	75 49		 jne	 SHORT $LN98@CGUseItemR

; 14002: 		{
; 14003: 			if ( iItemUseType == 0 )

  017fa	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iItemUseType$[ebp]
  01800	85 c0		 test	 eax, eax
  01802	75 1b		 jne	 SHORT $LN97@CGUseItemR

; 14004: 			{
; 14005: 				gObjUsePlusStatFruit(aIndex, pos);

  01804	53		 push	 ebx
  01805	57		 push	 edi
  01806	e8 00 00 00 00	 call	 ?gObjUsePlusStatFruit@@YAXHH@Z ; gObjUsePlusStatFruit
  0180b	83 c4 08	 add	 esp, 8
  0180e	5b		 pop	 ebx
  0180f	5f		 pop	 edi
  01810	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01811	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01814	33 cd		 xor	 ecx, ebp
  01816	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0181b	8b e5		 mov	 esp, ebp
  0181d	5d		 pop	 ebp
  0181e	c3		 ret	 0
$LN97@CGUseItemR:

; 14006: 			}
; 14007: 			else if ( iItemUseType == 1 )

  0181f	83 f8 01	 cmp	 eax, 1
  01822	0f 85 c0 19 00
	00		 jne	 $LN358@CGUseItemR

; 14008: 			{
; 14009: 				gObjUseMinusStatFruit(aIndex, pos);

  01828	53		 push	 ebx
  01829	57		 push	 edi
  0182a	e8 00 00 00 00	 call	 ?gObjUseMinusStatFruit@@YAXHH@Z ; gObjUseMinusStatFruit
  0182f	83 c4 08	 add	 esp, 8
  01832	5b		 pop	 ebx
  01833	5f		 pop	 edi
  01834	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01835	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01838	33 cd		 xor	 ecx, ebp
  0183a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0183f	8b e5		 mov	 esp, ebp
  01841	5d		 pop	 ebp
  01842	c3		 ret	 0
$LN98@CGUseItemR:

; 14010: 			}
; 14011: 		}
; 14012: 		else if ( citem->m_Type == ITEMGET(13,54) ||
; 14013: 				  citem->m_Type == ITEMGET(13,55) ||
; 14014: 				  citem->m_Type == ITEMGET(13,56) ||
; 14015: 				  citem->m_Type == ITEMGET(13,57) ||
; 14016: 				  citem->m_Type == ITEMGET(13,58) )

  01843	b9 36 1a 00 00	 mov	 ecx, 6710		; 00001a36H
  01848	66 3b c1	 cmp	 ax, cx
  0184b	0f 84 4e 10 00
	00		 je	 $LN92@CGUseItemR
  01851	ba 37 1a 00 00	 mov	 edx, 6711		; 00001a37H
  01856	66 3b c2	 cmp	 ax, dx
  01859	0f 84 40 10 00
	00		 je	 $LN92@CGUseItemR
  0185f	b9 38 1a 00 00	 mov	 ecx, 6712		; 00001a38H
  01864	66 3b c1	 cmp	 ax, cx
  01867	0f 84 32 10 00
	00		 je	 $LN92@CGUseItemR
  0186d	ba 39 1a 00 00	 mov	 edx, 6713		; 00001a39H
  01872	66 3b c2	 cmp	 ax, dx
  01875	0f 84 24 10 00
	00		 je	 $LN92@CGUseItemR
  0187b	b9 3a 1a 00 00	 mov	 ecx, 6714		; 00001a3aH
  01880	66 3b c1	 cmp	 ax, cx
  01883	0f 84 16 10 00
	00		 je	 $LN92@CGUseItemR

; 14019: 		}
; 14020: 		else if( citem->m_Type == ITEMGET(14,78) ||
; 14021: 				 citem->m_Type == ITEMGET(14,79) ||
; 14022: 				 citem->m_Type == ITEMGET(14,80) ||
; 14023: 				 citem->m_Type == ITEMGET(14,81) ||
; 14024: 				 citem->m_Type == ITEMGET(14,82) )

  01889	ba 4e 1c 00 00	 mov	 edx, 7246		; 00001c4eH
  0188e	66 3b c2	 cmp	 ax, dx
  01891	0f 84 e7 0f 00
	00		 je	 $LN89@CGUseItemR
  01897	b9 4f 1c 00 00	 mov	 ecx, 7247		; 00001c4fH
  0189c	66 3b c1	 cmp	 ax, cx
  0189f	0f 84 d9 0f 00
	00		 je	 $LN89@CGUseItemR
  018a5	ba 50 1c 00 00	 mov	 edx, 7248		; 00001c50H
  018aa	66 3b c2	 cmp	 ax, dx
  018ad	0f 84 cb 0f 00
	00		 je	 $LN89@CGUseItemR
  018b3	b9 51 1c 00 00	 mov	 ecx, 7249		; 00001c51H
  018b8	66 3b c1	 cmp	 ax, cx
  018bb	0f 84 bd 0f 00
	00		 je	 $LN89@CGUseItemR
  018c1	ba 52 1c 00 00	 mov	 edx, 7250		; 00001c52H
  018c6	66 3b c2	 cmp	 ax, dx
  018c9	0f 84 af 0f 00
	00		 je	 $LN89@CGUseItemR

; 14027: 		}
; 14028: 		else if( citem->m_Type == ITEMGET(14,72) )

  018cf	b9 48 1c 00 00	 mov	 ecx, 7240		; 00001c48H
  018d4	66 3b c1	 cmp	 ax, cx
  018d7	75 21		 jne	 SHORT $LN87@CGUseItemR

; 14029: 		{
; 14030: 			UsePKRemoveItem(&gObj[aIndex],pos);

  018d9	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018df	53		 push	 ebx
  018e0	56		 push	 esi
  018e1	e8 00 00 00 00	 call	 ?UsePKRemoveItem@@YAXPAUOBJECTSTRUCT@@H@Z ; UsePKRemoveItem
  018e6	83 c4 08	 add	 esp, 8
  018e9	5b		 pop	 ebx
  018ea	5f		 pop	 edi
  018eb	5e		 pop	 esi

; 14467: 	}
; 14468: }

  018ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  018ef	33 cd		 xor	 ecx, ebp
  018f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  018f6	8b e5		 mov	 esp, ebp
  018f8	5d		 pop	 ebp
  018f9	c3		 ret	 0
$LN87@CGUseItemR:

; 14031: 		}
; 14032: 		else if( citem->m_Type == ITEMGET(14,70) || citem->m_Type == ITEMGET(14,71) )

  018fa	b9 46 1c 00 00	 mov	 ecx, 7238		; 00001c46H
  018ff	66 3b c1	 cmp	 ax, cx
  01902	0f 84 55 0f 00
	00		 je	 $LN84@CGUseItemR
  01908	ba 47 1c 00 00	 mov	 edx, 7239		; 00001c47H
  0190d	66 3b c2	 cmp	 ax, dx
  01910	0f 84 47 0f 00
	00		 je	 $LN84@CGUseItemR

; 14035: 		}
; 14036: 		else if( citem->m_Type == ITEMGET(14,94) )

  01916	b9 5e 1c 00 00	 mov	 ecx, 7262		; 00001c5eH
  0191b	66 3b c1	 cmp	 ax, cx
  0191e	75 2d		 jne	 SHORT $LN82@CGUseItemR

; 14037: 		{
; 14038: 			UseMediumElitePotion(&gObj[aIndex],pos,(double)0.65);

  01920	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe4cccccccccccd
  01926	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0192c	83 ec 08	 sub	 esp, 8
  0192f	dd 1c 24	 fstp	 QWORD PTR [esp]
  01932	53		 push	 ebx
  01933	56		 push	 esi
  01934	e8 00 00 00 00	 call	 ?UseMediumElitePotion@@YAXPAUOBJECTSTRUCT@@HN@Z ; UseMediumElitePotion
  01939	83 c4 10	 add	 esp, 16			; 00000010H
  0193c	5b		 pop	 ebx
  0193d	5f		 pop	 edi
  0193e	5e		 pop	 esi

; 14467: 	}
; 14468: }

  0193f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01942	33 cd		 xor	 ecx, ebp
  01944	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01949	8b e5		 mov	 esp, ebp
  0194b	5d		 pop	 ebp
  0194c	c3		 ret	 0
$LN82@CGUseItemR:

; 14039: 		}
; 14040: 		else if( citem->m_Type == ITEMGET(14,85) ||
; 14041: 				 citem->m_Type == ITEMGET(14,86) ||
; 14042: 				 citem->m_Type == ITEMGET(14,87) )

  0194d	b9 55 1c 00 00	 mov	 ecx, 7253		; 00001c55H
  01952	66 3b c1	 cmp	 ax, cx
  01955	0f 84 45 0e 00
	00		 je	 $LN79@CGUseItemR
  0195b	ba 56 1c 00 00	 mov	 edx, 7254		; 00001c56H
  01960	66 3b c2	 cmp	 ax, dx
  01963	0f 84 37 0e 00
	00		 je	 $LN79@CGUseItemR
  01969	b9 57 1c 00 00	 mov	 ecx, 7255		; 00001c57H
  0196e	66 3b c1	 cmp	 ax, cx
  01971	0f 84 29 0e 00
	00		 je	 $LN79@CGUseItemR

; 14067: 		}
; 14068: 		else if ( citem->m_Type == ITEMGET(14,7) )	// Siege Potion

  01977	ba 07 1c 00 00	 mov	 edx, 7175		; 00001c07H
  0197c	66 3b c2	 cmp	 ax, dx
  0197f	0f 85 2e 01 00
	00		 jne	 $LN71@CGUseItemR

; 14069: 		{
; 14070: 			int iLevel = citem->m_Level;

  01985	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  0198b	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  0198f	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iLevel$222575[ebp], eax

; 14071: 			int iSerial = citem->GetNumber();

  01995	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 14072: 			int iDur = (int)citem->m_Durability;

  0199a	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  019a0	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iSerial$222576[ebp], eax
  019a6	d9 41 24	 fld	 DWORD PTR [ecx+36]
  019a9	e8 00 00 00 00	 call	 __ftol2_sse

; 14073: 
; 14074: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  019ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  019b4	6a 01		 push	 1
  019b6	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iDur$222577[ebp], eax
  019bc	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  019bf	53		 push	 ebx
  019c0	50		 push	 eax
  019c1	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  019c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  019c9	85 c0		 test	 eax, eax
  019cb	75 33		 jne	 SHORT $LN70@CGUseItemR

; 14075: 			{
; 14076: 				gObjInventoryItemSet(aIndex, pos, -1);

  019cd	68 ff 00 00 00	 push	 255			; 000000ffH
  019d2	53		 push	 ebx
  019d3	57		 push	 edi
  019d4	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14077: 				gObj[aIndex].pInventory[pos].Clear();

  019d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  019df	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  019e6	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  019ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  019ef	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14078: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  019f4	6a 01		 push	 1
  019f6	53		 push	 ebx
  019f7	57		 push	 edi
  019f8	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  019fd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN70@CGUseItemR:

; 14079: 			}
; 14080: 
; 14081: 			if ( gObj[aIndex].lpGuild )

  01a00	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a05	8b 8c 06 18 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1560]
  01a0c	85 c9		 test	 ecx, ecx
  01a0e	74 33		 je	 SHORT $LN69@CGUseItemR

; 14082: 			{
; 14083: 				LogAddTD("[CastleSiege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s][%s] - (Guild : %s)",
; 14084: 					iLevel, iSerial, iDur, gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].lpGuild->Name);

  01a10	83 c1 04	 add	 ecx, 4
  01a13	51		 push	 ecx
  01a14	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _iDur$222577[ebp]
  01a1a	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  01a1e	52		 push	 edx
  01a1f	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _iSerial$222576[ebp]
  01a25	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  01a29	8b b5 f8 fe ff
	ff		 mov	 esi, DWORD PTR _iLevel$222575[ebp]
  01a2f	50		 push	 eax
  01a30	51		 push	 ecx
  01a31	52		 push	 edx
  01a32	56		 push	 esi
  01a33	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
  01a38	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01a3e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 14085: 			}
; 14086: 			else

  01a41	eb 2d		 jmp	 SHORT $LN68@CGUseItemR
$LN69@CGUseItemR:

; 14087: 			{
; 14088: 				LogAddTD("[CastleSiege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s][%s]",
; 14089: 					iLevel, iSerial, iDur, gObj[aIndex].AccountID, gObj[aIndex].Name);

  01a43	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  01a47	51		 push	 ecx
  01a48	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iSerial$222576[ebp]
  01a4e	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  01a52	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iDur$222577[ebp]
  01a58	8b b5 f8 fe ff
	ff		 mov	 esi, DWORD PTR _iLevel$222575[ebp]
  01a5e	52		 push	 edx
  01a5f	50		 push	 eax
  01a60	51		 push	 ecx
  01a61	56		 push	 esi
  01a62	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
  01a67	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01a6d	83 c4 18	 add	 esp, 24			; 00000018H
$LN68@CGUseItemR:

; 14090: 			}
; 14091: 
; 14092: 			if ( iLevel == 0 )

  01a70	85 f6		 test	 esi, esi
  01a72	75 1b		 jne	 SHORT $LN67@CGUseItemR

; 14093: 			{
; 14094: 				gObjUseBlessAndSoulPotion(aIndex, iLevel);

  01a74	56		 push	 esi
  01a75	57		 push	 edi
  01a76	e8 00 00 00 00	 call	 ?gObjUseBlessAndSoulPotion@@YAXHH@Z ; gObjUseBlessAndSoulPotion
  01a7b	83 c4 08	 add	 esp, 8
  01a7e	5b		 pop	 ebx
  01a7f	5f		 pop	 edi
  01a80	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01a81	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a84	33 cd		 xor	 ecx, ebp
  01a86	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a8b	8b e5		 mov	 esp, ebp
  01a8d	5d		 pop	 ebp
  01a8e	c3		 ret	 0
$LN67@CGUseItemR:

; 14095: 			}
; 14096: 			else if ( iLevel == 1 )

  01a8f	83 fe 01	 cmp	 esi, 1
  01a92	0f 85 50 17 00
	00		 jne	 $LN358@CGUseItemR

; 14097: 			{
; 14098: 				gObjUseBlessAndSoulPotion(aIndex, iLevel);

  01a98	56		 push	 esi
  01a99	57		 push	 edi
  01a9a	e8 00 00 00 00	 call	 ?gObjUseBlessAndSoulPotion@@YAXHH@Z ; gObjUseBlessAndSoulPotion
  01a9f	83 c4 08	 add	 esp, 8
  01aa2	5b		 pop	 ebx
  01aa3	5f		 pop	 edi
  01aa4	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01aa5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01aa8	33 cd		 xor	 ecx, ebp
  01aaa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01aaf	8b e5		 mov	 esp, ebp
  01ab1	5d		 pop	 ebp
  01ab2	c3		 ret	 0
$LN71@CGUseItemR:

; 14099: 			}
; 14100: 		}
; 14101: 		else if ( citem->m_Type == ITEMGET(13,48) )

  01ab3	ba 30 1a 00 00	 mov	 edx, 6704		; 00001a30H
  01ab8	66 3b c2	 cmp	 ax, dx
  01abb	0f 85 77 01 00
	00		 jne	 $LN63@CGUseItemR

; 14102: 		{
; 14103: 			if ( (gObj[aIndex].MapNumber < MAP_INDEX_KALIMA1 || gObj[aIndex].MapNumber > MAP_INDEX_KALIMA6 ) && gObj[aIndex].MapNumber != MAP_INDEX_KALIMA7 )

  01ac1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ac6	8a 84 06 23 01
	00 00		 mov	 al, BYTE PTR [esi+eax+291]
  01acd	3c 18		 cmp	 al, 24			; 00000018H
  01acf	72 08		 jb	 SHORT $LN61@CGUseItemR
  01ad1	3c 1d		 cmp	 al, 29			; 0000001dH
  01ad3	0f 86 0f 17 00
	00		 jbe	 $LN358@CGUseItemR
$LN61@CGUseItemR:
  01ad9	3c 24		 cmp	 al, 36			; 00000024H
  01adb	0f 84 07 17 00
	00		 je	 $LN358@CGUseItemR

; 14104: 			{
; 14105: 				int iLevel = g_KalimaGate.GetKalimaGateLevel2(aIndex);

  01ae1	57		 push	 edi
  01ae2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  01ae7	e8 00 00 00 00	 call	 ?GetKalimaGateLevel2@CKalimaGate@@QAEHH@Z ; CKalimaGate::GetKalimaGateLevel2

; 14106: 				int iSerial = citem->GetNumber();

  01aec	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  01af2	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iLevel$222591[ebp], eax
  01af8	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 14107: 				int iDuration = (int)citem->m_Durability;
; 14108: 				BOOL bKalimaGateCreateResult = FALSE;
; 14109: 				int iKalimaGateX = 0;
; 14110: 				int iKalimaGateY = 0;
; 14111: 
; 14112: 				iLevel++;
; 14113: 				iKalimaGateX = gObj[aIndex].X + rand()%6 - 2;

  01afd	e8 00 00 00 00	 call	 _rand
  01b02	99		 cdq
  01b03	b9 06 00 00 00	 mov	 ecx, 6
  01b08	f7 f9		 idiv	 ecx
  01b0a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b0f	0f b6 8c 06 20
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+288]
  01b17	8d 54 0a fe	 lea	 edx, DWORD PTR [edx+ecx-2]
  01b1b	89 95 f8 fe ff
	ff		 mov	 DWORD PTR _iKalimaGateX$222596[ebp], edx

; 14114: 				iKalimaGateY = gObj[aIndex].Y + rand()%6 - 2;

  01b21	e8 00 00 00 00	 call	 _rand
  01b26	99		 cdq
  01b27	b9 06 00 00 00	 mov	 ecx, 6
  01b2c	f7 f9		 idiv	 ecx
  01b2e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b33	0f b6 8c 06 21
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+289]
  01b3b	8d 44 0a fe	 lea	 eax, DWORD PTR [edx+ecx-2]

; 14115: 
; 14116: 				bKalimaGateCreateResult = g_KalimaGate.CreateKalimaGate(aIndex, iLevel, iKalimaGateX, iKalimaGateY);

  01b3f	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _iKalimaGateX$222596[ebp]
  01b45	50		 push	 eax
  01b46	8a 85 f0 fe ff
	ff		 mov	 al, BYTE PTR _iLevel$222591[ebp]
  01b4c	fe c0		 inc	 al
  01b4e	0f b6 c0	 movzx	 eax, al
  01b51	52		 push	 edx
  01b52	50		 push	 eax
  01b53	57		 push	 edi
  01b54	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  01b59	e8 00 00 00 00	 call	 ?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z ; CKalimaGate::CreateKalimaGate

; 14117: 
; 14118: 				if ( bKalimaGateCreateResult == TRUE )
; 14119: 				{
; 14120: 					if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  01b5e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b64	6a 01		 push	 1
  01b66	83 f8 01	 cmp	 eax, 1
  01b69	75 62		 jne	 SHORT $LN60@CGUseItemR
  01b6b	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  01b6e	53		 push	 ebx
  01b6f	52		 push	 edx
  01b70	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  01b75	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b78	85 c0		 test	 eax, eax
  01b7a	75 32		 jne	 SHORT $LN59@CGUseItemR

; 14121: 					{
; 14122: 						gObjInventoryItemSet(aIndex, pos, -1);

  01b7c	68 ff 00 00 00	 push	 255			; 000000ffH
  01b81	53		 push	 ebx
  01b82	57		 push	 edi
  01b83	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14123: 						gObj[aIndex].pInventory[pos].Clear();

  01b88	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b8d	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  01b94	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  01b9a	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b9d	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14124: 						GCInventoryItemDeleteSend(aIndex, pos, 1);

  01ba2	6a 01		 push	 1
  01ba4	53		 push	 ebx
  01ba5	57		 push	 edi
  01ba6	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01bab	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN59@CGUseItemR:

; 14125: 					}
; 14126: 
; 14127: 					LogAddTD("[PCS] Use Free Kalima Ticket Success");

  01bae	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@
  01bb3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01bb9	83 c4 04	 add	 esp, 4
  01bbc	5b		 pop	 ebx
  01bbd	5f		 pop	 edi
  01bbe	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01bbf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01bc2	33 cd		 xor	 ecx, ebp
  01bc4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01bc9	8b e5		 mov	 esp, ebp
  01bcb	5d		 pop	 ebp
  01bcc	c3		 ret	 0
$LN60@CGUseItemR:

; 14128: 				}
; 14129: 				else
; 14130: 				{
; 14131: 					GCItemDurSend(aIndex,pos,(BYTE)gObj[aIndex].pInventory[pos].m_Durability,1);

  01bcd	8b 94 0e c0 11
	00 00		 mov	 edx, DWORD PTR [esi+ecx+4544]
  01bd4	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv4234[ebp]
  01bda	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv4235[ebp]
  01be0	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  01be4	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv4234[ebp]
  01beb	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01bf0	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4231[ebp], eax
  01bf6	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4231[ebp]
  01bfc	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv4228[ebp]
  01c02	8a 8d f8 fe ff
	ff		 mov	 cl, BYTE PTR tv4228[ebp]
  01c08	0f b6 d1	 movzx	 edx, cl
  01c0b	52		 push	 edx
  01c0c	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv4234[ebp]
  01c12	53		 push	 ebx
  01c13	57		 push	 edi
  01c14	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend

; 14132: 					LogAddTD("[PCS] Use Free Kalima Ticket Failed");

  01c19	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@
  01c1e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01c24	83 c4 14	 add	 esp, 20			; 00000014H
  01c27	5b		 pop	 ebx
  01c28	5f		 pop	 edi
  01c29	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01c2a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c2d	33 cd		 xor	 ecx, ebp
  01c2f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c34	8b e5		 mov	 esp, ebp
  01c36	5d		 pop	 ebp
  01c37	c3		 ret	 0
$LN63@CGUseItemR:

; 14133: 				}
; 14134: 			}
; 14135: 		}
; 14136: 		else if( citem->m_Type == ITEMGET(13,69) )

  01c38	b9 45 1a 00 00	 mov	 ecx, 6725		; 00001a45H
  01c3d	66 3b c1	 cmp	 ax, cx
  01c40	0f 85 10 02 00
	00		 jne	 $LN56@CGUseItemR

; 14137: 		{
; 14138: 			int bMove = gMoveCommand.CheckEquipmentToMove(&gObj[aIndex],gObj[aIndex].DeathMap);

  01c46	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c4c	0f b6 8c 16 b7
	01 00 00	 movzx	 ecx, BYTE PTR [esi+edx+439]
  01c54	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  01c57	51		 push	 ecx
  01c58	50		 push	 eax
  01c59	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  01c5e	e8 00 00 00 00	 call	 ?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove

; 14139: 
; 14140: 			if( !BC_MAP_RANGE(gObj[aIndex].MapNumber) &&
; 14141: 				!CC_MAP_RANGE(gObj[aIndex].MapNumber) &&
; 14142: 				!KALIMA_MAP_RANGE(gObj[aIndex].MapNumber) &&
; 14143: 				!DS_MAP_RANGE(gObj[aIndex].MapNumber) &&
; 14144: 				!IT_MAP_RANGE(gObj[aIndex].MapNumber) &&
; 14145: 				gObj[aIndex].MapNumber != MAP_INDEX_CASTLESIEGE &&
; 14146: 				gObj[aIndex].MapNumber != MAP_INDEX_CASTLEHUNTZONE
; 14147: 				&& !DG_MAP_RANGE(gObj[aIndex].MapNumber)
; 14148: 				&& !IF_MAP_RANGE(gObj[aIndex].MapNumber)
; 14149: 				&& bMove == TRUE )

  01c63	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c69	8a 8c 16 23 01
	00 00		 mov	 cl, BYTE PTR [esi+edx+291]
  01c70	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _bMove$222606[ebp], eax
  01c76	80 f9 34	 cmp	 cl, 52			; 00000034H
  01c79	0f 84 97 01 00
	00		 je	 $LN55@CGUseItemR
  01c7f	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  01c82	72 10		 jb	 SHORT $LN348@CGUseItemR
  01c84	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  01c89	3a c1		 cmp	 al, cl
  01c8b	1b c0		 sbb	 eax, eax
  01c8d	40		 inc	 eax
  01c8e	0f 85 82 01 00
	00		 jne	 $LN55@CGUseItemR
$LN348@CGUseItemR:
  01c94	80 f9 35	 cmp	 cl, 53			; 00000035H
  01c97	0f 84 79 01 00
	00		 je	 $LN55@CGUseItemR
  01c9d	80 f9 12	 cmp	 cl, 18			; 00000012H
  01ca0	72 10		 jb	 SHORT $LN336@CGUseItemR
  01ca2	b8 17 00 00 00	 mov	 eax, 23			; 00000017H
  01ca7	3a c1		 cmp	 al, cl
  01ca9	1b c0		 sbb	 eax, eax
  01cab	40		 inc	 eax
  01cac	0f 85 64 01 00
	00		 jne	 $LN55@CGUseItemR
$LN336@CGUseItemR:
  01cb2	80 f9 18	 cmp	 cl, 24			; 00000018H
  01cb5	72 19		 jb	 SHORT $LN337@CGUseItemR
  01cb7	80 f9 1d	 cmp	 cl, 29			; 0000001dH
  01cba	0f 86 56 01 00
	00		 jbe	 $LN55@CGUseItemR
  01cc0	33 c0		 xor	 eax, eax
  01cc2	80 f9 24	 cmp	 cl, 36			; 00000024H
  01cc5	0f 94 c0	 sete	 al
  01cc8	85 c0		 test	 eax, eax
  01cca	0f 85 46 01 00
	00		 jne	 $LN55@CGUseItemR
$LN337@CGUseItemR:
  01cd0	80 f9 09	 cmp	 cl, 9
  01cd3	0f 84 3d 01 00
	00		 je	 $LN55@CGUseItemR
  01cd9	33 c0		 xor	 eax, eax
  01cdb	80 f9 20	 cmp	 cl, 32			; 00000020H
  01cde	0f 94 c0	 sete	 al
  01ce1	85 c0		 test	 eax, eax
  01ce3	0f 85 2d 01 00
	00		 jne	 $LN55@CGUseItemR
  01ce9	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  01cec	72 10		 jb	 SHORT $LN338@CGUseItemR
  01cee	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  01cf3	3a c1		 cmp	 al, cl
  01cf5	1b c0		 sbb	 eax, eax
  01cf7	40		 inc	 eax
  01cf8	0f 85 18 01 00
	00		 jne	 $LN55@CGUseItemR
$LN338@CGUseItemR:
  01cfe	80 f9 1e	 cmp	 cl, 30			; 0000001eH
  01d01	0f 84 0f 01 00
	00		 je	 $LN55@CGUseItemR
  01d07	80 f9 1f	 cmp	 cl, 31			; 0000001fH
  01d0a	0f 84 06 01 00
	00		 je	 $LN55@CGUseItemR
  01d10	80 f9 41	 cmp	 cl, 65			; 00000041H
  01d13	72 10		 jb	 SHORT $LN339@CGUseItemR
  01d15	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  01d1a	3a c1		 cmp	 al, cl
  01d1c	1b c0		 sbb	 eax, eax
  01d1e	40		 inc	 eax
  01d1f	0f 85 f1 00 00
	00		 jne	 $LN55@CGUseItemR
$LN339@CGUseItemR:
  01d25	80 f9 45	 cmp	 cl, 69			; 00000045H
  01d28	72 10		 jb	 SHORT $LN340@CGUseItemR
  01d2a	b8 48 00 00 00	 mov	 eax, 72			; 00000048H
  01d2f	3a c1		 cmp	 al, cl
  01d31	1b c0		 sbb	 eax, eax
  01d33	40		 inc	 eax
  01d34	0f 85 dc 00 00
	00		 jne	 $LN55@CGUseItemR
$LN340@CGUseItemR:
  01d3a	83 bd f8 fe ff
	ff 01		 cmp	 DWORD PTR _bMove$222606[ebp], 1
  01d41	0f 85 cf 00 00
	00		 jne	 $LN55@CGUseItemR

; 14150: 			{
; 14151: 				gObjTeleport(aIndex,gObj[aIndex].DeathMap,gObj[aIndex].DeathX,gObj[aIndex].DeathY);

  01d47	0f b6 8c 16 b6
	01 00 00	 movzx	 ecx, BYTE PTR [esi+edx+438]
  01d4f	0f b6 84 16 b5
	01 00 00	 movzx	 eax, BYTE PTR [esi+edx+437]
  01d57	51		 push	 ecx
  01d58	0f b6 8c 16 b7
	01 00 00	 movzx	 ecx, BYTE PTR [esi+edx+439]
  01d60	50		 push	 eax
  01d61	51		 push	 ecx
  01d62	57		 push	 edi
  01d63	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport

; 14152: 				gObjInventoryItemSet(aIndex, pos, -1);

  01d68	68 ff 00 00 00	 push	 255			; 000000ffH
  01d6d	53		 push	 ebx
  01d6e	57		 push	 edi
  01d6f	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14153: 				gObj[aIndex].pInventory[pos].Clear();

  01d74	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d7a	8b 8c 16 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4544]
  01d81	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  01d87	83 c4 1c	 add	 esp, 28			; 0000001cH
  01d8a	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14154: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  01d8f	6a 01		 push	 1
  01d91	53		 push	 ebx
  01d92	57		 push	 edi
  01d93	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 14155: 
; 14156: 				LogAddTD("[Using Item] [Charm of Raise] [%s][%s] Die Position Map:[%d] X:[%d] Y:[%d]",
; 14157: 					gObj[aIndex].AccountID,gObj[aIndex].Name,gObj[aIndex].DeathMap,gObj[aIndex].DeathX,gObj[aIndex].DeathY);

  01d98	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d9d	0f b6 8c 06 b6
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+438]
  01da5	0f b6 94 06 b5
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+437]
  01dad	51		 push	 ecx
  01dae	0f b6 8c 06 b7
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+439]
  01db6	52		 push	 edx
  01db7	51		 push	 ecx
  01db8	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  01dbc	52		 push	 edx
  01dbd	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  01dc1	50		 push	 eax
  01dc2	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@
  01dc7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14158: 
; 14159: 				gObj[aIndex].DeathMap = 0;

  01dcd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01dd3	c6 84 0e b7 01
	00 00 00	 mov	 BYTE PTR [esi+ecx+439], 0

; 14160: 				gObj[aIndex].DeathX = 0;

  01ddb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 14161: 				gObj[aIndex].DeathY = 0;
; 14162: 
; 14163: 				GCServerCmd(aIndex,60,0,0);

  01de1	6a 00		 push	 0
  01de3	6a 00		 push	 0
  01de5	c6 84 16 b5 01
	00 00 00	 mov	 BYTE PTR [esi+edx+437], 0
  01ded	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01df2	6a 3c		 push	 60			; 0000003cH
  01df4	57		 push	 edi
  01df5	c6 84 06 b6 01
	00 00 00	 mov	 BYTE PTR [esi+eax+438], 0
  01dfd	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd
  01e02	83 c4 34	 add	 esp, 52			; 00000034H
  01e05	5b		 pop	 ebx
  01e06	5f		 pop	 edi
  01e07	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01e08	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01e0b	33 cd		 xor	 ecx, ebp
  01e0d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01e12	8b e5		 mov	 esp, ebp
  01e14	5d		 pop	 ebp
  01e15	c3		 ret	 0
$LN55@CGUseItemR:

; 14164: 			}
; 14165: 			else
; 14166: 			{
; 14167: 				char szMsg[256];
; 14168: 				wsprintf(szMsg,lMsg.Get(MSGGET(4,228)));

  01e16	68 e4 04 00 00	 push	 1252			; 000004e4H
  01e1b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  01e20	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01e25	50		 push	 eax
  01e26	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$222610[ebp]
  01e2c	51		 push	 ecx
  01e2d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 14169: 				GCServerMsgStringSend(szMsg,aIndex,1);

  01e33	6a 01		 push	 1
  01e35	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szMsg$222610[ebp]
  01e3b	57		 push	 edi
  01e3c	52		 push	 edx
  01e3d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  01e42	83 c4 14	 add	 esp, 20			; 00000014H
  01e45	5b		 pop	 ebx
  01e46	5f		 pop	 edi
  01e47	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01e48	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01e4b	33 cd		 xor	 ecx, ebp
  01e4d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01e52	8b e5		 mov	 esp, ebp
  01e54	5d		 pop	 ebp
  01e55	c3		 ret	 0
$LN56@CGUseItemR:

; 14170: 			}
; 14171: 		}
; 14172: 		else if( citem->m_Type == ITEMGET(13,70) )

  01e56	b9 46 1a 00 00	 mov	 ecx, 6726		; 00001a46H
  01e5b	66 3b c1	 cmp	 ax, cx
  01e5e	0f 85 e3 01 00
	00		 jne	 $LN52@CGUseItemR

; 14173: 		{
; 14174: 			int bMove = gMoveCommand.CheckEquipmentToMove(&gObj[aIndex],gObj[aIndex].BindMap);

  01e64	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e6a	0f b6 8c 16 ba
	01 00 00	 movzx	 ecx, BYTE PTR [esi+edx+442]
  01e72	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  01e75	51		 push	 ecx
  01e76	50		 push	 eax
  01e77	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  01e7c	e8 00 00 00 00	 call	 ?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove

; 14175: 
; 14176: 			if( gObjCheckMapBind(gObj[aIndex].MapNumber) == TRUE &&
; 14177: 				bMove == TRUE )

  01e81	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e87	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _bMove$222613[ebp], eax
  01e8d	0f b6 84 16 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+edx+291]
  01e95	50		 push	 eax
  01e96	e8 00 00 00 00	 call	 ?gObjCheckMapBind@@YAHH@Z ; gObjCheckMapBind
  01e9b	83 c4 04	 add	 esp, 4
  01e9e	83 f8 01	 cmp	 eax, 1
  01ea1	0f 85 60 01 00
	00		 jne	 $LN51@CGUseItemR
  01ea7	39 85 f8 fe ff
	ff		 cmp	 DWORD PTR _bMove$222613[ebp], eax
  01ead	0f 85 54 01 00
	00		 jne	 $LN51@CGUseItemR

; 14178: 			{
; 14179: 				if( gObjSearchItemMinus(&gObj[aIndex],pos,1)== FALSE )

  01eb3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01eb9	50		 push	 eax
  01eba	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  01ebd	53		 push	 ebx
  01ebe	52		 push	 edx
  01ebf	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  01ec4	83 c4 0c	 add	 esp, 12			; 0000000cH
  01ec7	85 c0		 test	 eax, eax

; 14180: 				{
; 14181: 					gObjTeleport(aIndex,gObj[aIndex].BindMap,gObj[aIndex].BindX,gObj[aIndex].BindY);

  01ec9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ece	0f 85 b4 00 00
	00		 jne	 $LN50@CGUseItemR
  01ed4	0f b6 8c 06 b9
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+441]
  01edc	0f b6 94 06 b8
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+440]
  01ee4	0f b6 84 06 ba
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+442]
  01eec	51		 push	 ecx
  01eed	52		 push	 edx
  01eee	50		 push	 eax
  01eef	57		 push	 edi
  01ef0	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport

; 14182: 
; 14183: 					gObjInventoryItemSet(aIndex, pos, -1);

  01ef5	68 ff 00 00 00	 push	 255			; 000000ffH
  01efa	53		 push	 ebx
  01efb	57		 push	 edi
  01efc	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14184: 					gObj[aIndex].pInventory[pos].Clear();

  01f01	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f07	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  01f0e	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  01f14	83 c4 1c	 add	 esp, 28			; 0000001cH
  01f17	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14185: 					GCInventoryItemDeleteSend(aIndex, pos, 1);

  01f1c	6a 01		 push	 1
  01f1e	53		 push	 ebx
  01f1f	57		 push	 edi
  01f20	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 14186: 
; 14187: 					gObj[aIndex].BindX = 0;

  01f25	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f2b	c6 84 16 b8 01
	00 00 00	 mov	 BYTE PTR [esi+edx+440], 0

; 14188: 					gObj[aIndex].BindY = 0;

  01f33	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 14189: 					gObj[aIndex].BindMap = 0;
; 14190: 
; 14191: 					GCServerCmd(aIndex,61,0,0);

  01f38	6a 00		 push	 0
  01f3a	6a 00		 push	 0
  01f3c	c6 84 06 b9 01
	00 00 00	 mov	 BYTE PTR [esi+eax+441], 0
  01f44	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f4a	6a 3d		 push	 61			; 0000003dH
  01f4c	57		 push	 edi
  01f4d	c6 84 0e ba 01
	00 00 00	 mov	 BYTE PTR [esi+ecx+442], 0
  01f55	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd

; 14192: 
; 14193: 
; 14194: 					LogAddTD("[Using Item] [Charm of Move] [%s][%s]",gObj[aIndex].AccountID,gObj[aIndex].Name);

  01f5a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f5f	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  01f63	52		 push	 edx
  01f64	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  01f68	50		 push	 eax
  01f69	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@
  01f6e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14465: 		LogAdd("error-L3 : %s return %s %d %d",
; 14466: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);

  01f74	83 c4 28	 add	 esp, 40			; 00000028H
  01f77	5b		 pop	 ebx
  01f78	5f		 pop	 edi
  01f79	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01f7a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01f7d	33 cd		 xor	 ecx, ebp
  01f7f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01f84	8b e5		 mov	 esp, ebp
  01f86	5d		 pop	 ebp
  01f87	c3		 ret	 0
$LN50@CGUseItemR:

; 14195: 				}
; 14196: 				else
; 14197: 				{
; 14198: 					gObj[aIndex].BindX = gObj[aIndex].X;

  01f88	0f b6 8c 06 20
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+288]
  01f90	88 8c 06 b8 01
	00 00		 mov	 BYTE PTR [esi+eax+440], cl

; 14199: 					gObj[aIndex].BindY = gObj[aIndex].Y;

  01f97	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f9c	8a 94 06 21 01
	00 00		 mov	 dl, BYTE PTR [esi+eax+289]
  01fa3	88 94 06 b9 01
	00 00		 mov	 BYTE PTR [esi+eax+441], dl

; 14200: 					gObj[aIndex].BindMap = gObj[aIndex].MapNumber;

  01faa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01faf	0f b6 8c 06 23
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+291]
  01fb7	88 8c 06 ba 01
	00 00		 mov	 BYTE PTR [esi+eax+442], cl

; 14201: 
; 14202: 					LogAddTD("[Using Item] [Charm of Move - SavePosition] [%s][%s] Map:[%d] X:[%d] Y:[%d]",
; 14203: 						gObj[aIndex].AccountID,gObj[aIndex].Name,gObj[aIndex].BindMap,gObj[aIndex].BindX,gObj[aIndex].BindY);

  01fbe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01fc3	0f b6 94 06 b9
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+441]
  01fcb	0f b6 8c 06 b8
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+440]
  01fd3	52		 push	 edx
  01fd4	0f b6 94 06 ba
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+442]
  01fdc	51		 push	 ecx
  01fdd	52		 push	 edx
  01fde	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  01fe2	51		 push	 ecx
  01fe3	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  01fe7	52		 push	 edx
  01fe8	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@
  01fed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01ff3	83 c4 18	 add	 esp, 24			; 00000018H
  01ff6	5b		 pop	 ebx
  01ff7	5f		 pop	 edi
  01ff8	5e		 pop	 esi

; 14467: 	}
; 14468: }

  01ff9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ffc	33 cd		 xor	 ecx, ebp
  01ffe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02003	8b e5		 mov	 esp, ebp
  02005	5d		 pop	 ebp
  02006	c3		 ret	 0
$LN51@CGUseItemR:

; 14204: 				}
; 14205: 			}
; 14206: 			else
; 14207: 			{
; 14208: 				char szMsg[256];
; 14209: 				wsprintf(szMsg,lMsg.Get(MSGGET(4,228)));

  02007	68 e4 04 00 00	 push	 1252			; 000004e4H
  0200c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  02011	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  02016	50		 push	 eax
  02017	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$222620[ebp]
  0201d	50		 push	 eax
  0201e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 14210: 				GCServerMsgStringSend(szMsg,aIndex,1);

  02024	6a 01		 push	 1
  02026	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$222620[ebp]
  0202c	57		 push	 edi
  0202d	51		 push	 ecx
  0202e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  02033	83 c4 14	 add	 esp, 20			; 00000014H
  02036	5b		 pop	 ebx
  02037	5f		 pop	 edi
  02038	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02039	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0203c	33 cd		 xor	 ecx, ebp
  0203e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02043	8b e5		 mov	 esp, ebp
  02045	5d		 pop	 ebp
  02046	c3		 ret	 0
$LN52@CGUseItemR:

; 14211: 			}
; 14212: 		}
; 14213: 		else if( citem->m_Type == ITEMGET(13,66) )

  02047	ba 42 1a 00 00	 mov	 edx, 6722		; 00001a42H
  0204c	66 3b c2	 cmp	 ax, dx
  0204f	0f 85 88 00 00
	00		 jne	 $LN46@CGUseItemR

; 14214: 		{
; 14215: 			if( gObj[aIndex].Level < 15 )

  02055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0205a	66 83 bc 06 96
	00 00 00 0f	 cmp	 WORD PTR [esi+eax+150], 15 ; 0000000fH
  02063	7d 2c		 jge	 SHORT $LN45@CGUseItemR

; 14216: 			{
; 14217: 				GCServerMsgStringSend(lMsg.Get(MSGGET(13,53)),aIndex,1);

  02065	6a 01		 push	 1
  02067	57		 push	 edi
  02068	68 35 0d 00 00	 push	 3381			; 00000d35H
  0206d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  02072	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  02077	50		 push	 eax
  02078	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0207d	83 c4 0c	 add	 esp, 12			; 0000000cH
  02080	5b		 pop	 ebx
  02081	5f		 pop	 edi
  02082	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02083	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02086	33 cd		 xor	 ecx, ebp
  02088	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0208d	8b e5		 mov	 esp, ebp
  0208f	5d		 pop	 ebp
  02090	c3		 ret	 0
$LN45@CGUseItemR:

; 14218: 			}
; 14219: 			else
; 14220: 			{
; 14221: 				gObjTeleport(aIndex,62,220,20);

  02091	6a 14		 push	 20			; 00000014H
  02093	68 dc 00 00 00	 push	 220			; 000000dcH
  02098	6a 3e		 push	 62			; 0000003eH
  0209a	57		 push	 edi
  0209b	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport

; 14222: 
; 14223: 				if( gObjSearchItemMinus(&gObj[aIndex],pos,1) == FALSE )

  020a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020a6	6a 01		 push	 1
  020a8	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  020ab	53		 push	 ebx
  020ac	52		 push	 edx
  020ad	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  020b2	83 c4 1c	 add	 esp, 28			; 0000001cH
  020b5	85 c0		 test	 eax, eax
  020b7	0f 85 2b 11 00
	00		 jne	 $LN358@CGUseItemR

; 14224: 				{
; 14225: 					gObjInventoryItemSet(aIndex, pos, -1);

  020bd	68 ff 00 00 00	 push	 255			; 000000ffH
  020c2	53		 push	 ebx
  020c3	57		 push	 edi
  020c4	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14226: 					gObj[aIndex].pInventory[pos].Clear();

  020c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020ce	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  020d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14227: 					GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14228: 				}
; 14229: 			}

  020d8	e9 68 10 00 00	 jmp	 $LN385@CGUseItemR
$LN46@CGUseItemR:

; 14230: 		}
; 14231: 		else if( citem->m_Type == ITEMGET(13,81) )

  020dd	b9 51 1a 00 00	 mov	 ecx, 6737		; 00001a51H
  020e2	66 3b c1	 cmp	 ax, cx
  020e5	75 1c		 jne	 SHORT $LN41@CGUseItemR

; 14232: 		{
; 14233: 			g_CashItemPeriodSystem.GDReqPeriodItemInsert(&gObj[aIndex],citem->m_Type,-1);

  020e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020ed	6a ff		 push	 -1
  020ef	51		 push	 ecx
  020f0	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  020f3	50		 push	 eax
  020f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  020f9	e8 00 00 00 00	 call	 ?GDReqPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ; CCashItemPeriodSystem::GDReqPeriodItemInsert

; 14234: 
; 14235: 			gObjInventoryItemSet(aIndex, pos, -1);
; 14236: 			gObj[aIndex].pInventory[pos].Clear();
; 14237: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  020fe	e9 26 10 00 00	 jmp	 $LN386@CGUseItemR
$LN41@CGUseItemR:

; 14238: 		}
; 14239: 		else if( citem->m_Type == ITEMGET(13,82) )

  02103	ba 52 1a 00 00	 mov	 edx, 6738		; 00001a52H
  02108	66 3b c2	 cmp	 ax, dx
  0210b	75 37		 jne	 SHORT $LN39@CGUseItemR

; 14240: 		{
; 14241: 			g_CashItemPeriodSystem.GDReqPeriodItemInsert(&gObj[aIndex],citem->m_Type,-1);

  0210d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02112	6a ff		 push	 -1
  02114	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  02117	52		 push	 edx
  02118	51		 push	 ecx
  02119	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  0211e	e8 00 00 00 00	 call	 ?GDReqPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ; CCashItemPeriodSystem::GDReqPeriodItemInsert
$LN391@CGUseItemR:

; 14242: 
; 14243: 			gObjInventoryItemSet(aIndex, pos, -1);

  02123	68 ff 00 00 00	 push	 255			; 000000ffH
  02128	53		 push	 ebx
  02129	57		 push	 edi
  0212a	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14244: 			gObj[aIndex].pInventory[pos].Clear();

  0212f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02135	8b 8c 16 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4544]
  0213c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14245: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  0213f	e9 01 10 00 00	 jmp	 $LN385@CGUseItemR
$LN39@CGUseItemR:

; 14246: 		}
; 14247: 		else if( citem->m_Type == ITEMGET(14,160) )

  02144	b9 a0 1c 00 00	 mov	 ecx, 7328		; 00001ca0H
  02149	66 3b c1	 cmp	 ax, cx
  0214c	0f 85 96 00 00
	00		 jne	 $LN37@CGUseItemR

; 14248: 		{
; 14249: 			if ( gObjItemDurUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  02152	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  02158	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  0215c	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  02160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02166	52		 push	 edx
  02167	50		 push	 eax
  02168	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0216b	52		 push	 edx
  0216c	e8 00 00 00 00	 call	 ?gObjItemDurUp@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemDurUp
  02171	83 c4 0c	 add	 esp, 12			; 0000000cH
  02174	83 f8 01	 cmp	 eax, 1

; 14250: 			{
; 14251: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14252: 				gObj[aIndex].pInventory[pos].Clear();
; 14253: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14254: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14255: 			}
; 14256: 			else

  02177	0f 84 a0 00 00
	00		 je	 $LN387@CGUseItemR

; 14257: 			{
; 14258: 				GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  0217d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02182	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv4154[ebp]
  02188	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  0218f	0f b7 8c 06 2c
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+300]
  02197	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv4154[ebp]
  0219e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  021a3	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv3516[ebp], eax
  021a9	51		 push	 ecx
  021aa	6a 01		 push	 1
  021ac	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv3516[ebp]
  021b2	68 fd 00 00 00	 push	 253			; 000000fdH
  021b7	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv3513[ebp]
  021bd	66 8b 95 f8 fe
	ff ff		 mov	 dx, WORD PTR tv3513[ebp]
  021c4	0f b7 c2	 movzx	 eax, dx
  021c7	50		 push	 eax
  021c8	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv4154[ebp]
  021ce	57		 push	 edi
  021cf	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  021d4	83 c4 14	 add	 esp, 20			; 00000014H
  021d7	5b		 pop	 ebx
  021d8	5f		 pop	 edi
  021d9	5e		 pop	 esi

; 14467: 	}
; 14468: }

  021da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  021dd	33 cd		 xor	 ecx, ebp
  021df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  021e4	8b e5		 mov	 esp, ebp
  021e6	5d		 pop	 ebp
  021e7	c3		 ret	 0
$LN37@CGUseItemR:

; 14259: 			}
; 14260: 		}
; 14261: 		else if ( citem->m_Type == ITEMGET(14,161) )

  021e8	b9 a1 1c 00 00	 mov	 ecx, 7329		; 00001ca1H
  021ed	66 3b c1	 cmp	 ax, cx
  021f0	0f 85 e6 00 00
	00		 jne	 $LN33@CGUseItemR

; 14262: 		{
; 14263: 			if ( gObjItemStrenghtenUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  021f6	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  021fc	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  02200	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  02204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0220a	52		 push	 edx
  0220b	50		 push	 eax
  0220c	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0220f	52		 push	 edx
  02210	e8 00 00 00 00	 call	 ?gObjItemStrenghtenUp@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemStrenghtenUp
  02215	83 c4 0c	 add	 esp, 12			; 0000000cH
  02218	83 f8 01	 cmp	 eax, 1
  0221b	75 54		 jne	 SHORT $LN32@CGUseItemR
$LN387@CGUseItemR:

; 14264: 			{
; 14265: 				gObjInventoryItemSet(aIndex, pos, -1);

  0221d	68 ff 00 00 00	 push	 255			; 000000ffH
  02222	53		 push	 ebx
  02223	57		 push	 edi
  02224	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14266: 				gObj[aIndex].pInventory[pos].Clear();

  02229	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0222e	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  02235	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  0223b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0223e	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14267: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);

  02243	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  02249	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  0224d	52		 push	 edx
$LN388@CGUseItemR:
  0224e	57		 push	 edi
  0224f	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 14268: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  02254	6a 01		 push	 1
  02256	53		 push	 ebx
  02257	57		 push	 edi
  02258	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0225d	83 c4 14	 add	 esp, 20			; 00000014H
  02260	5b		 pop	 ebx
  02261	5f		 pop	 edi
  02262	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02263	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02266	33 cd		 xor	 ecx, ebp
  02268	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0226d	8b e5		 mov	 esp, ebp
  0226f	5d		 pop	 ebp
  02270	c3		 ret	 0
$LN32@CGUseItemR:

; 14269: 			}
; 14270: 			else
; 14271: 			{
; 14272: 				GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  02271	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02276	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv2728[ebp]
  0227c	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  02283	0f b7 8c 06 2c
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+300]
  0228b	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv2728[ebp]
  02292	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  02297	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv2590[ebp], eax
  0229d	51		 push	 ecx
  0229e	6a 01		 push	 1
  022a0	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv2590[ebp]
  022a6	68 fd 00 00 00	 push	 253			; 000000fdH
  022ab	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv2297[ebp]
  022b1	66 8b 95 f8 fe
	ff ff		 mov	 dx, WORD PTR tv2297[ebp]
  022b8	0f b7 c2	 movzx	 eax, dx
  022bb	50		 push	 eax
  022bc	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv2728[ebp]
  022c2	57		 push	 edi
  022c3	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  022c8	83 c4 14	 add	 esp, 20			; 00000014H
  022cb	5b		 pop	 ebx
  022cc	5f		 pop	 edi
  022cd	5e		 pop	 esi

; 14467: 	}
; 14468: }

  022ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  022d1	33 cd		 xor	 ecx, ebp
  022d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  022d8	8b e5		 mov	 esp, ebp
  022da	5d		 pop	 ebp
  022db	c3		 ret	 0
$LN33@CGUseItemR:

; 14273: 			}
; 14274: 		}
; 14275: 		else if( citem->m_Type == ITEMGET(14,162) )

  022dc	b9 a2 1c 00 00	 mov	 ecx, 7330		; 00001ca2H
  022e1	66 3b c1	 cmp	 ax, cx
  022e4	0f 85 cb 00 00
	00		 jne	 $LN29@CGUseItemR

; 14276: 		{
; 14277: 			PMSG_ANS_EXTEND pMsg;
; 14278: 			PHeadSetB((LPBYTE)&pMsg,0x2B,sizeof(pMsg));

  022ea	6a 04		 push	 4
  022ec	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$222642[ebp]
  022f2	6a 2b		 push	 43			; 0000002bH
  022f4	52		 push	 edx
  022f5	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14279: 
; 14280: 			if( gObj[aIndex].pInventoryExtend >= 4 )

  022fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02300	8d 84 0e cd 11
	00 00		 lea	 eax, DWORD PTR [esi+ecx+4557]
  02307	83 c4 0c	 add	 esp, 12			; 0000000cH
  0230a	80 38 04	 cmp	 BYTE PTR [eax], 4
  0230d	0f 82 85 00 00
	00		 jb	 $LN28@CGUseItemR

; 14281: 			{
; 14282: 				pMsg.btResult = 0;

  02313	c6 85 f3 fe ff
	ff 00		 mov	 BYTE PTR _pMsg$222642[ebp+3], 0

; 14283: 				GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  0231a	d9 84 0e d8 00
	00 00		 fld	 DWORD PTR [esi+ecx+216]
  02321	0f b7 84 0e 2c
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+300]
  02329	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv2130[ebp]
  0232f	50		 push	 eax
  02330	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv2130[ebp]
  02337	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0233c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv2120[ebp], eax
  02342	6a 01		 push	 1
  02344	68 fd 00 00 00	 push	 253			; 000000fdH
  02349	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv2120[ebp]
  0234f	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv2114[ebp]
  02355	66 8b 8d f8 fe
	ff ff		 mov	 cx, WORD PTR tv2114[ebp]
  0235c	0f b7 d1	 movzx	 edx, cx
  0235f	52		 push	 edx
  02360	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv2130[ebp]
  02366	57		 push	 edi
  02367	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 14316: 
; 14317: 				pMsg.btResult = 1;
; 14318: 			}
; 14319: 
; 14320: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  0236c	0f b6 85 f1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$222650[ebp+1]
  02373	83 c4 14	 add	 esp, 20			; 00000014H
  02376	50		 push	 eax
  02377	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$222650[ebp]
  0237d	51		 push	 ecx
  0237e	57		 push	 edi
  0237f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02384	83 c4 0c	 add	 esp, 12			; 0000000cH
  02387	5b		 pop	 ebx
  02388	5f		 pop	 edi
  02389	5e		 pop	 esi

; 14467: 	}
; 14468: }

  0238a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0238d	33 cd		 xor	 ecx, ebp
  0238f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02394	8b e5		 mov	 esp, ebp
  02396	5d		 pop	 ebp
  02397	c3		 ret	 0
$LN28@CGUseItemR:

; 14284: 			}
; 14285: 			else
; 14286: 			{
; 14287: 				gObj[aIndex].pInventoryExtend++;

  02398	fe 00		 inc	 BYTE PTR [eax]

; 14288: 				GDExpandInventorySend(&gObj[aIndex],gObj[aIndex].pInventoryExtend);

  0239a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0239f	0f b6 8c 30 cd
	11 00 00	 movzx	 ecx, BYTE PTR [eax+esi+4557]
  023a7	03 c6		 add	 eax, esi
  023a9	51		 push	 ecx
  023aa	50		 push	 eax
  023ab	e8 00 00 00 00	 call	 ?GDExpandInventorySend@@YAXPAUOBJECTSTRUCT@@H@Z ; GDExpandInventorySend

; 14289: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14290: 				gObj[aIndex].pInventory[pos].Clear();
; 14291: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14292: 
; 14293: 				pMsg.btResult = 1;
; 14294: 			}
; 14295: 
; 14296: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  023b0	e9 d7 00 00 00	 jmp	 $LN392@CGUseItemR
$LN29@CGUseItemR:

; 14297: 		}
; 14298: 		else if( citem->m_Type == ITEMGET(14,163) )

  023b5	ba a3 1c 00 00	 mov	 edx, 7331		; 00001ca3H
  023ba	66 3b c2	 cmp	 ax, dx
  023bd	0f 85 2c 01 00
	00		 jne	 $LN25@CGUseItemR

; 14299: 		{
; 14300: 			PMSG_ANS_EXTEND pMsg;
; 14301: 			PHeadSetB((LPBYTE)&pMsg,0x2B,sizeof(pMsg));

  023c3	6a 04		 push	 4
  023c5	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$222650[ebp]
  023cb	6a 2b		 push	 43			; 0000002bH
  023cd	50		 push	 eax
  023ce	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14302: 
; 14303: 			if( gObj[aIndex].pWarehouseExtend >= 1 )

  023d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  023d9	8d 84 0e 00 12
	00 00		 lea	 eax, DWORD PTR [esi+ecx+4608]
  023e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  023e3	80 38 01	 cmp	 BYTE PTR [eax], 1
  023e6	0f 82 85 00 00
	00		 jb	 $LN24@CGUseItemR

; 14304: 			{
; 14305: 				pMsg.btResult = 0;
; 14306: 				GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  023ec	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv512[ebp]
  023f2	c6 85 f3 fe ff
	ff 00		 mov	 BYTE PTR _pMsg$222650[ebp+3], 0
  023f9	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv512[ebp]
  02400	d9 84 0e d8 00
	00 00		 fld	 DWORD PTR [esi+ecx+216]
  02407	0f b7 94 0e 2c
	01 00 00	 movzx	 edx, WORD PTR [esi+ecx+300]
  0240f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  02414	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv503[ebp], eax
  0241a	52		 push	 edx
  0241b	6a 01		 push	 1
  0241d	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv503[ebp]
  02423	68 fd 00 00 00	 push	 253			; 000000fdH
  02428	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv497[ebp]
  0242e	66 8b 85 f8 fe
	ff ff		 mov	 ax, WORD PTR tv497[ebp]
  02435	0f b7 c8	 movzx	 ecx, ax
  02438	51		 push	 ecx
  02439	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv512[ebp]
  0243f	57		 push	 edi
  02440	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 14316: 
; 14317: 				pMsg.btResult = 1;
; 14318: 			}
; 14319: 
; 14320: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  02445	0f b6 85 f1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$222650[ebp+1]
  0244c	83 c4 14	 add	 esp, 20			; 00000014H
  0244f	50		 push	 eax
  02450	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$222650[ebp]
  02456	51		 push	 ecx
  02457	57		 push	 edi
  02458	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0245d	83 c4 0c	 add	 esp, 12			; 0000000cH
  02460	5b		 pop	 ebx
  02461	5f		 pop	 edi
  02462	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02463	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02466	33 cd		 xor	 ecx, ebp
  02468	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0246d	8b e5		 mov	 esp, ebp
  0246f	5d		 pop	 ebp
  02470	c3		 ret	 0
$LN24@CGUseItemR:

; 14307: 			}
; 14308: 			else
; 14309: 			{
; 14310: 				gObj[aIndex].pWarehouseExtend = 1;

  02471	c6 00 01	 mov	 BYTE PTR [eax], 1

; 14311: 				GDExpandWarehouseSend(&gObj[aIndex],gObj[aIndex].pWarehouseExtend);

  02474	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0247a	0f b6 8c 16 00
	12 00 00	 movzx	 ecx, BYTE PTR [esi+edx+4608]
  02482	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  02485	51		 push	 ecx
  02486	50		 push	 eax
  02487	e8 00 00 00 00	 call	 ?GDExpandWarehouseSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GDExpandWarehouseSend
$LN392@CGUseItemR:

; 14312: 
; 14313: 				gObjInventoryItemSet(aIndex, pos, -1);

  0248c	68 ff 00 00 00	 push	 255			; 000000ffH
  02491	53		 push	 ebx
  02492	57		 push	 edi
  02493	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14314: 				gObj[aIndex].pInventory[pos].Clear();

  02498	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0249e	8b 8c 16 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4544]
  024a5	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  024ab	83 c4 14	 add	 esp, 20			; 00000014H
  024ae	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14315: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  024b3	6a 01		 push	 1
  024b5	53		 push	 ebx
  024b6	57		 push	 edi
  024b7	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 14316: 
; 14317: 				pMsg.btResult = 1;
; 14318: 			}
; 14319: 
; 14320: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  024bc	0f b6 85 f1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$222650[ebp+1]
  024c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  024c6	50		 push	 eax
  024c7	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$222650[ebp]
  024cd	51		 push	 ecx
  024ce	57		 push	 edi
  024cf	c6 85 f3 fe ff
	ff 01		 mov	 BYTE PTR _pMsg$222650[ebp+3], 1
  024d6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  024db	83 c4 0c	 add	 esp, 12			; 0000000cH
  024de	5b		 pop	 ebx
  024df	5f		 pop	 edi
  024e0	5e		 pop	 esi

; 14467: 	}
; 14468: }

  024e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  024e4	33 cd		 xor	 ecx, ebp
  024e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  024eb	8b e5		 mov	 esp, ebp
  024ed	5d		 pop	 ebp
  024ee	c3		 ret	 0
$LN25@CGUseItemR:

; 14321: 		}
; 14322: 		else if (citem->m_Type == ITEMGET(13, 152)
; 14323: 			|| citem->m_Type == ITEMGET(13, 156)) {

  024ef	ba 98 1a 00 00	 mov	 edx, 6808		; 00001a98H
  024f4	66 3b c2	 cmp	 ax, dx
  024f7	0f 84 43 02 00
	00		 je	 $LN20@CGUseItemR
  024fd	b9 9c 1a 00 00	 mov	 ecx, 6812		; 00001a9cH
  02502	66 3b c1	 cmp	 ax, cx
  02505	0f 84 35 02 00
	00		 je	 $LN20@CGUseItemR

; 14334: 				GCServerMsgStringSend("Master Skill Reset Fail", aIndex, 1);
; 14335: 			}
; 14336: 		}
; 14337: 		else if (citem->m_Type == ITEMGET(13, 153)
; 14338: 			|| citem->m_Type == ITEMGET(13, 157)) {

  0250b	ba 99 1a 00 00	 mov	 edx, 6809		; 00001a99H
  02510	66 3b c2	 cmp	 ax, dx
  02513	0f 84 a6 01 00
	00		 je	 $LN15@CGUseItemR
  02519	b9 9d 1a 00 00	 mov	 ecx, 6813		; 00001a9dH
  0251e	66 3b c1	 cmp	 ax, cx
  02521	0f 84 98 01 00
	00		 je	 $LN15@CGUseItemR

; 14350: 			}
; 14351: 		}
; 14352: 		else if (citem->m_Type == ITEMGET(13, 154)
; 14353: 			|| citem->m_Type == ITEMGET(13, 158)) {

  02527	ba 9a 1a 00 00	 mov	 edx, 6810		; 00001a9aH
  0252c	66 3b c2	 cmp	 ax, dx
  0252f	0f 84 26 01 00
	00		 je	 $LN10@CGUseItemR
  02535	b9 9e 1a 00 00	 mov	 ecx, 6814		; 00001a9eH
  0253a	66 3b c1	 cmp	 ax, cx
  0253d	0f 84 18 01 00
	00		 je	 $LN10@CGUseItemR

; 14364: 				GCServerMsgStringSend("Master Skill Reset Fail", aIndex, 1);
; 14365: 			}
; 14366: 		}
; 14367: 		else if (citem->m_Type == ITEMGET(13, 155)
; 14368: 			|| citem->m_Type == ITEMGET(13, 159)) {

  02543	ba 9b 1a 00 00	 mov	 edx, 6811		; 00001a9bH
  02548	66 3b c2	 cmp	 ax, dx
  0254b	0f 84 a6 00 00
	00		 je	 $LN5@CGUseItemR
  02551	b9 9f 1a 00 00	 mov	 ecx, 6815		; 00001a9fH
  02556	66 3b c1	 cmp	 ax, cx
  02559	0f 84 98 00 00
	00		 je	 $LN5@CGUseItemR

; 14379: 				GCServerMsgStringSend("Master Skill Reset Fail", aIndex, 1);
; 14380: 			}
; 14381: 		}
; 14382: #if (ENABLETEST_CUSTOM_JEWELS == 1)
; 14383: 		else if( citem->m_Type == ITEMGET(14,200) )
; 14384: 		{
; 14385: 			if ( gObjJewel1Enchant(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 14386: 			{
; 14387: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14388: 				gObj[aIndex].pInventory[pos].Clear();
; 14389: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14390: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14391: 			}
; 14392: 			else
; 14393: 			{
; 14394: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14395: 			}
; 14396: 		}
; 14397: 		else if( citem->m_Type == ITEMGET(14,201) )
; 14398: 		{
; 14399: 			if ( gObjJewel2Enchant(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 14400: 			{
; 14401: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14402: 				gObj[aIndex].pInventory[pos].Clear();
; 14403: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14404: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14405: 			}
; 14406: 			else
; 14407: 			{
; 14408: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14409: 			}
; 14410: 		}
; 14411: 		else if( citem->m_Type == ITEMGET(14,202) )
; 14412: 		{
; 14413: 			if ( gObjJewel3Enchant(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 14414: 			{
; 14415: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14416: 				gObj[aIndex].pInventory[pos].Clear();
; 14417: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14418: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14419: 			}
; 14420: 			else
; 14421: 			{
; 14422: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14423: 			}
; 14424: 		}
; 14425: 		else if( citem->m_Type == ITEMGET(14,203) )
; 14426: 		{
; 14427: 			if ( gObjJewel4Enchant(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 14428: 			{
; 14429: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14430: 				gObj[aIndex].pInventory[pos].Clear();
; 14431: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14432: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14433: 			}
; 14434: 			else
; 14435: 			{
; 14436: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14437: 			}
; 14438: 		}
; 14439: 		else if( citem->m_Type == ITEMGET(14,204) )
; 14440: 		{
; 14441: 			if ( gObjJewel5Enchant(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 14442: 			{
; 14443: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14444: 				gObj[aIndex].pInventory[pos].Clear();
; 14445: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14446: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14447: 			}
; 14448: 			else
; 14449: 			{
; 14450: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14451: 			}
; 14452: 		}
; 14453: #endif
; 14454: 		else
; 14455: 		{
; 14456: 			LogAdd("error-L3 : %s return %s %d %d %s",
; 14457: 				gObj[aIndex].Name, __FILE__,__LINE__, pos,citem->GetName());

  0255f	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  02565	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0256a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02570	50		 push	 eax
  02571	53		 push	 ebx
  02572	68 79 38 00 00	 push	 14457			; 00003879H
  02577	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0257c	8d 44 16 5d	 lea	 eax, DWORD PTR [esi+edx+93]
  02580	50		 push	 eax
  02581	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@
  02586	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 14458: 
; 14459: 			GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  0258c	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv480[ebp]
  02592	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02597	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  0259e	0f b7 8c 06 2c
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+300]
  025a6	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv480[ebp]
  025ad	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  025b2	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv476[ebp], eax
  025b8	51		 push	 ecx
  025b9	6a 01		 push	 1
  025bb	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv476[ebp]
  025c1	68 fd 00 00 00	 push	 253			; 000000fdH
  025c6	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv472[ebp]
  025cc	66 8b 95 f8 fe
	ff ff		 mov	 dx, WORD PTR tv472[ebp]
  025d3	0f b7 c2	 movzx	 eax, dx
  025d6	50		 push	 eax
  025d7	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv480[ebp]
  025dd	57		 push	 edi
  025de	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  025e3	83 c4 2c	 add	 esp, 44			; 0000002cH
  025e6	5b		 pop	 ebx
  025e7	5f		 pop	 edi
  025e8	5e		 pop	 esi

; 14467: 	}
; 14468: }

  025e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  025ec	33 cd		 xor	 ecx, ebp
  025ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  025f3	8b e5		 mov	 esp, ebp
  025f5	5d		 pop	 ebp
  025f6	c3		 ret	 0
$LN5@CGUseItemR:

; 14369: 			if (g_MasterSkillSystem.CheckMasterSkillPoint(aIndex, 0)) {

  025f7	6a 00		 push	 0
  025f9	57		 push	 edi
  025fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  025ff	e8 00 00 00 00	 call	 ?CheckMasterSkillPoint@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterSkillPoint
  02604	84 c0		 test	 al, al
  02606	0f 84 13 01 00
	00		 je	 $LN14@CGUseItemR

; 14370: 				g_MasterSkillSystem.ResetMasterSkill(aIndex, 0);

  0260c	6a 00		 push	 0
  0260e	57		 push	 edi
  0260f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  02614	e8 00 00 00 00	 call	 ?ResetMasterSkill@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::ResetMasterSkill

; 14371: 				LogAddTD("[%s] [%s] [MasterLevelSkill Reset] - All", 
; 14372: 					gObj[aIndex].AccountID, gObj[aIndex].Name);

  02619	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0261e	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  02622	51		 push	 ecx
  02623	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  02627	52		 push	 edx
  02628	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@HAOMGPEH@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
  0262d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14373: 				gObjCloseSet(aIndex, 1);

  02633	6a 01		 push	 1
  02635	57		 push	 edi
  02636	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet

; 14374: 				gObjInventoryItemSet(aIndex, pos, -1);

  0263b	68 ff 00 00 00	 push	 255			; 000000ffH
  02640	53		 push	 ebx
  02641	57		 push	 edi
  02642	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14375: 				gObj[aIndex].pInventory[pos].Clear();

  02647	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0264c	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  02653	83 c4 20	 add	 esp, 32			; 00000020H

; 14376: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14377: 			}
; 14378: 			else {

  02656	e9 ea 0a 00 00	 jmp	 $LN385@CGUseItemR
$LN10@CGUseItemR:

; 14354: 			if (g_MasterSkillSystem.CheckMasterSkillPoint(aIndex, 3)) {

  0265b	6a 03		 push	 3
  0265d	57		 push	 edi
  0265e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  02663	e8 00 00 00 00	 call	 ?CheckMasterSkillPoint@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterSkillPoint
  02668	84 c0		 test	 al, al
  0266a	0f 84 af 00 00
	00		 je	 $LN14@CGUseItemR

; 14355: 				g_MasterSkillSystem.ResetMasterSkill(aIndex, 3);

  02670	6a 03		 push	 3
  02672	57		 push	 edi
  02673	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  02678	e8 00 00 00 00	 call	 ?ResetMasterSkill@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::ResetMasterSkill

; 14356: 				LogAddTD("[%s] [%s] [MasterLevelSkill Reset] - Enhance Attack/Defense (%d)", 
; 14357: 					gObj[aIndex].AccountID, gObj[aIndex].Name);

  0267d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02682	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  02686	51		 push	 ecx
  02687	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  0268b	52		 push	 edx
  0268c	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@LLBOIAD@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
  02691	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14358: 				gObjCloseSet(aIndex, 1);

  02697	6a 01		 push	 1
  02699	57		 push	 edi
  0269a	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet

; 14359: 				gObjInventoryItemSet(aIndex, pos, -1);

  0269f	68 ff 00 00 00	 push	 255			; 000000ffH
  026a4	53		 push	 ebx
  026a5	57		 push	 edi
  026a6	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14360: 				gObj[aIndex].pInventory[pos].Clear();

  026ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  026b0	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  026b7	83 c4 20	 add	 esp, 32			; 00000020H

; 14361: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14362: 			}
; 14363: 			else {

  026ba	e9 86 0a 00 00	 jmp	 $LN385@CGUseItemR
$LN15@CGUseItemR:

; 14339: 			if (g_MasterSkillSystem.CheckMasterSkillPoint(aIndex, 2)) {

  026bf	6a 02		 push	 2
  026c1	57		 push	 edi
  026c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  026c7	e8 00 00 00 00	 call	 ?CheckMasterSkillPoint@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterSkillPoint
  026cc	84 c0		 test	 al, al
  026ce	74 4f		 je	 SHORT $LN14@CGUseItemR

; 14340: 				g_MasterSkillSystem.ResetMasterSkill(aIndex, 2);

  026d0	6a 02		 push	 2
  026d2	57		 push	 edi
  026d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  026d8	e8 00 00 00 00	 call	 ?ResetMasterSkill@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::ResetMasterSkill

; 14341: 				LogAddTD("[%s] [%s] [MasterLevelSkill Reset] - Strengthen Skill", 
; 14342: 					gObj[aIndex].AccountID, gObj[aIndex].Name);

  026dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  026e2	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  026e6	51		 push	 ecx
  026e7	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  026eb	52		 push	 edx
  026ec	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@CEAHPFGG@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
  026f1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14343: 				gObjCloseSet(aIndex, 1);

  026f7	6a 01		 push	 1
  026f9	57		 push	 edi
  026fa	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet

; 14344: 				gObjInventoryItemSet(aIndex, pos, -1);

  026ff	68 ff 00 00 00	 push	 255			; 000000ffH
  02704	53		 push	 ebx
  02705	57		 push	 edi
  02706	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14345: 				gObj[aIndex].pInventory[pos].Clear();

  0270b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02710	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  02717	83 c4 20	 add	 esp, 32			; 00000020H

; 14346: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14347: 			}
; 14348: 			else {

  0271a	e9 26 0a 00 00	 jmp	 $LN385@CGUseItemR
$LN14@CGUseItemR:

; 14349: 				GCServerMsgStringSend("Master Skill Reset Fail", aIndex, 1);

  0271f	6a 01		 push	 1
  02721	57		 push	 edi
$LN19@CGUseItemR:
  02722	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@IGJGPHCH@Master?5Skill?5Reset?5Fail?$AA@
  02727	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0272c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0272f	5b		 pop	 ebx
  02730	5f		 pop	 edi
  02731	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02732	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02735	33 cd		 xor	 ecx, ebp
  02737	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0273c	8b e5		 mov	 esp, ebp
  0273e	5d		 pop	 ebp
  0273f	c3		 ret	 0
$LN20@CGUseItemR:

; 14324: 			if (g_MasterSkillSystem.CheckMasterSkillPoint(aIndex, 1)) {

  02740	6a 01		 push	 1
  02742	57		 push	 edi
  02743	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  02748	e8 00 00 00 00	 call	 ?CheckMasterSkillPoint@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterSkillPoint

; 14325: 				g_MasterSkillSystem.ResetMasterSkill(aIndex, 1);

  0274d	6a 01		 push	 1
  0274f	57		 push	 edi
  02750	84 c0		 test	 al, al
  02752	74 ce		 je	 SHORT $LN19@CGUseItemR
  02754	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  02759	e8 00 00 00 00	 call	 ?ResetMasterSkill@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::ResetMasterSkill

; 14326: 				LogAddTD("[%s] [%s] [MasterLevelSkill Reset] - Passive", 
; 14327: 					gObj[aIndex].AccountID, gObj[aIndex].Name);

  0275e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02763	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  02767	51		 push	 ecx
  02768	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  0276c	52		 push	 edx
  0276d	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@HEGKGIOI@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
  02772	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14328: 				gObjCloseSet(aIndex, 1);

  02778	6a 01		 push	 1
  0277a	57		 push	 edi
  0277b	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet

; 14329: 				gObjInventoryItemSet(aIndex, pos, -1);

  02780	68 ff 00 00 00	 push	 255			; 000000ffH
  02785	53		 push	 ebx
  02786	57		 push	 edi
  02787	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14330: 				gObj[aIndex].pInventory[pos].Clear();

  0278c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02791	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  02798	83 c4 20	 add	 esp, 32			; 00000020H

; 14331: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14332: 			}
; 14333: 			else {

  0279b	e9 a5 09 00 00	 jmp	 $LN385@CGUseItemR
$LN79@CGUseItemR:

; 14043: 		{
; 14044: 			int BuffNumber = 0;
; 14045: 
; 14046: 			if( citem->m_Type == ITEMGET(14,85) )

  027a0	b9 55 1c 00 00	 mov	 ecx, 7253		; 00001c55H
  027a5	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _BuffNumber$222566[ebp], 0
  027af	66 3b c1	 cmp	 ax, cx
  027b2	75 0c		 jne	 SHORT $LN78@CGUseItemR

; 14047: 			{
; 14048: 				BuffNumber = BUFF_CHERRY_WINE;

  027b4	c7 85 f0 fe ff
	ff 4e 00 00 00	 mov	 DWORD PTR _BuffNumber$222566[ebp], 78 ; 0000004eH
  027be	eb 2a		 jmp	 SHORT $LN74@CGUseItemR
$LN78@CGUseItemR:

; 14049: 			}
; 14050: 			else if( citem->m_Type == ITEMGET(14,86) )

  027c0	ba 56 1c 00 00	 mov	 edx, 7254		; 00001c56H
  027c5	66 3b c2	 cmp	 ax, dx
  027c8	75 0c		 jne	 SHORT $LN76@CGUseItemR

; 14051: 			{
; 14052: 				BuffNumber = BUFF_CHERRY_RICECAKE;

  027ca	c7 85 f0 fe ff
	ff 4f 00 00 00	 mov	 DWORD PTR _BuffNumber$222566[ebp], 79 ; 0000004fH
  027d4	eb 14		 jmp	 SHORT $LN74@CGUseItemR
$LN76@CGUseItemR:

; 14053: 			}
; 14054: 			else if( citem->m_Type == ITEMGET(14,87) )

  027d6	b9 57 1c 00 00	 mov	 ecx, 7255		; 00001c57H
  027db	66 3b c1	 cmp	 ax, cx
  027de	75 0a		 jne	 SHORT $LN74@CGUseItemR

; 14055: 			{
; 14056: 				BuffNumber = BUFF_CHERRY_FLOWERPETAL;

  027e0	c7 85 f0 fe ff
	ff 50 00 00 00	 mov	 DWORD PTR _BuffNumber$222566[ebp], 80 ; 00000050H
$LN74@CGUseItemR:

; 14057: 			}
; 14058: 
; 14059: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  027ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  027f0	6a 01		 push	 1
  027f2	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  027f5	53		 push	 ebx
  027f6	50		 push	 eax
  027f7	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  027fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  027ff	85 c0		 test	 eax, eax
  02801	75 33		 jne	 SHORT $LN73@CGUseItemR

; 14060: 			{
; 14061: 				gObjInventoryItemSet(aIndex, pos, -1);

  02803	68 ff 00 00 00	 push	 255			; 000000ffH
  02808	53		 push	 ebx
  02809	57		 push	 edi
  0280a	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14062: 				gObj[aIndex].pInventory[pos].Clear();

  0280f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02815	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  0281c	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  02822	83 c4 0c	 add	 esp, 12			; 0000000cH
  02825	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14063: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  0282a	6a 01		 push	 1
  0282c	53		 push	 ebx
  0282d	57		 push	 edi
  0282e	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  02833	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN73@CGUseItemR:

; 14064: 			}
; 14065: 
; 14066: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  02836	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _BuffNumber$222566[ebp]
  0283c	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02842	52		 push	 edx
  02843	56		 push	 esi
  02844	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjAddBuffEffect
  02849	83 c4 08	 add	 esp, 8
  0284c	5b		 pop	 ebx
  0284d	5f		 pop	 edi
  0284e	5e		 pop	 esi

; 14467: 	}
; 14468: }

  0284f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02852	33 cd		 xor	 ecx, ebp
  02854	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02859	8b e5		 mov	 esp, ebp
  0285b	5d		 pop	 ebp
  0285c	c3		 ret	 0
$LN84@CGUseItemR:

; 14033: 		{
; 14034: 			UseExCashPotions(&gObj[aIndex],pos);

  0285d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02863	53		 push	 ebx
  02864	56		 push	 esi
  02865	e8 00 00 00 00	 call	 ?UseExCashPotions@@YAXPAUOBJECTSTRUCT@@H@Z ; UseExCashPotions
  0286a	83 c4 08	 add	 esp, 8
  0286d	5b		 pop	 ebx
  0286e	5f		 pop	 edi
  0286f	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02870	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02873	33 cd		 xor	 ecx, ebp
  02875	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0287a	8b e5		 mov	 esp, ebp
  0287c	5d		 pop	 ebp
  0287d	c3		 ret	 0
$LN89@CGUseItemR:

; 14025: 		{
; 14026: 			UseCashItems(&gObj[aIndex],pos);

  0287e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02884	53		 push	 ebx
  02885	56		 push	 esi
  02886	e8 00 00 00 00	 call	 ?UseCashItems@@YAXPAUOBJECTSTRUCT@@H@Z ; UseCashItems
  0288b	83 c4 08	 add	 esp, 8
  0288e	5b		 pop	 ebx
  0288f	5f		 pop	 edi
  02890	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02891	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02894	33 cd		 xor	 ecx, ebp
  02896	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0289b	8b e5		 mov	 esp, ebp
  0289d	5d		 pop	 ebp
  0289e	c3		 ret	 0
$LN92@CGUseItemR:

; 14017: 		{
; 14018: 			ExMinusStatFruit(&gObj[aIndex],pos);

  0289f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  028a5	53		 push	 ebx
  028a6	56		 push	 esi
  028a7	e8 00 00 00 00	 call	 ?ExMinusStatFruit@@YAXPAUOBJECTSTRUCT@@H@Z ; ExMinusStatFruit
  028ac	83 c4 08	 add	 esp, 8
  028af	5b		 pop	 ebx
  028b0	5f		 pop	 edi
  028b1	5e		 pop	 esi

; 14467: 	}
; 14468: }

  028b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  028b5	33 cd		 xor	 ecx, ebp
  028b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  028bc	8b e5		 mov	 esp, ebp
  028be	5d		 pop	 ebp
  028bf	c3		 ret	 0
$LN162@CGUseItemR:

; 13799: 		{
; 13800: 			if ( (gObj[aIndex].Strength + gObj[aIndex].AddStrength) < citem->m_RequireStrength )

  028c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  028c6	03 ce		 add	 ecx, esi
  028c8	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv4197[ebp], ecx
  028ce	0f b7 91 fc 00
	00 00		 movzx	 edx, WORD PTR [ecx+252]
  028d5	0f b7 89 d0 00
	00 00		 movzx	 ecx, WORD PTR [ecx+208]
  028dc	03 d1		 add	 edx, ecx
  028de	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  028e4	0f b7 49 52	 movzx	 ecx, WORD PTR [ecx+82]
  028e8	3b d1		 cmp	 edx, ecx
  028ea	7d 6a		 jge	 SHORT $LN160@CGUseItemR

; 13801: 			{
; 13802: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  028ec	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv4197[ebp]
  028f2	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv435[ebp]
  028f8	d9 80 d8 00 00
	00		 fld	 DWORD PTR [eax+216]
  028fe	0f b7 90 2c 01
	00 00		 movzx	 edx, WORD PTR [eax+300]
  02905	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv435[ebp]
  0290c	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  02911	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4138[ebp], eax
  02917	52		 push	 edx
  02918	6a 01		 push	 1
  0291a	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4138[ebp]
  02920	68 fd 00 00 00	 push	 253			; 000000fdH
  02925	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv4150[ebp]
  0292b	66 8b 85 f8 fe
	ff ff		 mov	 ax, WORD PTR tv4150[ebp]
  02932	0f b7 c8	 movzx	 ecx, ax
  02935	51		 push	 ecx
  02936	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv435[ebp]
  0293c	57		 push	 edi
  0293d	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  02942	83 c4 14	 add	 esp, 20			; 00000014H
  02945	5b		 pop	 ebx
  02946	5f		 pop	 edi
  02947	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02948	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0294b	33 cd		 xor	 ecx, ebp
  0294d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02952	8b e5		 mov	 esp, ebp
  02954	5d		 pop	 ebp
  02955	c3		 ret	 0
$LN160@CGUseItemR:

; 13803: 				return;
; 13804: 			}
; 13805: 			
; 13806: 			if ( (gObj[aIndex].Dexterity + gObj[aIndex].AddDexterity) < citem->m_RequireDexterity )

  02956	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv4197[ebp]
  0295c	0f b7 91 fe 00
	00 00		 movzx	 edx, WORD PTR [ecx+254]
  02963	0f b7 89 d2 00
	00 00		 movzx	 ecx, WORD PTR [ecx+210]
  0296a	03 d1		 add	 edx, ecx
  0296c	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  02972	0f b7 49 54	 movzx	 ecx, WORD PTR [ecx+84]
  02976	3b d1		 cmp	 edx, ecx
  02978	7d 6a		 jge	 SHORT $LN159@CGUseItemR

; 13807: 			{
; 13808: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  0297a	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv4197[ebp]
  02980	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv2173[ebp]
  02986	d9 80 d8 00 00
	00		 fld	 DWORD PTR [eax+216]
  0298c	0f b7 90 2c 01
	00 00		 movzx	 edx, WORD PTR [eax+300]
  02993	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv2173[ebp]
  0299a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0299f	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv2180[ebp], eax
  029a5	52		 push	 edx
  029a6	6a 01		 push	 1
  029a8	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv2180[ebp]
  029ae	68 fd 00 00 00	 push	 253			; 000000fdH
  029b3	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv368[ebp]
  029b9	66 8b 85 f8 fe
	ff ff		 mov	 ax, WORD PTR tv368[ebp]
  029c0	0f b7 c8	 movzx	 ecx, ax
  029c3	51		 push	 ecx
  029c4	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv2173[ebp]
  029ca	57		 push	 edi
  029cb	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  029d0	83 c4 14	 add	 esp, 20			; 00000014H
  029d3	5b		 pop	 ebx
  029d4	5f		 pop	 edi
  029d5	5e		 pop	 esi

; 14467: 	}
; 14468: }

  029d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  029d9	33 cd		 xor	 ecx, ebp
  029db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  029e0	8b e5		 mov	 esp, ebp
  029e2	5d		 pop	 ebp
  029e3	c3		 ret	 0
$LN159@CGUseItemR:

; 13809: 				return;
; 13810: 			}
; 13811: 
; 13812: 			if ( citem->m_Type == ITEMGET(15,18) )	// Scroll of HellBurst

  029e4	ba 12 1e 00 00	 mov	 edx, 7698		; 00001e12H
  029e9	66 3b c2	 cmp	 ax, dx
  029ec	0f 85 83 00 00
	00		 jne	 $LN351@CGUseItemR

; 13813: 			{
; 13814: 				if ( g_QuestInfo.GetQuestState(&gObj[aIndex], 2) != 2 )

  029f2	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv4197[ebp]
  029f8	6a 02		 push	 2
  029fa	50		 push	 eax
  029fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  02a00	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  02a05	83 f8 02	 cmp	 eax, 2

; 13815: 				{
; 13816: 					GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  02a08	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02a0d	74 6b		 je	 SHORT $LN157@CGUseItemR
  02a0f	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  02a16	0f b7 8c 06 2c
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+300]
  02a1e	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv621[ebp]
  02a24	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv621[ebp]
  02a2b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  02a30	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv4119[ebp], eax
  02a36	51		 push	 ecx
  02a37	6a 01		 push	 1
  02a39	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv4119[ebp]
  02a3f	68 fd 00 00 00	 push	 253			; 000000fdH
  02a44	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv595[ebp]
  02a4a	66 8b 95 f8 fe
	ff ff		 mov	 dx, WORD PTR tv595[ebp]
  02a51	0f b7 c2	 movzx	 eax, dx
  02a54	50		 push	 eax
  02a55	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv621[ebp]
  02a5b	57		 push	 edi
  02a5c	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  02a61	83 c4 14	 add	 esp, 20			; 00000014H
  02a64	5b		 pop	 ebx
  02a65	5f		 pop	 edi
  02a66	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02a67	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02a6a	33 cd		 xor	 ecx, ebp
  02a6c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02a71	8b e5		 mov	 esp, ebp
  02a73	5d		 pop	 ebp
  02a74	c3		 ret	 0
$LN351@CGUseItemR:

; 13817: 					return;

  02a75	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN157@CGUseItemR:

; 13818: 				}
; 13819: 			}
; 13820: 
; 13821: 			if (citem->m_Type >= ITEMGET(12,8) && citem->m_Type <= ITEMGET(12,24))

  02a7a	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  02a80	0f b7 49 06	 movzx	 ecx, WORD PTR [ecx+6]
  02a84	ba 08 18 00 00	 mov	 edx, 6152		; 00001808H
  02a89	66 3b ca	 cmp	 cx, dx
  02a8c	0f 8c 86 00 00
	00		 jl	 $LN155@CGUseItemR
  02a92	ba 18 18 00 00	 mov	 edx, 6168		; 00001818H
  02a97	66 3b ca	 cmp	 cx, dx
  02a9a	7f 7c		 jg	 SHORT $LN155@CGUseItemR

; 13822: 			{
; 13823: 				if ( gObj[aIndex].Level < citem->m_RequireLevel )	// Orbs

  02a9c	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  02aa2	0f bf 8c 06 96
	00 00 00	 movsx	 ecx, WORD PTR [esi+eax+150]
  02aaa	0f b7 52 58	 movzx	 edx, WORD PTR [edx+88]
  02aae	3b ca		 cmp	 ecx, edx
  02ab0	7d 66		 jge	 SHORT $LN155@CGUseItemR

; 13824: 				{
; 13825: 					GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  02ab2	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  02ab9	0f b7 8c 06 2c
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+300]
  02ac1	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv539[ebp]
  02ac7	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv539[ebp]
  02ace	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  02ad3	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv556[ebp], eax
  02ad9	51		 push	 ecx
  02ada	6a 01		 push	 1
  02adc	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv556[ebp]
  02ae2	68 fd 00 00 00	 push	 253			; 000000fdH
  02ae7	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv582[ebp]
  02aed	66 8b 95 f8 fe
	ff ff		 mov	 dx, WORD PTR tv582[ebp]
  02af4	0f b7 c2	 movzx	 eax, dx
  02af7	50		 push	 eax
  02af8	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv539[ebp]
  02afe	57		 push	 edi
  02aff	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  02b04	83 c4 14	 add	 esp, 20			; 00000014H
  02b07	5b		 pop	 ebx
  02b08	5f		 pop	 edi
  02b09	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02b0a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02b0d	33 cd		 xor	 ecx, ebp
  02b0f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02b14	8b e5		 mov	 esp, ebp
  02b16	5d		 pop	 ebp
  02b17	c3		 ret	 0
$LN155@CGUseItemR:

; 13826: 					return;
; 13827: 				}
; 13828: 			}
; 13829: 
; 13830: 			WORD skillnumber;
; 13831: 
; 13832: 			if ( citem->IsClass((char)gObj[aIndex].Class, gObj[aIndex].ChangeUP,gObj[aIndex].ChangeUP2) == FALSE )

  02b18	0f b6 8c 06 94
	00 00 00	 movzx	 ecx, BYTE PTR [esi+eax+148]
  02b20	0f b6 94 06 93
	00 00 00	 movzx	 edx, BYTE PTR [esi+eax+147]
  02b28	0f b6 84 06 90
	00 00 00	 movzx	 eax, BYTE PTR [esi+eax+144]
  02b30	51		 push	 ecx
  02b31	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  02b37	52		 push	 edx
  02b38	50		 push	 eax
  02b39	e8 00 00 00 00	 call	 ?IsClass@CItem@@QAEHDHH@Z ; CItem::IsClass
  02b3e	85 c0		 test	 eax, eax
  02b40	75 21		 jne	 SHORT $LN154@CGUseItemR

; 13833: 			{	
; 13834: 				GCInventoryItemDeleteSend(aIndex, -1, 1);

  02b42	6a 01		 push	 1
  02b44	68 ff 00 00 00	 push	 255			; 000000ffH
  02b49	57		 push	 edi
  02b4a	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  02b4f	83 c4 0c	 add	 esp, 12			; 0000000cH
  02b52	5b		 pop	 ebx
  02b53	5f		 pop	 edi
  02b54	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02b55	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02b58	33 cd		 xor	 ecx, ebp
  02b5a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02b5f	8b e5		 mov	 esp, ebp
  02b61	5d		 pop	 ebp
  02b62	c3		 ret	 0
$LN154@CGUseItemR:

; 13835: 			}
; 13836: 			else
; 13837: 			{
; 13838: 				int addskill = gObjMagicAdd(&gObj[aIndex], citem->m_Type>>(9), citem->m_Type %  MAX_SUBTYPE_ITEMS,citem->m_Level, skillnumber);

  02b63	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  02b69	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  02b6d	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  02b71	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _skillnumber$222483[ebp]
  02b77	52		 push	 edx
  02b78	0f bf d0	 movsx	 edx, ax
  02b7b	81 e2 ff 01 00
	80		 and	 edx, -2147483137	; 800001ffH
  02b81	51		 push	 ecx
  02b82	79 08		 jns	 SHORT $LN377@CGUseItemR
  02b84	4a		 dec	 edx
  02b85	81 ca 00 fe ff
	ff		 or	 edx, -512		; fffffe00H
  02b8b	42		 inc	 edx
$LN377@CGUseItemR:
  02b8c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02b92	66 c1 f8 09	 sar	 ax, 9
  02b96	52		 push	 edx
  02b97	0f b6 c0	 movzx	 eax, al
  02b9a	50		 push	 eax
  02b9b	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  02b9e	52		 push	 edx
  02b9f	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EEEAAG@Z ; gObjMagicAdd
  02ba4	83 c4 14	 add	 esp, 20			; 00000014H
  02ba7	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _addskill$222487[ebp], eax

; 13839: 
; 13840: 				if ( addskill >= 0 )

  02bad	85 c0		 test	 eax, eax
  02baf	78 37		 js	 SHORT $LN152@CGUseItemR

; 13841: 				{
; 13842: 					gObjInventoryItemSet(aIndex, pos, -1);

  02bb1	68 ff 00 00 00	 push	 255			; 000000ffH
  02bb6	53		 push	 ebx
  02bb7	57		 push	 edi
  02bb8	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13843: 					GCMagicListOneSend(aIndex, addskill, skillnumber, citem->m_Level, 0, 0);

  02bbd	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _citem$[ebp]
  02bc3	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  02bc7	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _skillnumber$222483[ebp]
  02bcd	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _addskill$222487[ebp]
  02bd3	6a 00		 push	 0
  02bd5	6a 00		 push	 0
  02bd7	51		 push	 ecx
  02bd8	52		 push	 edx
  02bd9	50		 push	 eax
  02bda	57		 push	 edi
  02bdb	e8 00 00 00 00	 call	 ?GCMagicListOneSend@@YAXHDGEEE@Z ; GCMagicListOneSend
  02be0	83 c4 24	 add	 esp, 36			; 00000024H

; 13844: 					gObj[aIndex].pInventory[pos].Clear();
; 13845: 					GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13846: 				}
; 13847: 				else

  02be3	e9 50 05 00 00	 jmp	 $LN382@CGUseItemR
$LN152@CGUseItemR:

; 13848: 				{
; 13849: 					GCInventoryItemDeleteSend(aIndex, -1, 1);

  02be8	6a 01		 push	 1
  02bea	68 ff 00 00 00	 push	 255			; 000000ffH
  02bef	57		 push	 edi
  02bf0	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  02bf5	83 c4 0c	 add	 esp, 12			; 0000000cH
  02bf8	5b		 pop	 ebx
  02bf9	5f		 pop	 edi
  02bfa	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02bfb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02bfe	33 cd		 xor	 ecx, ebp
  02c00	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02c05	8b e5		 mov	 esp, ebp
  02c07	5d		 pop	 ebp
  02c08	c3		 ret	 0
$LN180@CGUseItemR:

; 13679: 		{
; 13680: 			switch( citem->m_Type)

  02c09	98		 cwde
  02c0a	2d 3f 1c 00 00	 sub	 eax, 7231		; 00001c3fH
  02c0f	74 4e		 je	 SHORT $LN177@CGUseItemR
  02c11	48		 dec	 eax
  02c12	0f 85 bb 00 00
	00		 jne	 $LN178@CGUseItemR

; 13685: 				break;
; 13686: 			case ITEMGET(14,64):
; 13687: 				gObj[aIndex].Mana = gObj[aIndex].MaxMana + gObj[aIndex].AddMana;

  02c18	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02c1d	db 84 06 28 01
	00 00		 fild	 DWORD PTR [esi+eax+296]
  02c24	d8 84 06 f0 00
	00 00		 fadd	 DWORD PTR [esi+eax+240]
  02c2b	d9 9c 06 ec 00
	00 00		 fstp	 DWORD PTR [esi+eax+236]

; 13688: 				GCManaSend(aIndex,(WORD)gObj[aIndex].Mana,0xFF,0,gObj[aIndex].BP);

  02c32	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02c37	0f b7 94 06 04
	01 00 00	 movzx	 edx, WORD PTR [esi+eax+260]
  02c3f	d9 84 06 ec 00
	00 00		 fld	 DWORD PTR [esi+eax+236]
  02c46	52		 push	 edx
  02c47	6a 00		 push	 0
  02c49	68 ff 00 00 00	 push	 255			; 000000ffH
  02c4e	e8 00 00 00 00	 call	 __ftol2_sse
  02c53	0f b7 c0	 movzx	 eax, ax
  02c56	50		 push	 eax
  02c57	57		 push	 edi
  02c58	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend

; 13689: 				break;

  02c5d	eb 71		 jmp	 SHORT $LN380@CGUseItemR
$LN177@CGUseItemR:

; 13681: 			{
; 13682: 			case ITEMGET(14,63):
; 13683: 				gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  02c5f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13684: 				GCReFillSend(aIndex,(WORD)gObj[aIndex].Life,0xFF,0,gObj[aIndex].iShield);

  02c64	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv1989[ebp]
  02c6a	db 84 06 24 01
	00 00		 fild	 DWORD PTR [esi+eax+292]
  02c71	d8 84 06 dc 00
	00 00		 fadd	 DWORD PTR [esi+eax+220]
  02c78	d9 9c 06 d8 00
	00 00		 fstp	 DWORD PTR [esi+eax+216]
  02c7f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02c84	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  02c8b	0f b7 8c 06 2c
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+300]
  02c93	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv1989[ebp]
  02c9a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  02c9f	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv2366[ebp], eax
  02ca5	51		 push	 ecx
  02ca6	6a 00		 push	 0
  02ca8	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv2366[ebp]
  02cae	68 ff 00 00 00	 push	 255			; 000000ffH
  02cb3	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv2369[ebp]
  02cb9	66 8b 95 f8 fe
	ff ff		 mov	 dx, WORD PTR tv2369[ebp]
  02cc0	0f b7 c2	 movzx	 eax, dx
  02cc3	50		 push	 eax
  02cc4	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv1989[ebp]
  02cca	57		 push	 edi
  02ccb	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
$LN380@CGUseItemR:
  02cd0	83 c4 14	 add	 esp, 20			; 00000014H
$LN178@CGUseItemR:

; 13690: 			}
; 13691: 
; 13692: 			if(gObjSearchItemMinus(&gObj[aIndex],pos,1) == FALSE)

  02cd3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02cd9	6a 01		 push	 1
  02cdb	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  02cde	53		 push	 ebx
  02cdf	52		 push	 edx
  02ce0	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  02ce5	83 c4 0c	 add	 esp, 12			; 0000000cH
  02ce8	85 c0		 test	 eax, eax
  02cea	0f 85 f8 04 00
	00		 jne	 $LN358@CGUseItemR

; 13693: 			{
; 13694: 				gObjInventoryItemSet(aIndex,pos,0xFF);

  02cf0	68 ff 00 00 00	 push	 255			; 000000ffH
  02cf5	53		 push	 ebx
  02cf6	57		 push	 edi
  02cf7	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13695: 				gObj[aIndex].pInventory[pos].Clear();

  02cfc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02d01	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  02d08	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  02d0e	83 c4 0c	 add	 esp, 12			; 0000000cH
  02d11	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13696: 				GCInventoryItemDeleteSend(aIndex,pos,1);

  02d16	6a 01		 push	 1
  02d18	53		 push	 ebx
  02d19	57		 push	 edi
  02d1a	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  02d1f	83 c4 0c	 add	 esp, 12			; 0000000cH
  02d22	5b		 pop	 ebx
  02d23	5f		 pop	 edi
  02d24	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02d25	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02d28	33 cd		 xor	 ecx, ebp
  02d2a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02d2f	8b e5		 mov	 esp, ebp
  02d31	5d		 pop	 ebp
  02d32	c3		 ret	 0
$LN254@CGUseItemR:

; 13345: 		{
; 13346: 			int tMana = (citem->m_Value*10) - (gObj[aIndex].Level);	// #formula

  02d33	8b 49 70	 mov	 ecx, DWORD PTR [ecx+112]
  02d36	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02d3c	0f bf 94 16 96
	00 00 00	 movsx	 edx, WORD PTR [esi+edx+150]
  02d44	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  02d47	03 c9		 add	 ecx, ecx
  02d49	2b ca		 sub	 ecx, edx
  02d4b	89 8d ec fe ff
	ff		 mov	 DWORD PTR _tMana$222340[ebp], ecx

; 13347: 
; 13348: 			if ( tMana < 0 )

  02d51	79 0a		 jns	 SHORT $LN253@CGUseItemR

; 13349: 			{
; 13350: 				tMana=0;

  02d53	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tMana$222340[ebp], 0
$LN253@CGUseItemR:

; 13351: 			}
; 13352: 
; 13353: 			switch ( citem->m_Type )

  02d5d	98		 cwde
  02d5e	2d 04 1c 00 00	 sub	 eax, 7172		; 00001c04H
  02d63	74 63		 je	 SHORT $LN250@CGUseItemR
  02d65	48		 dec	 eax
  02d66	74 26		 je	 SHORT $LN249@CGUseItemR
  02d68	48		 dec	 eax
  02d69	0f 85 8f 00 00
	00		 jne	 $LN356@CGUseItemR

; 13361: 				case ITEMGET(14,6):	// Large Mana Potion
; 13362: 					tMana += ((int)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana))*40/100; 

  02d6f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02d74	db 84 06 28 01
	00 00		 fild	 DWORD PTR [esi+eax+296]
  02d7b	d8 84 06 f0 00
	00 00		 fadd	 DWORD PTR [esi+eax+240]
  02d82	e8 00 00 00 00	 call	 __ftol2_sse
  02d87	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  02d8a	03 c9		 add	 ecx, ecx

; 13363: 					break;

  02d8c	eb 55		 jmp	 SHORT $LN381@CGUseItemR
$LN249@CGUseItemR:

; 13357: 					break;
; 13358: 				case ITEMGET(14,5):	// Mana Potion
; 13359: 					tMana += ((int)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana))*30/100; 

  02d8e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02d93	db 84 06 28 01
	00 00		 fild	 DWORD PTR [esi+eax+296]
  02d9a	d8 84 06 f0 00
	00 00		 fadd	 DWORD PTR [esi+eax+240]
  02da1	e8 00 00 00 00	 call	 __ftol2_sse
  02da6	8b c8		 mov	 ecx, eax
  02da8	c1 e1 04	 shl	 ecx, 4
  02dab	2b c8		 sub	 ecx, eax
  02dad	03 c9		 add	 ecx, ecx
  02daf	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  02db4	f7 e9		 imul	 ecx
  02db6	c1 fa 05	 sar	 edx, 5
  02db9	8b ca		 mov	 ecx, edx
  02dbb	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  02dbe	03 ca		 add	 ecx, edx
  02dc0	01 8d ec fe ff
	ff		 add	 DWORD PTR _tMana$222340[ebp], ecx

; 13360: 					break;

  02dc6	eb 36		 jmp	 SHORT $LN356@CGUseItemR
$LN250@CGUseItemR:

; 13354: 			{
; 13355: 				case ITEMGET(14,4):	// Small Mana Potion
; 13356: 					tMana += ((int)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana))*20/100; 

  02dc8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02dcd	db 84 06 28 01
	00 00		 fild	 DWORD PTR [esi+eax+296]
  02dd4	d8 84 06 f0 00
	00 00		 fadd	 DWORD PTR [esi+eax+240]
  02ddb	e8 00 00 00 00	 call	 __ftol2_sse
  02de0	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
$LN381@CGUseItemR:
  02de3	03 c9		 add	 ecx, ecx
  02de5	03 c9		 add	 ecx, ecx
  02de7	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  02dec	f7 e9		 imul	 ecx
  02dee	c1 fa 05	 sar	 edx, 5
  02df1	8b c2		 mov	 eax, edx
  02df3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  02df6	03 c2		 add	 eax, edx
  02df8	01 85 ec fe ff
	ff		 add	 DWORD PTR _tMana$222340[ebp], eax
$LN356@CGUseItemR:

; 13364: 			}
; 13365: 
; 13366: 			gObj[aIndex].Mana += tMana;

  02dfe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02e04	db 85 ec fe ff
	ff		 fild	 DWORD PTR _tMana$222340[ebp]
  02e0a	8d 84 0e ec 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+236]
  02e11	d8 00		 fadd	 DWORD PTR [eax]
  02e13	d9 18		 fstp	 DWORD PTR [eax]

; 13367: 
; 13368: 			if ( gObj[aIndex].Mana > (gObj[aIndex].MaxMana+gObj[aIndex].AddMana-1.0f) )

  02e15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02e1b	db 84 0e 28 01
	00 00		 fild	 DWORD PTR [esi+ecx+296]
  02e22	8d 94 0e ec 00
	00 00		 lea	 edx, DWORD PTR [esi+ecx+236]
  02e29	d8 84 0e f0 00
	00 00		 fadd	 DWORD PTR [esi+ecx+240]
  02e30	d9 02		 fld	 DWORD PTR [edx]
  02e32	d9 c1		 fld	 ST(1)
  02e34	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  02e3a	de d9		 fcompp
  02e3c	df e0		 fnstsw	 ax
  02e3e	f6 c4 05	 test	 ah, 5
  02e41	7a 0a		 jp	 SHORT $LN369@CGUseItemR

; 13369: 				gObj[aIndex].Mana = gObj[aIndex].MaxMana+gObj[aIndex].AddMana;

  02e43	d9 1a		 fstp	 DWORD PTR [edx]
  02e45	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02e4b	eb 02		 jmp	 SHORT $LN247@CGUseItemR
$LN369@CGUseItemR:
  02e4d	dd d8		 fstp	 ST(0)
$LN247@CGUseItemR:

; 13370: 			
; 13371: 			GCManaSend(aIndex, (WORD)gObj[aIndex].Mana, 0xFF, 0, gObj[aIndex].BP);

  02e4f	0f b7 94 0e 04
	01 00 00	 movzx	 edx, WORD PTR [esi+ecx+260]
  02e57	d9 84 0e ec 00
	00 00		 fld	 DWORD PTR [esi+ecx+236]
  02e5e	52		 push	 edx
  02e5f	6a 00		 push	 0
  02e61	68 ff 00 00 00	 push	 255			; 000000ffH
  02e66	e8 00 00 00 00	 call	 __ftol2_sse
  02e6b	0f b7 c0	 movzx	 eax, ax
  02e6e	50		 push	 eax
  02e6f	57		 push	 edi
  02e70	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend

; 13372: 
; 13373: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  02e75	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02e7b	6a 01		 push	 1
  02e7d	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  02e80	53		 push	 ebx
  02e81	52		 push	 edx
  02e82	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  02e87	83 c4 20	 add	 esp, 32			; 00000020H
  02e8a	85 c0		 test	 eax, eax
  02e8c	0f 85 56 03 00
	00		 jne	 $LN358@CGUseItemR

; 13374: 			{
; 13375: 				gObjInventoryItemSet(aIndex, pos, -1);

  02e92	68 ff 00 00 00	 push	 255			; 000000ffH
  02e97	53		 push	 ebx
  02e98	57		 push	 edi
  02e99	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13376: 				gObj[aIndex].pInventory[pos].Clear();

  02e9e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02ea3	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  02eaa	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  02eb0	83 c4 0c	 add	 esp, 12			; 0000000cH
  02eb3	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13377: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  02eb8	6a 01		 push	 1
  02eba	53		 push	 ebx
  02ebb	57		 push	 edi
  02ebc	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  02ec1	83 c4 0c	 add	 esp, 12			; 0000000cH
  02ec4	5b		 pop	 ebx
  02ec5	5f		 pop	 edi
  02ec6	5e		 pop	 esi

; 14467: 	}
; 14468: }

  02ec7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02eca	33 cd		 xor	 ecx, ebp
  02ecc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02ed1	8b e5		 mov	 esp, ebp
  02ed3	5d		 pop	 ebp
  02ed4	c3		 ret	 0
$LN274@CGUseItemR:

; 13264: 		{
; 13265: 			int tLife = (citem->m_Value*10) - (gObj[aIndex].Level*2);	// #formula

  02ed5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02edb	8b 49 70	 mov	 ecx, DWORD PTR [ecx+112]
  02ede	0f bf 94 16 96
	00 00 00	 movsx	 edx, WORD PTR [esi+edx+150]
  02ee6	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  02ee9	2b ca		 sub	 ecx, edx
  02eeb	03 c9		 add	 ecx, ecx
  02eed	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _tLife$222312[ebp], ecx

; 13266: 
; 13267: 			if ( tLife <  0 )

  02ef3	79 0a		 jns	 SHORT $LN353@CGUseItemR

; 13268: 			{
; 13269: 				tLife = 0;

  02ef5	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tLife$222312[ebp], 0
$LN353@CGUseItemR:

; 13270: 			}
; 13271: 
; 13272: 			int nAddRate=0;
; 13273: 
; 13274: 			switch ( citem->m_Type )

  02eff	98		 cwde
  02f00	05 00 e4 ff ff	 add	 eax, -7168		; ffffe400H
  02f05	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _nAddRate$222314[ebp], 0
  02f0f	83 f8 03	 cmp	 eax, 3
  02f12	77 35		 ja	 SHORT $LN271@CGUseItemR
  02f14	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN399@CGUseItemR[eax*4]
$LN270@CGUseItemR:

; 13275: 			{
; 13276: 				case ITEMGET(14,0):	// Apple
; 13277: 					nAddRate = 10;

  02f1b	c7 85 f4 fe ff
	ff 0a 00 00 00	 mov	 DWORD PTR _nAddRate$222314[ebp], 10 ; 0000000aH

; 13278: 					break;

  02f25	eb 22		 jmp	 SHORT $LN271@CGUseItemR
$LN269@CGUseItemR:

; 13279: 				case ITEMGET(14,1):	// 
; 13280: 					nAddRate = 20;

  02f27	c7 85 f4 fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _nAddRate$222314[ebp], 20 ; 00000014H

; 13281: 					break;

  02f31	eb 16		 jmp	 SHORT $LN271@CGUseItemR
$LN268@CGUseItemR:

; 13282: 				case ITEMGET(14,2):	// 
; 13283: 					nAddRate = 30;

  02f33	c7 85 f4 fe ff
	ff 1e 00 00 00	 mov	 DWORD PTR _nAddRate$222314[ebp], 30 ; 0000001eH

; 13284: 					break;

  02f3d	eb 0a		 jmp	 SHORT $LN271@CGUseItemR
$LN267@CGUseItemR:

; 13285: 				case ITEMGET(14,3):	// 
; 13286: 					nAddRate = 40;

  02f3f	c7 85 f4 fe ff
	ff 28 00 00 00	 mov	 DWORD PTR _nAddRate$222314[ebp], 40 ; 00000028H
$LN271@CGUseItemR:

; 13287: 					break;
; 13288: 			}
; 13289: 
; 13290: 			if ( citem->m_Level == 1 )	// #formula

  02f49	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _citem$[ebp]
  02f4f	66 83 78 08 01	 cmp	 WORD PTR [eax+8], 1
  02f54	75 07		 jne	 SHORT $LN266@CGUseItemR

; 13291: 			{
; 13292: 				nAddRate += 5;

  02f56	83 85 f4 fe ff
	ff 05		 add	 DWORD PTR _nAddRate$222314[ebp], 5
$LN266@CGUseItemR:

; 13293: 			}
; 13294: 
; 13295: 			tLife += ((int)gObj[aIndex].MaxLife * nAddRate) / 100;	// #formula

  02f5d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02f63	d9 84 0e dc 00
	00 00		 fld	 DWORD PTR [esi+ecx+220]
  02f6a	e8 00 00 00 00	 call	 __ftol2_sse
  02f6f	8b c8		 mov	 ecx, eax
  02f71	0f af 8d f4 fe
	ff ff		 imul	 ecx, DWORD PTR _nAddRate$222314[ebp]
  02f78	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  02f7d	f7 e9		 imul	 ecx
  02f7f	c1 fa 05	 sar	 edx, 5
  02f82	8b c2		 mov	 eax, edx
  02f84	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  02f87	03 c2		 add	 eax, edx
  02f89	01 85 f0 fe ff
	ff		 add	 DWORD PTR _tLife$222312[ebp], eax

; 13296: 
; 13297: 			if ( citem->m_Type == ITEMGET(14,0) )
; 13298: 			{
; 13299: 				if ( citem->m_Level < 2 )

  02f8f	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  02f95	b9 00 1c 00 00	 mov	 ecx, 7168		; 00001c00H
  02f9a	66 39 8d f8 fe
	ff ff		 cmp	 WORD PTR tv4891[ebp], cx
  02fa1	75 2a		 jne	 SHORT $LN264@CGUseItemR
  02fa3	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  02fa7	66 83 f8 02	 cmp	 ax, 2
  02fab	7d 20		 jge	 SHORT $LN264@CGUseItemR

; 13300: 				{
; 13301: 					gObj[aIndex].FillLife += tLife;

  02fad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02fb2	db 85 f0 fe ff
	ff		 fild	 DWORD PTR _tLife$222312[ebp]
  02fb8	8d 84 06 e4 00
	00 00		 lea	 eax, DWORD PTR [esi+eax+228]

; 13302: 					tLife = 0;

  02fbf	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tLife$222312[ebp], 0
  02fc9	d8 00		 fadd	 DWORD PTR [eax]
  02fcb	d9 18		 fstp	 DWORD PTR [eax]
$LN264@CGUseItemR:

; 13303: 				}
; 13304: 			}
; 13305: 
; 13306: 			if ( gObj[aIndex].FillLife > 0.0f )

  02fcd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02fd3	d9 ee		 fldz
  02fd5	d8 94 0e e4 00
	00 00		 fcom	 DWORD PTR [esi+ecx+228]
  02fdc	8d 8c 0e e4 00
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+228]
  02fe3	df e0		 fnstsw	 ax
  02fe5	f6 c4 05	 test	 ah, 5
  02fe8	0f 8a b8 00 00
	00		 jp	 $LN372@CGUseItemR

; 13307: 			{
; 13308: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  02fee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02ff4	d9 84 16 d8 00
	00 00		 fld	 DWORD PTR [esi+edx+216]
  02ffb	8d 84 16 d8 00
	00 00		 lea	 eax, DWORD PTR [esi+edx+216]
  03002	d8 01		 fadd	 DWORD PTR [ecx]
  03004	d9 18		 fstp	 DWORD PTR [eax]

; 13309: 
; 13310: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife +gObj[aIndex].AddLife) )

  03006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0300c	db 84 0e 24 01
	00 00		 fild	 DWORD PTR [esi+ecx+292]
  03013	8d 94 0e d8 00
	00 00		 lea	 edx, DWORD PTR [esi+ecx+216]
  0301a	d8 84 0e dc 00
	00 00		 fadd	 DWORD PTR [esi+ecx+220]
  03021	d9 02		 fld	 DWORD PTR [edx]
  03023	d8 d9		 fcomp	 ST(1)
  03025	df e0		 fnstsw	 ax
  03027	f6 c4 41	 test	 ah, 65			; 00000041H
  0302a	75 16		 jne	 SHORT $LN375@CGUseItemR

; 13311: 				{
; 13312: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  0302c	d9 1a		 fstp	 DWORD PTR [edx]

; 13313: 					gObj[aIndex].FillLife = 0;

  0302e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03033	d9 9c 06 e4 00
	00 00		 fstp	 DWORD PTR [esi+eax+228]
  0303a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03040	eb 04		 jmp	 SHORT $LN262@CGUseItemR
$LN375@CGUseItemR:
  03042	dd d8		 fstp	 ST(0)
  03044	dd d8		 fstp	 ST(0)
$LN262@CGUseItemR:

; 13314: 				}
; 13315: 
; 13316: 				GCReFillSend(gObj[aIndex].m_Index,(WORD)gObj[aIndex].Life, 0xFF, FALSE, gObj[aIndex].iShield);

  03046	d9 84 0e d8 00
	00 00		 fld	 DWORD PTR [esi+ecx+216]
  0304d	0f b7 94 0e 2c
	01 00 00	 movzx	 edx, WORD PTR [esi+ecx+300]
  03055	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv3049[ebp]
  0305b	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv3049[ebp]
  03062	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  03067	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv2994[ebp], eax
  0306d	52		 push	 edx
  0306e	6a 00		 push	 0
  03070	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv2994[ebp]
  03076	68 ff 00 00 00	 push	 255			; 000000ffH
  0307b	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv3957[ebp]
  03081	66 8b 85 f8 fe
	ff ff		 mov	 ax, WORD PTR tv3957[ebp]
  03088	0f b7 d0	 movzx	 edx, ax
  0308b	8b 04 0e	 mov	 eax, DWORD PTR [esi+ecx]
  0308e	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv3049[ebp]
  03094	52		 push	 edx
  03095	50		 push	 eax
  03096	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  0309b	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  030a1	83 c4 14	 add	 esp, 20			; 00000014H
  030a4	eb 02		 jmp	 SHORT $LN263@CGUseItemR
$LN372@CGUseItemR:
  030a6	dd d8		 fstp	 ST(0)
$LN263@CGUseItemR:

; 13317: 			}
; 13318: 
; 13319: 			gObj[aIndex].FillLifeMax = (float)tLife;

  030a8	db 85 f0 fe ff
	ff		 fild	 DWORD PTR _tLife$222312[ebp]
  030ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  030b4	d9 9d f8 fe ff
	ff		 fstp	 DWORD PTR tv4784[ebp]
  030ba	d9 85 f8 fe ff
	ff		 fld	 DWORD PTR tv4784[ebp]
  030c0	d9 94 0e e8 00
	00 00		 fst	 DWORD PTR [esi+ecx+232]

; 13320: 			gObj[aIndex].FillLife = (float)tLife;

  030c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13321: 
; 13322: 			if ( citem->m_Type == ITEMGET(14,0) && citem->m_Level < 2 )

  030cc	b9 00 1c 00 00	 mov	 ecx, 7168		; 00001c00H
  030d1	d9 9c 06 e4 00
	00 00		 fstp	 DWORD PTR [esi+eax+228]
  030d8	66 39 4a 06	 cmp	 WORD PTR [edx+6], cx
  030dc	75 17		 jne	 SHORT $LN261@CGUseItemR
  030de	66 83 7a 08 02	 cmp	 WORD PTR [edx+8], 2
  030e3	7d 10		 jge	 SHORT $LN261@CGUseItemR

; 13323: 			{
; 13324: 				gObj[aIndex].FillLifeCount = 0;

  030e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  030eb	c6 84 16 fb 00
	00 00 00	 mov	 BYTE PTR [esi+edx+251], 0
  030f3	eb 17		 jmp	 SHORT $LN259@CGUseItemR
$LN261@CGUseItemR:

; 13325: 			}
; 13326: 			else if ( citem->m_Level == 1 )

  030f5	66 83 7a 08 01	 cmp	 WORD PTR [edx+8], 1
  030fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03100	0f 95 c0	 setne	 al
  03103	04 02		 add	 al, 2
  03105	88 84 0e fb 00
	00 00		 mov	 BYTE PTR [esi+ecx+251], al
$LN259@CGUseItemR:

; 13327: 			{
; 13328: 				gObj[aIndex].FillLifeCount = 2;
; 13329: 			}
; 13330: 			else
; 13331: 			{
; 13332: 				gObj[aIndex].FillLifeCount = 3;
; 13333: 			}
; 13334: 
; 13335: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  0310c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03112	6a 01		 push	 1
  03114	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  03117	53		 push	 ebx
  03118	50		 push	 eax
  03119	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  0311e	83 c4 0c	 add	 esp, 12			; 0000000cH
  03121	85 c0		 test	 eax, eax
  03123	0f 85 bf 00 00
	00		 jne	 $LN358@CGUseItemR
$LN386@CGUseItemR:

; 13336: 			{
; 13337: 				gObjInventoryItemSet(aIndex, pos, -1);

  03129	68 ff 00 00 00	 push	 255			; 000000ffH
  0312e	53		 push	 ebx
  0312f	57		 push	 edi
  03130	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  03135	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN382@CGUseItemR:

; 13338: 				gObj[aIndex].pInventory[pos].Clear();

  03138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0313e	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
$LN385@CGUseItemR:
  03145	03 8d e8 fe ff
	ff		 add	 ecx, DWORD PTR tv4235[ebp]
  0314b	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13339: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  03150	6a 01		 push	 1
  03152	53		 push	 ebx
  03153	57		 push	 edi
  03154	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  03159	83 c4 0c	 add	 esp, 12			; 0000000cH
  0315c	5b		 pop	 ebx
  0315d	5f		 pop	 edi
  0315e	5e		 pop	 esi

; 14467: 	}
; 14468: }

  0315f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  03162	33 cd		 xor	 ecx, ebp
  03164	e8 00 00 00 00	 call	 @__security_check_cookie@4
  03169	8b e5		 mov	 esp, ebp
  0316b	5d		 pop	 ebp
  0316c	c3		 ret	 0
$LN279@CGUseItemR:

; 14460: 		}
; 14461: 	}
; 14462: 	else
; 14463: 	{
; 14464: 		GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  0316d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03172	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv2886[ebp]
  03178	d9 84 06 d8 00
	00 00		 fld	 DWORD PTR [esi+eax+216]
  0317f	0f b7 94 06 2c
	01 00 00	 movzx	 edx, WORD PTR [esi+eax+300]
  03187	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv2886[ebp]
  0318e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  03193	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv2865[ebp], eax
  03199	52		 push	 edx
  0319a	6a 01		 push	 1
  0319c	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv2865[ebp]
  031a2	68 fd 00 00 00	 push	 253			; 000000fdH
  031a7	db 9d f8 fe ff
	ff		 fistp	 DWORD PTR tv2856[ebp]
  031ad	66 8b 85 f8 fe
	ff ff		 mov	 ax, WORD PTR tv2856[ebp]
  031b4	0f b7 c8	 movzx	 ecx, ax
  031b7	51		 push	 ecx
  031b8	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv2886[ebp]
  031be	57		 push	 edi
  031bf	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 14465: 		LogAdd("error-L3 : %s return %s %d %d",
; 14466: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);

  031c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  031ca	53		 push	 ebx
  031cb	68 82 38 00 00	 push	 14466			; 00003882H
  031d0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  031d5	8d 44 16 5d	 lea	 eax, DWORD PTR [esi+edx+93]
  031d9	50		 push	 eax
  031da	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@
$LN378@CGUseItemR:
  031df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  031e5	83 c4 28	 add	 esp, 40			; 00000028H
$LN358@CGUseItemR:

; 14467: 	}
; 14468: }

  031e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  031eb	5b		 pop	 ebx
  031ec	5f		 pop	 edi
  031ed	33 cd		 xor	 ecx, ebp
  031ef	5e		 pop	 esi
  031f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  031f5	8b e5		 mov	 esp, ebp
  031f7	5d		 pop	 ebp
  031f8	c3		 ret	 0
  031f9	8d 49 00	 npad	 3
$LN399@CGUseItemR:
  031fc	00 00 00 00	 DD	 $LN270@CGUseItemR
  03200	00 00 00 00	 DD	 $LN269@CGUseItemR
  03204	00 00 00 00	 DD	 $LN268@CGUseItemR
  03208	00 00 00 00	 DD	 $LN267@CGUseItemR
?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z ENDP		; CGUseItemRecv
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1108 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1109 : 		if (this->_Mysize < _Off)

  00006	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0000c	57		 push	 edi
  0000d	3b c1		 cmp	 eax, ecx
  0000f	73 0a		 jae	 SHORT $LN3@erase

; 1110 : 			_Xran();	// _Off off end

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00016	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN28@erase:
$LN3@erase:

; 1111 : 		if (this->_Mysize - _Off < _Count)

  0001b	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0001e	2b c1		 sub	 eax, ecx
  00020	3b c7		 cmp	 eax, edi
  00022	73 02		 jae	 SHORT $LN2@erase

; 1112 : 			_Count = this->_Mysize - _Off;	// trim _Count

  00024	8b f8		 mov	 edi, eax
$LN2@erase:

; 1113 : 		if (0 < _Count)

  00026	85 ff		 test	 edi, edi
  00028	74 50		 je	 SHORT $LN25@erase

; 1114 : 			{	// move elements down
; 1115 : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 1116 : 				this->_Mysize - _Off - _Count);

  0002a	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0002d	53		 push	 ebx
  0002e	83 fa 10	 cmp	 edx, 16			; 00000010H
  00031	72 04		 jb	 SHORT $LN11@erase
  00033	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00035	eb 02		 jmp	 SHORT $LN12@erase
$LN11@erase:
  00037	8b de		 mov	 ebx, esi
$LN12@erase:
  00039	83 fa 10	 cmp	 edx, 16			; 00000010H
  0003c	72 04		 jb	 SHORT $LN15@erase
  0003e	8b 16		 mov	 edx, DWORD PTR [esi]
  00040	eb 02		 jmp	 SHORT $LN16@erase
$LN15@erase:
  00042	8b d6		 mov	 edx, esi
$LN16@erase:
  00044	2b c7		 sub	 eax, edi
  00046	03 d9		 add	 ebx, ecx
  00048	50		 push	 eax
  00049	03 df		 add	 ebx, edi
  0004b	03 d1		 add	 edx, ecx
  0004d	53		 push	 ebx
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _memmove

; 1117 : 			size_type _Newsize = this->_Mysize - _Count;

  00054	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	2b c7		 sub	 eax, edi

; 1118 : 			_Eos(_Newsize);

  0005c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00060	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00063	5b		 pop	 ebx
  00064	72 0e		 jb	 SHORT $LN23@erase
  00066	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00068	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
  0006c	5f		 pop	 edi

; 1119 : 			}
; 1120 : 		return (*this);

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi

; 1121 : 		}

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8

; 1118 : 			_Eos(_Newsize);

$LN23@erase:
  00074	8b ce		 mov	 ecx, esi
  00076	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
$LN25@erase:

; 1119 : 			}
; 1120 : 		return (*this);

  0007a	5f		 pop	 edi
  0007b	8b c6		 mov	 eax, esi
  0007d	5e		 pop	 esi

; 1121 : 		}

  0007e	5d		 pop	 ebp
  0007f	c2 08 00	 ret	 8
$LN27@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1516 : 		size_type _Num = this->_Alval.max_size();
; 1517 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1518 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T236074 = -12						; size = 12
$T236066 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 3a		 je	 SHORT $LN1@allocate
  0000f	83 f9 ff	 cmp	 ecx, -1
  00012	77 0d		 ja	 SHORT $LN3@allocate
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00021	8d 45 08	 lea	 eax, DWORD PTR $T236066[ebp]
  00024	50		 push	 eax
  00025	8d 4d f4	 lea	 ecx, DWORD PTR $T236074[ebp]
  00028	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T236066[ebp], 0
  0002f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00034	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00039	8d 4d f4	 lea	 ecx, DWORD PTR $T236074[ebp]
  0003c	51		 push	 ecx
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T236074[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00044	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	?CGCloseWindow@@YAXH@Z				; CGCloseWindow
EXTRN	?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A:BYTE	; gQeustNpcTeleport
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
;	COMDAT ?CGCloseWindow@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGCloseWindow@@YAXH@Z PROC				; CGCloseWindow, COMDAT

; 15452: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15453: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000d	8b f7		 mov	 esi, edi
  0000f	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00015	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  0001c	f6 c1 03	 test	 cl, 3
  0001f	0f 84 09 01 00
	00		 je	 $LN7@CGCloseWin
  00025	c1 e9 06	 shr	 ecx, 6
  00028	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0002e	0f 84 fa 00 00
	00		 je	 $LN7@CGCloseWin

; 15454: 	{
; 15455: 		if ( gObj[aIndex].m_IfState.type == 7 )

  00034	83 f9 07	 cmp	 ecx, 7
  00037	0f 84 f1 00 00
	00		 je	 $LN7@CGCloseWin

; 15456: 			return;
; 15457: 
; 15458: 		if ( gObj[aIndex].m_IfState.type == 10 && gObj[aIndex].TargetShopNumber == 229 )	// Marlon

  0003d	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00040	75 2e		 jne	 SHORT $LN5@CGCloseWin
  00042	b9 e5 00 00 00	 mov	 ecx, 229		; 000000e5H
  00047	66 39 8c 06 3a
	06 00 00	 cmp	 WORD PTR [esi+eax+1594], cx
  0004f	75 1f		 jne	 SHORT $LN5@CGCloseWin

; 15459: 		{
; 15460: 			gQeustNpcTeleport.TalkRefDel();

  00051	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A ; gQeustNpcTeleport
  00056	e8 00 00 00 00	 call	 ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ; CQeustNpcTeleport::TalkRefDel

; 15461: 			gObj[aIndex].TargetShopNumber = -1;

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	83 ca ff	 or	 edx, -1
  00063	66 89 94 06 3a
	06 00 00	 mov	 WORD PTR [esi+eax+1594], dx
  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN5@CGCloseWin:

; 15462: 		}
; 15463: 
; 15464: 		if ( gObj[aIndex].m_IfState.type == 3 )

  00070	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  00077	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0007d	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  00083	75 10		 jne	 SHORT $LN4@CGCloseWin

; 15465: 		{
; 15466: 			gObj[aIndex].TargetShopNumber = -1;

  00085	83 ca ff	 or	 edx, -1
  00088	66 89 94 06 3a
	06 00 00	 mov	 WORD PTR [esi+eax+1594], dx
  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN4@CGCloseWin:

; 15467: 		}
; 15468: 
; 15469: 		if ( gObj[aIndex].m_IfState.type == 1 )

  00095	8b 8c 06 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4536]
  0009c	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  000a2	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000a5	75 0e		 jne	 SHORT $LN3@CGCloseWin

; 15470: 		{
; 15471: 			CGTradeCancelButtonRecv(aIndex);

  000a7	57		 push	 edi
  000a8	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b2	83 c4 04	 add	 esp, 4
$LN3@CGCloseWin:

; 15472: 		}
; 15473: 
; 15474: 		if ( gObj[aIndex].m_IfState.type == 6 )

  000b5	8b 94 06 b8 11
	00 00		 mov	 edx, DWORD PTR [esi+eax+4536]
  000bc	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  000c2	81 fa 80 01 00
	00		 cmp	 edx, 384		; 00000180H
  000c8	75 0e		 jne	 SHORT $LN2@CGCloseWin

; 15475: 		{
; 15476: 			CGWarehouseUseEnd(aIndex);

  000ca	57		 push	 edi
  000cb	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd
  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d5	83 c4 04	 add	 esp, 4
$LN2@CGCloseWin:

; 15477: 		}
; 15478: 
; 15479: 		if ( gObj[aIndex].m_IfState.type == 13 )

  000d8	8b 94 06 b8 11
	00 00		 mov	 edx, DWORD PTR [esi+eax+4536]
  000df	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000e2	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  000e8	81 fa 40 03 00
	00		 cmp	 edx, 832		; 00000340H
  000ee	75 19		 jne	 SHORT $LN1@CGCloseWin

; 15480: 		{
; 15481: 			g_ChaosBox.ChaosBoxInit(&gObj[aIndex]);

  000f0	51		 push	 ecx
  000f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  000f6	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 15482: 			gObjInventoryCommit(aIndex);

  000fb	57		 push	 edi
  000fc	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  00101	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00106	83 c4 04	 add	 esp, 4
$LN1@CGCloseWin:

; 15483: 		}
; 15484: 
; 15485: 		gObj[aIndex].m_IfState.state = 0;

  00109	83 a4 06 b8 11
	00 00 c3	 and	 DWORD PTR [esi+eax+4536], -61 ; ffffffc3H

; 15486: 		gObj[aIndex].m_IfState.type = 0;

  00111	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00116	81 a4 06 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [esi+eax+4536], -65473 ; ffff003fH

; 15487: 		gObj[aIndex].m_IfState.use = 0;

  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00126	83 a4 06 b8 11
	00 00 fc	 and	 DWORD PTR [esi+eax+4536], -4 ; fffffffcH
$LN7@CGCloseWin:
  0012e	5f		 pop	 edi
  0012f	5e		 pop	 esi

; 15488: 	}
; 15489: }

  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
?CGCloseWindow@@YAXH@Z ENDP				; CGCloseWindow
_TEXT	ENDS
PUBLIC	??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ; CGRequestEnterChaosCastle
EXTRN	?gObjMonsterCallKill@@YAXH@Z:PROC		; gObjMonsterCallKill
EXTRN	?GetIndex@PartyClass@@QAEHHHH@Z:PROC		; PartyClass::GetIndex
EXTRN	?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::LeaveUserChaosCastle
EXTRN	?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z:PROC	; CChaosCastle::PayUserEnterMoney
EXTRN	?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::EnterUserChaosCastle
EXTRN	?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::CheckUserEnterMoney
EXTRN	?IsTransformEquipment@@YA_NH@Z:PROC		; IsTransformEquipment
EXTRN	?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjDuelCheck
EXTRN	?GetPartyPkLevel@PartyClass@@QAEDH@Z:PROC	; PartyClass::GetPartyPkLevel
;	COMDAT ??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Chaos Castle] (%d) (Account:%s, Name:%s) Entered Chaos Castle'
	DB	' (Guard Mail Set Serial:%d)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z
_TEXT	SEGMENT
tv748 = -556						; size = 4
_dwITEM_SERIAL$ = -552					; size = 4
_btGuardMailSetItemPos$ = -548				; size = 1
_pMsg$223398 = -548					; size = 4
_iENTER_LEVEL$ = -544					; size = 4
_pResult$ = -540					; size = 5
_pNotice$223352 = -532					; size = 272
_pNotice$223342 = -532					; size = 272
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z PROC ; CGRequestEnterChaosCastle, COMDAT

; 15697: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 02 00
	00		 sub	 esp, 556		; 0000022cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 15698: 	if ( !OBJMAX_RANGE(iIndex))

  0001a	85 ff		 test	 edi, edi
  0001c	78 0f		 js	 SHORT $LN62@CGRequestE@3
  0001e	33 c9		 xor	 ecx, ecx
  00020	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00026	0f 9e c1	 setle	 cl
  00029	85 c9		 test	 ecx, ecx
  0002b	75 27		 jne	 SHORT $LN47@CGRequestE@3
$LN62@CGRequestE@3:

; 15699: 	{
; 15700: 		LogAdd("return %s %d", __FILE__, __LINE__);

  0002d	68 54 3d 00 00	 push	 15700			; 00003d54H
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi

; 15948: }

  00046	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN47@CGRequestE@3:
  00054	53		 push	 ebx

; 15701: 		return;
; 15702: 	}
; 15703: 
; 15704: 	BYTE btChaosCastleNumber = lpMsg->iChaosCastleNumber-1;
; 15705: 	BYTE btGuardMailSetItemPos = lpMsg->iItemPos;

  00055	8a 58 05	 mov	 bl, BYTE PTR [eax+5]
  00058	56		 push	 esi

; 15706: 	int iITEM_LEVEL=0;
; 15707: 	DWORD dwITEM_SERIAL=0;
; 15708: 	PMSG_RESULT_MOVECHAOSCASTLE pResult;
; 15709: 
; 15710: 	PHeadSubSetB((LPBYTE)&pResult, 0xAF, 0x01, sizeof(pResult));

  00059	6a 05		 push	 5
  0005b	6a 01		 push	 1
  0005d	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00063	68 af 00 00 00	 push	 175			; 000000afH
  00068	50		 push	 eax
  00069	88 9d dc fd ff
	ff		 mov	 BYTE PTR _btGuardMailSetItemPos$[ebp], bl
  0006f	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 15711: 	pResult.Result = 0;
; 15712: 
; 15713: 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007a	8b f7		 mov	 esi, edi
  0007c	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00082	83 c4 10	 add	 esp, 16			; 00000010H
  00085	c6 85 e8 fd ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+4], 0
  0008c	80 7c 0e 50 01	 cmp	 BYTE PTR [esi+ecx+80], 1
  00091	0f 85 a1 05 00
	00		 jne	 $LN70@CGRequestE@3
  00097	83 7c 0e 04 02	 cmp	 DWORD PTR [esi+ecx+4], 2
  0009c	0f 8e 96 05 00
	00		 jle	 $LN70@CGRequestE@3

; 15714: 		return;
; 15715: 
; 15716: 	if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) ||
; 15717: 	 	 CC_MAP_RANGE(gObj[iIndex].MapNumber) ||
; 15718: 		 DS_MAP_RANGE(gObj[iIndex].MapNumber) )

  000a2	8a 84 0e 23 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+291]
  000a9	3c 34		 cmp	 al, 52			; 00000034H
  000ab	0f 84 51 05 00
	00		 je	 $LN43@CGRequestE@3
  000b1	3c 0b		 cmp	 al, 11			; 0000000bH
  000b3	72 10		 jb	 SHORT $LN63@CGRequestE@3
  000b5	ba 11 00 00 00	 mov	 edx, 17			; 00000011H
  000ba	3a d0		 cmp	 dl, al
  000bc	1b d2		 sbb	 edx, edx
  000be	42		 inc	 edx
  000bf	0f 85 3d 05 00
	00		 jne	 $LN43@CGRequestE@3
$LN63@CGRequestE@3:
  000c5	3c 35		 cmp	 al, 53			; 00000035H
  000c7	0f 84 35 05 00
	00		 je	 $LN43@CGRequestE@3
  000cd	3c 12		 cmp	 al, 18			; 00000012H
  000cf	72 10		 jb	 SHORT $LN64@CGRequestE@3
  000d1	ba 17 00 00 00	 mov	 edx, 23			; 00000017H
  000d6	3a d0		 cmp	 dl, al
  000d8	1b d2		 sbb	 edx, edx
  000da	42		 inc	 edx
  000db	0f 85 21 05 00
	00		 jne	 $LN43@CGRequestE@3
$LN64@CGRequestE@3:
  000e1	3c 09		 cmp	 al, 9
  000e3	0f 84 19 05 00
	00		 je	 $LN43@CGRequestE@3
  000e9	33 d2		 xor	 edx, edx
  000eb	3c 20		 cmp	 al, 32			; 00000020H
  000ed	0f 94 c2	 sete	 dl
  000f0	8b c2		 mov	 eax, edx
  000f2	85 c0		 test	 eax, eax
  000f4	0f 85 08 05 00
	00		 jne	 $LN43@CGRequestE@3

; 15723: 		return;
; 15724: 	}
; 15725: 
; 15726: 	if ( gObj[iIndex].m_IfState.use && gObj[iIndex].m_IfState.type != 12 )

  000fa	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  00101	a8 03		 test	 al, 3
  00103	74 10		 je	 SHORT $LN42@CGRequestE@3
  00105	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0010a	3d 00 03 00 00	 cmp	 eax, 768		; 00000300H
  0010f	0f 85 23 05 00
	00		 jne	 $LN70@CGRequestE@3
$LN42@CGRequestE@3:

; 15727: 		return;
; 15728: 
; 15729: 	if ( gPkLimitFree == FALSE )

  00115	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  0011c	75 20		 jne	 SHORT $LN69@CGRequestE@3

; 15730: 	{
; 15731: 		int bIsPk = FALSE;
; 15732: 
; 15733: 		if ( gObj[iIndex].PartyNumber >= 0 )

  0011e	8b 84 0e 0c 06
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1548]
  00125	85 c0		 test	 eax, eax
  00127	78 30		 js	 SHORT $LN40@CGRequestE@3

; 15734: 		{
; 15735: 			if( gParty.GetPartyPkLevel(gObj[iIndex].PartyNumber) >= 6 )

  00129	50		 push	 eax
  0012a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0012f	e8 00 00 00 00	 call	 ?GetPartyPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPartyPkLevel
  00134	3c 06		 cmp	 al, 6
  00136	7d 2b		 jge	 SHORT $LN65@CGRequestE@3

; 15751: 			return;

  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN69@CGRequestE@3:

; 15752: 		}
; 15753: 	}
; 15754: 
; 15755: 	if ( gObjDuelCheck(&gObj[iIndex]) == TRUE )

  0013e	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjDuelCheck
  00147	83 c4 04	 add	 esp, 4
  0014a	83 f8 01	 cmp	 eax, 1
  0014d	75 46		 jne	 SHORT $LN35@CGRequestE@3

; 15756: 	{
; 15757: 		PMSG_NOTICE pNotice;
; 15758: 		TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 202)));

  0014f	68 ca 04 00 00	 push	 1226			; 000004caH

; 15759: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 15760: 		return;

  00154	e9 ae 04 00 00	 jmp	 $LN73@CGRequestE@3
$LN40@CGRequestE@3:

; 15736: 			{
; 15737: 				bIsPk = TRUE;
; 15738: 			}
; 15739: 		}
; 15740: 		else if( gObj[iIndex].m_PK_Level >= 6 )

  00159	80 bc 0e 19 01
	00 00 06	 cmp	 BYTE PTR [esi+ecx+281], 6
  00161	7c db		 jl	 SHORT $LN69@CGRequestE@3
$LN65@CGRequestE@3:

; 15741: 		{
; 15742: 			bIsPk = TRUE;
; 15743: 		}
; 15744: 		
; 15745: 		
; 15746: 		if ( bIsPk == TRUE )
; 15747: 		{
; 15748: 			PMSG_NOTICE pNotice;
; 15749: 			TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 201)));

  00163	68 c9 04 00 00	 push	 1225			; 000004c9H
  00168	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0016d	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00172	50		 push	 eax
  00173	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$223352[ebp]
  00179	6a 01		 push	 1
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 15750: 			DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00181	0f b6 8d ed fd
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$223352[ebp+1]
  00188	51		 push	 ecx
  00189	8d 95 ec fd ff
	ff		 lea	 edx, DWORD PTR _pNotice$223352[ebp]
  0018f	52		 push	 edx

; 15751: 			return;

  00190	e9 9a 04 00 00	 jmp	 $LN72@CGRequestE@3
$LN35@CGRequestE@3:

; 15761: 	}
; 15762: 
; 15763: 	if ( gObj[iIndex].lpGuild )

  00195	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0019b	8b 84 0e 18 06
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1560]
  001a2	85 c0		 test	 eax, eax
  001a4	74 13		 je	 SHORT $LN33@CGRequestE@3

; 15764: 	{
; 15765: 		if ( gObj[iIndex].lpGuild->WarState == 1 )

  001a6	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  001ad	75 0a		 jne	 SHORT $LN33@CGRequestE@3

; 15766: 		{
; 15767: 			PMSG_NOTICE pNotice;
; 15768: 			TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 203)));

  001af	68 cb 04 00 00	 push	 1227			; 000004cbH

; 15769: 			DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 15770: 			return;

  001b4	e9 4e 04 00 00	 jmp	 $LN73@CGRequestE@3
$LN33@CGRequestE@3:

; 15771: 		}
; 15772: 	}
; 15773: 
; 15774: 	if ( gObj[iIndex].pInventory[8].m_Type == ITEMGET(13,3) ||	// Dino
; 15775: 		 gObj[iIndex].pInventory[8].m_Type == ITEMGET(13,2) ||	// Uniria
; 15776: 		 gObj[iIndex].pInventory[8].m_Type == ITEMGET(13,37) )	// Fenrir

  001b9	8b 94 0e c0 11
	00 00		 mov	 edx, DWORD PTR [esi+ecx+4544]
  001c0	0f b7 82 a6 06
	00 00		 movzx	 eax, WORD PTR [edx+1702]
  001c7	ba 03 1a 00 00	 mov	 edx, 6659		; 00001a03H
  001cc	66 3b c2	 cmp	 ax, dx
  001cf	0f 84 26 04 00
	00		 je	 $LN31@CGRequestE@3
  001d5	ba 02 1a 00 00	 mov	 edx, 6658		; 00001a02H
  001da	66 3b c2	 cmp	 ax, dx
  001dd	0f 84 18 04 00
	00		 je	 $LN31@CGRequestE@3
  001e3	ba 25 1a 00 00	 mov	 edx, 6693		; 00001a25H
  001e8	66 3b c2	 cmp	 ax, dx
  001eb	0f 84 0a 04 00
	00		 je	 $LN31@CGRequestE@3

; 15782: 	}
; 15783: 
; 15784: 	int bIsPk = FALSE;
; 15785: 
; 15786: 	if ( gObj[iIndex].PartyNumber >= 0 )

  001f1	8b 84 0e 0c 06
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1548]
  001f8	85 c0		 test	 eax, eax
  001fa	78 0f		 js	 SHORT $LN30@CGRequestE@3

; 15787: 	{
; 15788: 		if( gParty.GetPartyPkLevel(gObj[iIndex].PartyNumber) >= 5 )

  001fc	50		 push	 eax
  001fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00202	e8 00 00 00 00	 call	 ?GetPartyPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPartyPkLevel
  00207	3c 05		 cmp	 al, 5

; 15789: 		{
; 15790: 			bIsPk = TRUE;
; 15791: 		}
; 15792: 	}

  00209	eb 08		 jmp	 SHORT $LN74@CGRequestE@3
$LN30@CGRequestE@3:

; 15793: 	else if ( gObj[iIndex].m_PK_Level >= 4 )

  0020b	80 bc 0e 19 01
	00 00 04	 cmp	 BYTE PTR [esi+ecx+281], 4
$LN74@CGRequestE@3:
  00213	7c 30		 jl	 SHORT $LN26@CGRequestE@3

; 15794: 	{
; 15795: 		bIsPk = TRUE;
; 15796: 	}
; 15797: 
; 15798: 	if ( bIsPk == TRUE )
; 15799: 	{
; 15800: 		pResult.Result = 8;
; 15801: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00215	0f b6 85 e5 fd
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0021c	50		 push	 eax
  0021d	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00223	51		 push	 ecx

; 15838: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00224	57		 push	 edi
  00225	c6 85 e8 fd ff
	ff 08		 mov	 BYTE PTR _pResult$[ebp+4], 8
  0022c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00231	83 c4 0c	 add	 esp, 12			; 0000000cH
  00234	5e		 pop	 esi
  00235	5b		 pop	 ebx
  00236	5f		 pop	 edi

; 15948: }

  00237	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023a	33 cd		 xor	 ecx, ebp
  0023c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00241	8b e5		 mov	 esp, ebp
  00243	5d		 pop	 ebp
  00244	c3		 ret	 0
$LN26@CGRequestE@3:

; 15802: 		return;
; 15803: 	}
; 15804: 
; 15805: 	int iENTER_LEVEL = g_ChaosCastle.GetUserLevelToEnter(iIndex);

  00245	57		 push	 edi
  00246	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0024b	e8 00 00 00 00	 call	 ?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetUserLevelToEnter
  00250	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _iENTER_LEVEL$[ebp], eax

; 15806: 
; 15807: 	if ( iENTER_LEVEL == -1 )

  00256	83 f8 ff	 cmp	 eax, -1

; 15808: 	{
; 15809: 		pResult.Result = 1;
; 15810: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15811: 		return;

  00259	0f 84 6c 03 00
	00		 je	 $LN23@CGRequestE@3

; 15812: 	}
; 15813: 
; 15814: 	if ( g_ChaosCastle.CheckCanEnter(iENTER_LEVEL) == false )

  0025f	50		 push	 eax
  00260	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00265	e8 00 00 00 00	 call	 ?CheckCanEnter@CChaosCastle@@QAE_NH@Z ; CChaosCastle::CheckCanEnter
  0026a	84 c0		 test	 al, al
  0026c	75 30		 jne	 SHORT $LN24@CGRequestE@3

; 15815: 	{
; 15816: 		pResult.Result = 2;
; 15817: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0026e	0f b6 8d e5 fd
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00275	51		 push	 ecx
  00276	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  0027c	52		 push	 edx

; 15838: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0027d	57		 push	 edi
  0027e	c6 85 e8 fd ff
	ff 02		 mov	 BYTE PTR _pResult$[ebp+4], 2
  00285	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0028a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028d	5e		 pop	 esi
  0028e	5b		 pop	 ebx
  0028f	5f		 pop	 edi

; 15948: }

  00290	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00293	33 cd		 xor	 ecx, ebp
  00295	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029a	8b e5		 mov	 esp, ebp
  0029c	5d		 pop	 ebp
  0029d	c3		 ret	 0
$LN24@CGRequestE@3:

; 15818: 		return;
; 15819: 	}
; 15820: 
; 15821: 	if ( gObj[iIndex].pInventory[btGuardMailSetItemPos].IsItem() == TRUE )

  0029e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a3	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  002aa	0f b6 db	 movzx	 ebx, bl
  002ad	89 9d d4 fd ff
	ff		 mov	 DWORD PTR tv748[ebp], ebx
  002b3	69 db d4 00 00
	00		 imul	 ebx, 212		; 000000d4H
  002b9	03 cb		 add	 ecx, ebx
  002bb	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002c0	83 f8 01	 cmp	 eax, 1
  002c3	0f 85 02 03 00
	00		 jne	 $LN23@CGRequestE@3

; 15822: 	{
; 15823: 		if ( gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Type == ITEMGET(13,29) ) // Armor of Guardman

  002c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ce	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  002d5	ba 1d 1a 00 00	 mov	 edx, 6685		; 00001a1dH
  002da	66 39 54 0b 06	 cmp	 WORD PTR [ebx+ecx+6], dx
  002df	0f 85 b6 02 00
	00		 jne	 $LN22@CGRequestE@3

; 15824: 		{
; 15825: 			iITEM_LEVEL = gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Level;
; 15826: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Number;

  002e5	8b 0c 0b	 mov	 ecx, DWORD PTR [ebx+ecx]

; 15839: 		return;
; 15840: 	}
; 15841: 
; 15842: 	if( IsTransformEquipment(iIndex) )

  002e8	57		 push	 edi
  002e9	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _dwITEM_SERIAL$[ebp], ecx
  002ef	e8 00 00 00 00	 call	 ?IsTransformEquipment@@YA_NH@Z ; IsTransformEquipment
  002f4	83 c4 04	 add	 esp, 4
  002f7	84 c0		 test	 al, al
  002f9	74 2c		 je	 SHORT $LN19@CGRequestE@3

; 15843: 	{
; 15844: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 205)), iIndex, 1);

  002fb	6a 01		 push	 1
  002fd	57		 push	 edi
  002fe	68 cd 04 00 00	 push	 1229			; 000004cdH
  00303	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00308	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0030d	50		 push	 eax
  0030e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00313	83 c4 0c	 add	 esp, 12			; 0000000cH
  00316	5e		 pop	 esi
  00317	5b		 pop	 ebx
  00318	5f		 pop	 edi

; 15948: }

  00319	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0031c	33 cd		 xor	 ecx, ebp
  0031e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00323	8b e5		 mov	 esp, ebp
  00325	5d		 pop	 ebp
  00326	c3		 ret	 0
$LN19@CGRequestE@3:

; 15845: 		return;
; 15846: 	}
; 15847: 
; 15848: 	BYTE btAttr = MapC[gObj[iIndex].MapNumber].GetAttr(gObj[iIndex].X,gObj[iIndex].Y);

  00327	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15849: 
; 15850: 	if( (btAttr & 1) != 1 )

  0032c	0f b6 94 06 21
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+289]
  00334	0f b6 8c 06 20
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+288]
  0033c	52		 push	 edx
  0033d	51		 push	 ecx
  0033e	0f b6 8c 06 23
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+291]
  00346	69 c9 28 38 05
	00		 imul	 ecx, 342056		; 00053828H
  0034c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00352	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00357	a8 01		 test	 al, 1
  00359	0f 84 d9 02 00
	00		 je	 $LN70@CGRequestE@3

; 15851: 	{
; 15852: 		return;
; 15853: 	}
; 15854: 
; 15855: 	int iCC_INDEX = -1;
; 15856: 
; 15857: 	if ( g_ChaosCastle.CheckUserEnterMoney(iIndex, iENTER_LEVEL) )

  0035f	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _iENTER_LEVEL$[ebp]
  00365	53		 push	 ebx
  00366	57		 push	 edi
  00367	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0036c	e8 00 00 00 00	 call	 ?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z ; CChaosCastle::CheckUserEnterMoney
  00371	85 c0		 test	 eax, eax
  00373	0f 84 f2 01 00
	00		 je	 $LN17@CGRequestE@3

; 15858: 	{
; 15859: 		iCC_INDEX = g_ChaosCastle.EnterUserChaosCastle(iENTER_LEVEL, iIndex);

  00379	57		 push	 edi
  0037a	53		 push	 ebx
  0037b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00380	e8 00 00 00 00	 call	 ?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z ; CChaosCastle::EnterUserChaosCastle
  00385	8b d8		 mov	 ebx, eax

; 15860: 
; 15861: 		if ( iCC_INDEX == -1 )

  00387	83 fb ff	 cmp	 ebx, -1
  0038a	75 0c		 jne	 SHORT $LN16@CGRequestE@3

; 15862: 		{
; 15863: 			pResult.Result = 5;

  0038c	c6 85 e8 fd ff
	ff 05		 mov	 BYTE PTR _pResult$[ebp+4], 5

; 15864: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15865: 			return;

  00393	e9 3a 02 00 00	 jmp	 $LN76@CGRequestE@3
$LN16@CGRequestE@3:

; 15872: 		return;
; 15873: 	}
; 15874: 
; 15875: 	BOOL bRES = g_ChaosCastle.PayUserEnterMoney(iIndex, iENTER_LEVEL);

  00398	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR _iENTER_LEVEL$[ebp]
  0039e	51		 push	 ecx
  0039f	57		 push	 edi
  003a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  003a5	e8 00 00 00 00	 call	 ?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z ; CChaosCastle::PayUserEnterMoney

; 15876: 
; 15877: 	if ( bRES == FALSE )

  003aa	85 c0		 test	 eax, eax
  003ac	75 1e		 jne	 SHORT $LN14@CGRequestE@3

; 15878: 	{
; 15879: 		g_ChaosCastle.LeaveUserChaosCastle(iENTER_LEVEL, iIndex);

  003ae	8b 95 e0 fd ff
	ff		 mov	 edx, DWORD PTR _iENTER_LEVEL$[ebp]
  003b4	57		 push	 edi
  003b5	52		 push	 edx
  003b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  003bb	e8 00 00 00 00	 call	 ?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z ; CChaosCastle::LeaveUserChaosCastle

; 15880: 		pResult.Result = 5;

  003c0	c6 85 e8 fd ff
	ff 05		 mov	 BYTE PTR _pResult$[ebp+4], 5

; 15881: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15882: 		return;

  003c7	e9 d6 01 00 00	 jmp	 $LN79@CGRequestE@3
$LN14@CGRequestE@3:

; 15883: 	}
; 15884: 
; 15885: 	gObjInventoryDeleteItem(iIndex, btGuardMailSetItemPos);

  003cc	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR tv748[ebp]
  003d2	52		 push	 edx
  003d3	57		 push	 edi
  003d4	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 15886: 	GCInventoryItemDeleteSend(iIndex, btGuardMailSetItemPos, 1);

  003d9	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _btGuardMailSetItemPos$[ebp]
  003df	6a 01		 push	 1
  003e1	50		 push	 eax
  003e2	57		 push	 edi
  003e3	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 15887: 
; 15888: 	DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  003e8	0f b6 8d e5 fd
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  003ef	51		 push	 ecx
  003f0	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  003f6	52		 push	 edx
  003f7	57		 push	 edi
  003f8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 15889: 
; 15890: 	gObj[iIndex].m_cChaosCastleIndex = iENTER_LEVEL;

  003fd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00402	8a 8d e0 fd ff
	ff		 mov	 cl, BYTE PTR _iENTER_LEVEL$[ebp]
  00408	88 8c 06 3d 12
	00 00		 mov	 BYTE PTR [esi+eax+4669], cl

; 15891: 	gObj[iIndex].m_cChaosCastleSubIndex = iCC_INDEX;

  0040f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00415	88 9c 16 3e 12
	00 00		 mov	 BYTE PTR [esi+edx+4670], bl

; 15892: 	gObj[iIndex].m_IfState.state = 0;

  0041c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00421	83 a4 06 b8 11
	00 00 c3	 and	 DWORD PTR [esi+eax+4536], -61 ; ffffffc3H

; 15893: 	gObj[iIndex].m_IfState.type = 0;

  00429	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0042e	81 a4 06 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [esi+eax+4536], -65473 ; ffff003fH

; 15894: 	gObj[iIndex].m_IfState.use = 0;

  00439	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0043e	83 a4 06 b8 11
	00 00 fc	 and	 DWORD PTR [esi+eax+4536], -4 ; fffffffcH

; 15895: 
; 15896: 	if ( gObj[iIndex].m_bPShopOpen == true )

  00446	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0044b	83 c4 20	 add	 esp, 32			; 00000020H
  0044e	80 bc 06 5c 12
	00 00 01	 cmp	 BYTE PTR [esi+eax+4700], 1
  00456	75 0e		 jne	 SHORT $LN13@CGRequestE@3

; 15897: 		CGPShopReqClose(iIndex);

  00458	57		 push	 edi
  00459	e8 00 00 00 00	 call	 ?CGPShopReqClose@@YAXH@Z ; CGPShopReqClose
  0045e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00463	83 c4 04	 add	 esp, 4
$LN13@CGRequestE@3:

; 15898: 
; 15899: 	if ( gObj[iIndex].PartyNumber >= 0 )

  00466	8b 8c 06 0c 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1548]
  0046d	85 c9		 test	 ecx, ecx
  0046f	78 30		 js	 SHORT $LN11@CGRequestE@3

; 15900: 	{
; 15901: 		PMSG_PARTYDELUSER pMsg;
; 15902: 		int pindex = gParty.GetIndex(gObj[iIndex].PartyNumber, iIndex, gObj[iIndex].DBNumber);

  00471	8b 44 06 30	 mov	 eax, DWORD PTR [esi+eax+48]
  00475	50		 push	 eax
  00476	57		 push	 edi
  00477	51		 push	 ecx
  00478	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0047d	e8 00 00 00 00	 call	 ?GetIndex@PartyClass@@QAEHHHH@Z ; PartyClass::GetIndex

; 15903: 
; 15904: 		if ( pindex >= 0 )

  00482	85 c0		 test	 eax, eax
  00484	78 16		 js	 SHORT $LN68@CGRequestE@3

; 15905: 		{
; 15906: 			pMsg.Number = pindex;
; 15907: 			CGPartyDelUser(&pMsg, iIndex);

  00486	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _pMsg$223398[ebp]
  0048c	57		 push	 edi
  0048d	51		 push	 ecx
  0048e	88 85 df fd ff
	ff		 mov	 BYTE PTR _pMsg$223398[ebp+3], al
  00494	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  00499	83 c4 08	 add	 esp, 8
$LN68@CGRequestE@3:
  0049c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN11@CGRequestE@3:

; 15908: 		}
; 15909: 	}
; 15910: 
; 15911: 	if ( gObj[iIndex].Class == CLASS_ELF && gObj[iIndex].m_RecallMon >= 0)

  004a1	66 83 bc 06 90
	00 00 00 02	 cmp	 WORD PTR [esi+eax+144], 2
  004aa	75 1d		 jne	 SHORT $LN10@CGRequestE@3
  004ac	83 bc 06 30 06
	00 00 00	 cmp	 DWORD PTR [esi+eax+1584], 0
  004b4	7c 13		 jl	 SHORT $LN10@CGRequestE@3

; 15912: 	{
; 15913: 		GCRecallMonLife(iIndex, 60, 0);

  004b6	6a 00		 push	 0
  004b8	6a 3c		 push	 60			; 0000003cH
  004ba	57		 push	 edi
  004bb	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife

; 15914: 		gObjMonsterCallKill(iIndex);

  004c0	57		 push	 edi
  004c1	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  004c6	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@CGRequestE@3:

; 15915: 	}
; 15916: 
; 15917: 	char szTemp[256];
; 15918: 	wsprintf(szTemp, lMsg.Get(MSGGET(4, 206)), iENTER_LEVEL+1);

  004c9	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _iENTER_LEVEL$[ebp]
  004cf	43		 inc	 ebx
  004d0	53		 push	 ebx
  004d1	68 ce 04 00 00	 push	 1230			; 000004ceH
  004d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  004db	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  004e0	50		 push	 eax
  004e1	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  004e7	52		 push	 edx
  004e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 15919: 	GCServerMsgStringSend(szTemp, iIndex, 1);

  004ee	6a 01		 push	 1
  004f0	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  004f6	57		 push	 edi
  004f7	50		 push	 eax
  004f8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 15920: 
; 15921: 	switch ( iENTER_LEVEL+1 )

  004fd	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00500	83 c4 18	 add	 esp, 24			; 00000018H
  00503	83 f8 06	 cmp	 eax, 6
  00506	77 2d		 ja	 SHORT $LN8@CGRequestE@3
  00508	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN80@CGRequestE@3[eax*4]
$LN7@CGRequestE@3:

; 15922: 	{
; 15923: 		case 1:
; 15924: 			gObjMoveGate(iIndex, 82);

  0050f	6a 52		 push	 82			; 00000052H

; 15925: 			break;

  00511	eb 19		 jmp	 SHORT $LN75@CGRequestE@3
$LN6@CGRequestE@3:

; 15926: 		case 2:
; 15927: 			gObjMoveGate(iIndex, 83);

  00513	6a 53		 push	 83			; 00000053H

; 15928: 			break;

  00515	eb 15		 jmp	 SHORT $LN75@CGRequestE@3
$LN5@CGRequestE@3:

; 15929: 		case 3:
; 15930: 			gObjMoveGate(iIndex, 84);

  00517	6a 54		 push	 84			; 00000054H

; 15931: 			break;

  00519	eb 11		 jmp	 SHORT $LN75@CGRequestE@3
$LN4@CGRequestE@3:

; 15932: 		case 4:
; 15933: 			gObjMoveGate(iIndex, 85);

  0051b	6a 55		 push	 85			; 00000055H

; 15934: 			break;

  0051d	eb 0d		 jmp	 SHORT $LN75@CGRequestE@3
$LN3@CGRequestE@3:

; 15935: 		case 5:
; 15936: 			gObjMoveGate(iIndex, 86);

  0051f	6a 56		 push	 86			; 00000056H

; 15937: 			break;

  00521	eb 09		 jmp	 SHORT $LN75@CGRequestE@3
$LN2@CGRequestE@3:

; 15938: 		case 6:
; 15939: 			gObjMoveGate(iIndex, 87);

  00523	6a 57		 push	 87			; 00000057H

; 15940: 			break;

  00525	eb 05		 jmp	 SHORT $LN75@CGRequestE@3
$LN1@CGRequestE@3:

; 15941: 		case 7:
; 15942: 			gObjMoveGate(iIndex, 272);

  00527	68 10 01 00 00	 push	 272			; 00000110H
$LN75@CGRequestE@3:
  0052c	57		 push	 edi
  0052d	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00532	83 c4 08	 add	 esp, 8
$LN8@CGRequestE@3:

; 15943: 			break;
; 15944: 	}
; 15945: 
; 15946: 	LogAddTD("[Chaos Castle] (%d) (Account:%s, Name:%s) Entered Chaos Castle (Guard Mail Set Serial:%d)",
; 15947: 		iENTER_LEVEL+1, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);

  00535	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0053a	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _dwITEM_SERIAL$[ebp]
  00540	51		 push	 ecx
  00541	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  00545	52		 push	 edx
  00546	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  0054a	50		 push	 eax
  0054b	53		 push	 ebx
  0054c	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  00551	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00557	83 c4 14	 add	 esp, 20			; 00000014H
  0055a	5e		 pop	 esi
  0055b	5b		 pop	 ebx
  0055c	5f		 pop	 edi

; 15948: }

  0055d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00560	33 cd		 xor	 ecx, ebp
  00562	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00567	8b e5		 mov	 esp, ebp
  00569	5d		 pop	 ebp
  0056a	c3		 ret	 0
$LN17@CGRequestE@3:

; 15866: 		}
; 15867: 	}
; 15868: 	else
; 15869: 	{
; 15870: 		pResult.Result = 7;
; 15871: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0056b	0f b6 8d e5 fd
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00572	51		 push	 ecx
  00573	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00579	52		 push	 edx
  0057a	57		 push	 edi
  0057b	c6 85 e8 fd ff
	ff 07		 mov	 BYTE PTR _pResult$[ebp+4], 7
  00582	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00587	83 c4 0c	 add	 esp, 12			; 0000000cH
  0058a	5e		 pop	 esi
  0058b	5b		 pop	 ebx
  0058c	5f		 pop	 edi

; 15948: }

  0058d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00590	33 cd		 xor	 ecx, ebp
  00592	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00597	8b e5		 mov	 esp, ebp
  00599	5d		 pop	 ebp
  0059a	c3		 ret	 0
$LN22@CGRequestE@3:

; 15827: 		}
; 15828: 		else
; 15829: 		{
; 15830: 			pResult.Result = 1;

  0059b	c6 85 e8 fd ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+4], 1
$LN79@CGRequestE@3:

; 15831: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  005a2	0f b6 85 e5 fd
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  005a9	50		 push	 eax
  005aa	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  005b0	51		 push	 ecx
  005b1	57		 push	 edi
  005b2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  005ba	5e		 pop	 esi
  005bb	5b		 pop	 ebx
  005bc	5f		 pop	 edi

; 15948: }

  005bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005c0	33 cd		 xor	 ecx, ebp
  005c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005c7	8b e5		 mov	 esp, ebp
  005c9	5d		 pop	 ebp
  005ca	c3		 ret	 0
$LN23@CGRequestE@3:

; 15832: 			return;
; 15833: 		}
; 15834: 	}
; 15835: 	else
; 15836: 	{
; 15837: 		pResult.Result = 1;

  005cb	c6 85 e8 fd ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+4], 1
$LN76@CGRequestE@3:

; 15838: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  005d2	0f b6 95 e5 fd
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  005d9	52		 push	 edx
  005da	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  005e0	50		 push	 eax
  005e1	57		 push	 edi
  005e2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  005ea	5e		 pop	 esi
  005eb	5b		 pop	 ebx
  005ec	5f		 pop	 edi

; 15948: }

  005ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f0	33 cd		 xor	 ecx, ebp
  005f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f7	8b e5		 mov	 esp, ebp
  005f9	5d		 pop	 ebp
  005fa	c3		 ret	 0
$LN31@CGRequestE@3:

; 15777: 	{
; 15778: 		PMSG_NOTICE pNotice;
; 15779: 		TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 204)));

  005fb	68 cc 04 00 00	 push	 1228			; 000004ccH

; 15780: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 15781: 		return;

  00600	eb 05		 jmp	 SHORT $LN73@CGRequestE@3
$LN43@CGRequestE@3:

; 15719: 	{
; 15720: 		PMSG_NOTICE pNotice;
; 15721: 		TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 200)));

  00602	68 c8 04 00 00	 push	 1224			; 000004c8H
$LN73@CGRequestE@3:
  00607	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0060c	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00611	50		 push	 eax
  00612	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _pNotice$223342[ebp]
  00618	6a 01		 push	 1
  0061a	51		 push	 ecx
  0061b	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 15722: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00620	0f b6 95 ed fd
	ff ff		 movzx	 edx, BYTE PTR _pNotice$223342[ebp+1]
  00627	52		 push	 edx
  00628	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$223342[ebp]
  0062e	50		 push	 eax
$LN72@CGRequestE@3:
  0062f	57		 push	 edi
  00630	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00635	83 c4 18	 add	 esp, 24			; 00000018H
$LN70@CGRequestE@3:

; 15948: }

  00638	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0063b	5e		 pop	 esi
  0063c	5b		 pop	 ebx
  0063d	33 cd		 xor	 ecx, ebp
  0063f	5f		 pop	 edi
  00640	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00645	8b e5		 mov	 esp, ebp
  00647	5d		 pop	 ebp
  00648	c3		 ret	 0
  00649	8d 49 00	 npad	 3
$LN80@CGRequestE@3:
  0064c	00 00 00 00	 DD	 $LN7@CGRequestE@3
  00650	00 00 00 00	 DD	 $LN6@CGRequestE@3
  00654	00 00 00 00	 DD	 $LN5@CGRequestE@3
  00658	00 00 00 00	 DD	 $LN4@CGRequestE@3
  0065c	00 00 00 00	 DD	 $LN3@CGRequestE@3
  00660	00 00 00 00	 DD	 $LN2@CGRequestE@3
  00664	00 00 00 00	 DD	 $LN1@CGRequestE@3
?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ENDP ; CGRequestEnterChaosCastle
_TEXT	ENDS
PUBLIC	??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z ; CGReqMapSvrAuth
EXTRN	?GJReqMapSvrAuth@@YAXHPAD0HHHH@Z:PROC		; GJReqMapSvrAuth
;	COMDAT ??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@
CONST	SEGMENT
??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@ DB '[MapSe'
	DB	'rverMng] Map Server Join Send : [%s][%s](%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z
_TEXT	SEGMENT
_btSerial$ = -36					; size = 17
_id$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z PROC ; CGReqMapSvrAuth, COMDAT

; 17583: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 17584: 	if ( lpMsg->btCliVersion[0] != szClientVersion[0] ||
; 17585: 		 lpMsg->btCliVersion[1] != szClientVersion[1] ||
; 17586: 		 lpMsg->btCliVersion[2] != szClientVersion[2] ||
; 17587: 		 lpMsg->btCliVersion[3] != szClientVersion[3] ||
; 17588: 		 lpMsg->btCliVersion[4] != szClientVersion[4] )

  00010	0f be 0d 00 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA
  00017	53		 push	 ebx
  00018	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001f	0f b6 47 30	 movzx	 eax, BYTE PTR [edi+48]
  00023	3b c1		 cmp	 eax, ecx
  00025	0f 85 b0 02 00
	00		 jne	 $LN9@CGReqMapSv
  0002b	0f b6 57 31	 movzx	 edx, BYTE PTR [edi+49]
  0002f	0f be 05 01 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+1
  00036	3b d0		 cmp	 edx, eax
  00038	0f 85 9d 02 00
	00		 jne	 $LN9@CGReqMapSv
  0003e	0f b6 4f 32	 movzx	 ecx, BYTE PTR [edi+50]
  00042	0f be 15 02 00
	00 00		 movsx	 edx, BYTE PTR ?szClientVersion@@3PADA+2
  00049	3b ca		 cmp	 ecx, edx
  0004b	0f 85 8a 02 00
	00		 jne	 $LN9@CGReqMapSv
  00051	0f b6 47 33	 movzx	 eax, BYTE PTR [edi+51]
  00055	0f be 0d 03 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA+3
  0005c	3b c1		 cmp	 eax, ecx
  0005e	0f 85 77 02 00
	00		 jne	 $LN9@CGReqMapSv
  00064	0f b6 57 34	 movzx	 edx, BYTE PTR [edi+52]
  00068	0f be 05 04 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+4
  0006f	3b d0		 cmp	 edx, eax
  00071	0f 85 64 02 00
	00		 jne	 $LN9@CGReqMapSv

; 17592: 
; 17593: 		return;
; 17594: 	}
; 17595: 
; 17596: 	BYTE btSerial[17];
; 17597: 
; 17598: 	btSerial[16]=0;
; 17599: 	memcpy(btSerial, lpMsg->btCliSerial, sizeof(lpMsg->btCliSerial));

  00077	8b 57 39	 mov	 edx, DWORD PTR [edi+57]
  0007a	8b 4f 35	 mov	 ecx, DWORD PTR [edi+53]
  0007d	8b 47 3d	 mov	 eax, DWORD PTR [edi+61]
  00080	89 55 e0	 mov	 DWORD PTR _btSerial$[ebp+4], edx

; 17600: 	char id[MAX_ACCOUNT_LEN+1];
; 17601: 	id[MAX_ACCOUNT_LEN] = 0;
; 17602: 	memcpy(id, lpMsg->szAccountID, MAX_ACCOUNT_LEN);

  00083	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00086	89 4d dc	 mov	 DWORD PTR _btSerial$[ebp], ecx
  00089	8b 4f 41	 mov	 ecx, DWORD PTR [edi+65]
  0008c	89 55 f0	 mov	 DWORD PTR _id$[ebp], edx
  0008f	89 45 e4	 mov	 DWORD PTR _btSerial$[ebp+8], eax
  00092	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00095	89 4d e8	 mov	 DWORD PTR _btSerial$[ebp+12], ecx
  00098	66 8b 4f 0c	 mov	 cx, WORD PTR [edi+12]

; 17603: 	BuxConvert(id, MAX_ACCOUNT_LEN);

  0009c	8d 55 f0	 lea	 edx, DWORD PTR _id$[ebp]
  0009f	6a 0a		 push	 10			; 0000000aH
  000a1	52		 push	 edx
  000a2	c6 45 ec 00	 mov	 BYTE PTR _btSerial$[ebp+16], 0
  000a6	c6 45 fa 00	 mov	 BYTE PTR _id$[ebp+10], 0
  000aa	89 45 f4	 mov	 DWORD PTR _id$[ebp+4], eax
  000ad	66 89 4d f8	 mov	 WORD PTR _id$[ebp+8], cx
  000b1	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  000b6	83 c4 08	 add	 esp, 8

; 17604: 
; 17605: 	if ( strcmp((char*)btSerial, szGameServerExeSerial) )

  000b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?szGameServerExeSerial@@3PADA ; szGameServerExeSerial
  000be	8d 45 dc	 lea	 eax, DWORD PTR _btSerial$[ebp]
$LL13@CGReqMapSv:
  000c1	8a 10		 mov	 dl, BYTE PTR [eax]
  000c3	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000c5	75 1a		 jne	 SHORT $LN14@CGReqMapSv
  000c7	84 d2		 test	 dl, dl
  000c9	74 12		 je	 SHORT $LN15@CGReqMapSv
  000cb	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000ce	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000d1	75 0e		 jne	 SHORT $LN14@CGReqMapSv
  000d3	83 c0 02	 add	 eax, 2
  000d6	83 c1 02	 add	 ecx, 2
  000d9	84 d2		 test	 dl, dl
  000db	75 e4		 jne	 SHORT $LL13@CGReqMapSv
$LN15@CGReqMapSv:
  000dd	33 c0		 xor	 eax, eax
  000df	eb 05		 jmp	 SHORT $LN16@CGReqMapSv
$LN14@CGReqMapSv:
  000e1	1b c0		 sbb	 eax, eax
  000e3	83 d8 ff	 sbb	 eax, -1
$LN16@CGReqMapSv:
  000e6	85 c0		 test	 eax, eax
  000e8	74 36		 je	 SHORT $LN8@CGReqMapSv

; 17606: 	{
; 17607: 		LogAddC(2, "error-L1: Serial error [%s] [%s]", id, btSerial);

  000ea	8d 45 dc	 lea	 eax, DWORD PTR _btSerial$[ebp]
  000ed	50		 push	 eax
  000ee	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  000f1	51		 push	 ecx
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@
  000f7	6a 02		 push	 2
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 17608: 		GCAnsMapSvrAuth(iIndex, 6);

  000ff	6a 06		 push	 6
  00101	53		 push	 ebx
  00102	e8 00 00 00 00	 call	 ?GCAnsMapSvrAuth@@YAXHH@Z ; GCAnsMapSvrAuth

; 17609: 		CloseClient(iIndex);

  00107	53		 push	 ebx
  00108	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0010d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00110	5f		 pop	 edi
  00111	5b		 pop	 ebx

; 17668: 
; 17669: 
; 17670: }

  00112	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	33 cd		 xor	 ecx, ebp
  00117	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN8@CGReqMapSv:

; 17610: 		return;
; 17611: 	}
; 17612: 
; 17613: 	if ( g_ConnectMemberLoad == TRUE )

  00120	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR ?g_ConnectMemberLoad@@3_NA, 1 ; g_ConnectMemberLoad
  00127	75 2d		 jne	 SHORT $LN6@CGReqMapSv

; 17614: 	{
; 17615: 		if ( ConMember.IsMember(id) == FALSE )

  00129	8d 55 f0	 lea	 edx, DWORD PTR _id$[ebp]
  0012c	52		 push	 edx
  0012d	b9 00 00 00 00	 mov	 ecx, OFFSET ?ConMember@@3VCConMember@@A ; ConMember
  00132	e8 00 00 00 00	 call	 ?IsMember@CConMember@@QAEHPAD@Z ; CConMember::IsMember
  00137	85 c0		 test	 eax, eax
  00139	75 1b		 jne	 SHORT $LN6@CGReqMapSv

; 17616: 		{
; 17617: 			GCAnsMapSvrAuth(iIndex, 2);	

  0013b	6a 02		 push	 2
  0013d	53		 push	 ebx
  0013e	e8 00 00 00 00	 call	 ?GCAnsMapSvrAuth@@YAXHH@Z ; GCAnsMapSvrAuth
  00143	83 c4 08	 add	 esp, 8
  00146	5f		 pop	 edi
  00147	5b		 pop	 ebx

; 17668: 
; 17669: 
; 17670: }

  00148	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014b	33 cd		 xor	 ecx, ebp
  0014d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c3		 ret	 0
$LN6@CGReqMapSv:

; 17618: 			return;
; 17619: 		}
; 17620: 	}
; 17621: 
; 17622: 	LPOBJ lpObj = &gObj[iIndex];

  00156	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015b	56		 push	 esi
  0015c	8b f3		 mov	 esi, ebx
  0015e	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00164	03 c6		 add	 eax, esi

; 17623: 
; 17624: 	if ( PacketCheckTime(lpObj) == FALSE )

  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0016c	83 c4 04	 add	 esp, 4
  0016f	85 c0		 test	 eax, eax
  00171	75 0c		 jne	 SHORT $LN5@CGReqMapSv

; 17625: 	{
; 17626: 		LogAdd(lMsg.Get(MSGGET(1, 217)), iIndex, id);

  00173	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  00176	51		 push	 ecx
  00177	53		 push	 ebx
  00178	68 d9 01 00 00	 push	 473			; 000001d9H

; 17627: 		CloseClient(iIndex);
; 17628: 
; 17629: 		return;

  0017d	eb 17		 jmp	 SHORT $LN18@CGReqMapSv
$LN5@CGReqMapSv:

; 17630: 	}
; 17631: 
; 17632: 	if ( gObj[iIndex].Connected != PLAYER_CONNECTED )

  0017f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00185	83 7c 0e 04 01	 cmp	 DWORD PTR [esi+ecx+4], 1
  0018a	74 35		 je	 SHORT $LN4@CGReqMapSv

; 17633: 	{
; 17634: 		LogAdd(lMsg.Get(MSGGET(1, 218)), iIndex, id);

  0018c	8d 55 f0	 lea	 edx, DWORD PTR _id$[ebp]
  0018f	52		 push	 edx
  00190	53		 push	 ebx
  00191	68 da 01 00 00	 push	 474			; 000001daH
$LN18@CGReqMapSv:
  00196	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0019b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001a0	50		 push	 eax
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 17635: 		CloseClient(iIndex);

  001a7	53		 push	 ebx
  001a8	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 17645: 		}
; 17646: 		else
; 17647: 		{
; 17648: 			LogAdd("error : %d %s %d", gObj[iIndex].LoginMsgSnd, __FILE__, __LINE__);

  001ad	83 c4 10	 add	 esp, 16			; 00000010H
  001b0	5e		 pop	 esi
  001b1	5f		 pop	 edi
  001b2	5b		 pop	 ebx

; 17668: 
; 17669: 
; 17670: }

  001b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b6	33 cd		 xor	 ecx, ebp
  001b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c3		 ret	 0
$LN4@CGReqMapSv:

; 17636: 
; 17637: 		return;
; 17638: 	}
; 17639: 
; 17640: 	if ( gObj[iIndex].LoginMsgSnd != 0 )

  001c1	8a 44 0e 0a	 mov	 al, BYTE PTR [esi+ecx+10]
  001c5	84 c0		 test	 al, al
  001c7	74 4d		 je	 SHORT $LN3@CGReqMapSv

; 17641: 	{
; 17642: 		if ( gObj[iIndex].LoginMsgSnd == 1 )

  001c9	3c 01		 cmp	 al, 1
  001cb	75 34		 jne	 SHORT $LN2@CGReqMapSv

; 17643: 		{
; 17644: 			LogAdd(lMsg.Get(MSGGET(1, 219)), iIndex, id, gObj[iIndex].Ip_addr);

  001cd	8d 44 0e 1c	 lea	 eax, DWORD PTR [esi+ecx+28]
  001d1	50		 push	 eax
  001d2	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  001d5	51		 push	 ecx
  001d6	53		 push	 ebx
  001d7	68 db 01 00 00	 push	 475			; 000001dbH
  001dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001e1	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001e6	50		 push	 eax
$LN19@CGReqMapSv:

; 17645: 		}
; 17646: 		else
; 17647: 		{
; 17648: 			LogAdd("error : %d %s %d", gObj[iIndex].LoginMsgSnd, __FILE__, __LINE__);

  001e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001ed	83 c4 10	 add	 esp, 16			; 00000010H
  001f0	5e		 pop	 esi
  001f1	5f		 pop	 edi
  001f2	5b		 pop	 ebx

; 17668: 
; 17669: 
; 17670: }

  001f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f6	33 cd		 xor	 ecx, ebp
  001f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fd	8b e5		 mov	 esp, ebp
  001ff	5d		 pop	 ebp
  00200	c3		 ret	 0
$LN2@CGReqMapSv:

; 17645: 		}
; 17646: 		else
; 17647: 		{
; 17648: 			LogAdd("error : %d %s %d", gObj[iIndex].LoginMsgSnd, __FILE__, __LINE__);

  00201	68 f0 44 00 00	 push	 17648			; 000044f0H
  00206	0f be d0	 movsx	 edx, al
  00209	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0020e	52		 push	 edx
  0020f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@

; 17649: 		}
; 17650: 
; 17651: 		return;

  00214	eb d1		 jmp	 SHORT $LN19@CGReqMapSv
$LN3@CGReqMapSv:

; 17652: 	}
; 17653: 
; 17654: 	gObj[iIndex].ConnectCheckTime = GetTickCount(); 

  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0021c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00222	89 44 0e 3c	 mov	 DWORD PTR [esi+ecx+60], eax

; 17655: 
; 17656: 	gObj[iIndex].LoginMsgSnd = 1;

  00226	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0022c	c6 44 16 0a 01	 mov	 BYTE PTR [esi+edx+10], 1

; 17657: 	gObj[iIndex].LoginMsgCount++;

  00231	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00236	fe 44 06 0b	 inc	 BYTE PTR [esi+eax+11]

; 17658: 	gObj[iIndex].AccountID[MAX_ACCOUNT_LEN] = 0;

  0023a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0023f	c6 44 06 5c 00	 mov	 BYTE PTR [esi+eax+92], 0

; 17659: 	memcpy(gObj[iIndex].AccountID, id, MAX_ACCOUNT_LEN);

  00244	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0024a	8b 55 f0	 mov	 edx, DWORD PTR _id$[ebp]
  0024d	89 54 0e 52	 mov	 DWORD PTR [esi+ecx+82], edx
  00251	8d 44 0e 52	 lea	 eax, DWORD PTR [esi+ecx+82]
  00255	8b 4d f4	 mov	 ecx, DWORD PTR _id$[ebp+4]
  00258	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0025b	66 8b 55 f8	 mov	 dx, WORD PTR _id$[ebp+8]
  0025f	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 17660: 	memset(gObj[iIndex].Name, 0, MAX_ACCOUNT_LEN);

  00263	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00269	33 c0		 xor	 eax, eax
  0026b	89 44 0e 5d	 mov	 DWORD PTR [esi+ecx+93], eax
  0026f	8d 4c 0e 5d	 lea	 ecx, DWORD PTR [esi+ecx+93]
  00273	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00276	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 17661: 	gObj[iIndex].m_cAccountItemBlock = 0;

  0027a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00280	88 84 16 c4 01
	00 00		 mov	 BYTE PTR [esi+edx+452], al

; 17662: 	GJReqMapSvrAuth(iIndex, gObj[iIndex].AccountID, lpMsg->szCharName,
; 17663: 		lpMsg->iJoinAuthCode1, lpMsg->iJoinAuthCode2,
; 17664: 		lpMsg->iJoinAuthCode3, lpMsg->iJoinAuthCode4);

  00287	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  0028a	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  0028d	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  00290	50		 push	 eax
  00291	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00294	51		 push	 ecx
  00295	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029b	52		 push	 edx
  0029c	50		 push	 eax
  0029d	83 c7 10	 add	 edi, 16			; 00000010H
  002a0	57		 push	 edi
  002a1	8d 54 0e 52	 lea	 edx, DWORD PTR [esi+ecx+82]
  002a5	52		 push	 edx
  002a6	53		 push	 ebx
  002a7	e8 00 00 00 00	 call	 ?GJReqMapSvrAuth@@YAXHPAD0HHHH@Z ; GJReqMapSvrAuth

; 17665: 
; 17666: 	LogAddTD("[MapServerMng] Map Server Join Send : [%s][%s](%d)",
; 17667: 		gObj[iIndex].AccountID, gObj[iIndex].Name, iIndex);

  002ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b1	53		 push	 ebx
  002b2	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  002b6	51		 push	 ecx
  002b7	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  002bb	52		 push	 edx
  002bc	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@
  002c1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002c7	83 c4 2c	 add	 esp, 44			; 0000002cH
  002ca	5e		 pop	 esi
  002cb	5f		 pop	 edi
  002cc	5b		 pop	 ebx

; 17668: 
; 17669: 
; 17670: }

  002cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d0	33 cd		 xor	 ecx, ebp
  002d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d7	8b e5		 mov	 esp, ebp
  002d9	5d		 pop	 ebp
  002da	c3		 ret	 0
$LN9@CGReqMapSv:

; 17589: 	{
; 17590: 		GCAnsMapSvrAuth(iIndex, 6);

  002db	6a 06		 push	 6
  002dd	53		 push	 ebx
  002de	e8 00 00 00 00	 call	 ?GCAnsMapSvrAuth@@YAXHH@Z ; GCAnsMapSvrAuth

; 17591: 		CloseClient(iIndex);

  002e3	53		 push	 ebx
  002e4	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 17668: 
; 17669: 
; 17670: }

  002e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ef	5f		 pop	 edi
  002f0	33 cd		 xor	 ecx, ebp
  002f2	5b		 pop	 ebx
  002f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f8	8b e5		 mov	 esp, ebp
  002fa	5d		 pop	 ebp
  002fb	c3		 ret	 0
?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z ENDP ; CGReqMapSvrAuth
_TEXT	ENDS
PUBLIC	?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z ; CGReqRegCastleSiege
EXTRN	?GS_GDReqRegAttackGuild@@YAXHH@Z:PROC		; GS_GDReqRegAttackGuild
EXTRN	?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z:PROC ; CCastleSiege::CheckUnionGuildMaster
; Function compile flags: /Ogtp
;	COMDAT ?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z PROC ; CGReqRegCastleSiege, COMDAT

; 17798: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17799: #if (GS_CASTLE==1)
; 17800: 
; 17801: 	if(g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_REGSIEGE)

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00008	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  0000d	83 f8 01	 cmp	 eax, 1
  00010	74 15		 je	 SHORT $LN5@CGReqRegCa

; 17802: 	{
; 17803: 		GCAnsRegCastleSiege(iIndex,7,"");

  00012	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0001a	6a 07		 push	 7
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17826: #endif
; 17827: }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN5@CGReqRegCa:

; 17804: 		return;
; 17805: 	}
; 17806: 
; 17807: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	56		 push	 esi
  0002d	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00030	8b d6		 mov	 edx, esi
  00032	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0003d	8d 84 02 1c 06
	00 00		 lea	 eax, DWORD PTR [edx+eax+1564]
$LL11@CGReqRegCa:
  00044	8a 10		 mov	 dl, BYTE PTR [eax]
  00046	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00048	75 1a		 jne	 SHORT $LN12@CGReqRegCa
  0004a	84 d2		 test	 dl, dl
  0004c	74 12		 je	 SHORT $LN13@CGReqRegCa
  0004e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00051	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00054	75 0e		 jne	 SHORT $LN12@CGReqRegCa
  00056	83 c0 02	 add	 eax, 2
  00059	83 c1 02	 add	 ecx, 2
  0005c	84 d2		 test	 dl, dl
  0005e	75 e4		 jne	 SHORT $LL11@CGReqRegCa
$LN13@CGReqRegCa:
  00060	33 c0		 xor	 eax, eax
  00062	eb 05		 jmp	 SHORT $LN14@CGReqRegCa
$LN12@CGReqRegCa:
  00064	1b c0		 sbb	 eax, eax
  00066	83 d8 ff	 sbb	 eax, -1
$LN14@CGReqRegCa:
  00069	85 c0		 test	 eax, eax
  0006b	75 13		 jne	 SHORT $LN4@CGReqRegCa

; 17808: 	{
; 17809: 		GCAnsRegCastleSiege(iIndex,6,"");

  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00072	6a 06		 push	 6

; 17820: 	{
; 17821: 		GCAnsRegCastleSiege(iIndex,3,"");

  00074	56		 push	 esi
  00075	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	5e		 pop	 esi

; 17826: #endif
; 17827: }

  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN4@CGReqRegCa:

; 17810: 		return;
; 17811: 	}
; 17812: 
; 17813: 	if(g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE)

  00080	56		 push	 esi
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00086	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  0008b	85 c0		 test	 eax, eax
  0008d	75 12		 jne	 SHORT $LN3@CGReqRegCa

; 17814: 	{
; 17815: 		GCAnsRegCastleSiege(iIndex,0,"");

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00094	50		 push	 eax

; 17820: 	{
; 17821: 		GCAnsRegCastleSiege(iIndex,3,"");

  00095	56		 push	 esi
  00096	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009e	5e		 pop	 esi

; 17826: #endif
; 17827: }

  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
$LN3@CGReqRegCa:

; 17816: 		return;
; 17817: 	}
; 17818: 
; 17819: 	if(g_CastleSiege.CheckCastleOwnerMember(iIndex) != FALSE || g_CastleSiege.CheckCastleOwnerUnionMember(iIndex) != FALSE)

  000a1	56		 push	 esi
  000a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000a7	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  000ac	85 c0		 test	 eax, eax
  000ae	75 39		 jne	 SHORT $LN1@CGReqRegCa
  000b0	56		 push	 esi
  000b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b6	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
  000bb	85 c0		 test	 eax, eax
  000bd	75 2a		 jne	 SHORT $LN1@CGReqRegCa

; 17822: 		return;
; 17823: 	}
; 17824: 
; 17825: 	GS_GDReqRegAttackGuild(g_MapServerManager.GetMapSvrGroup(),iIndex);

  000bf	a1 00 6b 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92928
  000c4	85 c0		 test	 eax, eax
  000c6	74 11		 je	 SHORT $LN8@CGReqRegCa
  000c8	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  000cc	56		 push	 esi
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?GS_GDReqRegAttackGuild@@YAXHH@Z ; GS_GDReqRegAttackGuild
  000d3	83 c4 08	 add	 esp, 8
  000d6	5e		 pop	 esi

; 17826: #endif
; 17827: }

  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0

; 17822: 		return;
; 17823: 	}
; 17824: 
; 17825: 	GS_GDReqRegAttackGuild(g_MapServerManager.GetMapSvrGroup(),iIndex);

$LN8@CGReqRegCa:
  000d9	83 c8 ff	 or	 eax, -1
  000dc	56		 push	 esi
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ?GS_GDReqRegAttackGuild@@YAXHH@Z ; GS_GDReqRegAttackGuild
  000e3	83 c4 08	 add	 esp, 8
  000e6	5e		 pop	 esi

; 17826: #endif
; 17827: }

  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
$LN1@CGReqRegCa:

; 17820: 	{
; 17821: 		GCAnsRegCastleSiege(iIndex,3,"");

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000ee	6a 03		 push	 3
  000f0	56		 push	 esi
  000f1	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f9	5e		 pop	 esi

; 17826: #endif
; 17827: }

  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z ENDP ; CGReqRegCastleSiege
_TEXT	ENDS
PUBLIC	?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z ; CGReqGiveUpCastleSiege
EXTRN	?GS_GDReqGuildSetGiveUp@@YAXHHH@Z:PROC		; GS_GDReqGuildSetGiveUp
; Function compile flags: /Ogtp
;	COMDAT ?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z PROC ; CGReqGiveUpCastleSiege, COMDAT

; 17864: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17865: #if (GS_CASTLE==1)
; 17866: 
; 17867: 	if(g_CastleSiege.GetCastleState() < CASTLESIEGE_STATE_REGSIEGE || g_CastleSiege.GetCastleState() > CASTLESIEGE_STATE_REGMARK)

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00008	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  0000d	83 f8 01	 cmp	 eax, 1
  00010	0f 8c 8c 00 00
	00		 jl	 $LN3@CGReqGiveU@2
  00016	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0001b	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00020	83 f8 03	 cmp	 eax, 3
  00023	7f 7d		 jg	 SHORT $LN3@CGReqGiveU@2

; 17870: 		return;
; 17871: 	}
; 17872: 
; 17873: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00025	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	56		 push	 esi
  0002c	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0002f	8b c6		 mov	 eax, esi
  00031	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0003c	8d 84 10 1c 06
	00 00		 lea	 eax, DWORD PTR [eax+edx+1564]
$LL10@CGReqGiveU@2:
  00043	8a 10		 mov	 dl, BYTE PTR [eax]
  00045	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00047	75 1a		 jne	 SHORT $LN11@CGReqGiveU@2
  00049	84 d2		 test	 dl, dl
  0004b	74 12		 je	 SHORT $LN12@CGReqGiveU@2
  0004d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00050	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00053	75 0e		 jne	 SHORT $LN11@CGReqGiveU@2
  00055	83 c0 02	 add	 eax, 2
  00058	83 c1 02	 add	 ecx, 2
  0005b	84 d2		 test	 dl, dl
  0005d	75 e4		 jne	 SHORT $LL10@CGReqGiveU@2
$LN12@CGReqGiveU@2:
  0005f	33 c0		 xor	 eax, eax
  00061	eb 05		 jmp	 SHORT $LN13@CGReqGiveU@2
$LN11@CGReqGiveU@2:
  00063	1b c0		 sbb	 eax, eax
  00065	83 d8 ff	 sbb	 eax, -1
$LN13@CGReqGiveU@2:
  00068	85 c0		 test	 eax, eax
  0006a	74 33		 je	 SHORT $LN14@CGReqGiveU@2

; 17874: 		return;
; 17875: 
; 17876: 	if(g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE)

  0006c	56		 push	 esi
  0006d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00072	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  00077	85 c0		 test	 eax, eax
  00079	74 24		 je	 SHORT $LN14@CGReqGiveU@2

; 17877: 		return;
; 17878: 
; 17879: 	GS_GDReqGuildSetGiveUp(g_MapServerManager.GetMapSvrGroup(),iIndex,lpMsg->btGiveUp);

  0007b	a1 00 6b 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92928
  00080	85 c0		 test	 eax, eax
  00082	74 06		 je	 SHORT $LN7@CGReqGiveU@2
  00084	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00088	eb 03		 jmp	 SHORT $LN8@CGReqGiveU@2
$LN7@CGReqGiveU@2:
  0008a	83 c8 ff	 or	 eax, -1
$LN8@CGReqGiveU@2:
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00090	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00094	52		 push	 edx
  00095	56		 push	 esi
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ?GS_GDReqGuildSetGiveUp@@YAXHHH@Z ; GS_GDReqGuildSetGiveUp
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@CGReqGiveU@2:
  0009f	5e		 pop	 esi

; 17880: #endif
; 17881: }

  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
$LN3@CGReqGiveU@2:

; 17868: 	{
; 17869: 		GCAnsGiveUpCastleSiege(iIndex,3,0,0,"");

  000a2	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	6a 03		 push	 3
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z ; GCAnsGiveUpCastleSiege
  000b6	83 c4 14	 add	 esp, 20			; 00000014H

; 17880: #endif
; 17881: }

  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z ENDP ; CGReqGiveUpCastleSiege
_TEXT	ENDS
PUBLIC	??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ ; `string'
PUBLIC	??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@ ; `string'
PUBLIC	??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ ; `string'
PUBLIC	?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z	; CGReqNpcBuy
EXTRN	?CheckAddDbNPC@CCastleSiege@@QAEHHHHPAE@Z:PROC	; CCastleSiege::CheckAddDbNPC
;	COMDAT ??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
CONST	SEGMENT
??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ DB '[C'
	DB	'astleSiege] CGReqNpcBuy() ERROR - Authority Fail [%s][%s], Gu'
	DB	'ild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@
CONST	SEGMENT
??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@ DB '['
	DB	'CastleSiege] CGReqNpcBuy() OK - [%s][%s], Guild:(%s)(%d), Npc'
	DB	':(CLS:%d, IDX:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
CONST	SEGMENT
??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ DB '[C'
	DB	'astleSiege] CGReqNpcBuy() ERROR - CCastleSiege::CheckAddDbNPC'
	DB	'() [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_btResult$ = 11						; size = 1
_iIndex$ = 12						; size = 4
?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z PROC		; CGReqNpcBuy, COMDAT

; 18136: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 18137: #if (GS_CASTLE==1)
; 18138: 	if(lpMsg == NULL)

  00004	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	0f 84 67 01 00
	00		 je	 $LN1@CGReqNpcBu

; 18139: 		return;
; 18140: 
; 18141: 	if(gObjIsConnected(iIndex) == FALSE)

  0000f	56		 push	 esi
  00010	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00019	83 c4 04	 add	 esp, 4
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 51 01 00
	00		 je	 $LN14@CGReqNpcBu

; 18142: 		return;
; 18143: 	
; 18144: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0002f	53		 push	 ebx
  00030	8d 9c 06 1c 06
	00 00		 lea	 ebx, DWORD PTR [esi+eax+1564]
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0003c	8b c3		 mov	 eax, ebx
  0003e	8b ff		 npad	 2
$LL10@CGReqNpcBu:
  00040	8a 10		 mov	 dl, BYTE PTR [eax]
  00042	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00044	75 1a		 jne	 SHORT $LN11@CGReqNpcBu
  00046	84 d2		 test	 dl, dl
  00048	74 12		 je	 SHORT $LN12@CGReqNpcBu
  0004a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0004d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00050	75 0e		 jne	 SHORT $LN11@CGReqNpcBu
  00052	83 c0 02	 add	 eax, 2
  00055	83 c1 02	 add	 ecx, 2
  00058	84 d2		 test	 dl, dl
  0005a	75 e4		 jne	 SHORT $LL10@CGReqNpcBu
$LN12@CGReqNpcBu:
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 05		 jmp	 SHORT $LN13@CGReqNpcBu
$LN11@CGReqNpcBu:
  00060	1b c0		 sbb	 eax, eax
  00062	83 d8 ff	 sbb	 eax, -1
$LN13@CGReqNpcBu:
  00065	85 c0		 test	 eax, eax
  00067	0f 84 07 01 00
	00		 je	 $LN15@CGReqNpcBu

; 18145: 		return;
; 18146: 
; 18147: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18148: 		|| (gObj[iIndex].GuildStatus != G_MASTER && gObj[iIndex].GuildStatus != G_SUB_MASTER))

  0006d	53		 push	 ebx
  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00073	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00078	85 c0		 test	 eax, eax
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007f	0f 84 bd 00 00
	00		 je	 $LN3@CGReqNpcBu
  00085	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  0008c	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00092	74 09		 je	 SHORT $LN4@CGReqNpcBu
  00094	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00097	0f 85 a5 00 00
	00		 jne	 $LN3@CGReqNpcBu
$LN4@CGReqNpcBu:

; 18152: 		return;
; 18153: 	}
; 18154: 
; 18155: 	BYTE btResult = NULL;
; 18156: 
; 18157: 	int bRETVAL = g_CastleSiege.CheckAddDbNPC(iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,&btResult);

  0009d	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000a0	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000a3	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  000a6	8d 4d 0b	 lea	 ecx, DWORD PTR _btResult$[ebp]
  000a9	51		 push	 ecx
  000aa	52		 push	 edx
  000ab	50		 push	 eax
  000ac	53		 push	 ebx
  000ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b2	c6 45 0b 00	 mov	 BYTE PTR _btResult$[ebp], 0
  000b6	e8 00 00 00 00	 call	 ?CheckAddDbNPC@CCastleSiege@@QAEHHHHPAE@Z ; CCastleSiege::CheckAddDbNPC

; 18158: 
; 18159: 	if(bRETVAL == FALSE)
; 18160: 	{
; 18161: 		GCAnsNpcBuy(iIndex,btResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  000bb	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000be	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000c1	51		 push	 ecx
  000c2	52		 push	 edx
  000c3	85 c0		 test	 eax, eax
  000c5	75 47		 jne	 SHORT $LN2@CGReqNpcBu
  000c7	0f b6 45 0b	 movzx	 eax, BYTE PTR _btResult$[ebp]
  000cb	50		 push	 eax
  000cc	53		 push	 ebx
  000cd	e8 00 00 00 00	 call	 ?GCAnsNpcBuy@@YAXHHHH@Z	; GCAnsNpcBuy

; 18162: 		LogAddC(2,"[CastleSiege] CGReqNpcBuy() ERROR - CCastleSiege::CheckAddDbNPC() [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",
; 18163: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d7	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000da	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000dd	51		 push	 ecx
  000de	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  000e5	52		 push	 edx
  000e6	51		 push	 ecx
  000e7	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  000ee	52		 push	 edx
  000ef	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  000f3	51		 push	 ecx
  000f4	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  000f8	52		 push	 edx
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
  000fe	6a 02		 push	 2
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00106	83 c4 30	 add	 esp, 48			; 00000030H
  00109	5b		 pop	 ebx
  0010a	5e		 pop	 esi
  0010b	5f		 pop	 edi

; 18169: 	}
; 18170: #endif
; 18171: }

  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
$LN2@CGReqNpcBu:

; 18164: 	}
; 18165: 	else
; 18166: 	{
; 18167: 		LogAddC(2,"[CastleSiege] CGReqNpcBuy() OK - [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",
; 18168: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00113	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  0011a	51		 push	 ecx
  0011b	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  00122	52		 push	 edx
  00123	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00127	51		 push	 ecx
  00128	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  0012c	52		 push	 edx
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@
  00132	6a 02		 push	 2
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0013a	83 c4 20	 add	 esp, 32			; 00000020H
  0013d	5b		 pop	 ebx
  0013e	5e		 pop	 esi
  0013f	5f		 pop	 edi

; 18169: 	}
; 18170: #endif
; 18171: }

  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
$LN3@CGReqNpcBu:

; 18149: 	{
; 18150: 		LogAddC(2,"[CastleSiege] CGReqNpcBuy() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",
; 18151: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  00142	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00145	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00148	51		 push	 ecx
  00149	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  00150	52		 push	 edx
  00151	51		 push	 ecx
  00152	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  00159	52		 push	 edx
  0015a	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0015e	51		 push	 ecx
  0015f	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00163	52		 push	 edx
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
  00169	6a 02		 push	 2
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00171	83 c4 20	 add	 esp, 32			; 00000020H
$LN15@CGReqNpcBu:
  00174	5b		 pop	 ebx
$LN14@CGReqNpcBu:
  00175	5e		 pop	 esi
$LN1@CGReqNpcBu:
  00176	5f		 pop	 edi

; 18169: 	}
; 18170: #endif
; 18171: }

  00177	5d		 pop	 ebp
  00178	c3		 ret	 0
?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z ENDP		; CGReqNpcBuy
_TEXT	ENDS
PUBLIC	??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@ ; `string'
PUBLIC	??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z	; CGReqNpcRepair
EXTRN	?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z:PROC	; GS_GDReqCastleNpcRepair
EXTRN	?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z:PROC ; CCastleSiege::GetNpcData
;	COMDAT ??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\castlesiege.h
CONST	SEGMENT
??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - Authority Fail [%s][%s],'
	DB	' Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@
CONST	SEGMENT
??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() OK - [%s][%s], Guild:(%s)(%d), N'
	DB	'pc:(CLS:%d, IDX:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - Money isn''t enough [%s]'
	DB	'[%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - Npc Alive Data Mismatch '
	DB	'[%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - CL Request Fail [%s][%s]'
	DB	', Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z$0
__ehfuncinfo$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
xdata$x	ENDS
;	COMDAT ?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
_TEXT	SEGMENT
_pNpcData$ = -132					; size = 116
tv497 = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv494 = 8						; size = 4
tv485 = 8						; size = 4
tv285 = 8						; size = 4
_iRepairCost$ = 8					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z PROC	; CGReqNpcRepair, COMDAT

; 18199: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 78	 sub	 esp, 120		; 00000078H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 18200: #if (GS_CASTLE==1)
; 18201: 	if(lpMsg == NULL)

  00028	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0002b	85 ff		 test	 edi, edi
  0002d	0f 84 7f 03 00
	00		 je	 $LN35@CGReqNpcRe

; 18202: 		return;
; 18203: 
; 18204: 	if(gObjIsConnected(iIndex) == FALSE)

  00033	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003c	83 c4 04	 add	 esp, 4
  0003f	85 c0		 test	 eax, eax
  00041	0f 84 6b 03 00
	00		 je	 $LN35@CGReqNpcRe

; 18205: 		return;
; 18206: 
; 18207: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00052	8d 9c 06 1c 06
	00 00		 lea	 ebx, DWORD PTR [esi+eax+1564]
  00059	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005e	8b c3		 mov	 eax, ebx
$LL37@CGReqNpcRe:
  00060	8a 10		 mov	 dl, BYTE PTR [eax]
  00062	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00064	75 1a		 jne	 SHORT $LN38@CGReqNpcRe
  00066	84 d2		 test	 dl, dl
  00068	74 12		 je	 SHORT $LN39@CGReqNpcRe
  0006a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0006d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00070	75 0e		 jne	 SHORT $LN38@CGReqNpcRe
  00072	83 c0 02	 add	 eax, 2
  00075	83 c1 02	 add	 ecx, 2
  00078	84 d2		 test	 dl, dl
  0007a	75 e4		 jne	 SHORT $LL37@CGReqNpcRe
$LN39@CGReqNpcRe:
  0007c	33 c0		 xor	 eax, eax
  0007e	eb 05		 jmp	 SHORT $LN40@CGReqNpcRe
$LN38@CGReqNpcRe:
  00080	1b c0		 sbb	 eax, eax
  00082	83 d8 ff	 sbb	 eax, -1
$LN40@CGReqNpcRe:
  00085	85 c0		 test	 eax, eax
  00087	0f 84 25 03 00
	00		 je	 $LN35@CGReqNpcRe

; 18208: 		return;
; 18209: 
; 18210: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18211: 		|| (gObj[iIndex].GuildStatus != G_MASTER && gObj[iIndex].GuildStatus != G_SUB_MASTER))

  0008d	53		 push	 ebx
  0008e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00093	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00098	85 c0		 test	 eax, eax
  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009f	0f 84 e3 02 00
	00		 je	 $LN12@CGReqNpcRe
  000a5	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  000ac	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000b2	74 09		 je	 SHORT $LN13@CGReqNpcRe
  000b4	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000b7	0f 85 cb 02 00
	00		 jne	 $LN12@CGReqNpcRe
$LN13@CGReqNpcRe:

; 18215: 		return;
; 18216: 	}
; 18217: 
; 18218: 	_CS_NPC_DATA pNpcData;

  000bd	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$[ebp]
  000c3	e8 00 00 00 00	 call	 ??0_CS_NPC_DATA@@QAE@XZ	; _CS_NPC_DATA::_CS_NPC_DATA

; 18219: 
; 18220: 	int bRETVAL = g_CastleSiege.GetNpcData(lpMsg->iNpcNumber,lpMsg->iNpcIndex,(_CS_NPC_DATA &)pNpcData);

  000c8	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000cb	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ce	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$[ebp]
  000d4	51		 push	 ecx
  000d5	52		 push	 edx
  000d6	50		 push	 eax
  000d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000dc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000e3	e8 00 00 00 00	 call	 ?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z ; CCastleSiege::GetNpcData

; 18221: 
; 18222: 	if(bRETVAL == FALSE)

  000e8	85 c0		 test	 eax, eax
  000ea	75 5d		 jne	 SHORT $LN11@CGReqNpcRe

; 18223: 	{
; 18224: 		GCAnsNpcRepair(iIndex,0,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);

  000ec	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000ef	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000f2	50		 push	 eax
  000f3	50		 push	 eax
  000f4	51		 push	 ecx
  000f5	52		 push	 edx
  000f6	50		 push	 eax
  000f7	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair

; 18225: 		LogAddC(2,"[CastleSiege] CGReqNpcRepair() ERROR - CL Request Fail [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",
; 18226: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  00100	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00105	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00108	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0010b	51		 push	 ecx
  0010c	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  00113	52		 push	 edx
  00114	51		 push	 ecx
  00115	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  0011c	52		 push	 edx
  0011d	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00121	51		 push	 ecx
  00122	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00126	52		 push	 edx
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
  0012c	6a 02		 push	 2
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00134	83 c4 38	 add	 esp, 56			; 00000038H

; 18282: #endif
; 18283: }

  00137	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00141	59		 pop	 ecx
  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c3		 ret	 0
$LN11@CGReqNpcRe:

; 18227: 		return;
; 18228: 	}
; 18229: 
; 18230: 	int iNpcIndex = pNpcData.m_iNPC_OBJINDEX;

  00149	8b 5d 94	 mov	 ebx, DWORD PTR _pNpcData$[ebp+24]

; 18231: 
; 18232: 	if(gObjIsConnected(iNpcIndex) == FALSE)

  0014c	53		 push	 ebx
  0014d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00152	83 c4 04	 add	 esp, 4
  00155	85 c0		 test	 eax, eax
  00157	75 5e		 jne	 SHORT $LN10@CGReqNpcRe

; 18233: 	{
; 18234: 		GCAnsNpcRepair(iIndex,0,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);

  00159	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0015c	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0015f	50		 push	 eax
  00160	50		 push	 eax
  00161	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00164	50		 push	 eax
  00165	51		 push	 ecx
  00166	6a 00		 push	 0
  00168	52		 push	 edx
$LN44@CGReqNpcRe:
  00169	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair

; 18235: 		LogAddC(2,"[CastleSiege] CGReqNpcRepair() ERROR - Npc Alive Data Mismatch [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",
; 18236: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,pNpcData.m_iNPC_NUM,pNpcData.m_iNPC_INDEX);

  0016e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00173	8b 4d 88	 mov	 ecx, DWORD PTR _pNpcData$[ebp+12]
  00176	8b 55 84	 mov	 edx, DWORD PTR _pNpcData$[ebp+8]
  00179	51		 push	 ecx
  0017a	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  00181	52		 push	 edx
  00182	51		 push	 ecx
  00183	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  0018a	52		 push	 edx
  0018b	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0018f	51		 push	 ecx
  00190	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00194	52		 push	 edx
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
$LN45@CGReqNpcRe:
  0019a	6a 02		 push	 2
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001a2	83 c4 38	 add	 esp, 56			; 00000038H

; 18282: #endif
; 18283: }

  001a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001af	59		 pop	 ecx
  001b0	5f		 pop	 edi
  001b1	5e		 pop	 esi
  001b2	5b		 pop	 ebx
  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	c3		 ret	 0
$LN10@CGReqNpcRe:

; 18237: 		return;
; 18238: 	}
; 18239: 
; 18240: 	if(gObj[iNpcIndex].Live == FALSE)

  001b7	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  001bd	89 5d 08	 mov	 DWORD PTR tv285[ebp], ebx
  001c0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c6	8b 4d 08	 mov	 ecx, DWORD PTR tv285[ebp]
  001c9	03 cb		 add	 ecx, ebx
  001cb	80 79 51 00	 cmp	 BYTE PTR [ecx+81], 0
  001cf	75 14		 jne	 SHORT $LN9@CGReqNpcRe

; 18241: 	{
; 18242: 		GCAnsNpcRepair(iIndex,0,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);

  001d1	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  001d4	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  001d7	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  001da	6a 00		 push	 0
  001dc	6a 00		 push	 0
  001de	51		 push	 ecx
  001df	52		 push	 edx
  001e0	6a 00		 push	 0
  001e2	50		 push	 eax

; 18243: 		LogAddC(2,"[CastleSiege] CGReqNpcRepair() ERROR - Npc Alive Data Mismatch [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",
; 18244: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,pNpcData.m_iNPC_NUM,pNpcData.m_iNPC_INDEX);
; 18245: 		return;

  001e3	eb 84		 jmp	 SHORT $LN44@CGReqNpcRe
$LN9@CGReqNpcRe:

; 18246: 	}
; 18247: 
; 18248: 	if(gObj[iNpcIndex].MaxLife == gObj[iNpcIndex].Life || gObj[iNpcIndex].MaxLife < gObj[iNpcIndex].Life)

  001e5	d9 81 dc 00 00
	00		 fld	 DWORD PTR [ecx+220]
  001eb	d9 81 d8 00 00
	00		 fld	 DWORD PTR [ecx+216]
  001f1	da e9		 fucompp
  001f3	df e0		 fnstsw	 ax
  001f5	f6 c4 44	 test	 ah, 68			; 00000044H
  001f8	0f 8b 65 01 00
	00		 jnp	 $LN7@CGReqNpcRe
  001fe	d9 81 dc 00 00
	00		 fld	 DWORD PTR [ecx+220]
  00204	d9 81 d8 00 00
	00		 fld	 DWORD PTR [ecx+216]
  0020a	de d9		 fcompp
  0020c	df e0		 fnstsw	 ax
  0020e	f6 c4 41	 test	 ah, 65			; 00000041H
  00211	0f 84 4c 01 00
	00		 je	 $LN7@CGReqNpcRe

; 18253: 	}
; 18254: 
; 18255: 	int iRepairCost = 0;
; 18256: 
; 18257: 	switch(lpMsg->iNpcNumber)

  00217	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0021a	8b d0		 mov	 edx, eax
  0021c	81 ea 15 01 00
	00		 sub	 edx, 277		; 00000115H
  00222	74 50		 je	 SHORT $LN4@CGReqNpcRe
  00224	83 ea 06	 sub	 edx, 6
  00227	74 19		 je	 SHORT $LN3@CGReqNpcRe

; 18265: 	default:
; 18266: 		GCAnsNpcRepair(iIndex,0,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);

  00229	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0022c	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0022f	6a 00		 push	 0
  00231	6a 00		 push	 0
  00233	51		 push	 ecx
  00234	50		 push	 eax
  00235	6a 00		 push	 0
  00237	52		 push	 edx
  00238	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair

; 18267: 		return;

  0023d	e9 6d 01 00 00	 jmp	 $LN42@CGReqNpcRe
$LN3@CGReqNpcRe:

; 18261: 		break;
; 18262: 	case 283:
; 18263: 		iRepairCost = (int)((gObj[iNpcIndex].MaxLife - gObj[iNpcIndex].Life) * 3.0f +  (gObj[iNpcIndex].m_btCsNpcDfLevel + gObj[iNpcIndex].m_btCsNpcRgLevel) * 1000000);

  00242	0f b6 81 59 20
	00 00		 movzx	 eax, BYTE PTR [ecx+8281]
  00249	0f b6 91 58 20
	00 00		 movzx	 edx, BYTE PTR [ecx+8280]
  00250	03 c2		 add	 eax, edx
  00252	69 c0 40 42 0f
	00		 imul	 eax, 1000000		; 000f4240H
  00258	89 45 08	 mov	 DWORD PTR tv494[ebp], eax
  0025b	db 45 08	 fild	 DWORD PTR tv494[ebp]
  0025e	d9 81 dc 00 00
	00		 fld	 DWORD PTR [ecx+220]
  00264	d8 a1 d8 00 00
	00		 fsub	 DWORD PTR [ecx+216]
  0026a	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4008000000000000
  00270	de c1		 faddp	 ST(1), ST(0)

; 18264: 		break;

  00272	eb 25		 jmp	 SHORT $LN43@CGReqNpcRe
$LN4@CGReqNpcRe:

; 18258: 	{
; 18259: 	case 277:
; 18260: 		iRepairCost = (int)((gObj[iNpcIndex].MaxLife - gObj[iNpcIndex].Life) * 5.0f +  gObj[iNpcIndex].m_btCsNpcDfLevel * 1000000);

  00274	0f b6 81 58 20
	00 00		 movzx	 eax, BYTE PTR [ecx+8280]
  0027b	d9 81 dc 00 00
	00		 fld	 DWORD PTR [ecx+220]
  00281	d8 a1 d8 00 00
	00		 fsub	 DWORD PTR [ecx+216]
  00287	69 c0 40 42 0f
	00		 imul	 eax, 1000000		; 000f4240H
  0028d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4014000000000000
  00293	89 45 08	 mov	 DWORD PTR tv485[ebp], eax
  00296	da 45 08	 fiadd	 DWORD PTR tv485[ebp]
$LN43@CGReqNpcRe:
  00299	e8 00 00 00 00	 call	 __ftol2_sse

; 18268: 	}
; 18269: 
; 18270: 	if(gObj[iIndex].Money < iRepairCost)

  0029e	8b c8		 mov	 ecx, eax
  002a0	89 45 08	 mov	 DWORD PTR _iRepairCost$[ebp], eax
  002a3	39 8c 1e cc 00
	00 00		 cmp	 DWORD PTR [esi+ebx+204], ecx
  002aa	7d 48		 jge	 SHORT $LN1@CGReqNpcRe

; 18271: 	{
; 18272: 		GCAnsNpcRepair(iIndex,3,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);

  002ac	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  002af	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  002b2	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  002b5	6a 00		 push	 0
  002b7	6a 00		 push	 0
  002b9	52		 push	 edx
  002ba	50		 push	 eax
  002bb	6a 03		 push	 3
  002bd	51		 push	 ecx
  002be	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair

; 18273: 		LogAddC(2,"[CastleSiege] CGReqNpcRepair() ERROR - Money isn't enough [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",
; 18274: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,pNpcData.m_iNPC_NUM,pNpcData.m_iNPC_INDEX);

  002c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c8	8b 55 88	 mov	 edx, DWORD PTR _pNpcData$[ebp+12]
  002cb	8b 4d 84	 mov	 ecx, DWORD PTR _pNpcData$[ebp+8]
  002ce	52		 push	 edx
  002cf	8b 94 06 28 06
	00 00		 mov	 edx, DWORD PTR [esi+eax+1576]
  002d6	51		 push	 ecx
  002d7	52		 push	 edx
  002d8	8d 8c 06 1c 06
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1564]
  002df	51		 push	 ecx
  002e0	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  002e4	52		 push	 edx
  002e5	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  002e9	50		 push	 eax
  002ea	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@

; 18275: 		return;

  002ef	e9 a6 fe ff ff	 jmp	 $LN45@CGReqNpcRe
$LN1@CGReqNpcRe:

; 18276: 	}
; 18277: 
; 18278: 	LogAddC(2,"[CastleSiege] CGReqNpcRepair() OK - [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",
; 18279: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,pNpcData.m_iNPC_NUM,pNpcData.m_iNPC_INDEX);

  002f4	8b 4d 88	 mov	 ecx, DWORD PTR _pNpcData$[ebp+12]
  002f7	8b 55 84	 mov	 edx, DWORD PTR _pNpcData$[ebp+8]
  002fa	8b 84 1e 28 06
	00 00		 mov	 eax, DWORD PTR [esi+ebx+1576]
  00301	51		 push	 ecx
  00302	52		 push	 edx
  00303	50		 push	 eax
  00304	8d 8c 1e 1c 06
	00 00		 lea	 ecx, DWORD PTR [esi+ebx+1564]
  0030b	51		 push	 ecx
  0030c	8d 54 1e 5d	 lea	 edx, DWORD PTR [esi+ebx+93]
  00310	52		 push	 edx
  00311	8d 44 1e 52	 lea	 eax, DWORD PTR [esi+ebx+82]
  00315	50		 push	 eax
  00316	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@
  0031b	6a 02		 push	 2
  0031d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 18280: 
; 18281: 	GS_GDReqCastleNpcRepair(g_MapServerManager.GetMapSvrGroup(),iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,iRepairCost);

  00323	a1 00 6b 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92928
  00328	83 c4 20	 add	 esp, 32			; 00000020H
  0032b	85 c0		 test	 eax, eax
  0032d	74 06		 je	 SHORT $LN32@CGReqNpcRe
  0032f	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00333	eb 03		 jmp	 SHORT $LN33@CGReqNpcRe
$LN32@CGReqNpcRe:
  00335	83 c8 ff	 or	 eax, -1
$LN33@CGReqNpcRe:
  00338	8b 4d 08	 mov	 ecx, DWORD PTR _iRepairCost$[ebp]
  0033b	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  0033e	51		 push	 ecx
  0033f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00342	52		 push	 edx
  00343	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00346	51		 push	 ecx
  00347	52		 push	 edx
  00348	50		 push	 eax
  00349	e8 00 00 00 00	 call	 ?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z ; GS_GDReqCastleNpcRepair
  0034e	83 c4 14	 add	 esp, 20			; 00000014H

; 18282: #endif
; 18283: }

  00351	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00354	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0035b	59		 pop	 ecx
  0035c	5f		 pop	 edi
  0035d	5e		 pop	 esi
  0035e	5b		 pop	 ebx
  0035f	8b e5		 mov	 esp, ebp
  00361	5d		 pop	 ebp
  00362	c3		 ret	 0
$LN7@CGReqNpcRe:

; 18249: 	{
; 18250: 		gObj[iNpcIndex].Life = gObj[iNpcIndex].MaxLife;

  00363	d9 81 dc 00 00
	00		 fld	 DWORD PTR [ecx+220]

; 18251: 		GCAnsNpcRepair(iIndex,0,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);

  00369	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0036c	6a 00		 push	 0
  0036e	d9 99 d8 00 00
	00		 fstp	 DWORD PTR [ecx+216]
  00374	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00377	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0037a	6a 00		 push	 0
  0037c	50		 push	 eax
  0037d	51		 push	 ecx
  0037e	6a 00		 push	 0
  00380	52		 push	 edx
  00381	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair

; 18252: 		return;

  00386	eb 27		 jmp	 SHORT $LN42@CGReqNpcRe
$LN12@CGReqNpcRe:

; 18212: 	{
; 18213: 		LogAddC(2,"[CastleSiege] CGReqNpcRepair() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",
; 18214: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  00388	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  0038f	51		 push	 ecx
  00390	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  00397	52		 push	 edx
  00398	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0039c	51		 push	 ecx
  0039d	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  003a1	52		 push	 edx
  003a2	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
  003a7	6a 02		 push	 2
  003a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
$LN42@CGReqNpcRe:
  003af	83 c4 18	 add	 esp, 24			; 00000018H

; 18282: #endif
; 18283: }

$LN35@CGReqNpcRe:
  003b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003bc	59		 pop	 ecx
  003bd	5f		 pop	 edi
  003be	5e		 pop	 esi
  003bf	5b		 pop	 ebx
  003c0	8b e5		 mov	 esp, ebp
  003c2	5d		 pop	 ebp
  003c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z$0:
  00000	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA
__ehhandler$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 78 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-136]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z ENDP	; CGReqNpcRepair
PUBLIC	??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@ ; `string'
PUBLIC	??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z ; CGReqNpcUpgrade
EXTRN	?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z:PROC	; GS_GDReqCastleNpcUpgrade
EXTRN	?PayForUpgradeDbNPC@CCastleSiege@@QAEHHHHHHH@Z:PROC ; CCastleSiege::PayForUpgradeDbNPC
EXTRN	?g_iNpcUpDfLevel_CGATE@@3PAY02HA:BYTE		; g_iNpcUpDfLevel_CGATE
EXTRN	?g_iNpcUpMaxHP_CGATE@@3PAY02HA:BYTE		; g_iNpcUpMaxHP_CGATE
EXTRN	?g_iNpcUpDfLevel_CSTATUE@@3PAY02HA:BYTE		; g_iNpcUpDfLevel_CSTATUE
EXTRN	?g_iNpcUpRgLevel_CSTATUE@@3PAY02HA:BYTE		; g_iNpcUpRgLevel_CSTATUE
EXTRN	?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA:BYTE		; g_iNpcUpMaxHP_CSTATUE
;	COMDAT ??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\mapservermanager.h
CONST	SEGMENT
??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - Authority Fail [%s][%s]'
	DB	', Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[Ca'
	DB	'stleSiege] CGReqNpcUpgrade() REQ OK - [%s][%s], Guild:(%s)(%d'
	DB	'), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@
CONST	SEGMENT
??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@ DB '['
	DB	'CastleSiege] [0xB2][0x07] CGReqNpcUpgrade() - Pay For Npc Upg'
	DB	'rade (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - Gem is Low [%s][%s], Gu'
	DB	'ild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:'
	DB	'%d, Gem:%d, Need Gem:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - Money is Low [%s][%s], '
	DB	'Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTL'
	DB	'V:%d, Money:%d, Need Money:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - UpType doesn''t Exist ['
	DB	'%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL'
	DB	':%d', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$1
__ehfuncinfo$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
xdata$x	ENDS
;	COMDAT ?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
_TEXT	SEGMENT
_pNpcData$224395 = -148					; size = 116
_pNpcData$224369 = -148					; size = 116
tv852 = -32						; size = 4
_iNEED_MONEY$ = -28					; size = 4
_iNEED_GEMOFDEFEND$ = -24				; size = 4
_iNXT_UPVALUE$ = -20					; size = 4
_iGEMOFDEFEND_COUNT$ = -16				; size = 4
_bENABLE_UPGRADE$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
tv1132 = 8						; size = 4
_iCUR_UPLVL$ = 8					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z PROC	; CGReqNpcUpgrade, COMDAT

; 18315: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 18316: #if (GS_CASTLE==1)
; 18317: 	if(lpMsg == NULL)

  0002b	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0002e	33 ff		 xor	 edi, edi
  00030	3b f7		 cmp	 esi, edi
  00032	0f 84 91 06 00
	00		 je	 $LN59@CGReqNpcUp

; 18318: 		return;
; 18319: 
; 18320: 	if(gObjIsConnected(iIndex) == FALSE)

  00038	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  0003b	53		 push	 ebx
  0003c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00041	83 c4 04	 add	 esp, 4
  00044	85 c0		 test	 eax, eax
  00046	0f 84 7d 06 00
	00		 je	 $LN59@CGReqNpcUp

; 18321: 		return;
; 18322: 
; 18323: 	int iNEED_GEMOFDEFEND = 0;
; 18324: 	int iNEED_MONEY = 0;
; 18325: 	int iCUR_UPLVL = 0;
; 18326: 	int iNXT_UPLVL = 0;
; 18327: 	int iNXT_UPVALUE = 0;
; 18328: 	int bENABLE_UPGRADE = FALSE;
; 18329: 
; 18330: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00051	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00057	8d 94 03 1c 06
	00 00		 lea	 edx, DWORD PTR [ebx+eax+1564]
  0005e	89 7d e8	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$[ebp], edi
  00061	89 7d e4	 mov	 DWORD PTR _iNEED_MONEY$[ebp], edi
  00064	89 7d ec	 mov	 DWORD PTR _iNXT_UPVALUE$[ebp], edi
  00067	89 7d f0	 mov	 DWORD PTR _bENABLE_UPGRADE$[ebp], edi
  0006a	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006f	8b c2		 mov	 eax, edx
$LL121@CGReqNpcUp:
  00071	8a 08		 mov	 cl, BYTE PTR [eax]
  00073	3a 0f		 cmp	 cl, BYTE PTR [edi]
  00075	75 1a		 jne	 SHORT $LN122@CGReqNpcUp
  00077	84 c9		 test	 cl, cl
  00079	74 12		 je	 SHORT $LN123@CGReqNpcUp
  0007b	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0007e	3a 4f 01	 cmp	 cl, BYTE PTR [edi+1]
  00081	75 0e		 jne	 SHORT $LN122@CGReqNpcUp
  00083	83 c0 02	 add	 eax, 2
  00086	83 c7 02	 add	 edi, 2
  00089	84 c9		 test	 cl, cl
  0008b	75 e4		 jne	 SHORT $LL121@CGReqNpcUp
$LN123@CGReqNpcUp:
  0008d	33 c0		 xor	 eax, eax
  0008f	eb 05		 jmp	 SHORT $LN124@CGReqNpcUp
$LN122@CGReqNpcUp:
  00091	1b c0		 sbb	 eax, eax
  00093	83 d8 ff	 sbb	 eax, -1
$LN124@CGReqNpcUp:
  00096	33 ff		 xor	 edi, edi
  00098	3b c7		 cmp	 eax, edi
  0009a	0f 84 29 06 00
	00		 je	 $LN59@CGReqNpcUp

; 18331: 		return;
; 18332: 
; 18333: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18334: 		|| gObj[iIndex].GuildStatus != G_MASTER)

  000a0	52		 push	 edx
  000a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000a6	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  000ab	85 c0		 test	 eax, eax
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b2	0f 84 e9 05 00
	00		 je	 $LN54@CGReqNpcUp
  000b8	81 bc 03 28 06
	00 00 80 00 00
	00		 cmp	 DWORD PTR [ebx+eax+1576], 128 ; 00000080H
  000c3	0f 85 d8 05 00
	00		 jne	 $LN54@CGReqNpcUp

; 18338: 		return;
; 18339: 	}
; 18340: 
; 18341: 	switch(lpMsg->iNpcNumber)

  000c9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000cc	2d 15 01 00 00	 sub	 eax, 277		; 00000115H
  000d1	0f 84 00 02 00
	00		 je	 $LN51@CGReqNpcUp
  000d7	83 e8 06	 sub	 eax, 6
  000da	0f 85 3c 03 00
	00		 jne	 $LN116@CGReqNpcUp

; 18411: 			return;
; 18412: 		}
; 18413: 	}
; 18414: 		break;
; 18415: 	case 283:
; 18416: 	{
; 18417: 		_CS_NPC_DATA pNpcData;

  000e0	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$224395[ebp]
  000e6	e8 00 00 00 00	 call	 ??0_CS_NPC_DATA@@QAE@XZ	; _CS_NPC_DATA::_CS_NPC_DATA

; 18418: 
; 18419: 		int bIsLive = g_CastleSiege.GetNpcData(lpMsg->iNpcNumber,lpMsg->iNpcIndex,(_CS_NPC_DATA &)pNpcData);

  000eb	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ee	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$224395[ebp]
  000f4	51		 push	 ecx
  000f5	52		 push	 edx
  000f6	bf 01 00 00 00	 mov	 edi, 1
  000fb	68 1b 01 00 00	 push	 283			; 0000011bH
  00100	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00105	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00108	e8 00 00 00 00	 call	 ?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z ; CCastleSiege::GetNpcData

; 18420: 
; 18421: 		if(bIsLive != FALSE)

  0010d	85 c0		 test	 eax, eax
  0010f	0f 84 92 01 00
	00		 je	 $LN30@CGReqNpcUp

; 18422: 		{
; 18423: 			switch(lpMsg->iNpcUpType)

  00115	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00118	8b c1		 mov	 eax, ecx
  0011a	2b c7		 sub	 eax, edi
  0011c	89 4d e0	 mov	 DWORD PTR tv852[ebp], ecx
  0011f	0f 84 3a 01 00
	00		 je	 $LN27@CGReqNpcUp
  00125	2b c7		 sub	 eax, edi
  00127	0f 84 07 01 00
	00		 je	 $LN24@CGReqNpcUp
  0012d	2b c7		 sub	 eax, edi
  0012f	74 67		 je	 SHORT $LN21@CGReqNpcUp

; 18493: 			default:
; 18494: 				GCAnsNpcUpgrade(iIndex,5,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  00131	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00134	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00137	50		 push	 eax
  00138	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0013b	51		 push	 ecx
  0013c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0013f	51		 push	 ecx
  00140	52		 push	 edx
  00141	6a 05		 push	 5
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade

; 18495: 				LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - UpType doesn't Exist [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d",
; 18496: 					gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  00149	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0014c	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0014f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00154	51		 push	 ecx
  00155	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00158	52		 push	 edx
  00159	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0015c	51		 push	 ecx
  0015d	8b 8c 03 28 06
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+1576]
  00164	52		 push	 edx
  00165	51		 push	 ecx
  00166	8d 94 03 1c 06
	00 00		 lea	 edx, DWORD PTR [ebx+eax+1564]
  0016d	52		 push	 edx
  0016e	8d 4c 03 5d	 lea	 ecx, DWORD PTR [ebx+eax+93]
  00172	51		 push	 ecx
  00173	8d 54 03 52	 lea	 edx, DWORD PTR [ebx+eax+82]
  00177	52		 push	 edx
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00183	83 c4 3c	 add	 esp, 60			; 0000003cH

; 18554: #endif
; 18555: }

  00186	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00189	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00190	59		 pop	 ecx
  00191	5f		 pop	 edi
  00192	5e		 pop	 esi
  00193	5b		 pop	 ebx
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c3		 ret	 0
$LN21@CGReqNpcUp:

; 18459: 			case 3:
; 18460: 				{
; 18461: 					iCUR_UPLVL = 0;
; 18462: 					int iLV;
; 18463: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18464: 					{
; 18465: 						if(pNpcData.m_iNPC_MAXHP >= g_iNpcUpMaxHP_CSTATUE[iLV][0])

  00198	8b 45 90	 mov	 eax, DWORD PTR _pNpcData$224395[ebp+36]
  0019b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA
  001a1	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iCUR_UPLVL$[ebp], 0
  001a8	3b c2		 cmp	 eax, edx
  001aa	7c 03		 jl	 SHORT $LN19@CGReqNpcUp

; 18466: 						{
; 18467: 							iCUR_UPLVL = iLV+1;

  001ac	89 7d 08	 mov	 DWORD PTR _iCUR_UPLVL$[ebp], edi
$LN19@CGReqNpcUp:

; 18459: 			case 3:
; 18460: 				{
; 18461: 					iCUR_UPLVL = 0;
; 18462: 					int iLV;
; 18463: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18464: 					{
; 18465: 						if(pNpcData.m_iNPC_MAXHP >= g_iNpcUpMaxHP_CSTATUE[iLV][0])

  001af	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA+12
  001b5	7c 07		 jl	 SHORT $LN92@CGReqNpcUp

; 18466: 						{
; 18467: 							iCUR_UPLVL = iLV+1;

  001b7	c7 45 08 02 00
	00 00		 mov	 DWORD PTR _iCUR_UPLVL$[ebp], 2
$LN92@CGReqNpcUp:

; 18459: 			case 3:
; 18460: 				{
; 18461: 					iCUR_UPLVL = 0;
; 18462: 					int iLV;
; 18463: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18464: 					{
; 18465: 						if(pNpcData.m_iNPC_MAXHP >= g_iNpcUpMaxHP_CSTATUE[iLV][0])

  001be	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA+24
  001c4	7c 07		 jl	 SHORT $LN94@CGReqNpcUp

; 18466: 						{
; 18467: 							iCUR_UPLVL = iLV+1;

  001c6	c7 45 08 03 00
	00 00		 mov	 DWORD PTR _iCUR_UPLVL$[ebp], 3
$LN94@CGReqNpcUp:

; 18468: 						}
; 18469: 					}
; 18470: 
; 18471: 					iNXT_UPLVL = 0;
; 18472: 
; 18473: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18474: 					{
; 18475: 						if(lpMsg->iNpcUpValue >= g_iNpcUpMaxHP_CSTATUE[iLV][0])

  001cd	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001d0	33 ff		 xor	 edi, edi
  001d2	3b ca		 cmp	 ecx, edx
  001d4	7c 05		 jl	 SHORT $LN15@CGReqNpcUp

; 18476: 						{
; 18477: 							iNXT_UPLVL = iLV+1;

  001d6	bf 01 00 00 00	 mov	 edi, 1
$LN15@CGReqNpcUp:

; 18468: 						}
; 18469: 					}
; 18470: 
; 18471: 					iNXT_UPLVL = 0;
; 18472: 
; 18473: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18474: 					{
; 18475: 						if(lpMsg->iNpcUpValue >= g_iNpcUpMaxHP_CSTATUE[iLV][0])

  001db	3b 0d 0c 00 00
	00		 cmp	 ecx, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA+12
  001e1	7c 05		 jl	 SHORT $LN99@CGReqNpcUp

; 18476: 						{
; 18477: 							iNXT_UPLVL = iLV+1;

  001e3	bf 02 00 00 00	 mov	 edi, 2
$LN99@CGReqNpcUp:

; 18468: 						}
; 18469: 					}
; 18470: 
; 18471: 					iNXT_UPLVL = 0;
; 18472: 
; 18473: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18474: 					{
; 18475: 						if(lpMsg->iNpcUpValue >= g_iNpcUpMaxHP_CSTATUE[iLV][0])

  001e8	3b 0d 18 00 00
	00		 cmp	 ecx, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA+24
  001ee	7c 07		 jl	 SHORT $LN101@CGReqNpcUp

; 18476: 						{
; 18477: 							iNXT_UPLVL = iLV+1;

  001f0	bf 03 00 00 00	 mov	 edi, 3

; 18478: 						}
; 18479: 					}
; 18480: 
; 18481: 					if(iNXT_UPLVL >= 1 && iNXT_UPLVL <= CS_MAX_UPGRADE)

  001f5	eb 12		 jmp	 SHORT $LN118@CGReqNpcUp
$LN101@CGReqNpcUp:
  001f7	83 ff 01	 cmp	 edi, 1
  001fa	0f 8c 98 00 00
	00		 jl	 $LN25@CGReqNpcUp
  00200	83 ff 03	 cmp	 edi, 3
  00203	0f 8f 8f 00 00
	00		 jg	 $LN25@CGReqNpcUp
$LN118@CGReqNpcUp:

; 18482: 					{
; 18483: 						if(iNXT_UPLVL == iCUR_UPLVL + 1)

  00209	8b 45 08	 mov	 eax, DWORD PTR _iCUR_UPLVL$[ebp]
  0020c	40		 inc	 eax
  0020d	3b f8		 cmp	 edi, eax
  0020f	0f 85 83 00 00
	00		 jne	 $LN25@CGReqNpcUp

; 18484: 						{
; 18485: 							bENABLE_UPGRADE = TRUE;
; 18486: 							iNXT_UPVALUE = g_iNpcUpMaxHP_CSTATUE[iNXT_UPLVL - 1][0];

  00215	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00218	03 c0		 add	 eax, eax
  0021a	8b 94 00 f4 ff
	ff ff		 mov	 edx, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA[eax+eax-12]
  00221	03 c0		 add	 eax, eax
  00223	89 55 ec	 mov	 DWORD PTR _iNXT_UPVALUE$[ebp], edx

; 18487: 							iNEED_GEMOFDEFEND = g_iNpcUpMaxHP_CSTATUE[iNXT_UPLVL - 1][1];

  00226	8b 90 f8 ff ff
	ff		 mov	 edx, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA[eax-8]

; 18488: 							iNEED_MONEY = g_iNpcUpMaxHP_CSTATUE[iNXT_UPLVL - 1][2];

  0022c	8b 80 fc ff ff
	ff		 mov	 eax, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA[eax-4]

; 18489: 						}
; 18490: 					}
; 18491: 				}
; 18492: 				break;

  00232	eb 57		 jmp	 SHORT $LN135@CGReqNpcUp
$LN24@CGReqNpcUp:

; 18439: 					}
; 18440: 				}
; 18441: 				break;
; 18442: 			case 2:
; 18443: 				iCUR_UPLVL = pNpcData.m_iNPC_RG_LEVEL;
; 18444: 
; 18445: 				iNXT_UPLVL = lpMsg->iNpcUpValue;

  00234	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00237	8b f9		 mov	 edi, ecx

; 18446: 
; 18447: 				if(iNXT_UPLVL >= 1 && iNXT_UPLVL <= CS_MAX_UPGRADE)

  00239	8d 57 ff	 lea	 edx, DWORD PTR [edi-1]
  0023c	83 fa 02	 cmp	 edx, 2
  0023f	77 57		 ja	 SHORT $LN25@CGReqNpcUp

; 18448: 				{
; 18449: 					if(iNXT_UPLVL == iCUR_UPLVL + 1)

  00241	8b 45 8c	 mov	 eax, DWORD PTR _pNpcData$224395[ebp+32]
  00244	40		 inc	 eax
  00245	3b f8		 cmp	 edi, eax
  00247	75 4f		 jne	 SHORT $LN25@CGReqNpcUp

; 18450: 					{
; 18451: 						bENABLE_UPGRADE = TRUE;
; 18452: 						iNXT_UPVALUE = iNXT_UPLVL;
; 18453: 
; 18454: 						iNEED_GEMOFDEFEND = g_iNpcUpRgLevel_CSTATUE[iNXT_UPLVL - 1][1];

  00249	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0024c	03 c0		 add	 eax, eax
  0024e	8b 94 00 f8 ff
	ff ff		 mov	 edx, DWORD PTR ?g_iNpcUpRgLevel_CSTATUE@@3PAY02HA[eax+eax-8]
  00255	03 c0		 add	 eax, eax

; 18455: 						iNEED_MONEY = g_iNpcUpRgLevel_CSTATUE[iNXT_UPLVL - 1][2];

  00257	8b 80 fc ff ff
	ff		 mov	 eax, DWORD PTR ?g_iNpcUpRgLevel_CSTATUE@@3PAY02HA[eax-4]

; 18456: 					}
; 18457: 				}
; 18458: 				break;

  0025d	eb 29		 jmp	 SHORT $LN136@CGReqNpcUp
$LN27@CGReqNpcUp:

; 18424: 			{
; 18425: 			case 1:
; 18426: 				iCUR_UPLVL = pNpcData.m_iNPC_DF_LEVEL;
; 18427: 
; 18428: 				iNXT_UPLVL = lpMsg->iNpcUpValue;

  0025f	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00262	8b f9		 mov	 edi, ecx

; 18429: 
; 18430: 				if(iNXT_UPLVL >= 1 && iNXT_UPLVL <= CS_MAX_UPGRADE)

  00264	8d 57 ff	 lea	 edx, DWORD PTR [edi-1]
  00267	83 fa 02	 cmp	 edx, 2
  0026a	77 2c		 ja	 SHORT $LN25@CGReqNpcUp

; 18431: 				{
; 18432: 					if(iNXT_UPLVL == iCUR_UPLVL + 1)

  0026c	8b 45 88	 mov	 eax, DWORD PTR _pNpcData$224395[ebp+28]
  0026f	40		 inc	 eax
  00270	3b f8		 cmp	 edi, eax
  00272	75 24		 jne	 SHORT $LN25@CGReqNpcUp

; 18436: 
; 18437: 						iNEED_GEMOFDEFEND = g_iNpcUpDfLevel_CSTATUE[iNXT_UPLVL - 1][1];

  00274	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00277	03 c0		 add	 eax, eax
  00279	8b 94 00 f8 ff
	ff ff		 mov	 edx, DWORD PTR ?g_iNpcUpDfLevel_CSTATUE@@3PAY02HA[eax+eax-8]
  00280	03 c0		 add	 eax, eax

; 18438: 						iNEED_MONEY = g_iNpcUpDfLevel_CSTATUE[iNXT_UPLVL - 1][2];

  00282	8b 80 fc ff ff
	ff		 mov	 eax, DWORD PTR ?g_iNpcUpDfLevel_CSTATUE@@3PAY02HA[eax-4]
$LN136@CGReqNpcUp:

; 18435: 						iNXT_UPVALUE = iNXT_UPLVL;

  00288	89 7d ec	 mov	 DWORD PTR _iNXT_UPVALUE$[ebp], edi
$LN135@CGReqNpcUp:

; 18433: 					{
; 18434: 						bENABLE_UPGRADE = TRUE;

  0028b	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bENABLE_UPGRADE$[ebp], 1

; 18436: 
; 18437: 						iNEED_GEMOFDEFEND = g_iNpcUpDfLevel_CSTATUE[iNXT_UPLVL - 1][1];

  00292	89 55 e8	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$[ebp], edx

; 18438: 						iNEED_MONEY = g_iNpcUpDfLevel_CSTATUE[iNXT_UPLVL - 1][2];

  00295	89 45 e4	 mov	 DWORD PTR _iNEED_MONEY$[ebp], eax
$LN25@CGReqNpcUp:

; 18503: 			return;
; 18504: 		}
; 18505: 	}

  00298	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pNpcData$224395[ebp], OFFSET ??_7_CS_NPC_DATA@@6B@

; 18506: 		break;

  002a2	e9 68 01 00 00	 jmp	 $LN45@CGReqNpcUp
$LN30@CGReqNpcUp:

; 18497: 				return;
; 18498: 			}
; 18499: 		}
; 18500: 		else
; 18501: 		{
; 18502: 			GCAnsNpcUpgrade(iIndex,7,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  002a7	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  002aa	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  002ad	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002b0	51		 push	 ecx
  002b1	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  002b4	52		 push	 edx
  002b5	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  002b8	50		 push	 eax
  002b9	51		 push	 ecx
  002ba	6a 07		 push	 7
  002bc	52		 push	 edx
  002bd	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade
  002c2	83 c4 18	 add	 esp, 24			; 00000018H

; 18554: #endif
; 18555: }

  002c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002cf	59		 pop	 ecx
  002d0	5f		 pop	 edi
  002d1	5e		 pop	 esi
  002d2	5b		 pop	 ebx
  002d3	8b e5		 mov	 esp, ebp
  002d5	5d		 pop	 ebp
  002d6	c3		 ret	 0
$LN51@CGReqNpcUp:

; 18342: 	{
; 18343: 	case 277:
; 18344: 	{
; 18345: 		_CS_NPC_DATA pNpcData;

  002d7	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$224369[ebp]
  002dd	e8 00 00 00 00	 call	 ??0_CS_NPC_DATA@@QAE@XZ	; _CS_NPC_DATA::_CS_NPC_DATA

; 18346: 
; 18347: 		int bIsLive = g_CastleSiege.GetNpcData(lpMsg->iNpcNumber,lpMsg->iNpcIndex,(_CS_NPC_DATA &)pNpcData);

  002e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  002e5	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _pNpcData$224369[ebp]
  002eb	50		 push	 eax
  002ec	51		 push	 ecx
  002ed	68 15 01 00 00	 push	 277			; 00000115H
  002f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002f7	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  002fa	e8 00 00 00 00	 call	 ?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z ; CCastleSiege::GetNpcData

; 18348: 
; 18349: 		if(bIsLive != FALSE)
; 18350: 		{
; 18351: 			switch(lpMsg->iNpcUpType)

  002ff	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00302	3b c7		 cmp	 eax, edi
  00304	0f 84 6a 03 00
	00		 je	 $LN50@CGReqNpcUp
  0030a	8b c1		 mov	 eax, ecx
  0030c	48		 dec	 eax
  0030d	89 4d e0	 mov	 DWORD PTR tv852[ebp], ecx
  00310	0f 84 c0 00 00
	00		 je	 $LN47@CGReqNpcUp
  00316	83 e8 02	 sub	 eax, 2
  00319	74 2d		 je	 SHORT $LN44@CGReqNpcUp

; 18403: 			default:
; 18404: 				GCAnsNpcUpgrade(iIndex,5,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  0031b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0031e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00321	52		 push	 edx
  00322	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00325	51		 push	 ecx
  00326	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00329	50		 push	 eax
  0032a	51		 push	 ecx
  0032b	6a 05		 push	 5
  0032d	52		 push	 edx
  0032e	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade
  00333	83 c4 18	 add	 esp, 24			; 00000018H

; 18554: #endif
; 18555: }

  00336	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00339	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00340	59		 pop	 ecx
  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b e5		 mov	 esp, ebp
  00346	5d		 pop	 ebp
  00347	c3		 ret	 0
$LN44@CGReqNpcUp:

; 18365: 					}
; 18366: 				}
; 18367: 				break;
; 18368: 			case 3:
; 18369: 				{
; 18370: 					iCUR_UPLVL = 0;
; 18371: 					int iLV;
; 18372: 
; 18373: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18374: 					{
; 18375: 						if(pNpcData.m_iNPC_MAXHP >= g_iNpcUpMaxHP_CGATE[iLV][0])

  00348	8b 45 90	 mov	 eax, DWORD PTR _pNpcData$224369[ebp+36]
  0034b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA
  00351	89 7d 08	 mov	 DWORD PTR _iCUR_UPLVL$[ebp], edi
  00354	3b c2		 cmp	 eax, edx
  00356	7c 07		 jl	 SHORT $LN42@CGReqNpcUp

; 18376: 						{
; 18377: 							iCUR_UPLVL = iLV+1;

  00358	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _iCUR_UPLVL$[ebp], 1
$LN42@CGReqNpcUp:

; 18365: 					}
; 18366: 				}
; 18367: 				break;
; 18368: 			case 3:
; 18369: 				{
; 18370: 					iCUR_UPLVL = 0;
; 18371: 					int iLV;
; 18372: 
; 18373: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18374: 					{
; 18375: 						if(pNpcData.m_iNPC_MAXHP >= g_iNpcUpMaxHP_CGATE[iLV][0])

  0035f	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA+12
  00365	7c 07		 jl	 SHORT $LN106@CGReqNpcUp

; 18376: 						{
; 18377: 							iCUR_UPLVL = iLV+1;

  00367	c7 45 08 02 00
	00 00		 mov	 DWORD PTR _iCUR_UPLVL$[ebp], 2
$LN106@CGReqNpcUp:

; 18365: 					}
; 18366: 				}
; 18367: 				break;
; 18368: 			case 3:
; 18369: 				{
; 18370: 					iCUR_UPLVL = 0;
; 18371: 					int iLV;
; 18372: 
; 18373: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18374: 					{
; 18375: 						if(pNpcData.m_iNPC_MAXHP >= g_iNpcUpMaxHP_CGATE[iLV][0])

  0036e	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA+24
  00374	7c 07		 jl	 SHORT $LN108@CGReqNpcUp

; 18376: 						{
; 18377: 							iCUR_UPLVL = iLV+1;

  00376	c7 45 08 03 00
	00 00		 mov	 DWORD PTR _iCUR_UPLVL$[ebp], 3
$LN108@CGReqNpcUp:

; 18378: 						}
; 18379: 					}
; 18380: 
; 18381: 					iNXT_UPLVL = 0;
; 18382: 
; 18383: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18384: 					{
; 18385: 						if(lpMsg->iNpcUpValue >= g_iNpcUpMaxHP_CGATE[iLV][0])

  0037d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00380	3b ca		 cmp	 ecx, edx
  00382	7c 05		 jl	 SHORT $LN38@CGReqNpcUp

; 18386: 						{
; 18387: 							iNXT_UPLVL = iLV+1;

  00384	bf 01 00 00 00	 mov	 edi, 1
$LN38@CGReqNpcUp:

; 18378: 						}
; 18379: 					}
; 18380: 
; 18381: 					iNXT_UPLVL = 0;
; 18382: 
; 18383: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18384: 					{
; 18385: 						if(lpMsg->iNpcUpValue >= g_iNpcUpMaxHP_CGATE[iLV][0])

  00389	3b 0d 0c 00 00
	00		 cmp	 ecx, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA+12
  0038f	7c 05		 jl	 SHORT $LN113@CGReqNpcUp

; 18386: 						{
; 18387: 							iNXT_UPLVL = iLV+1;

  00391	bf 02 00 00 00	 mov	 edi, 2
$LN113@CGReqNpcUp:

; 18378: 						}
; 18379: 					}
; 18380: 
; 18381: 					iNXT_UPLVL = 0;
; 18382: 
; 18383: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18384: 					{
; 18385: 						if(lpMsg->iNpcUpValue >= g_iNpcUpMaxHP_CGATE[iLV][0])

  00396	3b 0d 18 00 00
	00		 cmp	 ecx, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA+24
  0039c	7c 07		 jl	 SHORT $LN115@CGReqNpcUp

; 18386: 						{
; 18387: 							iNXT_UPLVL = iLV+1;

  0039e	bf 03 00 00 00	 mov	 edi, 3

; 18388: 						}
; 18389: 					}
; 18390: 
; 18391: 					if(iNXT_UPLVL >= 1 && iNXT_UPLVL <= CS_MAX_UPGRADE)

  003a3	eb 0a		 jmp	 SHORT $LN120@CGReqNpcUp
$LN115@CGReqNpcUp:
  003a5	83 ff 01	 cmp	 edi, 1
  003a8	7c 65		 jl	 SHORT $LN45@CGReqNpcUp
  003aa	83 ff 03	 cmp	 edi, 3
  003ad	7f 60		 jg	 SHORT $LN45@CGReqNpcUp
$LN120@CGReqNpcUp:

; 18392: 					{
; 18393: 						if(iNXT_UPLVL == iCUR_UPLVL + 1)

  003af	8b 45 08	 mov	 eax, DWORD PTR _iCUR_UPLVL$[ebp]
  003b2	40		 inc	 eax
  003b3	3b f8		 cmp	 edi, eax
  003b5	75 58		 jne	 SHORT $LN45@CGReqNpcUp

; 18394: 						{
; 18395: 							bENABLE_UPGRADE = TRUE;
; 18396: 							iNXT_UPVALUE = g_iNpcUpMaxHP_CGATE[iNXT_UPLVL - 1][0];

  003b7	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  003ba	03 c0		 add	 eax, eax
  003bc	8b 94 00 f4 ff
	ff ff		 mov	 edx, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA[eax+eax-12]
  003c3	03 c0		 add	 eax, eax
  003c5	89 55 ec	 mov	 DWORD PTR _iNXT_UPVALUE$[ebp], edx

; 18397: 							iNEED_GEMOFDEFEND = g_iNpcUpMaxHP_CGATE[iNXT_UPLVL - 1][1];

  003c8	8b 90 f8 ff ff
	ff		 mov	 edx, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA[eax-8]

; 18398: 							iNEED_MONEY = g_iNpcUpMaxHP_CGATE[iNXT_UPLVL - 1][2];

  003ce	8b 80 fc ff ff
	ff		 mov	 eax, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA[eax-4]

; 18399: 						}
; 18400: 					}
; 18401: 				}
; 18402: 				break;

  003d4	eb 2c		 jmp	 SHORT $LN137@CGReqNpcUp
$LN47@CGReqNpcUp:

; 18352: 			{
; 18353: 			case 1:
; 18354: 				iCUR_UPLVL = pNpcData.m_iNPC_DF_LEVEL;
; 18355: 				iNXT_UPLVL = lpMsg->iNpcUpValue;

  003d6	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  003d9	8b f9		 mov	 edi, ecx

; 18356: 
; 18357: 				if(iNXT_UPLVL >= 1 && iNXT_UPLVL <= CS_MAX_UPGRADE)

  003db	8d 57 ff	 lea	 edx, DWORD PTR [edi-1]
  003de	83 fa 02	 cmp	 edx, 2
  003e1	77 2c		 ja	 SHORT $LN45@CGReqNpcUp

; 18358: 				{
; 18359: 					if(iNXT_UPLVL == iCUR_UPLVL + 1)

  003e3	8b 45 88	 mov	 eax, DWORD PTR _pNpcData$224369[ebp+28]
  003e6	40		 inc	 eax
  003e7	3b f8		 cmp	 edi, eax
  003e9	75 24		 jne	 SHORT $LN45@CGReqNpcUp

; 18360: 					{
; 18361: 						bENABLE_UPGRADE = TRUE;
; 18362: 						iNXT_UPVALUE = iNXT_UPLVL;
; 18363: 						iNEED_GEMOFDEFEND = g_iNpcUpDfLevel_CGATE[iNXT_UPLVL - 1][1];

  003eb	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  003ee	03 c0		 add	 eax, eax
  003f0	8b 94 00 f8 ff
	ff ff		 mov	 edx, DWORD PTR ?g_iNpcUpDfLevel_CGATE@@3PAY02HA[eax+eax-8]
  003f7	03 c0		 add	 eax, eax

; 18364: 						iNEED_MONEY = g_iNpcUpDfLevel_CGATE[iNXT_UPLVL - 1][2];

  003f9	8b 80 fc ff ff
	ff		 mov	 eax, DWORD PTR ?g_iNpcUpDfLevel_CGATE@@3PAY02HA[eax-4]
  003ff	89 7d ec	 mov	 DWORD PTR _iNXT_UPVALUE$[ebp], edi
$LN137@CGReqNpcUp:
  00402	89 45 e4	 mov	 DWORD PTR _iNEED_MONEY$[ebp], eax
  00405	89 55 e8	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$[ebp], edx
  00408	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bENABLE_UPGRADE$[ebp], 1
$LN45@CGReqNpcUp:

; 18507: 	}
; 18508: 
; 18509: 	if(bENABLE_UPGRADE == FALSE)

  0040f	83 7d f0 00	 cmp	 DWORD PTR _bENABLE_UPGRADE$[ebp], 0
  00413	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0041a	75 30		 jne	 SHORT $LN8@CGReqNpcUp
$LN116@CGReqNpcUp:

; 18510: 	{
; 18511: 		GCAnsNpcUpgrade(iIndex,6,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  0041c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0041f	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00422	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00425	51		 push	 ecx
  00426	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00429	52		 push	 edx
  0042a	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0042d	50		 push	 eax
  0042e	51		 push	 ecx
  0042f	6a 06		 push	 6
  00431	52		 push	 edx
  00432	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade
  00437	83 c4 18	 add	 esp, 24			; 00000018H

; 18554: #endif
; 18555: }

  0043a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0043d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00444	59		 pop	 ecx
  00445	5f		 pop	 edi
  00446	5e		 pop	 esi
  00447	5b		 pop	 ebx
  00448	8b e5		 mov	 esp, ebp
  0044a	5d		 pop	 ebp
  0044b	c3		 ret	 0
$LN8@CGReqNpcUp:

; 18512: 		return;
; 18513: 	}
; 18514: 
; 18515: 	if(gObj[iIndex].Money < iNEED_MONEY)

  0044c	8b 45 e4	 mov	 eax, DWORD PTR _iNEED_MONEY$[ebp]
  0044f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00455	39 84 13 cc 00
	00 00		 cmp	 DWORD PTR [ebx+edx+204], eax
  0045c	7d 74		 jge	 SHORT $LN7@CGReqNpcUp

; 18516: 	{
; 18517: 		GCAnsNpcUpgrade(iIndex,3,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  0045e	8b 45 e0	 mov	 eax, DWORD PTR tv852[ebp]
  00461	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00464	51		 push	 ecx
  00465	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00468	50		 push	 eax
  00469	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0046c	51		 push	 ecx
  0046d	52		 push	 edx
  0046e	6a 03		 push	 3
  00470	50		 push	 eax
  00471	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade

; 18518: 		LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - Money is Low [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d, Money:%d, Need Money:%d",
; 18519: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL,gObj[iIndex].Money,iNEED_MONEY);

  00476	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0047b	8b 4d e4	 mov	 ecx, DWORD PTR _iNEED_MONEY$[ebp]
  0047e	8b 94 03 cc 00
	00 00		 mov	 edx, DWORD PTR [ebx+eax+204]
  00485	51		 push	 ecx
  00486	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00489	52		 push	 edx
  0048a	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0048d	57		 push	 edi
  0048e	51		 push	 ecx
  0048f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00492	52		 push	 edx
  00493	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00496	51		 push	 ecx
  00497	8b 8c 03 28 06
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+1576]
  0049e	52		 push	 edx
  0049f	51		 push	 ecx
  004a0	8d 94 03 1c 06
	00 00		 lea	 edx, DWORD PTR [ebx+eax+1564]
  004a7	52		 push	 edx
  004a8	8d 4c 03 5d	 lea	 ecx, DWORD PTR [ebx+eax+93]
  004ac	51		 push	 ecx
  004ad	8d 54 03 52	 lea	 edx, DWORD PTR [ebx+eax+82]
  004b1	52		 push	 edx
  004b2	68 00 00 00 00	 push	 OFFSET ??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  004b7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004bd	83 c4 48	 add	 esp, 72			; 00000048H

; 18554: #endif
; 18555: }

  004c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004ca	59		 pop	 ecx
  004cb	5f		 pop	 edi
  004cc	5e		 pop	 esi
  004cd	5b		 pop	 ebx
  004ce	8b e5		 mov	 esp, ebp
  004d0	5d		 pop	 ebp
  004d1	c3		 ret	 0
$LN7@CGReqNpcUp:

; 18520: 		return;
; 18521: 	}
; 18522: 
; 18523: 	int iGEMOFDEFEND_COUNT = 0;

  004d2	33 c0		 xor	 eax, eax
  004d4	89 45 f0	 mov	 DWORD PTR _iGEMOFDEFEND_COUNT$[ebp], eax
  004d7	89 45 08	 mov	 DWORD PTR tv1132[ebp], eax
$LN6@CGReqNpcUp:

; 18526: 	{
; 18527: 		if(gObj[iIndex].pInventory[x].IsItem() == TRUE && gObj[iIndex].pInventory[x].m_Type == ITEMGET(14,31))

  004da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004df	8b 8c 03 c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4544]
  004e6	03 4d 08	 add	 ecx, DWORD PTR tv1132[ebp]
  004e9	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  004ee	83 f8 01	 cmp	 eax, 1
  004f1	75 1f		 jne	 SHORT $LN5@CGReqNpcUp
  004f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004f9	8b 94 0b c0 11
	00 00		 mov	 edx, DWORD PTR [ebx+ecx+4544]
  00500	8b 4d 08	 mov	 ecx, DWORD PTR tv1132[ebp]
  00503	b8 1f 1c 00 00	 mov	 eax, 7199		; 00001c1fH
  00508	66 39 44 0a 06	 cmp	 WORD PTR [edx+ecx+6], ax
  0050d	75 03		 jne	 SHORT $LN5@CGReqNpcUp

; 18528: 		{
; 18529: 			iGEMOFDEFEND_COUNT++;

  0050f	ff 45 f0	 inc	 DWORD PTR _iGEMOFDEFEND_COUNT$[ebp]
$LN5@CGReqNpcUp:

; 18524: 
; 18525: 	for(int x = 0; x < INVENTORY_SIZE; x++)

  00512	8b 45 08	 mov	 eax, DWORD PTR tv1132[ebp]
  00515	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  0051a	89 45 08	 mov	 DWORD PTR tv1132[ebp], eax
  0051d	3d 44 c4 00 00	 cmp	 eax, 50244		; 0000c444H
  00522	7c b6		 jl	 SHORT $LN6@CGReqNpcUp

; 18530: 		}
; 18531: 	}
; 18532: 
; 18533: 	if(iGEMOFDEFEND_COUNT < iNEED_GEMOFDEFEND)

  00524	8b 55 e8	 mov	 edx, DWORD PTR _iNEED_GEMOFDEFEND$[ebp]
  00527	39 55 f0	 cmp	 DWORD PTR _iGEMOFDEFEND_COUNT$[ebp], edx
  0052a	7d 73		 jge	 SHORT $LN2@CGReqNpcUp

; 18534: 	{
; 18535: 		GCAnsNpcUpgrade(iIndex,4,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  0052c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0052f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00532	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00535	50		 push	 eax
  00536	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00539	51		 push	 ecx
  0053a	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0053d	52		 push	 edx
  0053e	50		 push	 eax
  0053f	6a 04		 push	 4
  00541	51		 push	 ecx
  00542	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade

; 18536: 		LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - Gem is Low [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d, Gem:%d, Need Gem:%d",
; 18537: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL,iGEMOFDEFEND_COUNT,iNEED_GEMOFDEFEND);

  00547	8b 55 e8	 mov	 edx, DWORD PTR _iNEED_GEMOFDEFEND$[ebp]
  0054a	8b 4d f0	 mov	 ecx, DWORD PTR _iGEMOFDEFEND_COUNT$[ebp]
  0054d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00552	52		 push	 edx
  00553	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00556	51		 push	 ecx
  00557	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0055a	57		 push	 edi
  0055b	52		 push	 edx
  0055c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0055f	51		 push	 ecx
  00560	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00563	52		 push	 edx
  00564	8b 94 03 28 06
	00 00		 mov	 edx, DWORD PTR [ebx+eax+1576]
  0056b	51		 push	 ecx
  0056c	52		 push	 edx
  0056d	8d 8c 03 1c 06
	00 00		 lea	 ecx, DWORD PTR [ebx+eax+1564]
  00574	51		 push	 ecx
  00575	8d 54 03 5d	 lea	 edx, DWORD PTR [ebx+eax+93]
  00579	52		 push	 edx
  0057a	8d 44 03 52	 lea	 eax, DWORD PTR [ebx+eax+82]
  0057e	50		 push	 eax
  0057f	68 00 00 00 00	 push	 OFFSET ??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  00584	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0058a	83 c4 48	 add	 esp, 72			; 00000048H

; 18554: #endif
; 18555: }

  0058d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00590	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00597	59		 pop	 ecx
  00598	5f		 pop	 edi
  00599	5e		 pop	 esi
  0059a	5b		 pop	 ebx
  0059b	8b e5		 mov	 esp, ebp
  0059d	5d		 pop	 ebp
  0059e	c3		 ret	 0
$LN2@CGReqNpcUp:

; 18538: 		return;
; 18539: 	}
; 18540: 
; 18541: 	int bRESULT = g_CastleSiege.PayForUpgradeDbNPC(iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL -1);

  0059f	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  005a2	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  005a5	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  005a8	50		 push	 eax
  005a9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  005ac	51		 push	 ecx
  005ad	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  005b0	52		 push	 edx
  005b1	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  005b4	50		 push	 eax
  005b5	51		 push	 ecx
  005b6	52		 push	 edx
  005b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  005bc	e8 00 00 00 00	 call	 ?PayForUpgradeDbNPC@CCastleSiege@@QAEHHHHHHH@Z ; CCastleSiege::PayForUpgradeDbNPC

; 18542: 
; 18543: 	if(bRESULT == FALSE)

  005c1	85 c0		 test	 eax, eax
  005c3	0f 84 00 01 00
	00		 je	 $LN59@CGReqNpcUp

; 18544: 		return;
; 18545: 
; 18546: 	gObj[iIndex].m_bIsCastleNPCUpgradeCompleted = TRUE;

  005c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 18547: 
; 18548: 	LogAddTD("[CastleSiege] [0xB2][0x07] CGReqNpcUpgrade() - Pay For Npc Upgrade (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)",
; 18549: 		lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,iNXT_UPVALUE);

  005ce	8b 4d ec	 mov	 ecx, DWORD PTR _iNXT_UPVALUE$[ebp]
  005d1	51		 push	 ecx
  005d2	c6 84 03 5c 20
	00 00 01	 mov	 BYTE PTR [ebx+eax+8284], 1
  005da	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  005dd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  005e0	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  005e3	52		 push	 edx
  005e4	50		 push	 eax
  005e5	51		 push	 ecx
  005e6	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@
  005eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 18550: 
; 18551: 	GS_GDReqCastleNpcUpgrade(g_MapServerManager.GetMapSvrGroup(),iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,iNXT_UPVALUE,iNXT_UPLVL -1);

  005f1	a1 00 6b 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92928
  005f6	83 c4 14	 add	 esp, 20			; 00000014H
  005f9	85 c0		 test	 eax, eax
  005fb	74 06		 je	 SHORT $LN75@CGReqNpcUp
  005fd	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00601	eb 03		 jmp	 SHORT $LN76@CGReqNpcUp
$LN75@CGReqNpcUp:
  00603	83 c8 ff	 or	 eax, -1
$LN76@CGReqNpcUp:
  00606	8b 55 ec	 mov	 edx, DWORD PTR _iNXT_UPVALUE$[ebp]
  00609	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  0060c	51		 push	 ecx
  0060d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00610	52		 push	 edx
  00611	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00614	51		 push	 ecx
  00615	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00618	52		 push	 edx
  00619	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0061c	51		 push	 ecx
  0061d	52		 push	 edx
  0061e	50		 push	 eax
  0061f	e8 00 00 00 00	 call	 ?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z ; GS_GDReqCastleNpcUpgrade

; 18552: 	LogAddTD("[CastleSiege] CGReqNpcUpgrade() REQ OK - [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d",
; 18553: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL);

  00624	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00627	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0062a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0062f	57		 push	 edi
  00630	51		 push	 ecx
  00631	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00634	52		 push	 edx
  00635	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00638	51		 push	 ecx
  00639	8b 8c 03 28 06
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+1576]
  00640	52		 push	 edx
  00641	51		 push	 ecx
  00642	8d 94 03 1c 06
	00 00		 lea	 edx, DWORD PTR [ebx+eax+1564]
  00649	52		 push	 edx
  0064a	8d 4c 03 5d	 lea	 ecx, DWORD PTR [ebx+eax+93]
  0064e	51		 push	 ecx
  0064f	8d 54 03 52	 lea	 edx, DWORD PTR [ebx+eax+82]
  00653	52		 push	 edx
  00654	68 00 00 00 00	 push	 OFFSET ??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  00659	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0065f	83 c4 44	 add	 esp, 68			; 00000044H

; 18554: #endif
; 18555: }

  00662	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00665	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0066c	59		 pop	 ecx
  0066d	5f		 pop	 edi
  0066e	5e		 pop	 esi
  0066f	5b		 pop	 ebx
  00670	8b e5		 mov	 esp, ebp
  00672	5d		 pop	 ebp
  00673	c3		 ret	 0
$LN50@CGReqNpcUp:

; 18405: 				return;
; 18406: 			}
; 18407: 		}
; 18408: 		else
; 18409: 		{
; 18410: 			GCAnsNpcUpgrade(iIndex,7,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  00674	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00677	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0067a	50		 push	 eax
  0067b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0067e	51		 push	 ecx
  0067f	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00682	52		 push	 edx
  00683	50		 push	 eax
  00684	6a 07		 push	 7
  00686	51		 push	 ecx
  00687	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade
  0068c	83 c4 18	 add	 esp, 24			; 00000018H

; 18554: #endif
; 18555: }

  0068f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00692	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00699	59		 pop	 ecx
  0069a	5f		 pop	 edi
  0069b	5e		 pop	 esi
  0069c	5b		 pop	 ebx
  0069d	8b e5		 mov	 esp, ebp
  0069f	5d		 pop	 ebp
  006a0	c3		 ret	 0
$LN54@CGReqNpcUp:

; 18335: 	{
; 18336: 		LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",
; 18337: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  006a1	8b 94 03 28 06
	00 00		 mov	 edx, DWORD PTR [ebx+eax+1576]
  006a8	52		 push	 edx
  006a9	8d 8c 03 1c 06
	00 00		 lea	 ecx, DWORD PTR [ebx+eax+1564]
  006b0	51		 push	 ecx
  006b1	8d 54 03 5d	 lea	 edx, DWORD PTR [ebx+eax+93]
  006b5	52		 push	 edx
  006b6	8d 44 03 52	 lea	 eax, DWORD PTR [ebx+eax+82]
  006ba	50		 push	 eax
  006bb	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  006c0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006c6	83 c4 14	 add	 esp, 20			; 00000014H
$LN59@CGReqNpcUp:

; 18554: #endif
; 18555: }

  006c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006d3	59		 pop	 ecx
  006d4	5f		 pop	 edi
  006d5	5e		 pop	 esi
  006d6	5b		 pop	 ebx
  006d7	8b e5		 mov	 esp, ebp
  006d9	5d		 pop	 ebp
  006da	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$1:
  00000	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$224395[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA
__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$0:
  0000b	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$224369[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA
__ehhandler$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z ENDP	; CGReqNpcUpgrade
PUBLIC	??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ ; `string'
PUBLIC	??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ ; `string'
PUBLIC	??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ ; `string'
PUBLIC	?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z ; CGReqTaxRateChange
EXTRN	?GS_GDReqTaxRateChange@@YAXHHHH@Z:PROC		; GS_GDReqTaxRateChange
;	COMDAT ??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\mapservermanager.h
CONST	SEGMENT
??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ DB '[CastleSi'
	DB	'ege] CGReqTaxRateChange() ERROR - Authority Fail [%s][%s], Gu'
	DB	'ild:(%s)(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
CONST	SEGMENT
??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ DB '[CastleSi'
	DB	'ege] CGReqTaxRateChange() ERROR - Tax Rate Out of Range [%s]['
	DB	'%s], Guild:(%s)(%d), TaxType:%d, TaxRate:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
CONST	SEGMENT
??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ DB '[CastleSi'
	DB	'ege] CGReqTaxRateChange() REQ OK - [%s][%s], Guild:(%s)(%d), '
	DB	'TaxType:%d, TaxRate:%d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z PROC ; CGReqTaxRateChange, COMDAT

; 18656: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 18657: #if (GS_CASTLE==1)
; 18658: 	if(lpMsg == NULL)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	0f 84 82 01 00
	00		 je	 $LN12@CGReqTaxRa

; 18659: 		return;
; 18660: 
; 18661: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00018	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0001e	57		 push	 edi
  0001f	8d bc 06 1c 06
	00 00		 lea	 edi, DWORD PTR [esi+eax+1564]
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002b	8b c7		 mov	 eax, edi
  0002d	8d 49 00	 npad	 3
$LL17@CGReqTaxRa:
  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00034	75 1a		 jne	 SHORT $LN18@CGReqTaxRa
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN19@CGReqTaxRa
  0003a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00040	75 0e		 jne	 SHORT $LN18@CGReqTaxRa
  00042	83 c0 02	 add	 eax, 2
  00045	83 c1 02	 add	 ecx, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL17@CGReqTaxRa
$LN19@CGReqTaxRa:
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN20@CGReqTaxRa
$LN18@CGReqTaxRa:
  00050	1b c0		 sbb	 eax, eax
  00052	83 d8 ff	 sbb	 eax, -1
$LN20@CGReqTaxRa:
  00055	85 c0		 test	 eax, eax
  00057	0f 84 32 01 00
	00		 je	 $LN21@CGReqTaxRa

; 18662: 		return;
; 18663: 
; 18664: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18665: 		|| gObj[iIndex].GuildStatus != G_MASTER)

  0005d	57		 push	 edi
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00063	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00068	85 c0		 test	 eax, eax
  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	0f 84 f0 00 00
	00		 je	 $LN8@CGReqTaxRa
  00075	81 bc 06 28 06
	00 00 80 00 00
	00		 cmp	 DWORD PTR [esi+eax+1576], 128 ; 00000080H
  00080	0f 85 df 00 00
	00		 jne	 $LN8@CGReqTaxRa

; 18669: 		return;
; 18670: 	}
; 18671: 
; 18672: 	int iMaxTaxRate =0;
; 18673: 
; 18674: 	switch(lpMsg->btTaxType)

  00086	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  0008a	8b c1		 mov	 eax, ecx
  0008c	33 d2		 xor	 edx, edx
  0008e	48		 dec	 eax
  0008f	74 0d		 je	 SHORT $LN5@CGReqTaxRa
  00091	48		 dec	 eax
  00092	74 0a		 je	 SHORT $LN5@CGReqTaxRa
  00094	48		 dec	 eax
  00095	75 0c		 jne	 SHORT $LN6@CGReqTaxRa

; 18678: 		break;
; 18679: 	case 2:
; 18680: 		iMaxTaxRate = 3;
; 18681: 		break;
; 18682: 	case 3:
; 18683: 		iMaxTaxRate = 300000;

  00097	ba e0 93 04 00	 mov	 edx, 300000		; 000493e0H

; 18684: 		break;

  0009c	eb 05		 jmp	 SHORT $LN6@CGReqTaxRa
$LN5@CGReqTaxRa:

; 18675: 	{
; 18676: 	case 1:
; 18677: 		iMaxTaxRate = 3;

  0009e	ba 03 00 00 00	 mov	 edx, 3
$LN6@CGReqTaxRa:

; 18685: 	}
; 18686: 
; 18687: 	int iTaxRate = (( ( ( (lpMsg->btTaxRate4 & 0xFF) & 0xFF | ((lpMsg->btTaxRate3 & 0xFF) & 0xFF ) << 8)) &0xFFFF) & 0xFFFF) & 0xFFFF | ((( ( ( (lpMsg->btTaxRate2 & 0xFF) & 0xFF | ((lpMsg->btTaxRate1 & 0xFF) & 0xFF ) << 8)) &0xFFFF) & 0xFFFF) & 0xFFFF) << 16;

  000a3	0f b6 7b 05	 movzx	 edi, BYTE PTR [ebx+5]
  000a7	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  000ab	c1 e7 08	 shl	 edi, 8
  000ae	0b f8		 or	 edi, eax
  000b0	0f b6 43 07	 movzx	 eax, BYTE PTR [ebx+7]
  000b4	c1 e7 08	 shl	 edi, 8
  000b7	0b f8		 or	 edi, eax
  000b9	0f b6 43 08	 movzx	 eax, BYTE PTR [ebx+8]
  000bd	c1 e7 08	 shl	 edi, 8
  000c0	0b f8		 or	 edi, eax

; 18688: 
; 18689: 	if(iTaxRate < 0 || iTaxRate > iMaxTaxRate)

  000c2	7c 5a		 jl	 SHORT $LN1@CGReqTaxRa
  000c4	3b fa		 cmp	 edi, edx
  000c6	7f 56		 jg	 SHORT $LN1@CGReqTaxRa

; 18694: 		return;
; 18695: 	}
; 18696: 
; 18697: 	GS_GDReqTaxRateChange(g_MapServerManager.GetMapSvrGroup(),iIndex,lpMsg->btTaxType,iTaxRate);

  000c8	a1 00 6b 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92928
  000cd	85 c0		 test	 eax, eax
  000cf	74 06		 je	 SHORT $LN14@CGReqTaxRa
  000d1	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  000d5	eb 03		 jmp	 SHORT $LN15@CGReqTaxRa
$LN14@CGReqTaxRa:
  000d7	83 c8 ff	 or	 eax, -1
$LN15@CGReqTaxRa:
  000da	57		 push	 edi
  000db	51		 push	 ecx
  000dc	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000df	51		 push	 ecx
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ?GS_GDReqTaxRateChange@@YAXHHHH@Z ; GS_GDReqTaxRateChange

; 18698: 	LogAddTD("[CastleSiege] CGReqTaxRateChange() REQ OK - [%s][%s], Guild:(%s)(%d), TaxType:%d, TaxRate:%d",
; 18699: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->btTaxType,iTaxRate);

  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000eb	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  000ef	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  000f6	57		 push	 edi
  000f7	52		 push	 edx
  000f8	51		 push	 ecx
  000f9	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  00100	52		 push	 edx
  00101	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00105	51		 push	 ecx
  00106	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  0010a	52		 push	 edx
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00116	83 c4 2c	 add	 esp, 44			; 0000002cH
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx

; 18700: 
; 18701: #endif
; 18702: }

  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
$LN1@CGReqTaxRa:

; 18690: 	{
; 18691: 		GCAnsTaxRateChange(iIndex,0,0,0);

  0011e	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	6a 00		 push	 0
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ?GCAnsTaxRateChange@@YAXHHEH@Z ; GCAnsTaxRateChange

; 18692: 		LogAddTD("[CastleSiege] CGReqTaxRateChange() ERROR - Tax Rate Out of Range [%s][%s], Guild:(%s)(%d), TaxType:%d, TaxRate:%d",
; 18693: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->btTaxType,iTaxRate);

  0012d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00132	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  00136	8b 94 06 28 06
	00 00		 mov	 edx, DWORD PTR [esi+eax+1576]
  0013d	57		 push	 edi
  0013e	51		 push	 ecx
  0013f	52		 push	 edx
  00140	8d 8c 06 1c 06
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1564]
  00147	51		 push	 ecx
  00148	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  0014c	52		 push	 edx
  0014d	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00151	50		 push	 eax
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0015d	83 c4 2c	 add	 esp, 44			; 0000002cH
  00160	5f		 pop	 edi
  00161	5e		 pop	 esi
  00162	5b		 pop	 ebx

; 18700: 
; 18701: #endif
; 18702: }

  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
$LN8@CGReqTaxRa:

; 18666: 	{
; 18667: 		LogAddC(2,"[CastleSiege] CGReqTaxRateChange() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",
; 18668: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  00165	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  0016c	51		 push	 ecx
  0016d	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  00174	52		 push	 edx
  00175	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00179	51		 push	 ecx
  0017a	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  0017e	52		 push	 edx
  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
  00184	6a 02		 push	 2
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0018c	83 c4 18	 add	 esp, 24			; 00000018H
$LN21@CGReqTaxRa:
  0018f	5f		 pop	 edi
  00190	5e		 pop	 esi
$LN12@CGReqTaxRa:
  00191	5b		 pop	 ebx

; 18700: 
; 18701: #endif
; 18702: }

  00192	5d		 pop	 ebp
  00193	c3		 ret	 0
?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z ENDP ; CGReqTaxRateChange
_TEXT	ENDS
PUBLIC	??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z ; CGReqMoneyDrawOut
EXTRN	?GS_GDReqCastleMoneyChange@@YAXHHH@Z:PROC	; GS_GDReqCastleMoneyChange
EXTRN	?CheckCastleHasMoney@CCastleSiege@@QAEH_J@Z:PROC ; CCastleSiege::CheckCastleHasMoney
;	COMDAT ??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\mapservermanager.h
CONST	SEGMENT
??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() ERROR - Authority Fail [%s][%s], '
	DB	'Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
CONST	SEGMENT
??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() REQ OK - [%s][%s], Guild:(%s)(%d)'
	DB	', Money:%d, TotMoney:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
CONST	SEGMENT
??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() ERROR - Castle Money is Low [%s]['
	DB	'%s], Guild:(%s)(%d), Money:%d, TotMoney:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
CONST	SEGMENT
??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() ERROR - Req Money < 0 [%s][%s], G'
	DB	'uild:(%s)(%d), Money:%d, TotMoney:%d', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z PROC ; CGReqMoneyDrawOut, COMDAT

; 18738: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18739: #if (GS_CASTLE==1)
; 18740: 
; 18741: 	if(lpMsg == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	0f 84 ec 01 00
	00		 je	 $LN8@CGReqMoney

; 18742: 		return;
; 18743: 
; 18744: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	53		 push	 ebx
  00013	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00016	56		 push	 esi
  00017	8b f3		 mov	 esi, ebx
  00019	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0001f	57		 push	 edi
  00020	8d bc 06 1c 06
	00 00		 lea	 edi, DWORD PTR [esi+eax+1564]
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002c	8b c7		 mov	 eax, edi
  0002e	8b ff		 npad	 2
$LL13@CGReqMoney:
  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00034	75 1a		 jne	 SHORT $LN14@CGReqMoney
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN15@CGReqMoney
  0003a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00040	75 0e		 jne	 SHORT $LN14@CGReqMoney
  00042	83 c0 02	 add	 eax, 2
  00045	83 c1 02	 add	 ecx, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL13@CGReqMoney
$LN15@CGReqMoney:
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN16@CGReqMoney
$LN14@CGReqMoney:
  00050	1b c0		 sbb	 eax, eax
  00052	83 d8 ff	 sbb	 eax, -1
$LN16@CGReqMoney:
  00055	85 c0		 test	 eax, eax
  00057	0f 84 99 01 00
	00		 je	 $LN17@CGReqMoney

; 18745: 		return;
; 18746: 
; 18747: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18748: 		|| gObj[iIndex].GuildStatus != G_MASTER)

  0005d	57		 push	 edi
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00063	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00068	85 c0		 test	 eax, eax
  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	0f 84 57 01 00
	00		 je	 $LN4@CGReqMoney
  00075	81 bc 06 28 06
	00 00 80 00 00
	00		 cmp	 DWORD PTR [esi+eax+1576], 128 ; 00000080H
  00080	0f 85 46 01 00
	00		 jne	 $LN4@CGReqMoney

; 18752: 		return;
; 18753: 	}
; 18754: 
; 18755: 	int iMoneyChange = ((( ( ( (lpMsg->btMoney1 & 0xFF) & 0xFF | ((lpMsg->btMoney2 & 0xFF) & 0xFF ) << 8)) &0xFFFF) & 0xFFFF) & 0xFFFF) | ((( ( ( (lpMsg->btMoney3 & 0xFF) & 0xFF | ((lpMsg->btMoney4 & 0xFF) & 0xFF ) << 8)) &0xFFFF) & 0xFFFF) & 0xFFFF) << 16;

  00086	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00089	0f b6 78 07	 movzx	 edi, BYTE PTR [eax+7]
  0008d	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00091	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  00095	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00099	c1 e7 08	 shl	 edi, 8
  0009c	0b f9		 or	 edi, ecx
  0009e	c1 e7 08	 shl	 edi, 8
  000a1	0b fa		 or	 edi, edx
  000a3	c1 e7 08	 shl	 edi, 8
  000a6	0b f8		 or	 edi, eax

; 18756: 
; 18757: 	if(iMoneyChange <= 0)

  000a8	7f 47		 jg	 SHORT $LN3@CGReqMoney

; 18758: 	{
; 18759: 		GCAnsMoneyDrawOut(iIndex,0,0);

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	6a 00		 push	 0
  000b0	53		 push	 ebx
  000b1	e8 00 00 00 00	 call	 ?GCAnsMoneyDrawOut@@YAXHH_J@Z ; GCAnsMoneyDrawOut

; 18760: 		LogAddTD("[CastleSiege] CGReqMoneyDrawOut() ERROR - Req Money < 0 [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d",
; 18761: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iMoneyChange,gObj[iIndex].Money);

  000b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bb	8b 8c 06 cc 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+204]
  000c2	8b 94 06 28 06
	00 00		 mov	 edx, DWORD PTR [esi+eax+1576]
  000c9	51		 push	 ecx
  000ca	57		 push	 edi
  000cb	52		 push	 edx
  000cc	8d 8c 06 1c 06
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1564]
  000d3	51		 push	 ecx
  000d4	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  000d8	52		 push	 edx
  000d9	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  000dd	50		 push	 eax
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e9	83 c4 2c	 add	 esp, 44			; 0000002cH
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx

; 18784: #endif
; 18785: }

  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
$LN3@CGReqMoney:

; 18762: 		return;
; 18763: 	}
; 18764: 
; 18765: 	int bRETVAL = g_CastleSiege.CheckCastleHasMoney(iMoneyChange);
; 18766: 
; 18767: 	if(bRETVAL == FALSE)

  000f1	8b c7		 mov	 eax, edi
  000f3	99		 cdq
  000f4	52		 push	 edx
  000f5	50		 push	 eax
  000f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000fb	e8 00 00 00 00	 call	 ?CheckCastleHasMoney@CCastleSiege@@QAEH_J@Z ; CCastleSiege::CheckCastleHasMoney
  00100	85 c0		 test	 eax, eax
  00102	75 44		 jne	 SHORT $LN2@CGReqMoney

; 18768: 	{
; 18769: 		GCAnsMoneyDrawOut(iIndex,0,0);

  00104	50		 push	 eax
  00105	50		 push	 eax
  00106	50		 push	 eax
  00107	53		 push	 ebx
  00108	e8 00 00 00 00	 call	 ?GCAnsMoneyDrawOut@@YAXHH_J@Z ; GCAnsMoneyDrawOut

; 18770: 		LogAddTD("[CastleSiege] CGReqMoneyDrawOut() ERROR - Castle Money is Low [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d",
; 18771: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iMoneyChange,gObj[iIndex].Money);

  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00112	8b 8c 06 cc 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+204]
  00119	8b 94 06 28 06
	00 00		 mov	 edx, DWORD PTR [esi+eax+1576]
  00120	51		 push	 ecx
  00121	57		 push	 edi
  00122	52		 push	 edx
  00123	8d 8c 06 1c 06
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1564]
  0012a	51		 push	 ecx
  0012b	8d 54 06 5d	 lea	 edx, DWORD PTR [esi+eax+93]
  0012f	52		 push	 edx
  00130	8d 44 06 52	 lea	 eax, DWORD PTR [esi+eax+82]
  00134	50		 push	 eax
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00140	83 c4 2c	 add	 esp, 44			; 0000002cH
  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx

; 18784: #endif
; 18785: }

  00146	5d		 pop	 ebp
  00147	c3		 ret	 0
$LN2@CGReqMoney:

; 18772: 		return;
; 18773: 	}
; 18774: 
; 18775: 	if(gObj[iIndex].Money + iMoneyChange > 2000000000)

  00148	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014e	8b 94 0e cc 00
	00 00		 mov	 edx, DWORD PTR [esi+ecx+204]
  00155	03 d7		 add	 edx, edi
  00157	81 fa 00 94 35
	77		 cmp	 edx, 2000000000		; 77359400H
  0015d	7e 14		 jle	 SHORT $LN1@CGReqMoney

; 18776: 	{
; 18777: 		GCAnsMoneyDrawOut(iIndex,0,0);

  0015f	6a 00		 push	 0
  00161	6a 00		 push	 0
  00163	6a 00		 push	 0
  00165	53		 push	 ebx
  00166	e8 00 00 00 00	 call	 ?GCAnsMoneyDrawOut@@YAXHH_J@Z ; GCAnsMoneyDrawOut
  0016b	83 c4 10	 add	 esp, 16			; 00000010H
  0016e	5f		 pop	 edi
  0016f	5e		 pop	 esi
  00170	5b		 pop	 ebx

; 18784: #endif
; 18785: }

  00171	5d		 pop	 ebp
  00172	c3		 ret	 0
$LN1@CGReqMoney:

; 18778: 		return;
; 18779: 	}
; 18780: 
; 18781: 	GS_GDReqCastleMoneyChange(g_MapServerManager.GetMapSvrGroup(),iIndex,-iMoneyChange);

  00173	a1 00 6b 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92928
  00178	85 c0		 test	 eax, eax
  0017a	74 06		 je	 SHORT $LN10@CGReqMoney
  0017c	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00180	eb 03		 jmp	 SHORT $LN11@CGReqMoney
$LN10@CGReqMoney:
  00182	83 c8 ff	 or	 eax, -1
$LN11@CGReqMoney:
  00185	8b cf		 mov	 ecx, edi
  00187	f7 d9		 neg	 ecx
  00189	51		 push	 ecx
  0018a	53		 push	 ebx
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 ?GS_GDReqCastleMoneyChange@@YAXHHH@Z ; GS_GDReqCastleMoneyChange

; 18782: 	LogAddTD("[CastleSiege] CGReqMoneyDrawOut() REQ OK - [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d",
; 18783: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iMoneyChange,gObj[iIndex].Money);

  00191	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00196	8b 94 06 cc 00
	00 00		 mov	 edx, DWORD PTR [esi+eax+204]
  0019d	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  001a4	52		 push	 edx
  001a5	57		 push	 edi
  001a6	51		 push	 ecx
  001a7	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  001ae	52		 push	 edx
  001af	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  001b3	51		 push	 ecx
  001b4	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  001b8	52		 push	 edx
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c4	83 c4 28	 add	 esp, 40			; 00000028H
  001c7	5f		 pop	 edi
  001c8	5e		 pop	 esi
  001c9	5b		 pop	 ebx

; 18784: #endif
; 18785: }

  001ca	5d		 pop	 ebp
  001cb	c3		 ret	 0
$LN4@CGReqMoney:

; 18749: 	{
; 18750: 		LogAddC(2,"[CastleSiege] CGReqMoneyDrawOut() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",
; 18751: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  001cc	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  001d3	51		 push	 ecx
  001d4	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  001db	52		 push	 edx
  001dc	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  001e0	51		 push	 ecx
  001e1	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  001e5	52		 push	 edx
  001e6	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  001eb	6a 02		 push	 2
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001f3	83 c4 18	 add	 esp, 24			; 00000018H
$LN17@CGReqMoney:
  001f6	5f		 pop	 edi
  001f7	5e		 pop	 esi
  001f8	5b		 pop	 ebx
$LN8@CGReqMoney:

; 18784: #endif
; 18785: }

  001f9	5d		 pop	 ebp
  001fa	c3		 ret	 0
?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z ENDP ; CGReqMoneyDrawOut
_TEXT	ENDS
PUBLIC	??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z ; CGReqCsGateOperate
EXTRN	?SendCsGateStateViewPort@CCastleSiege@@QAEXHE@Z:PROC ; CCastleSiege::SendCsGateStateViewPort
EXTRN	?OperateGate@CCastleSiege@@QAEHHHH@Z:PROC	; CCastleSiege::OperateGate
EXTRN	?CheckCsGateAlive@CCastleSiege@@QAEHH@Z:PROC	; CCastleSiege::CheckCsGateAlive
;	COMDAT ??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
CONST	SEGMENT
??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() ERROR - Gate Doesn''t Exist [%s][%s'
	DB	'], Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
CONST	SEGMENT
??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() OK - [%s][%s], Guild:(%s)(%d), DOOR'
	DB	':(%d)(X:%d,Y:%d)(STATUE:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
CONST	SEGMENT
??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() ERROR - Operate Gate Failed [%s][%s'
	DB	'], Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
CONST	SEGMENT
??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() ERROR - Authority Fail [%s][%s], Gu'
	DB	'ild:(%s)(%d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z PROC ; CGReqCsGateOperate, COMDAT

; 18853: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18854: #if (GS_CASTLE==1)
; 18855: 
; 18856: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  0000c	56		 push	 esi
  0000d	8b f3		 mov	 esi, ebx
  0000f	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0001a	8d 84 06 1c 06
	00 00		 lea	 eax, DWORD PTR [esi+eax+1564]
$LL11@CGReqCsGat:
  00021	8a 10		 mov	 dl, BYTE PTR [eax]
  00023	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00025	75 1a		 jne	 SHORT $LN12@CGReqCsGat
  00027	84 d2		 test	 dl, dl
  00029	74 12		 je	 SHORT $LN13@CGReqCsGat
  0002b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002e	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00031	75 0e		 jne	 SHORT $LN12@CGReqCsGat
  00033	83 c0 02	 add	 eax, 2
  00036	83 c1 02	 add	 ecx, 2
  00039	84 d2		 test	 dl, dl
  0003b	75 e4		 jne	 SHORT $LL11@CGReqCsGat
$LN13@CGReqCsGat:
  0003d	33 c0		 xor	 eax, eax
  0003f	eb 05		 jmp	 SHORT $LN14@CGReqCsGat
$LN12@CGReqCsGat:
  00041	1b c0		 sbb	 eax, eax
  00043	83 d8 ff	 sbb	 eax, -1
$LN14@CGReqCsGat:
  00046	85 c0		 test	 eax, eax
  00048	0f 84 d8 01 00
	00		 je	 $LN1@CGReqCsGat

; 18857: 		return;
; 18858: 
; 18859: 	if(g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)

  0004e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00053	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00058	83 f8 07	 cmp	 eax, 7
  0005b	75 3b		 jne	 SHORT $LN7@CGReqCsGat

; 18860: 	{
; 18861: 		if(gObj[iIndex].m_btCsJoinSide != 1)

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00062	80 bc 06 5a 20
	00 00 01	 cmp	 BYTE PTR [esi+eax+8282], 1
  0006a	74 7b		 je	 SHORT $LN4@CGReqCsGat

; 18862: 		{
; 18863: 			LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",
; 18864: 				gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  0006c	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  00073	51		 push	 ecx
  00074	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  0007b	52		 push	 edx
  0007c	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00080	51		 push	 ecx
  00081	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00085	52		 push	 edx
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00091	83 c4 14	 add	 esp, 20			; 00000014H
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx

; 18900: 	}
; 18901: 
; 18902: #endif
; 18903: }

  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
$LN7@CGReqCsGat:

; 18865: 			return;
; 18866: 		}
; 18867: 	}
; 18868: 	else if(g_CastleSiege.CheckCastleOwnerMember(iIndex) == FALSE && g_CastleSiege.CheckCastleOwnerUnionMember(iIndex) == FALSE)

  00098	53		 push	 ebx
  00099	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0009e	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  000a3	85 c0		 test	 eax, eax
  000a5	75 40		 jne	 SHORT $LN4@CGReqCsGat
  000a7	53		 push	 ebx
  000a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000ad	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
  000b2	85 c0		 test	 eax, eax
  000b4	75 31		 jne	 SHORT $LN4@CGReqCsGat

; 18869: 	{
; 18870: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",
; 18871: 				gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  000b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bb	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  000c2	51		 push	 ecx
  000c3	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  000ca	52		 push	 edx
  000cb	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  000cf	51		 push	 ecx
  000d0	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  000d4	52		 push	 edx
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e0	83 c4 14	 add	 esp, 20			; 00000014H
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx

; 18900: 	}
; 18901: 
; 18902: #endif
; 18903: }

  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
$LN4@CGReqCsGat:

; 18872: 		return;
; 18873: 	}
; 18874: 
; 18875: 	int iGateIndex = ( ((lpMsg->btIndex2 & 0xFF) & 0xFF) | ((lpMsg->btIndex1 & 0xFF) & 0xFF) << 8) & 0xFFFF;

  000e7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000ea	57		 push	 edi
  000eb	0f b6 78 05	 movzx	 edi, BYTE PTR [eax+5]
  000ef	0f b6 40 06	 movzx	 eax, BYTE PTR [eax+6]
  000f3	c1 e7 08	 shl	 edi, 8
  000f6	0b f8		 or	 edi, eax

; 18876: 
; 18877: 	if(g_CastleSiege.CheckCsGateAlive(iGateIndex) == TRUE)

  000f8	57		 push	 edi
  000f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000fe	e8 00 00 00 00	 call	 ?CheckCsGateAlive@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCsGateAlive
  00103	83 f8 01	 cmp	 eax, 1
  00106	0f 85 e0 00 00
	00		 jne	 $LN3@CGReqCsGat

; 18878: 	{
; 18879: 		int bRETVAL = g_CastleSiege.OperateGate(iGateIndex,gObj[iGateIndex].m_iCsNpcExistVal,lpMsg->btOperate);
; 18880: 
; 18881: 		if(bRETVAL == FALSE)

  0010c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0010f	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00118	8b df		 mov	 ebx, edi
  0011a	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00120	8b 8c 03 4c 20
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+8268]
  00127	52		 push	 edx
  00128	51		 push	 ecx
  00129	57		 push	 edi
  0012a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0012f	e8 00 00 00 00	 call	 ?OperateGate@CCastleSiege@@QAEHHHH@Z ; CCastleSiege::OperateGate

; 18882: 		{
; 18883: 			GCAnsCsGateOperate(iIndex,0,-1,0);

  00134	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00137	85 c0		 test	 eax, eax
  00139	75 3c		 jne	 SHORT $LN2@CGReqCsGat
  0013b	50		 push	 eax
  0013c	6a ff		 push	 -1
  0013e	50		 push	 eax
  0013f	52		 push	 edx
  00140	e8 00 00 00 00	 call	 ?GCAnsCsGateOperate@@YAXHHHH@Z ; GCAnsCsGateOperate

; 18884: 			LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Operate Gate Failed [%s][%s], Guild:(%s)(%d)",
; 18885: 				gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  00145	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014a	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  00151	51		 push	 ecx
  00152	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  00159	52		 push	 edx
  0015a	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  0015e	51		 push	 ecx
  0015f	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00163	52		 push	 edx
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@

; 18898: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Gate Doesn't Exist [%s][%s], Guild:(%s)(%d)",
; 18899: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  00169	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0016f	83 c4 24	 add	 esp, 36			; 00000024H
  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx

; 18900: 	}
; 18901: 
; 18902: #endif
; 18903: }

  00175	5d		 pop	 ebp
  00176	c3		 ret	 0
$LN2@CGReqCsGat:

; 18886: 			return;
; 18887: 		}
; 18888: 
; 18889: 		GCAnsCsGateOperate(iIndex,1,iGateIndex,lpMsg->btOperate);

  00177	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0017a	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0017e	51		 push	 ecx
  0017f	57		 push	 edi
  00180	6a 01		 push	 1
  00182	52		 push	 edx
  00183	e8 00 00 00 00	 call	 ?GCAnsCsGateOperate@@YAXHHHH@Z ; GCAnsCsGateOperate

; 18890: 		g_CastleSiege.SendCsGateStateViewPort(iGateIndex,lpMsg->btOperate);

  00188	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0018b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0018f	83 c4 10	 add	 esp, 16			; 00000010H
  00192	51		 push	 ecx
  00193	57		 push	 edi
  00194	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00199	e8 00 00 00 00	 call	 ?SendCsGateStateViewPort@CCastleSiege@@QAEXHE@Z ; CCastleSiege::SendCsGateStateViewPort

; 18891: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() OK - [%s][%s], Guild:(%s)(%d), DOOR:(%d)(X:%d,Y:%d)(STATUE:%d)",
; 18892: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iGateIndex,gObj[iGateIndex].X,gObj[iGateIndex].Y,gObj[iGateIndex].m_btCsGateOpen);

  0019e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a3	0f b6 94 03 51
	20 00 00	 movzx	 edx, BYTE PTR [ebx+eax+8273]
  001ab	0f b6 8c 03 21
	01 00 00	 movzx	 ecx, BYTE PTR [ebx+eax+289]
  001b3	52		 push	 edx
  001b4	0f b6 94 03 20
	01 00 00	 movzx	 edx, BYTE PTR [ebx+eax+288]
  001bc	51		 push	 ecx
  001bd	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  001c4	52		 push	 edx
  001c5	57		 push	 edi
  001c6	51		 push	 ecx
  001c7	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  001ce	52		 push	 edx
  001cf	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  001d3	51		 push	 ecx
  001d4	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  001d8	52		 push	 edx
  001d9	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@

; 18898: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Gate Doesn't Exist [%s][%s], Guild:(%s)(%d)",
; 18899: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  001de	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001e4	83 c4 24	 add	 esp, 36			; 00000024H
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx

; 18900: 	}
; 18901: 
; 18902: #endif
; 18903: }

  001ea	5d		 pop	 ebp
  001eb	c3		 ret	 0
$LN3@CGReqCsGat:

; 18893: 
; 18894: 	}
; 18895: 	else
; 18896: 	{
; 18897: 		GCAnsCsGateOperate(iIndex,2,-1,0);

  001ec	6a 00		 push	 0
  001ee	6a ff		 push	 -1
  001f0	6a 02		 push	 2
  001f2	53		 push	 ebx
  001f3	e8 00 00 00 00	 call	 ?GCAnsCsGateOperate@@YAXHHHH@Z ; GCAnsCsGateOperate

; 18898: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Gate Doesn't Exist [%s][%s], Guild:(%s)(%d)",
; 18899: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);

  001f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001fd	8b 8c 06 28 06
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1576]
  00204	51		 push	 ecx
  00205	8d 94 06 1c 06
	00 00		 lea	 edx, DWORD PTR [esi+eax+1564]
  0020c	52		 push	 edx
  0020d	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  00211	51		 push	 ecx
  00212	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  00216	52		 push	 edx
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00222	83 c4 24	 add	 esp, 36			; 00000024H
  00225	5f		 pop	 edi
$LN1@CGReqCsGat:
  00226	5e		 pop	 esi
  00227	5b		 pop	 ebx

; 18900: 	}
; 18901: 
; 18902: #endif
; 18903: }

  00228	5d		 pop	 ebp
  00229	c3		 ret	 0
?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z ENDP ; CGReqCsGateOperate
_TEXT	ENDS
PUBLIC	?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z ; CGReqCsMiniMapData
EXTRN	?AddMiniMapDataReqUser@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::AddMiniMapDataReqUser
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z PROC ; CGReqCsMiniMapData, COMDAT

; 19102: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 19103: #if (GS_CASTLE==1)
; 19104: 	if(gObjIsConnected(iIndex) == FALSE)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 68		 je	 SHORT $LN1@CGReqCsMin

; 19105: 		return;
; 19106: 
; 19107: 	if(gObj[iIndex].m_btCsJoinSide <= 0 || g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE)

  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001a	8b c6		 mov	 eax, esi
  0001c	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00022	80 bc 08 5a 20
	00 00 00	 cmp	 BYTE PTR [eax+ecx+8282], 0
  0002a	76 45		 jbe	 SHORT $LN4@CGReqCsMin
  0002c	56		 push	 esi
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00032	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  00037	85 c0		 test	 eax, eax
  00039	74 36		 je	 SHORT $LN4@CGReqCsMin

; 19110: 	}
; 19111: 	else if(g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE)

  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00040	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00045	83 f8 07	 cmp	 eax, 7
  00048	74 0e		 je	 SHORT $LN2@CGReqCsMin

; 19112: 	{
; 19113: 		GCAnsCsMiniMapData(iIndex,2);

  0004a	6a 02		 push	 2
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ?GCAnsCsMiniMapData@@YAXHE@Z ; GCAnsCsMiniMapData
  00052	83 c4 08	 add	 esp, 8
  00055	5e		 pop	 esi

; 19119: 	}
; 19120: #endif
; 19121: }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN2@CGReqCsMin:

; 19114: 	}
; 19115: 	else
; 19116: 	{
; 19117: 		g_CastleSiege.AddMiniMapDataReqUser(iIndex);

  00058	56		 push	 esi
  00059	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0005e	e8 00 00 00 00	 call	 ?AddMiniMapDataReqUser@CCastleSiege@@QAEXH@Z ; CCastleSiege::AddMiniMapDataReqUser

; 19118: 		GCAnsCsMiniMapData(iIndex,1);

  00063	6a 01		 push	 1
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ?GCAnsCsMiniMapData@@YAXHE@Z ; GCAnsCsMiniMapData
  0006b	83 c4 08	 add	 esp, 8
  0006e	5e		 pop	 esi

; 19119: 	}
; 19120: #endif
; 19121: }

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN4@CGReqCsMin:

; 19108: 	{
; 19109: 		GCAnsCsMiniMapData(iIndex,3);

  00071	6a 03		 push	 3
  00073	56		 push	 esi
  00074	e8 00 00 00 00	 call	 ?GCAnsCsMiniMapData@@YAXHE@Z ; GCAnsCsMiniMapData
  00079	83 c4 08	 add	 esp, 8
$LN1@CGReqCsMin:
  0007c	5e		 pop	 esi

; 19119: 	}
; 19120: #endif
; 19121: }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z ENDP ; CGReqCsMiniMapData
_TEXT	ENDS
PUBLIC	?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z ; CGReqCsSendCommand
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z PROC	; CGReqCsSendCommand, COMDAT

; 19156: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 19157: #if (GS_CASTLE==1)
; 19158: 	if(gObjIsConnected(iIndex) == FALSE)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 64		 je	 SHORT $LN2@CGReqCsSen

; 19159: 		return;
; 19160: 
; 19161: 	if(gObj[iIndex].m_btCsJoinSide <= 0 || g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE)

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	56		 push	 esi
  0001a	8b f7		 mov	 esi, edi
  0001c	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00022	80 bc 06 5a 20
	00 00 00	 cmp	 BYTE PTR [esi+eax+8282], 0
  0002a	76 4b		 jbe	 SHORT $LN7@CGReqCsSen
  0002c	57		 push	 edi
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00032	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  00037	85 c0		 test	 eax, eax
  00039	74 3c		 je	 SHORT $LN7@CGReqCsSen

; 19162: 		return;
; 19163: 
; 19164: 	if(g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE)

  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00040	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00045	83 f8 07	 cmp	 eax, 7
  00048	75 2d		 jne	 SHORT $LN7@CGReqCsSen

; 19165: 		return;
; 19166: 
; 19167: 	GCAnsCsSendCommand(gObj[iIndex].m_btCsJoinSide,lpMsg->btTeam,lpMsg->btX,lpMsg->btY,lpMsg->btCommand);

  0004a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0004d	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  00051	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  00055	51		 push	 ecx
  00056	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0005a	52		 push	 edx
  0005b	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	51		 push	 ecx
  00065	0f b6 8c 06 5a
	20 00 00	 movzx	 ecx, BYTE PTR [esi+eax+8282]
  0006d	52		 push	 edx
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?GCAnsCsSendCommand@@YAXHEEEE@Z ; GCAnsCsSendCommand
  00074	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@CGReqCsSen:
  00077	5e		 pop	 esi
$LN2@CGReqCsSen:
  00078	5f		 pop	 edi

; 19168: 
; 19169: #endif
; 19170: }

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z ENDP	; CGReqCsSendCommand
_TEXT	ENDS
PUBLIC	?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z ; CGReqCsSetEnterHuntZone
EXTRN	?SetHuntZoneEnter@CCastleSiege@@QAEXH@Z:PROC	; CCastleSiege::SetHuntZoneEnter
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z PROC ; CGReqCsSetEnterHuntZone, COMDAT

; 19263: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 19264: #if (GS_CASTLE==1)
; 19265: 	if(gObjIsConnected(iIndex) == FALSE)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 6e		 je	 SHORT $LN4@CGReqCsSet

; 19266: 		return;
; 19267: 
; 19268: 	if(g_CastleSiege.CheckCastleOwnerMember(iIndex) == FALSE)

  00014	56		 push	 esi
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0001a	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  0001f	85 c0		 test	 eax, eax
  00021	75 16		 jne	 SHORT $LN2@CGReqCsSet

; 19269: 	{
; 19270: 		GCAnsCsSetEnterHuntZone(iIndex,2,lpMsg->btHuntZoneEnter);

  00023	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00026	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0002a	51		 push	 ecx
  0002b	6a 02		 push	 2
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ; GCAnsCsSetEnterHuntZone
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	5e		 pop	 esi

; 19282: #endif
; 19283: }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN2@CGReqCsSet:

; 19271: 		return;
; 19272: 	}
; 19273: 
; 19274: 	if(g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)

  00039	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0003e	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00043	83 f8 07	 cmp	 eax, 7
  00046	75 16		 jne	 SHORT $LN1@CGReqCsSet

; 19275: 	{
; 19276: 		GCAnsCsSetEnterHuntZone(iIndex,0,lpMsg->btHuntZoneEnter);

  00048	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0004b	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0004f	50		 push	 eax
  00050	6a 00		 push	 0
  00052	56		 push	 esi
  00053	e8 00 00 00 00	 call	 ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ; GCAnsCsSetEnterHuntZone
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	5e		 pop	 esi

; 19282: #endif
; 19283: }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN1@CGReqCsSet:
  0005e	57		 push	 edi

; 19277: 		return;
; 19278: 	}
; 19279: 
; 19280: 	g_CastleSiege.SetHuntZoneEnter(lpMsg->btHuntZoneEnter);

  0005f	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00062	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00066	51		 push	 ecx
  00067	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0006c	e8 00 00 00 00	 call	 ?SetHuntZoneEnter@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetHuntZoneEnter

; 19281: 	GCAnsCsSetEnterHuntZone(iIndex,1,lpMsg->btHuntZoneEnter);

  00071	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  00075	52		 push	 edx
  00076	6a 01		 push	 1
  00078	56		 push	 esi
  00079	e8 00 00 00 00	 call	 ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ; GCAnsCsSetEnterHuntZone
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	5f		 pop	 edi
$LN4@CGReqCsSet:
  00082	5e		 pop	 esi

; 19282: #endif
; 19283: }

  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z ENDP ; CGReqCsSetEnterHuntZone
_TEXT	ENDS
PUBLIC	?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z ; CGReqCrywolfInfo
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?GetCrywolfState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetCrywolfState
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z PROC ; CGReqCrywolfInfo, COMDAT

; 19593: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 19594: 	if ( !OBJMAX_RANGE(iIndex))

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 2e		 js	 SHORT $LN2@CGReqCrywo
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 1f		 je	 SHORT $LN2@CGReqCrywo

; 19595: 		return;
; 19596: 
; 19597: 	LPOBJ lpObj = &gObj[iIndex];
; 19598: 	GCAnsCrywolfInfo(iIndex, g_CrywolfSync.GetOccupationState(), g_CrywolfSync.GetCrywolfState());

  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0001f	e8 00 00 00 00	 call	 ?GetCrywolfState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetCrywolfState
  00024	50		 push	 eax
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0002a	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  0002f	50		 push	 eax
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ?GCAnsCrywolfInfo@@YAXHEE@Z ; GCAnsCrywolfInfo
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGReqCrywo:
  00039	5e		 pop	 esi

; 19599: }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z ENDP ; CGReqCrywolfInfo
_TEXT	ENDS
PUBLIC	??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ ; `string'
PUBLIC	??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@ ; `string'
PUBLIC	??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ ; `string'
PUBLIC	??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@ ; `string'
PUBLIC	??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@ ; `string'
PUBLIC	??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@ ; `string'
PUBLIC	??_C@_0CF@GLNEHHDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5Elemental?5Mi@ ; `string'
PUBLIC	??_C@_0CF@LHICMFIE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5LuckyItem?5Mi@ ; `string'
PUBLIC	??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@ ; `string'
PUBLIC	??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@ ; `string'
PUBLIC	??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@ ; `string'
PUBLIC	??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@ ; `string'
PUBLIC	??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ; CGInventoryItemMove
EXTRN	?gObjInventoryTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z:PROC ; gObjInventoryTradeMove
EXTRN	?gObjTradeInventoryMove@@YAEPAUOBJECTSTRUCT@@EE@Z:PROC ; gObjTradeInventoryMove
EXTRN	?gObjTradeTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z:PROC ; gObjTradeTradeMove
EXTRN	?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z:PROC	; gObjInventoryMoveItem
EXTRN	?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z:PROC	; GetItemAttr
;	COMDAT ??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@
CONST	SEGMENT
??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ DB '['
	DB	'%s][%s] error-L1 : used not Chaosbox', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@
CONST	SEGMENT
??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@ DB '['
	DB	'%s][%s] error-L1 : used not DarkTrainerBox', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@
CONST	SEGMENT
??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ DB '['
	DB	'%s][%s] error-L1 : used not ChaosBox', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@
CONST	SEGMENT
??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@ DB 'Pay WareHo'
	DB	'use Money(In WareHouse) : %d - %d = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@
CONST	SEGMENT
??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@ DB 'Pay WareHo'
	DB	'use Money(In Inventory) : %d - %d = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@
CONST	SEGMENT
??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@ DB '['
	DB	'%s][%s] error-L1 : used not Trade', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLNEHHDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5Elemental?5Mi@
CONST	SEGMENT
??_C@_0CF@GLNEHHDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5Elemental?5Mi@ DB '['
	DB	'%s][%s] error-L3 : Elemental Mixing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LHICMFIE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5LuckyItem?5Mi@
CONST	SEGMENT
??_C@_0CF@LHICMFIE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5LuckyItem?5Mi@ DB '['
	DB	'%s][%s] error-L3 : LuckyItem Mixing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@
CONST	SEGMENT
??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@ DB '['
	DB	'%s][%s] error-L3 : SocketItem Mixing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@
CONST	SEGMENT
??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@ DB '['
	DB	'%s][%s] error-L3 : JewelOfHarmony Mixing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@
CONST	SEGMENT
??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@ DB '['
	DB	'%s][%s] error-L3 : DarkTrainerBoxMixing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@
CONST	SEGMENT
??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@ DB '['
	DB	'%s][%s] error-L3 : CBMixing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@
CONST	SEGMENT
??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@ DB '[%s][%d'
	DB	'] error-L3', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z
_TEXT	SEGMENT
_DurTSend$218962 = -304					; size = 4
_DurSSend$218961 = -300					; size = 4
_result$ = -296						; size = 1
_it_type$ = -296					; size = 4
tv1462 = -292						; size = 4
tv1460 = -292						; size = 4
tv1452 = -292						; size = 4
tv1450 = -292						; size = 4
_source$ = -292						; size = 4
_target$ = -288						; size = 4
_lpObj$ = -284						; size = 4
tv1344 = -280						; size = 4
tv1465 = -278						; size = 2
tv1455 = -278						; size = 2
_aIndex$GSCopy$ = -276					; size = 4
_szTemp$218895 = -272					; size = 256
_ItemInfo$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z PROC ; CGInventoryItemMove, COMDAT

; 4667 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4668 : 	BYTE result;
; 4669 : 	BYTE ItemInfo[MAX_ITEM_INFO];
; 4670 : 
; 4671 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001c	56		 push	 esi
  0001d	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00020	57		 push	 edi
  00021	8b fb		 mov	 edi, ebx
  00023	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00029	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0002c	51		 push	 ecx

; 5065 : 				}
; 5066 : 			}
; 5067 : 		}
; 5068 : 
; 5069 : 		if ( result != 0xFF && lpMsg->sFlag == 2 && lpMsg->tFlag == 0)

  0002d	89 9d ec fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00033	89 bd e8 fe ff
	ff		 mov	 DWORD PTR tv1344[ebp], edi
  00039	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 25		 jne	 SHORT $LN141@CGInventor@3
$LN182@CGInventor@3:

; 4672 : 	{
; 4673 : 		::GCItemMoveResultSend(aIndex, -1, 0, ItemInfo);

  00045	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  00048	52		 push	 edx
$LN181@CGInventor@3:
  00049	6a 00		 push	 0
  0004b	68 ff 00 00 00	 push	 255			; 000000ffH
  00050	53		 push	 ebx
$LN183@CGInventor@3:
  00051	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00056	83 c4 10	 add	 esp, 16			; 00000010H
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN141@CGInventor@3:

; 4674 : 		return;
; 4675 : 	}
; 4676 : 
; 4677 : 	if ( !::gObjIsConnectedGP(aIndex))

  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00070	83 c4 04	 add	 esp, 4
  00073	85 c0		 test	 eax, eax
  00075	75 3c		 jne	 SHORT $LN140@CGInventor@3

; 4678 : 	{
; 4679 : 		LogAddC(2,"[%s][%d] error-L3", __FILE__, __LINE__);

  00077	68 47 12 00 00	 push	 4679			; 00001247H
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@
  00086	6a 02		 push	 2
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 4680 : 		::GCItemMoveResultSend(aIndex, -1, 0, ItemInfo);

  0008e	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00091	50		 push	 eax
$LN185@CGInventor@3:
  00092	6a 00		 push	 0
  00094	68 ff 00 00 00	 push	 255			; 000000ffH
  00099	53		 push	 ebx
  0009a	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0009f	83 c4 20	 add	 esp, 32			; 00000020H
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a8	33 cd		 xor	 ecx, ebp
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
$LN140@CGInventor@3:

; 4681 : 		return;
; 4682 : 	}
; 4683 : 
; 4684 : 	LPOBJ lpObj = &gObj[aIndex];

  000b3	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 4685 : 	int it_type = 0;

  000b9	33 c9		 xor	 ecx, ecx
  000bb	89 bd e4 fe ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], edi
  000c1	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _it_type$[ebp], ecx

; 4686 : 
; 4687 : 	if ( lpObj->m_ReqWarehouseOpen != false )

  000c7	38 8f b0 14 00
	00		 cmp	 BYTE PTR [edi+5296], cl
  000cd	74 1d		 je	 SHORT $LN139@CGInventor@3

; 4688 : 	{
; 4689 : 		LogAddC(2,"[%s][%d] error-L3", __FILE__, __LINE__);

  000cf	68 51 12 00 00	 push	 4689			; 00001251H
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@
  000de	6a 02		 push	 2
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 4690 : 		GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  000e6	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  000e9	52		 push	 edx

; 4691 : 
; 4692 : 		return;

  000ea	eb a6		 jmp	 SHORT $LN185@CGInventor@3
$LN139@CGInventor@3:

; 4693 : 	}
; 4694 : 
; 4695 : 	int source = lpMsg->source_item_num;
; 4696 : 	int target = lpMsg->target_item_num;

  000ec	0f b6 46 12	 movzx	 eax, BYTE PTR [esi+18]
  000f0	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  000f4	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _target$[ebp], eax

; 4697 : 
; 4698 : 	if ( lpMsg->tFlag == 2 || lpMsg->sFlag == 2 )

  000fa	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  000fd	89 95 dc fe ff
	ff		 mov	 DWORD PTR _source$[ebp], edx
  00103	3c 02		 cmp	 al, 2
  00105	74 06		 je	 SHORT $LN137@CGInventor@3
  00107	80 7e 03 02	 cmp	 BYTE PTR [esi+3], 2
  0010b	75 0b		 jne	 SHORT $LN138@CGInventor@3
$LN137@CGInventor@3:

; 4699 : 		it_type = 6;

  0010d	b9 06 00 00 00	 mov	 ecx, 6
  00112	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _it_type$[ebp], ecx
$LN138@CGInventor@3:

; 4700 : 
; 4701 : 	if ( lpMsg->tFlag == 0 && lpMsg->sFlag == 0 )

  00118	84 c0		 test	 al, al
  0011a	75 1a		 jne	 SHORT $LN133@CGInventor@3
  0011c	38 46 03	 cmp	 BYTE PTR [esi+3], al
  0011f	75 0b		 jne	 SHORT $LN136@CGInventor@3

; 4702 : 		it_type = 8;

  00121	b9 08 00 00 00	 mov	 ecx, 8
  00126	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _it_type$[ebp], ecx
$LN136@CGInventor@3:

; 4703 : 
; 4704 : 	if ( (lpMsg->tFlag == 0 && lpMsg->sFlag == 4) ||
; 4705 : 		(lpMsg->tFlag == 4 && lpMsg->sFlag == 0) ||
; 4706 : 		(lpMsg->tFlag == 4 && lpMsg->sFlag == 4) )

  0012c	84 c0		 test	 al, al
  0012e	75 06		 jne	 SHORT $LN133@CGInventor@3
  00130	80 7e 03 04	 cmp	 BYTE PTR [esi+3], 4
  00134	74 13		 je	 SHORT $LN134@CGInventor@3
$LN133@CGInventor@3:
  00136	3c 04		 cmp	 al, 4
  00138	75 1a		 jne	 SHORT $LN135@CGInventor@3
  0013a	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  0013e	74 09		 je	 SHORT $LN134@CGInventor@3
  00140	3a c0		 cmp	 al, al
  00142	75 10		 jne	 SHORT $LN135@CGInventor@3
  00144	38 46 03	 cmp	 BYTE PTR [esi+3], al
  00147	75 0b		 jne	 SHORT $LN135@CGInventor@3
$LN134@CGInventor@3:

; 4707 : 		it_type = 8;

  00149	b9 08 00 00 00	 mov	 ecx, 8
  0014e	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _it_type$[ebp], ecx
$LN135@CGInventor@3:

; 4708 : 
; 4709 : 	if ( lpMsg->tFlag == lpMsg->sFlag &&
; 4710 : 		 target == source)

  00154	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00157	75 11		 jne	 SHORT $LN131@CGInventor@3
  00159	39 95 e0 fe ff
	ff		 cmp	 DWORD PTR _target$[ebp], edx
  0015f	75 09		 jne	 SHORT $LN131@CGInventor@3
$LN187@CGInventor@3:

; 4711 : 	{
; 4712 : 		GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00161	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00164	51		 push	 ecx

; 4713 : 		return;

  00165	e9 df fe ff ff	 jmp	 $LN181@CGInventor@3
$LN131@CGInventor@3:

; 4714 : 	}
; 4715 : 
; 4716 : 	if (::gObjCanItemTouch(lpObj, it_type) == FALSE)

  0016a	51		 push	 ecx
  0016b	57		 push	 edi
  0016c	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  00171	83 c4 08	 add	 esp, 8
  00174	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00179	85 c0		 test	 eax, eax
  0017b	75 2f		 jne	 SHORT $LN125@CGInventor@3

; 4717 : 	{
; 4718 : 		if ( lpMsg->sItemInfo[I_TYPE] == ITEMGET(4,7) || lpMsg->sItemInfo[I_TYPE] == ITEMGET(4,15) )

  0017d	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00181	3d 07 08 00 00	 cmp	 eax, 2055		; 00000807H
  00186	74 0b		 je	 SHORT $LN128@CGInventor@3
  00188	3d 0f 08 00 00	 cmp	 eax, 2063		; 0000080fH

; 4724 : 			}
; 4725 : 		}
; 4726 : 		else
; 4727 : 		{
; 4728 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4729 : 			return;

  0018d	0f 85 b2 fe ff
	ff		 jne	 $LN182@CGInventor@3
$LN128@CGInventor@3:

; 4719 : 		{
; 4720 : 			if ( target >= 12 || source < 12 )

  00193	39 8d e0 fe ff
	ff		 cmp	 DWORD PTR _target$[ebp], ecx
  00199	7d 08		 jge	 SHORT $LN126@CGInventor@3
  0019b	39 8d dc fe ff
	ff		 cmp	 DWORD PTR _source$[ebp], ecx
  001a1	7d 09		 jge	 SHORT $LN125@CGInventor@3
$LN126@CGInventor@3:

; 4721 : 			{
; 4722 : 				::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  001a3	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  001a6	50		 push	 eax

; 4723 : 				return;

  001a7	e9 9d fe ff ff	 jmp	 $LN181@CGInventor@3
$LN125@CGInventor@3:

; 4730 : 		}
; 4731 : 	}
; 4732 : 
; 4733 : 	if ( lpObj->DieRegen != FALSE )

  001ac	80 bf 8a 05 00
	00 00		 cmp	 BYTE PTR [edi+1418], 0

; 4734 : 	{
; 4735 : 		::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4736 : 		return;

  001b3	75 ac		 jne	 SHORT $LN187@CGInventor@3

; 4737 : 	}
; 4738 : 
; 4739 : 	ItemInfo[I_TYPE] = lpMsg->sItemInfo[I_TYPE];
; 4740 : 	ItemInfo[I_OPTION] = lpMsg->sItemInfo[I_OPTION];
; 4741 : 	ItemInfo[I_DUR] = lpMsg->sItemInfo[I_DUR];

  001b5	0f b6 4e 07	 movzx	 ecx, BYTE PTR [esi+7]
  001b9	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  001bd	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  001c1	88 4d f2	 mov	 BYTE PTR _ItemInfo$[ebp+2], cl

; 4742 : 	ItemInfo[I_NOPTION] = lpMsg->sItemInfo[I_NOPTION];
; 4743 : 	ItemInfo[I_SOPTION] = lpMsg->sItemInfo[I_SOPTION];
; 4744 : 	ItemInfo[I_380OPTION] = lpMsg->sItemInfo[I_380OPTION];

  001c4	0f b6 4e 0a	 movzx	 ecx, BYTE PTR [esi+10]
  001c8	88 55 f0	 mov	 BYTE PTR _ItemInfo$[ebp], dl
  001cb	0f b6 56 08	 movzx	 edx, BYTE PTR [esi+8]
  001cf	88 45 f1	 mov	 BYTE PTR _ItemInfo$[ebp+1], al
  001d2	0f b6 46 09	 movzx	 eax, BYTE PTR [esi+9]
  001d6	88 4d f5	 mov	 BYTE PTR _ItemInfo$[ebp+5], cl

; 4745 : 	ItemInfo[I_JOHOPTION] = lpMsg->sItemInfo[I_JOHOPTION];
; 4746 : 
; 4747 : 	ItemInfo[7] = lpMsg->sItemInfo[7];
; 4748 : 	ItemInfo[8] = lpMsg->sItemInfo[8];

  001d9	0f b6 4e 0d	 movzx	 ecx, BYTE PTR [esi+13]
  001dd	88 55 f3	 mov	 BYTE PTR _ItemInfo$[ebp+3], dl
  001e0	0f b6 56 0b	 movzx	 edx, BYTE PTR [esi+11]
  001e4	88 45 f4	 mov	 BYTE PTR _ItemInfo$[ebp+4], al
  001e7	0f b6 46 0c	 movzx	 eax, BYTE PTR [esi+12]
  001eb	88 4d f8	 mov	 BYTE PTR _ItemInfo$[ebp+8], cl

; 4749 : 	ItemInfo[9] = lpMsg->sItemInfo[9];
; 4750 : 	ItemInfo[10] = lpMsg->sItemInfo[10];
; 4751 : 	ItemInfo[11] = lpMsg->sItemInfo[11];

  001ee	0f b6 4e 10	 movzx	 ecx, BYTE PTR [esi+16]
  001f2	88 55 f6	 mov	 BYTE PTR _ItemInfo$[ebp+6], dl
  001f5	0f b6 56 0e	 movzx	 edx, BYTE PTR [esi+14]
  001f9	88 45 f7	 mov	 BYTE PTR _ItemInfo$[ebp+7], al
  001fc	0f b6 46 0f	 movzx	 eax, BYTE PTR [esi+15]
  00200	88 4d fb	 mov	 BYTE PTR _ItemInfo$[ebp+11], cl

; 4752 : 
; 4753 : 	if ( lpMsg->sFlag == 3 || lpMsg->tFlag == 3 )

  00203	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]
  00206	88 55 f9	 mov	 BYTE PTR _ItemInfo$[ebp+9], dl
  00209	88 45 fa	 mov	 BYTE PTR _ItemInfo$[ebp+10], al
  0020c	bb 01 00 00 00	 mov	 ebx, 1
  00211	80 f9 03	 cmp	 cl, 3
  00214	74 06		 je	 SHORT $LN122@CGInventor@3
  00216	80 7e 11 03	 cmp	 BYTE PTR [esi+17], 3
  0021a	75 77		 jne	 SHORT $LN148@CGInventor@3
$LN122@CGInventor@3:

; 4754 : 	{
; 4755 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 7 )

  0021c	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  00222	8b d0		 mov	 edx, eax
  00224	80 e2 03	 and	 dl, 3
  00227	80 fa 01	 cmp	 dl, 1
  0022a	0f 82 b6 0d 00
	00		 jb	 $LN120@CGInventor@3
  00230	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00235	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  0023a	0f 85 a6 0d 00
	00		 jne	 $LN120@CGInventor@3

; 4759 : 
; 4760 : 			return;
; 4761 : 		}
; 4762 : 
; 4763 : 		if ( lpObj->ChaosLock == TRUE )

  00240	39 9f 20 12 00
	00		 cmp	 DWORD PTR [edi+4640], ebx
  00246	75 4b		 jne	 SHORT $LN148@CGInventor@3

; 4764 : 		{
; 4765 : 			LogAddTD("[%s][%s] error-L3 : CBMixing", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00248	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0024d	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  00253	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  00257	52		 push	 edx
  00258	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  0025c	50		 push	 eax
  0025d	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@
  00262	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4766 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00268	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0026e	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00271	51		 push	 ecx
  00272	6a 00		 push	 0
  00274	68 ff 00 00 00	 push	 255			; 000000ffH
  00279	52		 push	 edx
  0027a	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0027f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00282	5f		 pop	 edi
  00283	5e		 pop	 esi
  00284	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  00285	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00288	33 cd		 xor	 ecx, ebp
  0028a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028f	8b e5		 mov	 esp, ebp
  00291	5d		 pop	 ebp
  00292	c3		 ret	 0
$LN148@CGInventor@3:

; 4767 : 		
; 4768 : 			return;
; 4769 : 		}
; 4770 : 	}
; 4771 : 
; 4772 : 	if ( lpMsg->sFlag == 5 || lpMsg->tFlag == 5 )

  00293	80 f9 05	 cmp	 cl, 5
  00296	74 06		 je	 SHORT $LN117@CGInventor@3
  00298	80 7e 11 05	 cmp	 BYTE PTR [esi+17], 5
  0029c	75 7d		 jne	 SHORT $LN149@CGInventor@3
$LN117@CGInventor@3:

; 4773 : 	{
; 4774 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 13 )

  0029e	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  002a4	8b d0		 mov	 edx, eax
  002a6	80 e2 03	 and	 dl, 3
  002a9	80 fa 01	 cmp	 dl, 1
  002ac	0f 82 01 0d 00
	00		 jb	 $LN115@CGInventor@3
  002b2	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  002b7	3d 40 03 00 00	 cmp	 eax, 832		; 00000340H
  002bc	0f 85 f1 0c 00
	00		 jne	 $LN115@CGInventor@3

; 4780 : 		}
; 4781 : 
; 4782 : 		if ( lpObj->ChaosLock == TRUE )

  002c2	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  002c8	39 9f 20 12 00
	00		 cmp	 DWORD PTR [edi+4640], ebx
  002ce	75 4b		 jne	 SHORT $LN149@CGInventor@3

; 4783 : 		{
; 4784 : 			LogAddTD("[%s][%s] error-L3 : DarkTrainerBoxMixing", gObj[aIndex].AccountID, gObj[aIndex].Name);

  002d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d5	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  002db	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  002df	52		 push	 edx
  002e0	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  002e4	50		 push	 eax
  002e5	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@
  002ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4785 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  002f0	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  002f6	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  002f9	51		 push	 ecx
  002fa	6a 00		 push	 0
  002fc	68 ff 00 00 00	 push	 255			; 000000ffH
  00301	52		 push	 edx
  00302	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00307	83 c4 1c	 add	 esp, 28			; 0000001cH
  0030a	5f		 pop	 edi
  0030b	5e		 pop	 esi
  0030c	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  0030d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00310	33 cd		 xor	 ecx, ebp
  00312	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00317	8b e5		 mov	 esp, ebp
  00319	5d		 pop	 ebp
  0031a	c3		 ret	 0
$LN149@CGInventor@3:

; 4786 : 		
; 4787 : 			return;
; 4788 : 		}
; 4789 : 	}
; 4790 : 
; 4791 : 	if ( lpMsg->sFlag == 6 || lpMsg->sFlag == 7 || lpMsg->sFlag == 8 ||
; 4792 : 		 lpMsg->tFlag == 6 || lpMsg->tFlag == 7 || lpMsg->tFlag == 8 )

  0031b	80 f9 06	 cmp	 cl, 6
  0031e	74 19		 je	 SHORT $LN112@CGInventor@3
  00320	80 f9 07	 cmp	 cl, 7
  00323	74 14		 je	 SHORT $LN112@CGInventor@3
  00325	80 f9 08	 cmp	 cl, 8
  00328	74 0f		 je	 SHORT $LN112@CGInventor@3
  0032a	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0032d	3c 06		 cmp	 al, 6
  0032f	74 08		 je	 SHORT $LN112@CGInventor@3
  00331	3c 07		 cmp	 al, 7
  00333	74 04		 je	 SHORT $LN112@CGInventor@3
  00335	3c 08		 cmp	 al, 8
  00337	75 7d		 jne	 SHORT $LN150@CGInventor@3
$LN112@CGInventor@3:

; 4793 : 	{
; 4794 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type !=7 )

  00339	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  0033f	8b d0		 mov	 edx, eax
  00341	80 e2 03	 and	 dl, 3
  00344	80 fa 01	 cmp	 dl, 1
  00347	0f 82 33 0c 00
	00		 jb	 $LN90@CGInventor@3
  0034d	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00352	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  00357	0f 85 23 0c 00
	00		 jne	 $LN90@CGInventor@3

; 4795 : 		{
; 4796 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4797 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 4798 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4799 : 
; 4800 : 			return;
; 4801 : 		}
; 4802 : 
; 4803 : 		if ( lpObj->ChaosLock == TRUE )

  0035d	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  00363	39 9f 20 12 00
	00		 cmp	 DWORD PTR [edi+4640], ebx
  00369	75 4b		 jne	 SHORT $LN150@CGInventor@3
$LN180@CGInventor@3:

; 4804 : 		{
; 4805 : 			LogAddTD("[%s][%s] error-L3 : JewelOfHarmony Mixing",
; 4806 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  0036b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00370	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  00376	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  0037a	52		 push	 edx
  0037b	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  0037f	50		 push	 eax
  00380	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@
  00385	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4807 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  0038b	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00391	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00394	51		 push	 ecx
  00395	6a 00		 push	 0
  00397	68 ff 00 00 00	 push	 255			; 000000ffH
  0039c	52		 push	 edx
  0039d	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  003a2	83 c4 1c	 add	 esp, 28			; 0000001cH
  003a5	5f		 pop	 edi
  003a6	5e		 pop	 esi
  003a7	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  003a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ab	33 cd		 xor	 ecx, ebp
  003ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b2	8b e5		 mov	 esp, ebp
  003b4	5d		 pop	 ebp
  003b5	c3		 ret	 0
$LN150@CGInventor@3:

; 4808 : 
; 4809 : 			return;
; 4810 : 		}
; 4811 : 	}
; 4812 : 
; 4813 : 	if ( lpMsg->sFlag == 9 || lpMsg->tFlag == 9 )

  003b6	80 f9 09	 cmp	 cl, 9
  003b9	74 06		 je	 SHORT $LN107@CGInventor@3
  003bb	80 7e 11 09	 cmp	 BYTE PTR [esi+17], 9
  003bf	75 36		 jne	 SHORT $LN151@CGInventor@3
$LN107@CGInventor@3:

; 4814 : 	{
; 4815 : 		if ( lpObj->m_IfState.use	 < 1 || lpObj->m_IfState.type !=7 )

  003c1	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  003c7	8b d0		 mov	 edx, eax
  003c9	80 e2 03	 and	 dl, 3
  003cc	80 fa 01	 cmp	 dl, 1
  003cf	0f 82 ab 0b 00
	00		 jb	 $LN90@CGInventor@3
  003d5	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  003da	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  003df	0f 85 9b 0b 00
	00		 jne	 $LN90@CGInventor@3

; 4816 : 		{
; 4817 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4818 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 4819 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4820 : 
; 4821 : 			return;
; 4822 : 		}
; 4823 : 
; 4824 : 		if ( lpObj->ChaosLock == TRUE )

  003e5	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  003eb	39 9f 20 12 00
	00		 cmp	 DWORD PTR [edi+4640], ebx

; 4825 : 		{
; 4826 : 			LogAddTD("[%s][%s] error-L3 : JewelOfHarmony Mixing",
; 4827 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4828 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4829 : 
; 4830 : 			return;

  003f1	0f 84 74 ff ff
	ff		 je	 $LN180@CGInventor@3
$LN151@CGInventor@3:

; 4831 : 		}
; 4832 : 	}
; 4833 : 
; 4834 : 	if ( lpMsg->sFlag == 11 || lpMsg->sFlag == 12 || lpMsg->sFlag == 13 || lpMsg->sFlag == 14 ||
; 4835 : 		 lpMsg->tFlag == 11 || lpMsg->tFlag == 12 || lpMsg->tFlag == 13 || lpMsg->tFlag == 14 )

  003f7	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  003fa	74 22		 je	 SHORT $LN102@CGInventor@3
  003fc	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  003ff	74 1d		 je	 SHORT $LN102@CGInventor@3
  00401	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  00404	74 18		 je	 SHORT $LN102@CGInventor@3
  00406	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  00409	74 13		 je	 SHORT $LN102@CGInventor@3
  0040b	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0040e	3c 0b		 cmp	 al, 11			; 0000000bH
  00410	74 0c		 je	 SHORT $LN102@CGInventor@3
  00412	3c 0c		 cmp	 al, 12			; 0000000cH
  00414	74 08		 je	 SHORT $LN102@CGInventor@3
  00416	3c 0d		 cmp	 al, 13			; 0000000dH
  00418	74 04		 je	 SHORT $LN102@CGInventor@3
  0041a	3c 0e		 cmp	 al, 14			; 0000000eH
  0041c	75 7d		 jne	 SHORT $LN152@CGInventor@3
$LN102@CGInventor@3:

; 4836 : 	{
; 4837 : 		if ( lpObj->m_IfState.use	 < 1 || lpObj->m_IfState.type !=7 )

  0041e	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  00424	8b d0		 mov	 edx, eax
  00426	80 e2 03	 and	 dl, 3
  00429	80 fa 01	 cmp	 dl, 1
  0042c	0f 82 4e 0b 00
	00		 jb	 $LN90@CGInventor@3
  00432	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00437	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  0043c	0f 85 3e 0b 00
	00		 jne	 $LN90@CGInventor@3

; 4838 : 		{
; 4839 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4840 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 4841 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4842 : 
; 4843 : 			return;
; 4844 : 		}
; 4845 : 
; 4846 : 		if ( lpObj->ChaosLock == TRUE )

  00442	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  00448	39 9f 20 12 00
	00		 cmp	 DWORD PTR [edi+4640], ebx
  0044e	75 4b		 jne	 SHORT $LN152@CGInventor@3

; 4847 : 		{
; 4848 : 			LogAddTD("[%s][%s] error-L3 : SocketItem Mixing",
; 4849 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  00450	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00455	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  0045b	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  0045f	52		 push	 edx
  00460	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  00464	50		 push	 eax
  00465	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@
  0046a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4850 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00470	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00476	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00479	51		 push	 ecx
  0047a	6a 00		 push	 0
  0047c	68 ff 00 00 00	 push	 255			; 000000ffH
  00481	52		 push	 edx
  00482	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00487	83 c4 1c	 add	 esp, 28			; 0000001cH
  0048a	5f		 pop	 edi
  0048b	5e		 pop	 esi
  0048c	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  0048d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00490	33 cd		 xor	 ecx, ebp
  00492	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00497	8b e5		 mov	 esp, ebp
  00499	5d		 pop	 ebp
  0049a	c3		 ret	 0
$LN152@CGInventor@3:

; 4851 : 
; 4852 : 			return;
; 4853 : 		}
; 4854 : 	}
; 4855 : 
; 4856 : 	if ( lpMsg->sFlag == 15 || lpMsg->sFlag == 16 ||
; 4857 : 		 lpMsg->tFlag == 15 || lpMsg->tFlag == 16 )

  0049b	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  0049e	74 10		 je	 SHORT $LN97@CGInventor@3
  004a0	80 f9 10	 cmp	 cl, 16			; 00000010H
  004a3	74 0b		 je	 SHORT $LN97@CGInventor@3
  004a5	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  004a8	3c 0f		 cmp	 al, 15			; 0000000fH
  004aa	74 04		 je	 SHORT $LN97@CGInventor@3
  004ac	3c 10		 cmp	 al, 16			; 00000010H
  004ae	75 7d		 jne	 SHORT $LN153@CGInventor@3
$LN97@CGInventor@3:

; 4858 : 	{
; 4859 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type !=7 )

  004b0	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  004b6	8b d0		 mov	 edx, eax
  004b8	80 e2 03	 and	 dl, 3
  004bb	80 fa 01	 cmp	 dl, 1
  004be	0f 82 bc 0a 00
	00		 jb	 $LN90@CGInventor@3
  004c4	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  004c9	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  004ce	0f 85 ac 0a 00
	00		 jne	 $LN90@CGInventor@3

; 4860 : 		{
; 4861 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4862 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 4863 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4864 : 			return;
; 4865 : 		}
; 4866 : 
; 4867 : 		if ( lpObj->ChaosLock == TRUE )

  004d4	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  004da	39 9f 20 12 00
	00		 cmp	 DWORD PTR [edi+4640], ebx
  004e0	75 4b		 jne	 SHORT $LN153@CGInventor@3

; 4868 : 		{
; 4869 : 			LogAddTD("[%s][%s] error-L3 : LuckyItem Mixing",
; 4870 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  004e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004e7	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  004ed	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  004f1	52		 push	 edx
  004f2	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  004f6	50		 push	 eax
  004f7	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LHICMFIE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5LuckyItem?5Mi@
  004fc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4871 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00502	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00508	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  0050b	51		 push	 ecx
  0050c	6a 00		 push	 0
  0050e	68 ff 00 00 00	 push	 255			; 000000ffH
  00513	52		 push	 edx
  00514	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00519	83 c4 1c	 add	 esp, 28			; 0000001cH
  0051c	5f		 pop	 edi
  0051d	5e		 pop	 esi
  0051e	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  0051f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00522	33 cd		 xor	 ecx, ebp
  00524	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00529	8b e5		 mov	 esp, ebp
  0052b	5d		 pop	 ebp
  0052c	c3		 ret	 0
$LN153@CGInventor@3:

; 4872 : 			return;
; 4873 : 		}
; 4874 : 	}
; 4875 : 
; 4876 : 	if ( lpMsg->sFlag == 17 || lpMsg->tFlag == 17 )

  0052d	80 f9 11	 cmp	 cl, 17			; 00000011H
  00530	74 06		 je	 SHORT $LN92@CGInventor@3
  00532	80 7e 11 11	 cmp	 BYTE PTR [esi+17], 17	; 00000011H
  00536	75 7d		 jne	 SHORT $LN154@CGInventor@3
$LN92@CGInventor@3:

; 4877 : 	{
; 4878 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type !=7 )

  00538	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  0053e	8b d0		 mov	 edx, eax
  00540	80 e2 03	 and	 dl, 3
  00543	80 fa 01	 cmp	 dl, 1
  00546	0f 82 34 0a 00
	00		 jb	 $LN90@CGInventor@3
  0054c	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00551	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  00556	0f 85 24 0a 00
	00		 jne	 $LN90@CGInventor@3

; 4884 : 		}
; 4885 : 
; 4886 : 		if ( lpObj->ChaosLock == TRUE )

  0055c	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  00562	39 9f 20 12 00
	00		 cmp	 DWORD PTR [edi+4640], ebx
  00568	75 4b		 jne	 SHORT $LN154@CGInventor@3

; 4887 : 		{
; 4888 : 			LogAddTD("[%s][%s] error-L3 : Elemental Mixing",
; 4889 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  0056a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0056f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  00575	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  00579	52		 push	 edx
  0057a	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  0057e	50		 push	 eax
  0057f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GLNEHHDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5Elemental?5Mi@
  00584	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4890 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  0058a	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00590	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00593	51		 push	 ecx
  00594	6a 00		 push	 0
  00596	68 ff 00 00 00	 push	 255			; 000000ffH
  0059b	52		 push	 edx
  0059c	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  005a1	83 c4 1c	 add	 esp, 28			; 0000001cH
  005a4	5f		 pop	 edi
  005a5	5e		 pop	 esi
  005a6	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  005a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005aa	33 cd		 xor	 ecx, ebp
  005ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005b1	8b e5		 mov	 esp, ebp
  005b3	5d		 pop	 ebp
  005b4	c3		 ret	 0
$LN154@CGInventor@3:

; 4891 : 			return;
; 4892 : 		}
; 4893 : 	}
; 4894 : 
; 4895 : 	if ( lpMsg->sFlag == 2 || lpMsg->tFlag == 2 )

  005b5	80 f9 02	 cmp	 cl, 2
  005b8	74 06		 je	 SHORT $LN87@CGInventor@3
  005ba	80 7e 11 02	 cmp	 BYTE PTR [esi+17], 2
  005be	75 2a		 jne	 SHORT $LN86@CGInventor@3
$LN87@CGInventor@3:

; 4896 : 	{
; 4897 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 6 )

  005c0	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  005c6	8b d0		 mov	 edx, eax
  005c8	80 e2 03	 and	 dl, 3
  005cb	80 fa 01	 cmp	 dl, 1
  005ce	0f 82 76 09 00
	00		 jb	 $LN85@CGInventor@3
  005d4	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  005d9	3d 80 01 00 00	 cmp	 eax, 384		; 00000180H
  005de	0f 85 66 09 00
	00		 jne	 $LN85@CGInventor@3
  005e4	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
$LN86@CGInventor@3:

; 4903 : 		}
; 4904 : 	}
; 4905 : 
; 4906 : 	if ( lpMsg->sFlag == 1 && lpMsg->tFlag == 0 )

  005ea	80 f9 01	 cmp	 cl, 1
  005ed	75 55		 jne	 SHORT $LN155@CGInventor@3
  005ef	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  005f3	75 4f		 jne	 SHORT $LN155@CGInventor@3

; 4907 : 	{
; 4908 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 1 )

  005f5	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  005fb	8b d0		 mov	 edx, eax
  005fd	80 e2 03	 and	 dl, 3
  00600	3a d1		 cmp	 dl, cl
  00602	72 0a		 jb	 SHORT $LN82@CGInventor@3
  00604	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00609	83 f8 40	 cmp	 eax, 64			; 00000040H
  0060c	74 36		 je	 SHORT $LN155@CGInventor@3
$LN82@CGInventor@3:

; 4909 : 		{
; 4910 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  0060e	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00614	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00617	50		 push	 eax
  00618	6a 00		 push	 0
  0061a	68 ff 00 00 00	 push	 255			; 000000ffH
  0061f	51		 push	 ecx
  00620	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 4911 : 			LogAdd("[%s][%s] error-L1 : used not Trade", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00625	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0062a	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  00630	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  00634	52		 push	 edx
  00635	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  00639	50		 push	 eax
  0063a	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@

; 4912 : 
; 4913 : 			return;

  0063f	e9 d3 09 00 00	 jmp	 $LN160@CGInventor@3
$LN155@CGInventor@3:

; 4914 : 		}
; 4915 : 	}
; 4916 : 
; 4917 : 	if ( lpMsg->sFlag == 2 && lpMsg->tFlag == 0 )

  00644	80 f9 02	 cmp	 cl, 2
  00647	0f 85 1d 01 00
	00		 jne	 $LN145@CGInventor@3
  0064d	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00651	0f 85 13 01 00
	00		 jne	 $LN145@CGInventor@3

; 4918 : 	{
; 4919 : 		int money = ::GetWarehouseUsedHowMuch(lpObj->Level,lpObj->MasterLevel, lpObj->WarehousePW);

  00657	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0065d	0f bf 88 02 12
	00 00		 movsx	 ecx, WORD PTR [eax+4610]
  00664	0f bf 90 a8 00
	00 00		 movsx	 edx, WORD PTR [eax+168]
  0066b	0f bf 80 96 00
	00 00		 movsx	 eax, WORD PTR [eax+150]
  00672	51		 push	 ecx
  00673	52		 push	 edx
  00674	50		 push	 eax
  00675	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHHH@Z ; GetWarehouseUsedHowMuch

; 4920 : 
; 4921 : 		if ( (lpObj->Money - money ) < 1 && (lpObj->WarehouseMoney - money) < 1)

  0067a	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00680	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  00686	8b f8		 mov	 edi, eax
  00688	2b d7		 sub	 edx, edi
  0068a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0068d	3b d3		 cmp	 edx, ebx
  0068f	7d 6f		 jge	 SHORT $LN80@CGInventor@3
  00691	8b c1		 mov	 eax, ecx
  00693	8b 88 08 12 00
	00		 mov	 ecx, DWORD PTR [eax+4616]
  00699	2b cf		 sub	 ecx, edi
  0069b	3b cb		 cmp	 ecx, ebx
  0069d	7d 61		 jge	 SHORT $LN80@CGInventor@3

; 4922 : 		{
; 4923 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  0069f	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  006a5	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  006a8	52		 push	 edx
  006a9	6a 00		 push	 0
  006ab	68 ff 00 00 00	 push	 255			; 000000ffH
  006b0	50		 push	 eax
  006b1	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  006b6	83 c4 10	 add	 esp, 16			; 00000010H

; 4924 : 			char szTemp[256];
; 4925 : 			sprintf_s(szTemp, lMsg.Get(MSGGET(6, 69)), money);

  006b9	57		 push	 edi
  006ba	68 45 06 00 00	 push	 1605			; 00000645H
  006bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  006c4	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  006c9	50		 push	 eax
  006ca	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$218895[ebp]
  006d0	51		 push	 ecx
  006d1	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>

; 4926 : 			::GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  006d6	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  006dc	8b 02		 mov	 eax, DWORD PTR [edx]
  006de	53		 push	 ebx
  006df	50		 push	 eax
  006e0	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$218895[ebp]
  006e6	51		 push	 ecx
  006e7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  006ec	83 c4 18	 add	 esp, 24			; 00000018H
  006ef	5f		 pop	 edi
  006f0	5e		 pop	 esi
  006f1	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  006f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006f5	33 cd		 xor	 ecx, ebp
  006f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006fc	8b e5		 mov	 esp, ebp
  006fe	5d		 pop	 ebp
  006ff	c3		 ret	 0
$LN80@CGInventor@3:

; 4927 : 
; 4928 : 			return;
; 4929 : 		}
; 4930 : 
; 4931 : 		if ( ::bCanWarehouseLock == TRUE )

  00700	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, ebx ; bCanWarehouseLock
  00706	75 62		 jne	 SHORT $LN145@CGInventor@3

; 4932 : 		{
; 4933 : 			if ( gObj[aIndex].WarehouseLock == 1 )

  00708	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0070e	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv1344[ebp]
  00714	38 9c 10 04 12
	00 00		 cmp	 BYTE PTR [eax+edx+4612], bl
  0071b	75 4d		 jne	 SHORT $LN145@CGInventor@3

; 4934 : 			{
; 4935 : 				::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  0071d	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00723	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00726	51		 push	 ecx
  00727	6a 00		 push	 0
  00729	68 ff 00 00 00	 push	 255			; 000000ffH
  0072e	52		 push	 edx
  0072f	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 4936 : 				::GCServerMsgStringSend(lMsg.Get(MSGGET(6, 70)), lpObj->m_Index, 1);

  00734	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0073a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0073c	83 c4 10	 add	 esp, 16			; 00000010H
  0073f	53		 push	 ebx
  00740	51		 push	 ecx
  00741	68 46 06 00 00	 push	 1606			; 00000646H
  00746	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0074b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00750	50		 push	 eax
  00751	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00756	83 c4 0c	 add	 esp, 12			; 0000000cH
  00759	5f		 pop	 edi
  0075a	5e		 pop	 esi
  0075b	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  0075c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0075f	33 cd		 xor	 ecx, ebp
  00761	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00766	8b e5		 mov	 esp, ebp
  00768	5d		 pop	 ebp
  00769	c3		 ret	 0
$LN145@CGInventor@3:

; 4937 : 
; 4938 : 				return;
; 4939 : 			}
; 4940 : 		}
; 4941 : 	}
; 4942 : 
; 4943 : 	if( it_type != 8 )

  0076a	83 bd d8 fe ff
	ff 08		 cmp	 DWORD PTR _it_type$[ebp], 8
  00771	74 5f		 je	 SHORT $LN156@CGInventor@3

; 4944 : 	{
; 4945 : 		int type = (ItemInfo[I_TYPE] + ((ItemInfo[I_NOPTION] & 0x80 )*2)) + ((ItemInfo[I_380OPTION] & 0xF0)<<5);

  00773	0f b6 55 f5	 movzx	 edx, BYTE PTR _ItemInfo$[ebp+5]
  00777	0f b6 45 f3	 movzx	 eax, BYTE PTR _ItemInfo$[ebp+3]
  0077b	0f b6 4d f0	 movzx	 ecx, BYTE PTR _ItemInfo$[ebp]
  0077f	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  00785	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0078a	c1 e2 04	 shl	 edx, 4
  0078d	03 d0		 add	 edx, eax
  0078f	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]

; 4946 : 		LPITEM_ATTRIBUTE lpItemAttr = GetItemAttr(type);

  00792	50		 push	 eax
  00793	e8 00 00 00 00	 call	 ?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z ; GetItemAttr
  00798	83 c4 04	 add	 esp, 4

; 4947 : 
; 4948 : 		if ( lpItemAttr == NULL )

  0079b	85 c0		 test	 eax, eax
  0079d	75 16		 jne	 SHORT $LN76@CGInventor@3

; 4949 : 		{
; 4950 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  0079f	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  007a2	52		 push	 edx
  007a3	50		 push	 eax
  007a4	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  007aa	68 ff 00 00 00	 push	 255			; 000000ffH
  007af	50		 push	 eax

; 4951 : 			return;

  007b0	e9 9c f8 ff ff	 jmp	 $LN183@CGInventor@3
$LN76@CGInventor@3:

; 4952 : 		}
; 4953 : 
; 4954 : 		if ( lpItemAttr->QuestItem != false )

  007b5	80 78 60 00	 cmp	 BYTE PTR [eax+96], 0
  007b9	74 17		 je	 SHORT $LN156@CGInventor@3

; 4955 : 		{
; 4956 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  007bb	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  007c1	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  007c4	51		 push	 ecx
  007c5	6a 00		 push	 0
  007c7	68 ff 00 00 00	 push	 255			; 000000ffH
  007cc	52		 push	 edx

; 4957 : 			return;

  007cd	e9 7f f8 ff ff	 jmp	 $LN183@CGInventor@3
$LN156@CGInventor@3:

; 4958 : 		}
; 4959 : 	}
; 4960 : 
; 4961 : 	if ( (lpMsg->sFlag == 0 && lpMsg->tFlag == 0) ||
; 4962 :  		 (lpMsg->sFlag == 2 && lpMsg->tFlag == 0) ||
; 4963 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 2) ||
; 4964 :  		 (lpMsg->sFlag == 2 && lpMsg->tFlag == 2) ||
; 4965 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 3) ||
; 4966 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 5) ||
; 4967 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 6) ||
; 4968 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 7) ||
; 4969 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 8) ||
; 4970 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 9) ||
; 4971 : 		 (lpMsg->sFlag == 9 && lpMsg->tFlag == 9) ||
; 4972 : 		 (lpMsg->sFlag == 9 && lpMsg->tFlag == 0) ||
; 4973 : 
; 4974 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 10) ||
; 4975 : 		 (lpMsg->sFlag == 10 && lpMsg->tFlag == 10) ||
; 4976 : 		 (lpMsg->sFlag == 10 && lpMsg->tFlag == 0) ||
; 4977 : 
; 4978 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 4) ||
; 4979 : 		 (lpMsg->sFlag == 4 && lpMsg->tFlag == 0) ||
; 4980 : 		 (lpMsg->sFlag == 4 && lpMsg->tFlag == 4) ||
; 4981 : 		 (lpMsg->sFlag == 5 && lpMsg->tFlag == 0) ||
; 4982 : 		 (lpMsg->sFlag == 5 && lpMsg->tFlag == 5) ||
; 4983 : 		 (lpMsg->sFlag == 6 && lpMsg->tFlag == 0) ||
; 4984 : 		 (lpMsg->sFlag == 6 && lpMsg->tFlag == 6) ||
; 4985 : 		 (lpMsg->sFlag == 7 && lpMsg->tFlag == 0) ||
; 4986 : 		 (lpMsg->sFlag == 7 && lpMsg->tFlag == 7) ||
; 4987 : 		 (lpMsg->sFlag == 8 && lpMsg->tFlag == 0) ||
; 4988 : 		 (lpMsg->sFlag == 8 && lpMsg->tFlag == 8) ||
; 4989 : 
; 4990 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 11) ||
; 4991 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 12) ||
; 4992 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 13) ||
; 4993 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 14) ||
; 4994 : 		 (lpMsg->sFlag == 11 && lpMsg->tFlag == 0) ||
; 4995 : 		 (lpMsg->sFlag == 12 && lpMsg->tFlag == 0) ||
; 4996 : 		 (lpMsg->sFlag == 13 && lpMsg->tFlag == 0) ||
; 4997 : 		 (lpMsg->sFlag == 14 && lpMsg->tFlag == 0) ||
; 4998 : 		 (lpMsg->sFlag == 11 && lpMsg->tFlag == 11) ||
; 4999 : 		 (lpMsg->sFlag == 12 && lpMsg->tFlag == 12) ||
; 5000 : 		 (lpMsg->sFlag == 13 && lpMsg->tFlag == 13) ||
; 5001 : 		 (lpMsg->sFlag == 14 && lpMsg->tFlag == 14) ||
; 5002 : 
; 5003 : 		 (lpMsg->sFlag == 15 && lpMsg->tFlag == 0) ||
; 5004 : 		 (lpMsg->sFlag == 16 && lpMsg->tFlag == 0) ||
; 5005 : 		 (lpMsg->sFlag == 15 && lpMsg->tFlag == 15) ||
; 5006 : 		 (lpMsg->sFlag == 16 && lpMsg->tFlag == 16) ||
; 5007 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 15) ||
; 5008 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 16) ||
; 5009 : 
; 5010 : 		 (lpMsg->sFlag == 17 && lpMsg->tFlag == 0) ||
; 5011 : 		 (lpMsg->sFlag == 17 && lpMsg->tFlag == 17) ||
; 5012 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 17) ||
; 5013 : 
; 5014 : 		 (lpMsg->sFlag == 3 && lpMsg->tFlag == 0) ||
; 5015 : 		 (lpMsg->sFlag == 3 && lpMsg->tFlag == 3) )

  007d2	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]
  007d5	84 c9		 test	 cl, cl
  007d7	75 0b		 jne	 SHORT $LN72@CGInventor@3
  007d9	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  007dc	84 c0		 test	 al, al
  007de	0f 84 94 02 00
	00		 je	 $LN73@CGInventor@3
$LN72@CGInventor@3:
  007e4	80 f9 02	 cmp	 cl, 2
  007e7	75 0b		 jne	 SHORT $LN71@CGInventor@3
  007e9	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  007ec	84 c0		 test	 al, al
  007ee	0f 84 84 02 00
	00		 je	 $LN73@CGInventor@3
$LN71@CGInventor@3:
  007f4	84 c9		 test	 cl, cl
  007f6	75 0b		 jne	 SHORT $LN70@CGInventor@3
  007f8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  007fb	3c 02		 cmp	 al, 2
  007fd	0f 84 75 02 00
	00		 je	 $LN73@CGInventor@3
$LN70@CGInventor@3:
  00803	80 f9 02	 cmp	 cl, 2
  00806	75 0b		 jne	 SHORT $LN69@CGInventor@3
  00808	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0080b	3a c1		 cmp	 al, cl
  0080d	0f 84 65 02 00
	00		 je	 $LN73@CGInventor@3
$LN69@CGInventor@3:
  00813	84 c9		 test	 cl, cl
  00815	75 47		 jne	 SHORT $LN63@CGInventor@3
  00817	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0081a	3c 03		 cmp	 al, 3
  0081c	0f 84 56 02 00
	00		 je	 $LN73@CGInventor@3
  00822	84 c9		 test	 cl, cl
  00824	75 38		 jne	 SHORT $LN63@CGInventor@3
  00826	3c 05		 cmp	 al, 5
  00828	0f 84 4a 02 00
	00		 je	 $LN73@CGInventor@3
  0082e	84 c9		 test	 cl, cl
  00830	75 2c		 jne	 SHORT $LN63@CGInventor@3
  00832	3c 06		 cmp	 al, 6
  00834	0f 84 3e 02 00
	00		 je	 $LN73@CGInventor@3
  0083a	84 c9		 test	 cl, cl
  0083c	75 20		 jne	 SHORT $LN63@CGInventor@3
  0083e	3c 07		 cmp	 al, 7
  00840	0f 84 32 02 00
	00		 je	 $LN73@CGInventor@3
  00846	84 c9		 test	 cl, cl
  00848	75 14		 jne	 SHORT $LN63@CGInventor@3
  0084a	3c 08		 cmp	 al, 8
  0084c	0f 84 26 02 00
	00		 je	 $LN73@CGInventor@3
  00852	84 c9		 test	 cl, cl
  00854	75 08		 jne	 SHORT $LN63@CGInventor@3
  00856	3c 09		 cmp	 al, 9
  00858	0f 84 1a 02 00
	00		 je	 $LN73@CGInventor@3
$LN63@CGInventor@3:
  0085e	80 f9 09	 cmp	 cl, 9
  00861	75 17		 jne	 SHORT $LN61@CGInventor@3
  00863	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00866	3a c1		 cmp	 al, cl
  00868	0f 84 0a 02 00
	00		 je	 $LN73@CGInventor@3
  0086e	3a c9		 cmp	 cl, cl
  00870	75 08		 jne	 SHORT $LN61@CGInventor@3
  00872	84 c0		 test	 al, al
  00874	0f 84 fe 01 00
	00		 je	 $LN73@CGInventor@3
$LN61@CGInventor@3:
  0087a	84 c9		 test	 cl, cl
  0087c	75 0b		 jne	 SHORT $LN60@CGInventor@3
  0087e	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00881	3c 0a		 cmp	 al, 10			; 0000000aH
  00883	0f 84 ef 01 00
	00		 je	 $LN73@CGInventor@3
$LN60@CGInventor@3:
  00889	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  0088c	75 17		 jne	 SHORT $LN58@CGInventor@3
  0088e	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00891	3a c1		 cmp	 al, cl
  00893	0f 84 df 01 00
	00		 je	 $LN73@CGInventor@3
  00899	3a c9		 cmp	 cl, cl
  0089b	75 08		 jne	 SHORT $LN58@CGInventor@3
  0089d	84 c0		 test	 al, al
  0089f	0f 84 d3 01 00
	00		 je	 $LN73@CGInventor@3
$LN58@CGInventor@3:
  008a5	84 c9		 test	 cl, cl
  008a7	75 0b		 jne	 SHORT $LN57@CGInventor@3
  008a9	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  008ac	3c 04		 cmp	 al, 4
  008ae	0f 84 c4 01 00
	00		 je	 $LN73@CGInventor@3
$LN57@CGInventor@3:
  008b4	80 f9 04	 cmp	 cl, 4
  008b7	75 17		 jne	 SHORT $LN55@CGInventor@3
  008b9	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  008bc	84 c0		 test	 al, al
  008be	0f 84 b4 01 00
	00		 je	 $LN73@CGInventor@3
  008c4	3a c9		 cmp	 cl, cl
  008c6	75 08		 jne	 SHORT $LN55@CGInventor@3
  008c8	3a c1		 cmp	 al, cl
  008ca	0f 84 a8 01 00
	00		 je	 $LN73@CGInventor@3
$LN55@CGInventor@3:
  008d0	80 f9 05	 cmp	 cl, 5
  008d3	75 17		 jne	 SHORT $LN53@CGInventor@3
  008d5	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  008d8	84 c0		 test	 al, al
  008da	0f 84 98 01 00
	00		 je	 $LN73@CGInventor@3
  008e0	3a c9		 cmp	 cl, cl
  008e2	75 08		 jne	 SHORT $LN53@CGInventor@3
  008e4	3a c1		 cmp	 al, cl
  008e6	0f 84 8c 01 00
	00		 je	 $LN73@CGInventor@3
$LN53@CGInventor@3:
  008ec	80 f9 06	 cmp	 cl, 6
  008ef	75 17		 jne	 SHORT $LN51@CGInventor@3
  008f1	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  008f4	84 c0		 test	 al, al
  008f6	0f 84 7c 01 00
	00		 je	 $LN73@CGInventor@3
  008fc	3a c9		 cmp	 cl, cl
  008fe	75 08		 jne	 SHORT $LN51@CGInventor@3
  00900	3a c1		 cmp	 al, cl
  00902	0f 84 70 01 00
	00		 je	 $LN73@CGInventor@3
$LN51@CGInventor@3:
  00908	80 f9 07	 cmp	 cl, 7
  0090b	75 17		 jne	 SHORT $LN49@CGInventor@3
  0090d	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00910	84 c0		 test	 al, al
  00912	0f 84 60 01 00
	00		 je	 $LN73@CGInventor@3
  00918	3a c9		 cmp	 cl, cl
  0091a	75 08		 jne	 SHORT $LN49@CGInventor@3
  0091c	3a c1		 cmp	 al, cl
  0091e	0f 84 54 01 00
	00		 je	 $LN73@CGInventor@3
$LN49@CGInventor@3:
  00924	80 f9 08	 cmp	 cl, 8
  00927	75 17		 jne	 SHORT $LN47@CGInventor@3
  00929	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0092c	84 c0		 test	 al, al
  0092e	0f 84 44 01 00
	00		 je	 $LN73@CGInventor@3
  00934	3a c9		 cmp	 cl, cl
  00936	75 08		 jne	 SHORT $LN47@CGInventor@3
  00938	3a c1		 cmp	 al, cl
  0093a	0f 84 38 01 00
	00		 je	 $LN73@CGInventor@3
$LN47@CGInventor@3:
  00940	84 c9		 test	 cl, cl
  00942	75 2f		 jne	 SHORT $LN43@CGInventor@3
  00944	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00947	3c 0b		 cmp	 al, 11			; 0000000bH
  00949	0f 84 29 01 00
	00		 je	 $LN73@CGInventor@3
  0094f	84 c9		 test	 cl, cl
  00951	75 20		 jne	 SHORT $LN43@CGInventor@3
  00953	3c 0c		 cmp	 al, 12			; 0000000cH
  00955	0f 84 1d 01 00
	00		 je	 $LN73@CGInventor@3
  0095b	84 c9		 test	 cl, cl
  0095d	75 14		 jne	 SHORT $LN43@CGInventor@3
  0095f	3c 0d		 cmp	 al, 13			; 0000000dH
  00961	0f 84 11 01 00
	00		 je	 $LN73@CGInventor@3
  00967	84 c9		 test	 cl, cl
  00969	75 08		 jne	 SHORT $LN43@CGInventor@3
  0096b	3c 0e		 cmp	 al, 14			; 0000000eH
  0096d	0f 84 05 01 00
	00		 je	 $LN73@CGInventor@3
$LN43@CGInventor@3:
  00973	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00976	75 0b		 jne	 SHORT $LN42@CGInventor@3
  00978	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0097b	84 c0		 test	 al, al
  0097d	0f 84 f5 00 00
	00		 je	 $LN73@CGInventor@3
$LN42@CGInventor@3:
  00983	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  00986	75 0b		 jne	 SHORT $LN41@CGInventor@3
  00988	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0098b	84 c0		 test	 al, al
  0098d	0f 84 e5 00 00
	00		 je	 $LN73@CGInventor@3
$LN41@CGInventor@3:
  00993	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  00996	75 0b		 jne	 SHORT $LN40@CGInventor@3
  00998	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0099b	84 c0		 test	 al, al
  0099d	0f 84 d5 00 00
	00		 je	 $LN73@CGInventor@3
$LN40@CGInventor@3:
  009a3	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  009a6	75 0b		 jne	 SHORT $LN39@CGInventor@3
  009a8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  009ab	84 c0		 test	 al, al
  009ad	0f 84 c5 00 00
	00		 je	 $LN73@CGInventor@3
$LN39@CGInventor@3:
  009b3	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  009b6	75 0b		 jne	 SHORT $LN38@CGInventor@3
  009b8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  009bb	3a c1		 cmp	 al, cl
  009bd	0f 84 b5 00 00
	00		 je	 $LN73@CGInventor@3
$LN38@CGInventor@3:
  009c3	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  009c6	75 0b		 jne	 SHORT $LN37@CGInventor@3
  009c8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  009cb	3a c1		 cmp	 al, cl
  009cd	0f 84 a5 00 00
	00		 je	 $LN73@CGInventor@3
$LN37@CGInventor@3:
  009d3	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  009d6	75 0b		 jne	 SHORT $LN36@CGInventor@3
  009d8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  009db	3a c1		 cmp	 al, cl
  009dd	0f 84 95 00 00
	00		 je	 $LN73@CGInventor@3
$LN36@CGInventor@3:
  009e3	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  009e6	75 0b		 jne	 SHORT $LN35@CGInventor@3
  009e8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  009eb	3a c1		 cmp	 al, cl
  009ed	0f 84 85 00 00
	00		 je	 $LN73@CGInventor@3
$LN35@CGInventor@3:
  009f3	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  009f6	75 07		 jne	 SHORT $LN34@CGInventor@3
  009f8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  009fb	84 c0		 test	 al, al
  009fd	74 79		 je	 SHORT $LN73@CGInventor@3
$LN34@CGInventor@3:
  009ff	80 f9 10	 cmp	 cl, 16			; 00000010H
  00a02	75 07		 jne	 SHORT $LN33@CGInventor@3
  00a04	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a07	84 c0		 test	 al, al
  00a09	74 6d		 je	 SHORT $LN73@CGInventor@3
$LN33@CGInventor@3:
  00a0b	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  00a0e	75 07		 jne	 SHORT $LN32@CGInventor@3
  00a10	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a13	3a c1		 cmp	 al, cl
  00a15	74 61		 je	 SHORT $LN73@CGInventor@3
$LN32@CGInventor@3:
  00a17	80 f9 10	 cmp	 cl, 16			; 00000010H
  00a1a	75 07		 jne	 SHORT $LN31@CGInventor@3
  00a1c	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a1f	3a c1		 cmp	 al, cl
  00a21	74 55		 je	 SHORT $LN73@CGInventor@3
$LN31@CGInventor@3:
  00a23	84 c9		 test	 cl, cl
  00a25	75 0f		 jne	 SHORT $LN29@CGInventor@3
  00a27	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a2a	3c 0f		 cmp	 al, 15			; 0000000fH
  00a2c	74 4a		 je	 SHORT $LN73@CGInventor@3
  00a2e	84 c9		 test	 cl, cl
  00a30	75 04		 jne	 SHORT $LN29@CGInventor@3
  00a32	3c 10		 cmp	 al, 16			; 00000010H
  00a34	74 42		 je	 SHORT $LN73@CGInventor@3
$LN29@CGInventor@3:
  00a36	80 f9 11	 cmp	 cl, 17			; 00000011H
  00a39	75 0f		 jne	 SHORT $LN27@CGInventor@3
  00a3b	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a3e	84 c0		 test	 al, al
  00a40	74 36		 je	 SHORT $LN73@CGInventor@3
  00a42	3a c9		 cmp	 cl, cl
  00a44	75 04		 jne	 SHORT $LN27@CGInventor@3
  00a46	3a c1		 cmp	 al, cl
  00a48	74 2e		 je	 SHORT $LN73@CGInventor@3
$LN27@CGInventor@3:
  00a4a	84 c9		 test	 cl, cl
  00a4c	75 07		 jne	 SHORT $LN26@CGInventor@3
  00a4e	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a51	3c 11		 cmp	 al, 17			; 00000011H
  00a53	74 23		 je	 SHORT $LN73@CGInventor@3
$LN26@CGInventor@3:
  00a55	80 f9 03	 cmp	 cl, 3
  00a58	0f 85 4a 03 00
	00		 jne	 $LN74@CGInventor@3
  00a5e	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a61	84 c0		 test	 al, al
  00a63	74 13		 je	 SHORT $LN73@CGInventor@3
  00a65	3a c9		 cmp	 cl, cl
  00a67	0f 85 3b 03 00
	00		 jne	 $LN74@CGInventor@3
  00a6d	0f b6 c0	 movzx	 eax, al
  00a70	3a c1		 cmp	 al, cl
  00a72	0f 85 30 03 00
	00		 jne	 $LN74@CGInventor@3
$LN73@CGInventor@3:

; 5016 : 	{
; 5017 : 		BOOL DurSSend;
; 5018 : 		BOOL DurTSend;
; 5019 : 
; 5020 : 		result = gObjInventoryMoveItem(aIndex, source, target, DurSSend, DurTSend, lpMsg->sFlag, lpMsg->tFlag, (LPBYTE)&ItemInfo);

  00a78	8b bd ec fe ff
	ff		 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  00a7e	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  00a81	52		 push	 edx
  00a82	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _target$[ebp]
  00a88	50		 push	 eax
  00a89	51		 push	 ecx
  00a8a	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _DurTSend$218962[ebp]
  00a90	50		 push	 eax
  00a91	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _source$[ebp]
  00a97	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _DurSSend$218961[ebp]
  00a9d	51		 push	 ecx
  00a9e	52		 push	 edx
  00a9f	50		 push	 eax
  00aa0	57		 push	 edi
  00aa1	e8 00 00 00 00	 call	 ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ; gObjInventoryMoveItem

; 5021 : 		::GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  00aa6	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _target$[ebp]
  00aac	8a d8		 mov	 bl, al
  00aae	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00ab1	51		 push	 ecx
  00ab2	88 9d d8 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], bl
  00ab8	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _result$[ebp]
  00abe	52		 push	 edx
  00abf	50		 push	 eax
  00ac0	57		 push	 edi
  00ac1	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00ac6	83 c4 30	 add	 esp, 48			; 00000030H

; 5022 : 
; 5023 : 		if ( DurSSend != FALSE )

  00ac9	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR _DurSSend$218961[ebp], 0
  00ad0	74 5e		 je	 SHORT $LN146@CGInventor@3

; 5024 : 			::GCItemDurSend(aIndex, source, (BYTE)lpObj->pInventory[source].m_Durability, FALSE);

  00ad2	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _source$[ebp]
  00ad8	d9 bd ea fe ff
	ff		 fnstcw	 WORD PTR tv1465[ebp]
  00ade	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ae4	8b 80 c0 11 00
	00		 mov	 eax, DWORD PTR [eax+4544]
  00aea	8b d1		 mov	 edx, ecx
  00aec	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00af2	6a 00		 push	 0
  00af4	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  00af8	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv1465[ebp]
  00aff	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00b04	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv1462[ebp], eax
  00b0a	d9 ad dc fe ff
	ff		 fldcw	 WORD PTR tv1462[ebp]
  00b10	db 9d dc fe ff
	ff		 fistp	 DWORD PTR tv1460[ebp]
  00b16	8a 95 dc fe ff
	ff		 mov	 dl, BYTE PTR tv1460[ebp]
  00b1c	0f b6 c2	 movzx	 eax, dl
  00b1f	50		 push	 eax
  00b20	d9 ad ea fe ff
	ff		 fldcw	 WORD PTR tv1465[ebp]
  00b26	51		 push	 ecx
  00b27	57		 push	 edi
  00b28	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00b2d	83 c4 10	 add	 esp, 16			; 00000010H
$LN146@CGInventor@3:

; 5025 : 
; 5026 : 		if ( DurTSend != FALSE )

  00b30	83 bd d0 fe ff
	ff 00		 cmp	 DWORD PTR _DurTSend$218962[ebp], 0
  00b37	74 5e		 je	 SHORT $LN23@CGInventor@3

; 5027 : 			::GCItemDurSend(aIndex, target, (BYTE)lpObj->pInventory[target].m_Durability, FALSE);

  00b39	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _target$[ebp]
  00b3f	d9 bd ea fe ff
	ff		 fnstcw	 WORD PTR tv1455[ebp]
  00b45	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b4b	8b 80 c0 11 00
	00		 mov	 eax, DWORD PTR [eax+4544]
  00b51	8b d1		 mov	 edx, ecx
  00b53	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00b59	6a 00		 push	 0
  00b5b	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  00b5f	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv1455[ebp]
  00b66	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00b6b	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv1452[ebp], eax
  00b71	d9 ad dc fe ff
	ff		 fldcw	 WORD PTR tv1452[ebp]
  00b77	db 9d dc fe ff
	ff		 fistp	 DWORD PTR tv1450[ebp]
  00b7d	8a 95 dc fe ff
	ff		 mov	 dl, BYTE PTR tv1450[ebp]
  00b83	0f b6 c2	 movzx	 eax, dl
  00b86	50		 push	 eax
  00b87	d9 ad ea fe ff
	ff		 fldcw	 WORD PTR tv1455[ebp]
  00b8d	51		 push	 ecx
  00b8e	57		 push	 edi
  00b8f	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00b94	83 c4 10	 add	 esp, 16			; 00000010H
$LN23@CGInventor@3:

; 5028 : 
; 5029 : 		int type = lpMsg->sItemInfo[0] + ((lpMsg->sItemInfo[3]&0x80)*2)+((lpMsg->sItemInfo[5]&0xF0)<<5);

  00b97	0f b6 4e 0a	 movzx	 ecx, BYTE PTR [esi+10]
  00b9b	0f b6 56 08	 movzx	 edx, BYTE PTR [esi+8]
  00b9f	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00ba3	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00ba9	c1 e1 04	 shl	 ecx, 4
  00bac	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00bb2	03 ca		 add	 ecx, edx
  00bb4	8d 3c 48	 lea	 edi, DWORD PTR [eax+ecx*2]

; 5030 : 
; 5031 : 		if( type == ITEMGET(14, 29) ||
; 5032 : 			type == ITEMGET(12, 144) ||
; 5033 : 			type == ITEMGET(12, 146) )

  00bb7	81 ff 1d 1c 00
	00		 cmp	 edi, 7197		; 00001c1dH
  00bbd	74 10		 je	 SHORT $LN21@CGInventor@3
  00bbf	81 ff 90 18 00
	00		 cmp	 edi, 6288		; 00001890H
  00bc5	74 08		 je	 SHORT $LN21@CGInventor@3
  00bc7	81 ff 92 18 00
	00		 cmp	 edi, 6290		; 00001892H
  00bcd	75 4b		 jne	 SHORT $LN147@CGInventor@3
$LN21@CGInventor@3:

; 5034 : 		{
; 5035 : 			if( lpObj->pInventory[target].m_Durability == 0.0f )

  00bcf	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _target$[ebp]
  00bd5	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bdb	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00be1	8b 82 c0 11 00
	00		 mov	 eax, DWORD PTR [edx+4544]
  00be7	d9 44 08 24	 fld	 DWORD PTR [eax+ecx+36]
  00beb	d9 ee		 fldz
  00bed	da e9		 fucompp
  00bef	df e0		 fnstsw	 ax
  00bf1	f6 c4 44	 test	 ah, 68			; 00000044H
  00bf4	7a 24		 jp	 SHORT $LN147@CGInventor@3

; 5036 : 			{
; 5037 : 				if( lpMsg->sFlag == 0 &&
; 5038 : 					lpMsg->tFlag == 0 )

  00bf6	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00bfa	75 1e		 jne	 SHORT $LN147@CGInventor@3
  00bfc	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00c00	75 18		 jne	 SHORT $LN147@CGInventor@3

; 5039 : 				{
; 5040 : 					::GCInventoryItemDeleteSend(aIndex, target, FALSE);

  00c02	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _target$[ebp]
  00c08	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00c0e	6a 00		 push	 0
  00c10	51		 push	 ecx
  00c11	52		 push	 edx
  00c12	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00c17	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN147@CGInventor@3:

; 5041 : 				}
; 5042 : 			}
; 5043 : 		}
; 5044 : 
; 5045 : 		if( type == ITEMGET(14,110) || type == ITEMGET(14,101) )

  00c1a	81 ff 6e 1c 00
	00		 cmp	 edi, 7278		; 00001c6eH
  00c20	74 08		 je	 SHORT $LN17@CGInventor@3
  00c22	81 ff 65 1c 00
	00		 cmp	 edi, 7269		; 00001c65H
  00c28	75 4b		 jne	 SHORT $LN15@CGInventor@3
$LN17@CGInventor@3:

; 5046 : 		{
; 5047 : 			if( lpObj->pInventory[target].m_Durability == 0.0f )

  00c2a	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _target$[ebp]
  00c30	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c36	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00c3c	8b 91 c0 11 00
	00		 mov	 edx, DWORD PTR [ecx+4544]
  00c42	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  00c46	d9 ee		 fldz
  00c48	da e9		 fucompp
  00c4a	df e0		 fnstsw	 ax
  00c4c	f6 c4 44	 test	 ah, 68			; 00000044H
  00c4f	7a 24		 jp	 SHORT $LN15@CGInventor@3

; 5048 : 			{
; 5049 : 				if( lpMsg->sFlag == 0 &&
; 5050 : 					lpMsg->tFlag == 0 )

  00c51	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00c55	75 1e		 jne	 SHORT $LN15@CGInventor@3
  00c57	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00c5b	75 18		 jne	 SHORT $LN15@CGInventor@3

; 5051 : 				{
; 5052 : 					::GCInventoryItemDeleteSend(aIndex, target, FALSE);

  00c5d	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _target$[ebp]
  00c63	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00c69	6a 00		 push	 0
  00c6b	50		 push	 eax
  00c6c	51		 push	 ecx
  00c6d	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00c72	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@CGInventor@3:

; 5053 : 				}
; 5054 : 			}
; 5055 : 		}
; 5056 : 
; 5057 : 		if( type == ITEMGET(13, 135) )

  00c75	81 ff 87 1a 00
	00		 cmp	 edi, 6791		; 00001a87H
  00c7b	75 4b		 jne	 SHORT $LN12@CGInventor@3

; 5058 : 		{
; 5059 : 			if( lpObj->pInventory[target].m_Durability == 0.0f )

  00c7d	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _target$[ebp]
  00c83	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c89	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00c8f	8b 88 c0 11 00
	00		 mov	 ecx, DWORD PTR [eax+4544]
  00c95	d9 44 11 24	 fld	 DWORD PTR [ecx+edx+36]
  00c99	d9 ee		 fldz
  00c9b	da e9		 fucompp
  00c9d	df e0		 fnstsw	 ax
  00c9f	f6 c4 44	 test	 ah, 68			; 00000044H
  00ca2	7a 24		 jp	 SHORT $LN12@CGInventor@3

; 5060 : 			{
; 5061 : 				if( lpMsg->sFlag == 0 &&
; 5062 : 					lpMsg->tFlag == 0 )

  00ca4	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00ca8	75 1e		 jne	 SHORT $LN12@CGInventor@3
  00caa	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00cae	75 18		 jne	 SHORT $LN12@CGInventor@3

; 5063 : 				{
; 5064 : 					::GCInventoryItemDeleteSend(aIndex, target, FALSE);

  00cb0	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _target$[ebp]
  00cb6	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00cbc	6a 00		 push	 0
  00cbe	52		 push	 edx
  00cbf	50		 push	 eax
  00cc0	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00cc5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@CGInventor@3:

; 5065 : 				}
; 5066 : 			}
; 5067 : 		}
; 5068 : 
; 5069 : 		if ( result != 0xFF && lpMsg->sFlag == 2 && lpMsg->tFlag == 0)

  00cc8	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00ccb	0f 84 4f 03 00
	00		 je	 $LN1@CGInventor@3
  00cd1	80 7e 03 02	 cmp	 BYTE PTR [esi+3], 2
  00cd5	0f 85 45 03 00
	00		 jne	 $LN1@CGInventor@3
  00cdb	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00cdf	0f 85 3b 03 00
	00		 jne	 $LN1@CGInventor@3

; 5070 : 		{
; 5071 : 			int money = ::GetWarehouseUsedHowMuch(lpObj->Level,lpObj->MasterLevel, lpObj->WarehousePW);

  00ce5	8b 9d e4 fe ff
	ff		 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00ceb	0f bf 8b 02 12
	00 00		 movsx	 ecx, WORD PTR [ebx+4610]
  00cf2	0f bf 93 a8 00
	00 00		 movsx	 edx, WORD PTR [ebx+168]
  00cf9	0f bf 83 96 00
	00 00		 movsx	 eax, WORD PTR [ebx+150]
  00d00	51		 push	 ecx
  00d01	52		 push	 edx
  00d02	50		 push	 eax
  00d03	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHHH@Z ; GetWarehouseUsedHowMuch

; 5072 : 
; 5073 : 			if ( (lpObj->Money - money) > 0 )

  00d08	8b bb cc 00 00
	00		 mov	 edi, DWORD PTR [ebx+204]
  00d0e	8b f0		 mov	 esi, eax
  00d10	8b c7		 mov	 eax, edi
  00d12	2b c6		 sub	 eax, esi
  00d14	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d17	85 c0		 test	 eax, eax
  00d19	7e 37		 jle	 SHORT $LN10@CGInventor@3

; 5074 : 			{
; 5075 : 				int iZen = lpObj->Money;
; 5076 : 				lpObj->Money -= money;
; 5077 : 				GCMoneySend(lpObj->m_Index, lpObj->Money);

  00d1b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00d1d	50		 push	 eax
  00d1e	51		 push	 ecx
  00d1f	89 83 cc 00 00
	00		 mov	 DWORD PTR [ebx+204], eax
  00d25	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 5078 : 
; 5079 : 				LogAdd("Pay WareHouse Money(In Inventory) : %d - %d = %d",
; 5080 : 					iZen, money, lpObj->Money);

  00d2a	8b 93 cc 00 00
	00		 mov	 edx, DWORD PTR [ebx+204]
  00d30	52		 push	 edx
  00d31	56		 push	 esi
  00d32	57		 push	 edi
  00d33	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@
  00d38	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00d3e	83 c4 18	 add	 esp, 24			; 00000018H
  00d41	5f		 pop	 edi
  00d42	5e		 pop	 esi
  00d43	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  00d44	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d47	33 cd		 xor	 ecx, ebp
  00d49	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d4e	8b e5		 mov	 esp, ebp
  00d50	5d		 pop	 ebp
  00d51	c3		 ret	 0
$LN10@CGInventor@3:

; 5081 : 			}
; 5082 : 			else if ( (lpObj->WarehouseMoney - money) > 0 )

  00d52	8b 8b 08 12 00
	00		 mov	 ecx, DWORD PTR [ebx+4616]
  00d58	8b c1		 mov	 eax, ecx
  00d5a	2b c6		 sub	 eax, esi
  00d5c	85 c0		 test	 eax, eax
  00d5e	0f 8e bc 02 00
	00		 jle	 $LN1@CGInventor@3

; 5083 : 			{
; 5084 : 				int iZen = lpObj->WarehouseMoney;
; 5085 : 				lpObj->WarehouseMoney -= money;
; 5086 : 	
; 5087 : 				LogAdd("Pay WareHouse Money(In WareHouse) : %d - %d = %d",
; 5088 : 					iZen, money, lpObj->WarehouseMoney);

  00d64	50		 push	 eax
  00d65	56		 push	 esi
  00d66	51		 push	 ecx
  00d67	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@
  00d6c	89 83 08 12 00
	00		 mov	 DWORD PTR [ebx+4616], eax
  00d72	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 5089 : 
; 5090 : 				GCWarehouseInventoryMoneySend(aIndex, 1, lpObj->Money, lpObj->WarehouseMoney);

  00d78	8b 83 08 12 00
	00		 mov	 eax, DWORD PTR [ebx+4616]
  00d7e	8b 8b cc 00 00
	00		 mov	 ecx, DWORD PTR [ebx+204]
  00d84	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00d8a	50		 push	 eax
  00d8b	51		 push	 ecx
  00d8c	6a 01		 push	 1
  00d8e	52		 push	 edx
  00d8f	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00d94	83 c4 20	 add	 esp, 32			; 00000020H
  00d97	5f		 pop	 edi
  00d98	5e		 pop	 esi
  00d99	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  00d9a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d9d	33 cd		 xor	 ecx, ebp
  00d9f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00da4	8b e5		 mov	 esp, ebp
  00da6	5d		 pop	 ebp
  00da7	c3		 ret	 0
$LN74@CGInventor@3:

; 5091 : 			}
; 5092 : 		}
; 5093 : 
; 5094 : 		return;
; 5095 : 	}
; 5096 : 
; 5097 : 	if ( lpMsg->sFlag == 1 && lpMsg->tFlag == 1 )

  00da8	80 f9 01	 cmp	 cl, 1
  00dab	0f 85 3c 01 00
	00		 jne	 $LN6@CGInventor@3
  00db1	38 5e 11	 cmp	 BYTE PTR [esi+17], bl
  00db4	75 4c		 jne	 SHORT $LN7@CGInventor@3

; 5098 : 	{
; 5099 : 		result = gObjTradeTradeMove(lpObj, source, target);

  00db6	8b b5 e0 fe ff
	ff		 mov	 esi, DWORD PTR _target$[ebp]
  00dbc	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _source$[ebp]
  00dc2	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00dc8	56		 push	 esi
  00dc9	50		 push	 eax
  00dca	51		 push	 ecx
  00dcb	e8 00 00 00 00	 call	 ?gObjTradeTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z ; gObjTradeTradeMove

; 5100 : 		GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  00dd0	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00dd6	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  00dd9	52		 push	 edx
  00dda	88 85 d8 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], al
  00de0	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _result$[ebp]
  00de6	56		 push	 esi
  00de7	50		 push	 eax
  00de8	51		 push	 ecx
  00de9	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00dee	83 c4 1c	 add	 esp, 28			; 0000001cH
  00df1	5f		 pop	 edi
  00df2	5e		 pop	 esi
  00df3	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  00df4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00df7	33 cd		 xor	 ecx, ebp
  00df9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00dfe	8b e5		 mov	 esp, ebp
  00e00	5d		 pop	 ebp
  00e01	c3		 ret	 0
$LN7@CGInventor@3:

; 5101 : 
; 5102 : 		return;
; 5103 : 	}
; 5104 : 
; 5105 : 	if ( lpMsg->sFlag == 1 && lpMsg->tFlag == 0 )

  00e02	80 f9 01	 cmp	 cl, 1
  00e05	0f 85 e2 00 00
	00		 jne	 $LN6@CGInventor@3
  00e0b	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00e0f	0f 85 d8 00 00
	00		 jne	 $LN6@CGInventor@3

; 5106 : 	{
; 5107 : 		result = gObjTradeInventoryMove(lpObj, source, target);

  00e15	8b bd e0 fe ff
	ff		 mov	 edi, DWORD PTR _target$[ebp]
  00e1b	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _source$[ebp]
  00e21	8b b5 e4 fe ff
	ff		 mov	 esi, DWORD PTR _lpObj$[ebp]
  00e27	57		 push	 edi
  00e28	52		 push	 edx
  00e29	56		 push	 esi
  00e2a	e8 00 00 00 00	 call	 ?gObjTradeInventoryMove@@YAEPAUOBJECTSTRUCT@@EE@Z ; gObjTradeInventoryMove
  00e2f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e32	88 85 d8 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], al

; 5108 : 
; 5109 : 		if ( result == 0xFF )

  00e38	3c ff		 cmp	 al, 255			; 000000ffH
  00e3a	0f 85 90 00 00
	00		 jne	 $LN5@CGInventor@3

; 5110 : 		{
; 5111 : 			GCItemMoveResultSend(aIndex, 0xFF, target, (LPBYTE)&ItemInfo);

  00e40	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00e43	50		 push	 eax
  00e44	57		 push	 edi
  00e45	8b bd ec fe ff
	ff		 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  00e4b	68 ff 00 00 00	 push	 255			; 000000ffH
  00e50	57		 push	 edi
  00e51	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 5112 : 			CGTradeCancelButtonRecv(aIndex);

  00e56	57		 push	 edi
  00e57	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv

; 5120 : 		{
; 5121 : 			lpObj->m_IfState.state = 0;

  00e5c	83 a6 b8 11 00
	00 c3		 and	 DWORD PTR [esi+4536], -61 ; ffffffc3H
  00e63	83 c4 14	 add	 esp, 20			; 00000014H

; 5122 : 			GCItemListSend(aIndex);

  00e66	57		 push	 edi
  00e67	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  00e6c	83 c4 04	 add	 esp, 4
$LN3@CGInventor@3:

; 5123 : 		}
; 5124 : 		
; 5125 : 		if ( lpObj->TargetNumber >= 0 )

  00e6f	66 83 be 38 06
	00 00 00	 cmp	 WORD PTR [esi+1592], 0
  00e77	0f 8c a3 01 00
	00		 jl	 $LN1@CGInventor@3

; 5126 : 		{
; 5127 : 			lpObj->TradeOk = false;
; 5128 : 			gObj[gObj[aIndex].TargetNumber].TradeOk = false;

  00e7d	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  00e83	c6 86 f4 11 00
	00 00		 mov	 BYTE PTR [esi+4596], 0
  00e8a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e8f	0f bf 94 01 38
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1592]
  00e97	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  00e9d	c6 84 02 f4 11
	00 00 00	 mov	 BYTE PTR [edx+eax+4596], 0

; 5129 : 			GCTradeOkButtonSend(lpObj->TargetNumber, 2);

  00ea5	0f bf 86 38 06
	00 00		 movsx	 eax, WORD PTR [esi+1592]
  00eac	6a 02		 push	 2
  00eae	50		 push	 eax
  00eaf	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 5130 : 			GCTradeOkButtonSend(aIndex, 0);

  00eb4	6a 00		 push	 0
  00eb6	57		 push	 edi
  00eb7	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend
  00ebc	83 c4 10	 add	 esp, 16			; 00000010H
  00ebf	5f		 pop	 edi
  00ec0	5e		 pop	 esi
  00ec1	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  00ec2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ec5	33 cd		 xor	 ecx, ebp
  00ec7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ecc	8b e5		 mov	 esp, ebp
  00ece	5d		 pop	 ebp
  00ecf	c3		 ret	 0
$LN5@CGInventor@3:

; 5113 : 		}
; 5114 : 		else
; 5115 : 		{
; 5116 : 			GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  00ed0	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _result$[ebp]
  00ed6	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00ed9	51		 push	 ecx
  00eda	57		 push	 edi
  00edb	8b bd ec fe ff
	ff		 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  00ee1	52		 push	 edx
  00ee2	57		 push	 edi
  00ee3	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00ee8	83 c4 10	 add	 esp, 16			; 00000010H

; 5117 : 		}
; 5118 : 
; 5119 : 		if ( result == 0xFF )

  00eeb	eb 82		 jmp	 SHORT $LN3@CGInventor@3
$LN6@CGInventor@3:

; 5131 : 		}
; 5132 : 
; 5133 : 		return;
; 5134 : 	}
; 5135 : 
; 5136 : 	if ( lpMsg->sFlag == 0 && lpMsg->tFlag == 1 )

  00eed	84 c9		 test	 cl, cl
  00eef	0f 85 2b 01 00
	00		 jne	 $LN1@CGInventor@3
  00ef5	38 5e 11	 cmp	 BYTE PTR [esi+17], bl
  00ef8	0f 85 22 01 00
	00		 jne	 $LN1@CGInventor@3

; 5137 : 	{
; 5138 : 		result = gObjInventoryTradeMove(lpObj, source, target);

  00efe	8b b5 e0 fe ff
	ff		 mov	 esi, DWORD PTR _target$[ebp]
  00f04	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _source$[ebp]
  00f0a	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  00f10	56		 push	 esi
  00f11	51		 push	 ecx
  00f12	52		 push	 edx
  00f13	e8 00 00 00 00	 call	 ?gObjInventoryTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z ; gObjInventoryTradeMove

; 5139 : 		GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  00f18	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00f1e	88 85 d8 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], al
  00f24	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _result$[ebp]
  00f2a	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00f2d	50		 push	 eax
  00f2e	56		 push	 esi
  00f2f	51		 push	 ecx
  00f30	52		 push	 edx
  00f31	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00f36	83 c4 1c	 add	 esp, 28			; 0000001cH
  00f39	5f		 pop	 edi
  00f3a	5e		 pop	 esi
  00f3b	5b		 pop	 ebx

; 5140 : 	}
; 5141 : }

  00f3c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f3f	33 cd		 xor	 ecx, ebp
  00f41	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f46	8b e5		 mov	 esp, ebp
  00f48	5d		 pop	 ebp
  00f49	c3		 ret	 0
$LN85@CGInventor@3:

; 4898 : 		{
; 4899 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00f4a	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00f50	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00f53	50		 push	 eax
  00f54	6a 00		 push	 0
  00f56	68 ff 00 00 00	 push	 255			; 000000ffH
  00f5b	51		 push	 ecx
  00f5c	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 4900 : 			LogAdd("[%s][%s] error-L1 : used not Warehouse", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00f61	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f66	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  00f6c	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  00f70	52		 push	 edx
  00f71	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  00f75	50		 push	 eax
  00f76	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@

; 4901 : 
; 4902 : 			return;

  00f7b	e9 97 00 00 00	 jmp	 $LN160@CGInventor@3
$LN90@CGInventor@3:

; 4879 : 		{
; 4880 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00f80	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00f86	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00f89	51		 push	 ecx
  00f8a	6a 00		 push	 0
  00f8c	68 ff 00 00 00	 push	 255			; 000000ffH
  00f91	52		 push	 edx
  00f92	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 4881 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 4882 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  00f97	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f9c	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  00fa2	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  00fa6	52		 push	 edx
  00fa7	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  00fab	50		 push	 eax
  00fac	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@

; 4883 : 			return;

  00fb1	eb 64		 jmp	 SHORT $LN160@CGInventor@3
$LN115@CGInventor@3:

; 4775 : 		{
; 4776 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00fb3	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00fb9	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00fbc	51		 push	 ecx
  00fbd	6a 00		 push	 0
  00fbf	68 ff 00 00 00	 push	 255			; 000000ffH
  00fc4	52		 push	 edx
  00fc5	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 4777 : 			LogAdd("[%s][%s] error-L1 : used not DarkTrainerBox", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00fca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fcf	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  00fd5	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  00fd9	52		 push	 edx
  00fda	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  00fde	50		 push	 eax
  00fdf	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@

; 4778 : 
; 4779 : 			return;

  00fe4	eb 31		 jmp	 SHORT $LN160@CGInventor@3
$LN120@CGInventor@3:

; 4756 : 		{
; 4757 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00fe6	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00fec	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00fef	51		 push	 ecx
  00ff0	6a 00		 push	 0
  00ff2	68 ff 00 00 00	 push	 255			; 000000ffH
  00ff7	52		 push	 edx
  00ff8	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 4758 : 			LogAdd("[%s][%s] error-L1 : used not Chaosbox", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00ffd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01002	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1344[ebp]
  01008	8d 54 01 5d	 lea	 edx, DWORD PTR [ecx+eax+93]
  0100c	52		 push	 edx
  0100d	8d 44 01 52	 lea	 eax, DWORD PTR [ecx+eax+82]
  01011	50		 push	 eax
  01012	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@
$LN160@CGInventor@3:
  01017	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0101d	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@CGInventor@3:

; 5140 : 	}
; 5141 : }

  01020	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01023	5f		 pop	 edi
  01024	5e		 pop	 esi
  01025	33 cd		 xor	 ecx, ebp
  01027	5b		 pop	 ebx
  01028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0102d	8b e5		 mov	 esp, ebp
  0102f	5d		 pop	 ebp
  01030	c3		 ret	 0
?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ENDP ; CGInventoryItemMove
_TEXT	ENDS
PUBLIC	?GCManagerGuildWarSet@@YAXPAD0H@Z		; GCManagerGuildWarSet
; Function compile flags: /Ogtp
;	COMDAT ?GCManagerGuildWarSet@@YAXPAD0H@Z
_TEXT	SEGMENT
_lpNode$ = -4						; size = 4
_GuildName1$ = 8					; size = 4
_GuildName2$ = 12					; size = 4
_type$ = 16						; size = 4
?GCManagerGuildWarSet@@YAXPAD0H@Z PROC			; GCManagerGuildWarSet, COMDAT

; 9717 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 9718 : 	_GUILD_INFO_STRUCT * lpNode = Guild.SearchGuild(GuildName1);

  00004	8b 45 08	 mov	 eax, DWORD PTR _GuildName1$[ebp]
  00007	50		 push	 eax
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  0000d	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00012	8b c8		 mov	 ecx, eax
  00014	89 4d fc	 mov	 DWORD PTR _lpNode$[ebp], ecx

; 9719 : 
; 9720 : 	if ( lpNode == NULL )

  00017	85 c9		 test	 ecx, ecx
  00019	0f 84 7c 00 00
	00		 je	 $LN1@GCManagerG@2

; 9721 : 	{
; 9722 : 		return;
; 9723 : 	}
; 9724 : 
; 9725 : 	int n=0;

  0001f	56		 push	 esi
  00020	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	57		 push	 edi
  00027	33 ff		 xor	 edi, edi
  00029	83 c6 5d	 add	 esi, 93			; 0000005dH
  0002c	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  0002f	53		 push	 ebx
$LL9@GCManagerG@2:

; 9726 : 	int warmaster = -1;
; 9727 : 
; 9728 : 	while ( true )
; 9729 : 	{
; 9730 : 		if ( gObj[n].Type == OBJ_USER )

  00030	80 7e f3 01	 cmp	 BYTE PTR [esi-13], 1
  00034	75 3b		 jne	 SHORT $LN4@GCManagerG@2

; 9731 : 		{
; 9732 : 			if ( gObj[n].Connected > PLAYER_LOGGED )

  00036	39 46 a7	 cmp	 DWORD PTR [esi-89], eax
  00039	7e 36		 jle	 SHORT $LN4@GCManagerG@2

; 9733 : 			{
; 9734 : 				if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  0003b	8a 1e		 mov	 bl, BYTE PTR [esi]
  0003d	3a 59 2f	 cmp	 bl, BYTE PTR [ecx+47]
  00040	8d 51 2f	 lea	 edx, DWORD PTR [ecx+47]
  00043	75 2c		 jne	 SHORT $LN4@GCManagerG@2

; 9735 : 				{
; 9736 : 					if ( strcmp(gObj[n].Name, lpNode->Names[0]) == 0 )

  00045	8b ce		 mov	 ecx, esi
$LL15@GCManagerG@2:
  00047	8a 19		 mov	 bl, BYTE PTR [ecx]
  00049	3a 1a		 cmp	 bl, BYTE PTR [edx]
  0004b	75 18		 jne	 SHORT $LN16@GCManagerG@2
  0004d	84 db		 test	 bl, bl
  0004f	74 10		 je	 SHORT $LN17@GCManagerG@2
  00051	8a 59 01	 mov	 bl, BYTE PTR [ecx+1]
  00054	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  00057	75 0c		 jne	 SHORT $LN16@GCManagerG@2
  00059	03 c8		 add	 ecx, eax
  0005b	03 d0		 add	 edx, eax
  0005d	84 db		 test	 bl, bl
  0005f	75 e6		 jne	 SHORT $LL15@GCManagerG@2
$LN17@GCManagerG@2:
  00061	33 c9		 xor	 ecx, ecx
  00063	eb 05		 jmp	 SHORT $LN18@GCManagerG@2
$LN16@GCManagerG@2:
  00065	1b c9		 sbb	 ecx, ecx
  00067	83 d9 ff	 sbb	 ecx, -1
$LN18@GCManagerG@2:
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 14		 je	 SHORT $LN14@GCManagerG@2
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _lpNode$[ebp]
$LN4@GCManagerG@2:

; 9737 : 					{
; 9738 : 						warmaster = n;
; 9739 : 						break;
; 9740 : 					}
; 9741 : 				}
; 9742 : 			}
; 9743 : 		}
; 9744 : 
; 9745 : 		if ( n < OBJMAX-1 )

  00071	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00077	7d 1f		 jge	 SHORT $LN21@GCManagerG@2

; 9746 : 		{
; 9747 : 			n++;

  00079	47		 inc	 edi
  0007a	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H

; 9748 : 		}
; 9749 : 		else
; 9750 : 		{
; 9751 : 			break;
; 9752 : 		}
; 9753 : 	}

  00080	eb ae		 jmp	 SHORT $LL9@GCManagerG@2
$LN14@GCManagerG@2:

; 9754 : 
; 9755 : 	if ( warmaster >= 1 )

  00082	83 ff 01	 cmp	 edi, 1
  00085	7c 11		 jl	 SHORT $LN21@GCManagerG@2

; 9756 : 	{
; 9757 : 		::GCGuildWarRequestResult(GuildName2, warmaster, type);

  00087	8b 4d 10	 mov	 ecx, DWORD PTR _type$[ebp]
  0008a	8b 55 0c	 mov	 edx, DWORD PTR _GuildName2$[ebp]
  0008d	51		 push	 ecx
  0008e	57		 push	 edi
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ?GCGuildWarRequestResult@@YAXPADHH@Z ; GCGuildWarRequestResult
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@GCManagerG@2:
  00098	5b		 pop	 ebx
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
$LN1@GCManagerG@2:

; 9758 : 	}
; 9759 : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
?GCManagerGuildWarSet@@YAXPAD0H@Z ENDP			; GCManagerGuildWarSet
_TEXT	ENDS
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1641 : 		{	// look for [_Ptr, <null>) beginnng at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1642 : 		_DEBUG_POINTER(_Ptr);
; 1643 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	57		 push	 edi
  0000a	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000d	8d 49 00	 npad	 3
$LL5@find@2:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL5@find@2
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  0001d	50		 push	 eax
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi

; 1644 : 		}

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1987 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1988 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 22		 je	 SHORT $LN9@Tidy

; 1989 : 			;
; 1990 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 1c		 jb	 SHORT $LN9@Tidy

; 1991 : 			{	// copy any leftovers to small buffer and deallocate
; 1992 : 			_Elem *_Ptr = this->_Bx._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 1993 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN7@Tidy

; 1994 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@Tidy:

; 1995 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

  00028	53		 push	 ebx
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4
  00031	5b		 pop	 ebx
$LN9@Tidy:

; 1996 : 			}
; 1997 : 		this->_Myres = this->_BUF_SIZE - 1;
; 1998 : 		_Eos(_Newsize);

  00032	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00035	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0003c	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 1999 : 		}

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
$T236547 = -40						; size = 12
__Newres$ = -28						; size = 4
$T236524 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1918 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi

; 1919 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f0		 mov	 esi, eax
  00035	83 ce 0f	 or	 esi, 15			; 0000000fH

; 1920 : 		if (max_size() < _Newres)

  00038	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN9@Copy

; 1921 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f0		 mov	 esi, eax
  0003f	eb 27		 jmp	 SHORT $LN39@Copy
$LN9@Copy:

; 1922 : 		else if (this->_Myres / 2 <= _Newres / 3)

  00041	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e6		 mul	 esi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN39@Copy

; 1923 : 			;
; 1924 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005a	2b c1		 sub	 eax, ecx

; 1925 : 			_Newres = this->_Myres
; 1926 : 				+ this->_Myres / 2;	// grow exponentially if possible

  0005c	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN39@Copy

; 1927 : 		else
; 1928 : 			_Newres = max_size();	// settle for max_size()

  00063	be fe ff ff ff	 mov	 esi, -2			; fffffffeH
$LN39@Copy:

; 1929 : 
; 1930 : 		_Elem *_Ptr;
; 1931 : 		_TRY_BEGIN

  00068	33 c0		 xor	 eax, eax

; 1932 : 			_Ptr = this->_Alval.allocate(_Newres + 1);

  0006a	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0006d	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  00070	3b c8		 cmp	 ecx, eax
  00072	76 12		 jbe	 SHORT $LN47@Copy
  00074	83 f9 ff	 cmp	 ecx, -1
  00077	77 12		 ja	 SHORT $LN46@Copy
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007f	83 c4 04	 add	 esp, 4
  00082	85 c0		 test	 eax, eax
  00084	74 05		 je	 SHORT $LN46@Copy
$LN47@Copy:
  00086	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  00089	eb 51		 jmp	 SHORT $LN19@Copy
$LN46@Copy:
  0008b	8d 4d e8	 lea	 ecx, DWORD PTR $T236524[ebp]
  0008e	51		 push	 ecx
  0008f	8d 4d d8	 lea	 ecx, DWORD PTR $T236547[ebp]
  00092	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T236524[ebp], 0
  00099	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0009e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000a3	8d 55 d8	 lea	 edx, DWORD PTR $T236547[ebp]
  000a6	52		 push	 edx
  000a7	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T236547[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 1933 : 		_CATCH_ALL
; 1934 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000b3	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 1935 : 			_TRY_BEGIN
; 1936 : 				_Ptr = this->_Alval.allocate(_Newres + 1);

  000b6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	89 45 e4	 mov	 DWORD PTR __Newres$[ebp], eax
  000bc	40		 inc	 eax
  000bd	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000c0	50		 push	 eax
  000c1	83 c1 18	 add	 ecx, 24			; 00000018H
  000c4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000c8	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  000cd	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1940 : 			_CATCH_END
; 1941 : 		_CATCH_END

  000d0	b8 00 00 00 00	 mov	 eax, $LN107@Copy
  000d5	c3		 ret	 0
$LN107@Copy:
  000d6	8b 7d ec	 mov	 edi, DWORD PTR _this$[ebp]
  000d9	8b 75 e4	 mov	 esi, DWORD PTR __Newres$[ebp]
$LN19@Copy:

; 1942 : 
; 1943 : 		if (0 < _Oldlen)

  000dc	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000df	85 db		 test	 ebx, ebx
  000e1	74 1a		 je	 SHORT $LN78@Copy

; 1944 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  000e3	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  000e7	72 04		 jb	 SHORT $LN76@Copy
  000e9	8b 07		 mov	 eax, DWORD PTR [edi]
  000eb	eb 02		 jmp	 SHORT $LN77@Copy
$LN76@Copy:
  000ed	8b c7		 mov	 eax, edi
$LN77@Copy:
  000ef	53		 push	 ebx
  000f0	50		 push	 eax
  000f1	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _memcpy
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN78@Copy:

; 1945 : 		_Tidy(true);

  000fd	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00101	72 0b		 jb	 SHORT $LN88@Copy
  00103	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0010b	83 c4 04	 add	 esp, 4
$LN88@Copy:

; 1946 : 		this->_Bx._Ptr = _Ptr;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00111	c6 07 00	 mov	 BYTE PTR [edi], 0
  00114	89 07		 mov	 DWORD PTR [edi], eax

; 1947 : 		this->_Myres = _Newres;

  00116	89 77 14	 mov	 DWORD PTR [edi+20], esi

; 1948 : 		_Eos(_Oldlen);

  00119	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
  0011c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0011f	72 02		 jb	 SHORT $LN102@Copy
  00121	8b f8		 mov	 edi, eax
$LN102@Copy:
  00123	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 1949 : 		}

  00127	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0012a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00131	59		 pop	 ecx
  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	5b		 pop	 ebx
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 1937 : 			_CATCH_ALL
; 1938 : 			_Tidy(true);	// failed again, discard storage and reraise

  0013b	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0013e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00142	72 0b		 jb	 SHORT $LN64@Copy
  00144	8b 16		 mov	 edx, DWORD PTR [esi]
  00146	52		 push	 edx
  00147	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014c	83 c4 04	 add	 esp, 4
$LN64@Copy:

; 1939 : 			_RERAISE;

  0014f	6a 00		 push	 0
  00151	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00158	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0015f	6a 00		 push	 0
  00161	c6 06 00	 mov	 BYTE PTR [esi], 0
  00164	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN113@Copy:
$LN111@Copy:
  00169	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 752  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 753  : 		_Tidy(true);

  00003	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN11@basic_stri
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN11@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00022	c6 06 00	 mov	 BYTE PTR [esi], 0
  00025	5e		 pop	 esi

; 754  : 		}

  00026	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtp
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1958 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1959 : 		if (max_size() < _Newsize)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  0000d	76 0a		 jbe	 SHORT $LN6@Grow

; 1960 : 			_Xlen();	// result too long

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN49@Grow:
$LN6@Grow:

; 1961 : 		if (this->_Myres < _Newsize)

  00019	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0001c	3b c3		 cmp	 eax, ebx
  0001e	73 18		 jae	 SHORT $LN5@Grow

; 1962 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  00020	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

  0002a	33 c9		 xor	 ecx, ecx
  0002c	3b cb		 cmp	 ecx, ebx
  0002e	1b c0		 sbb	 eax, eax
  00030	5e		 pop	 esi
  00031	f7 d8		 neg	 eax
  00033	5b		 pop	 ebx

; 1969 : 		}

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN5@Grow:

; 1963 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00038	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  0003c	74 4e		 je	 SHORT $LN3@Grow
  0003e	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00041	73 49		 jae	 SHORT $LN3@Grow

; 1964 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1965 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

  00043	57		 push	 edi
  00044	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00047	3b df		 cmp	 ebx, edi
  00049	73 02		 jae	 SHORT $LN9@Grow
  0004b	8b fb		 mov	 edi, ebx
$LN9@Grow:
  0004d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00050	72 1d		 jb	 SHORT $LN30@Grow
  00052	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00054	85 ff		 test	 edi, edi
  00056	74 0b		 je	 SHORT $LN28@Grow
  00058	57		 push	 edi
  00059	53		 push	 ebx
  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 _memcpy
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@Grow:
  00063	53		 push	 ebx
  00064	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00069	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  0006c	83 c4 04	 add	 esp, 4
$LN30@Grow:
  0006f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00072	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

  00079	33 c9		 xor	 ecx, ecx
  0007b	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0007f	3b cb		 cmp	 ecx, ebx
  00081	5f		 pop	 edi
  00082	1b c0		 sbb	 eax, eax
  00084	5e		 pop	 esi
  00085	f7 d8		 neg	 eax
  00087	5b		 pop	 ebx

; 1969 : 		}

  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
$LN3@Grow:

; 1966 : 		else if (_Newsize == 0)

  0008c	85 db		 test	 ebx, ebx
  0008e	75 0d		 jne	 SHORT $LN46@Grow

; 1967 : 			_Eos(0);	// new size is zero, just null terminate

  00090	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00093	83 f8 10	 cmp	 eax, 16			; 00000010H
  00096	72 02		 jb	 SHORT $LN44@Grow
  00098	8b 36		 mov	 esi, DWORD PTR [esi]
$LN44@Grow:
  0009a	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN46@Grow:

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

  0009d	33 c9		 xor	 ecx, ecx
  0009f	3b cb		 cmp	 ecx, ebx
  000a1	1b c0		 sbb	 eax, eax
  000a3	5e		 pop	 esi
  000a4	f7 d8		 neg	 eax
  000a6	5b		 pop	 ebx

; 1969 : 		}

  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
$LN48@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 892  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 893  : 		if (_Right.size() < _Roff)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Roff$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	57		 push	 edi
  0000e	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  00011	3b fb		 cmp	 edi, ebx
  00013	73 0a		 jae	 SHORT $LN5@assign

; 894  : 			_Xran();	// _Roff off end

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN83@assign:
$LN5@assign:

; 895  : 		size_type _Num = _Right.size() - _Roff;
; 896  : 		if (_Count < _Num)

  0001f	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	2b fb		 sub	 edi, ebx
  00024	3b c7		 cmp	 eax, edi
  00026	73 02		 jae	 SHORT $LN4@assign

; 897  : 			_Num = _Count;	// trim _Num to size

  00028	8b f8		 mov	 edi, eax
$LN4@assign:

; 898  : 
; 899  : 		if (this == &_Right)

  0002a	3b f1		 cmp	 esi, ecx
  0002c	75 1f		 jne	 SHORT $LN3@assign

; 900  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002e	6a ff		 push	 -1
  00030	03 fb		 add	 edi, ebx
  00032	57		 push	 edi
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0003a	53		 push	 ebx
  0003b	6a 00		 push	 0
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00044	5f		 pop	 edi

; 905  : 			}
; 906  : 		return (*this);

  00045	8b c6		 mov	 eax, esi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx

; 907  : 		}

  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
$LN3@assign:

; 901  : 		else if (_Grow(_Num))

  0004d	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00050	76 0a		 jbe	 SHORT $LN20@assign
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00057	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN84@assign:
$LN20@assign:
  0005c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005f	3b c7		 cmp	 eax, edi
  00061	73 28		 jae	 SHORT $LN19@assign
  00063	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00066	50		 push	 eax
  00067	57		 push	 edi
  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00072	85 ff		 test	 edi, edi
  00074	74 68		 je	 SHORT $LN78@assign
$LN82@assign:

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  00076	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0007b	39 41 14	 cmp	 DWORD PTR [ecx+20], eax
  0007e	72 02		 jb	 SHORT $LN64@assign
  00080	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN64@assign:
  00082	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00085	72 2a		 jb	 SHORT $LN68@assign
  00087	8b 06		 mov	 eax, DWORD PTR [esi]
  00089	eb 28		 jmp	 SHORT $LN69@assign

; 901  : 		else if (_Grow(_Num))

$LN19@assign:
  0008b	85 ff		 test	 edi, edi
  0008d	75 e7		 jne	 SHORT $LN82@assign
  0008f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00092	83 f8 10	 cmp	 eax, 16			; 00000010H
  00095	72 0e		 jb	 SHORT $LN58@assign
  00097	8b 06		 mov	 eax, DWORD PTR [esi]
  00099	5f		 pop	 edi
  0009a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 905  : 			}
; 906  : 		return (*this);

  0009d	8b c6		 mov	 eax, esi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx

; 907  : 		}

  000a1	5d		 pop	 ebp
  000a2	c2 0c 00	 ret	 12			; 0000000cH

; 901  : 		else if (_Grow(_Num))

$LN58@assign:
  000a5	5f		 pop	 edi
  000a6	8b c6		 mov	 eax, esi
  000a8	5e		 pop	 esi
  000a9	c6 00 00	 mov	 BYTE PTR [eax], 0
  000ac	5b		 pop	 ebx

; 907  : 		}

  000ad	5d		 pop	 ebp
  000ae	c2 0c 00	 ret	 12			; 0000000cH

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$LN68@assign:
  000b1	8b c6		 mov	 eax, esi
$LN69@assign:
  000b3	57		 push	 edi
  000b4	03 cb		 add	 ecx, ebx
  000b6	51		 push	 ecx
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _memcpy
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 904  : 			_Eos(_Num);

  000c0	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c4	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000c7	72 0f		 jb	 SHORT $LN76@assign
  000c9	8b 06		 mov	 eax, DWORD PTR [esi]
  000cb	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  000cf	5f		 pop	 edi

; 905  : 			}
; 906  : 		return (*this);

  000d0	8b c6		 mov	 eax, esi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 907  : 		}

  000d4	5d		 pop	 ebp
  000d5	c2 0c 00	 ret	 12			; 0000000cH

; 904  : 			_Eos(_Num);

$LN76@assign:
  000d8	8b c6		 mov	 eax, esi
  000da	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN78@assign:

; 905  : 			}
; 906  : 		return (*this);

  000de	5f		 pop	 edi
  000df	8b c6		 mov	 eax, esi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx

; 907  : 		}

  000e3	5d		 pop	 ebp
  000e4	c2 0c 00	 ret	 12			; 0000000cH
$LN80@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 910  : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 911  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 912  : 		if (_Count != 0)
; 913  : 			_DEBUG_POINTER(_Ptr);
; 914  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 915  : 
; 916  : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 59		 je	 SHORT $LN85@assign@2
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN12@assign@2
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN13@assign@2
$LN12@assign@2:
  0001a	8b c6		 mov	 eax, esi
$LN13@assign@2:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 47		 jb	 SHORT $LN85@assign@2
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN16@assign@2
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN17@assign@2
$LN16@assign@2:
  00029	8b c6		 mov	 eax, esi
$LN17@assign@2:
  0002b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0002e	03 d0		 add	 edx, eax
  00030	3b d3		 cmp	 edx, ebx
  00032	76 33		 jbe	 SHORT $LN85@assign@2

; 917  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 17		 jb	 SHORT $LN20@assign@2
  00039	8b 06		 mov	 eax, DWORD PTR [esi]
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003e	51		 push	 ecx
  0003f	2b d8		 sub	 ebx, eax
  00041	53		 push	 ebx
  00042	56		 push	 esi
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 925  : 		}

  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8

; 917  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

$LN20@assign@2:
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00053	8b c6		 mov	 eax, esi
  00055	51		 push	 ecx
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 925  : 		}

  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
$LN85@assign@2:
  00067	57		 push	 edi

; 918  : 
; 919  : 		if (_Grow(_Count))

  00068	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0006b	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006e	76 0a		 jbe	 SHORT $LN27@assign@2
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00075	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN89@assign@2:
$LN27@assign@2:
  0007a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0007d	3b c7		 cmp	 eax, edi
  0007f	73 1a		 jae	 SHORT $LN26@assign@2
  00081	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00084	52		 push	 edx
  00085	57		 push	 edi
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0008d	85 ff		 test	 edi, edi
  0008f	74 5b		 je	 SHORT $LN82@assign@2
$LN88@assign@2:

; 920  : 			{	// make room and assign new stuff
; 921  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

  00091	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00095	72 2a		 jb	 SHORT $LN72@assign@2
  00097	8b 06		 mov	 eax, DWORD PTR [esi]
  00099	eb 28		 jmp	 SHORT $LN73@assign@2

; 918  : 
; 919  : 		if (_Grow(_Count))

$LN26@assign@2:
  0009b	85 ff		 test	 edi, edi
  0009d	75 f2		 jne	 SHORT $LN88@assign@2
  0009f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000a2	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a5	72 0e		 jb	 SHORT $LN65@assign@2
  000a7	8b 06		 mov	 eax, DWORD PTR [esi]
  000a9	5f		 pop	 edi
  000aa	c6 00 00	 mov	 BYTE PTR [eax], 0

; 923  : 			}
; 924  : 		return (*this);

  000ad	8b c6		 mov	 eax, esi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx

; 925  : 		}

  000b1	5d		 pop	 ebp
  000b2	c2 08 00	 ret	 8

; 918  : 
; 919  : 		if (_Grow(_Count))

$LN65@assign@2:
  000b5	5f		 pop	 edi
  000b6	8b c6		 mov	 eax, esi
  000b8	5e		 pop	 esi
  000b9	c6 00 00	 mov	 BYTE PTR [eax], 0
  000bc	5b		 pop	 ebx

; 925  : 		}

  000bd	5d		 pop	 ebp
  000be	c2 08 00	 ret	 8

; 920  : 			{	// make room and assign new stuff
; 921  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

$LN72@assign@2:
  000c1	8b c6		 mov	 eax, esi
$LN73@assign@2:
  000c3	57		 push	 edi
  000c4	53		 push	 ebx
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _memcpy
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 922  : 			_Eos(_Count);

  000ce	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000d2	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000d5	72 0f		 jb	 SHORT $LN80@assign@2
  000d7	8b 06		 mov	 eax, DWORD PTR [esi]
  000d9	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  000dd	5f		 pop	 edi

; 923  : 			}
; 924  : 		return (*this);

  000de	8b c6		 mov	 eax, esi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx

; 925  : 		}

  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8

; 922  : 			_Eos(_Count);

$LN80@assign@2:
  000e6	8b c6		 mov	 eax, esi
  000e8	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN82@assign@2:

; 923  : 			}
; 924  : 		return (*this);

  000ec	5f		 pop	 edi
  000ed	8b c6		 mov	 eax, esi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx

; 925  : 		}

  000f1	5d		 pop	 ebp
  000f2	c2 08 00	 ret	 8
$LN86@assign@2:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 928  : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 929  : 		_DEBUG_POINTER(_Ptr);
; 930  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	57		 push	 edi
  0000a	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000d	8d 49 00	 npad	 3
$LL5@assign@3:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL5@assign@3
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 931  : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 592  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		_Tidy();
; 594  : 		assign(_Ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b c2		 mov	 eax, edx
  0000b	57		 push	 edi
  0000c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00013	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001d	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$LL31@basic_stri@2:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL31@basic_stri@2
  00027	2b c7		 sub	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00032	5f		 pop	 edi

; 595  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??_C@_01MNNFJEPP@?$DM?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?isValidChatSyntax@ZTHelper@@SA_NPBD@Z		; ZTHelper::isValidChatSyntax
;	COMDAT ??_C@_01MNNFJEPP@?$DM?$AA@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM?$AA@ DB '<', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\zthelper.hpp
CONST	ENDS
;	COMDAT ?isValidChatSyntax@ZTHelper@@SA_NPBD@Z
_TEXT	SEGMENT
_strText$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_Text$ = 8						; size = 4
?isValidChatSyntax@ZTHelper@@SA_NPBD@Z PROC		; ZTHelper::isValidChatSyntax, COMDAT

; 10   : 	static bool isValidChatSyntax(const char* Text) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR _Text$[ebp]

; 11   : 		std::string strText(Text);

  00013	8b c2		 mov	 eax, edx
  00015	56		 push	 esi
  00016	c7 45 f4 0f 00
	00 00		 mov	 DWORD PTR _strText$[ebp+20], 15 ; 0000000fH
  0001d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _strText$[ebp+16], 0
  00024	c6 45 e0 00	 mov	 BYTE PTR _strText$[ebp], 0
  00028	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0002b	eb 03 8d 49 00	 npad	 5
$LL83@isValidCha:
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL83@isValidCha
  00037	2b c6		 sub	 eax, esi
  00039	50		 push	 eax
  0003a	52		 push	 edx
  0003b	8d 4d e0	 lea	 ecx, DWORD PTR _strText$[ebp]
  0003e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 12   : 		if (strText.find("<") != std::string::npos) {

  00043	6a 01		 push	 1
  00045	6a 00		 push	 0
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_01MNNFJEPP@?$DM?$AA@
  0004c	8d 4d e0	 lea	 ecx, DWORD PTR _strText$[ebp]
  0004f	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00054	5e		 pop	 esi
  00055	83 f8 ff	 cmp	 eax, -1
  00058	74 22		 je	 SHORT $LN1@isValidCha

; 13   : 			return false;

  0005a	83 7d f4 10	 cmp	 DWORD PTR _strText$[ebp+20], 16 ; 00000010H
  0005e	72 0c		 jb	 SHORT $LN49@isValidCha
  00060	8b 45 e0	 mov	 eax, DWORD PTR _strText$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00069	83 c4 04	 add	 esp, 4
$LN49@isValidCha:
  0006c	32 c0		 xor	 al, al

; 16   : 	}

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	33 cd		 xor	 ecx, ebp
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN1@isValidCha:

; 14   : 		}
; 15   : 		return true;

  0007c	83 7d f4 10	 cmp	 DWORD PTR _strText$[ebp+20], 16 ; 00000010H
  00080	72 0c		 jb	 SHORT $LN71@isValidCha
  00082	8b 4d e0	 mov	 ecx, DWORD PTR _strText$[ebp]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008b	83 c4 04	 add	 esp, 4
$LN71@isValidCha:

; 16   : 	}

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00091	33 cd		 xor	 ecx, ebp
  00093	b0 01		 mov	 al, 1
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
?isValidChatSyntax@ZTHelper@@SA_NPBD@Z ENDP		; ZTHelper::isValidChatSyntax
_TEXT	ENDS
PUBLIC	??_C@_0BM@KJGOCGNH@Need?5more?5zen?5for?5gens?5chat?$AA@ ; `string'
PUBLIC	??_C@_08IOFCDDNP@?1post?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BB@FKJLBJJB@Incorrect?5syntax?$AA@	; `string'
PUBLIC	??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@ ; `string'
PUBLIC	_lpChat$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z		; PChatProc
EXTRN	?GDGuildServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z:PROC ; GDGuildServerGroupChattingSend
EXTRN	?g_iServerGroupGuildChatting@@3HA:DWORD		; g_iServerGroupGuildChatting
EXTRN	?GDUnionServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z:PROC ; GDUnionServerGroupChattingSend
EXTRN	?g_iServerGroupUnionChatting@@3HA:DWORD		; g_iServerGroupUnionChatting
EXTRN	?GetGuildUnionMemberList@TUnion@@QAEHHAAHPAH@Z:PROC ; TUnion::GetGuildUnionMemberList
EXTRN	?GDGuildNoticeSave@@YAXPAD0@Z:PROC		; GDGuildNoticeSave
EXTRN	_sprintf_s:PROC
EXTRN	?CheckAuthority@@YAEHPAUOBJECTSTRUCT@@@Z:PROC	; CheckAuthority
EXTRN	?Run@CommandManager@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CommandManager::Run
EXTRN	?g_CommandManager@@3VCommandManager@@A:BYTE	; g_CommandManager
;	COMDAT ??_C@_0BM@KJGOCGNH@Need?5more?5zen?5for?5gens?5chat?$AA@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\guildclass.h
CONST	SEGMENT
??_C@_0BM@KJGOCGNH@Need?5more?5zen?5for?5gens?5chat?$AA@ DB 'Need more ze'
	DB	'n for gens chat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IOFCDDNP@?1post?5?$CFs?$AA@
CONST	SEGMENT
??_C@_08IOFCDDNP@?1post?5?$CFs?$AA@ DB '/post %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FKJLBJJB@Incorrect?5syntax?$AA@
CONST	SEGMENT
??_C@_0BB@FKJLBJJB@Incorrect?5syntax?$AA@ DB 'Incorrect syntax', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@
CONST	SEGMENT
??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@ DB '['
	DB	'Anti-HACK][PChatProc][%s][%s] Chat Message Len : %d', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\protocol.cpp
CONST	ENDS
;	COMDAT ?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z
_TEXT	SEGMENT
_lpGuildInfo$217546 = -428				; size = 4
tv952 = -424						; size = 4
tv611 = -424						; size = 4
_i$217542 = -420					; size = 4
_slen$ = -420						; size = 4
tv608 = -416						; size = 4
_iGuildCount$217539 = -416				; size = 4
_n$ = -416						; size = 4
_lpChat$GSCopy$ = -412					; size = 4
tv610 = -408						; size = 4
_iGuildList$217540 = -404				; size = 400
_tmpCommandText$217510 = -204				; size = 200
_lpRequest$217504 = -112				; size = 106
__$ArrayPad$ = -4					; size = 4
_lpChat$ = 8						; size = 4
_aIndex$ = 12						; size = 2
?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z PROC		; PChatProc, COMDAT

; 1698 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 01 00
	00		 sub	 esp, 428		; 000001acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	0f b7 45 0c	 movzx	 eax, WORD PTR _aIndex$[ebp]
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _lpChat$[ebp]
  0001a	56		 push	 esi

; 1699 : 
; 1700 : 	int n;
; 1701 : 	LPOBJ lpObj = &gObj[aIndex];

  0001b	0f bf f0	 movsx	 esi, ax
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00023	89 b5 60 fe ff
	ff		 mov	 DWORD PTR tv608[ebp], esi
  00029	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0002f	57		 push	 edi
  00030	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]

; 1702 : 	int number;
; 1703 : 	int slen = strlen(lpChat->chatmsg);

  00033	8d 41 0d	 lea	 eax, DWORD PTR [ecx+13]

; 1732 : 					/*MSG_SYS_BROADCAST	res = { 0 };
; 1733 : 					res.h.set((LPBYTE)&res, 0xCD, sizeof(res));
; 1734 : 					res.btSize = lpChat->h.size;
; 1735 : 					CopyMemory(res.szMessage, lpChat->chatmsg, lpChat->h.size);
; 1736 : 					cDBSMng.Send((char*)&res, sizeof(MSG_SYS_BROADCAST));
; 1737 : 					AllSendServerMsg(&lpChat->chatmsg[1]);*/
; 1738 : 					
; 1739 : 					BroadCastMessageInfo lpRequest = { 0 };

  00036	89 8d 64 fe ff
	ff		 mov	 DWORD PTR _lpChat$GSCopy$[ebp], ecx
  0003c	89 bd 68 fe ff
	ff		 mov	 DWORD PTR tv610[ebp], edi
  00042	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv611[ebp], eax
  00048	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0004b	eb 03 8d 49 00	 npad	 5
$LL94@PChatProc:

; 1702 : 	int number;
; 1703 : 	int slen = strlen(lpChat->chatmsg);

  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	40		 inc	 eax
  00053	84 c9		 test	 cl, cl
  00055	75 f9		 jne	 SHORT $LL94@PChatProc
  00057	2b c2		 sub	 eax, edx
  00059	89 85 5c fe ff
	ff		 mov	 DWORD PTR _slen$[ebp], eax

; 1704 : 
; 1705 : 	if ( slen < 1 )

  0005f	83 f8 01	 cmp	 eax, 1
  00062	0f 8c 78 07 00
	00		 jl	 $LN52@PChatProc

; 1706 : 		return;
; 1707 : 
; 1708 : 	if ( slen > MAX_CHAT_LEN-1 )

  00068	83 f8 59	 cmp	 eax, 89			; 00000059H
  0006b	7e 27		 jle	 SHORT $LN70@PChatProc

; 1709 : 	{
; 1710 : 		LogAddTD("[Anti-HACK][PChatProc][%s][%s] Chat Message Len : %d", lpObj->AccountID, lpObj->Name, slen);

  0006d	50		 push	 eax
  0006e	8d 4f 5d	 lea	 ecx, DWORD PTR [edi+93]
  00071	51		 push	 ecx
  00072	83 c7 52	 add	 edi, 82			; 00000052H
  00075	57		 push	 edi
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN70@PChatProc:

; 1711 : 		return;
; 1712 : 	}
; 1713 : 
; 1714 : 	char szId[MAX_ACCOUNT_LEN+1];
; 1715 : 	szId[MAX_ACCOUNT_LEN] = 0;
; 1716 : 
; 1717 : 	memcpy(szId, gObj[aIndex].Name, MAX_ACCOUNT_LEN);

  00094	8b 47 5d	 mov	 eax, DWORD PTR [edi+93]
  00097	8b 4f 61	 mov	 ecx, DWORD PTR [edi+97]
  0009a	66 8b 57 65	 mov	 dx, WORD PTR [edi+101]
  0009e	83 c7 5d	 add	 edi, 93			; 0000005dH
  000a1	53		 push	 ebx

; 1718 : 	memcpy(lpChat->chatid, szId, MAX_ACCOUNT_LEN);

  000a2	8b 9d 64 fe ff
	ff		 mov	 ebx, DWORD PTR _lpChat$GSCopy$[ebp]
  000a8	89 43 03	 mov	 DWORD PTR [ebx+3], eax
  000ab	89 4b 07	 mov	 DWORD PTR [ebx+7], ecx
  000ae	66 89 53 0b	 mov	 WORD PTR [ebx+11], dx

; 1719 : 	int szTargetNameCount = 0;
; 1720 : 
; 1721 : 	if (!ZTHelper::isValidChatSyntax(lpChat->chatmsg)) {

  000b2	8b 9d 58 fe ff
	ff		 mov	 ebx, DWORD PTR tv611[ebp]
  000b8	53		 push	 ebx
  000b9	e8 00 00 00 00	 call	 ?isValidChatSyntax@ZTHelper@@SA_NPBD@Z ; ZTHelper::isValidChatSyntax
  000be	83 c4 04	 add	 esp, 4
  000c1	84 c0		 test	 al, al
  000c3	75 25		 jne	 SHORT $LN69@PChatProc

; 1722 : 		MsgOutput(aIndex, "Incorrect syntax");

  000c5	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR tv608[ebp]
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FKJLBJJB@Incorrect?5syntax?$AA@
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000d6	83 c4 08	 add	 esp, 8
  000d9	5b		 pop	 ebx
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	33 cd		 xor	 ecx, ebp
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
$LN69@PChatProc:

; 1723 : 		return;
; 1724 : 	}
; 1725 : 	
; 1726 : 	switch ( lpChat->chatmsg[0] )

  000ea	8a 0b		 mov	 cl, BYTE PTR [ebx]
  000ec	b8 02 00 00 00	 mov	 eax, 2
  000f1	80 f9 21	 cmp	 cl, 33			; 00000021H
  000f4	74 38		 je	 SHORT $LN66@PChatProc
  000f6	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  000f9	0f 85 4b 01 00
	00		 jne	 $LN63@PChatProc

; 1751 : 					return;
; 1752 : 				}
; 1753 : 			}
; 1754 : 			break;
; 1755 : 		case '/':	// Command
; 1756 : 			if ( slen > 2 )

  000ff	39 85 5c fe ff
	ff		 cmp	 DWORD PTR _slen$[ebp], eax
  00105	0f 8e 3f 01 00
	00		 jle	 $LN63@PChatProc

; 1757 : 			{
; 1758 : 				g_CommandManager.Run(lpObj, lpChat->chatmsg);

  0010b	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR tv610[ebp]
  00111	53		 push	 ebx
  00112	50		 push	 eax
  00113	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CommandManager@@3VCommandManager@@A ; g_CommandManager
  00118	e8 00 00 00 00	 call	 ?Run@CommandManager@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CommandManager::Run
  0011d	5b		 pop	 ebx
  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  00120	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00123	33 cd		 xor	 ecx, ebp
  00125	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
$LN66@PChatProc:

; 1727 : 	{
; 1728 : 		case '!':	// Global Announcement
; 1729 : 			if ( slen > 2 )

  0012e	39 85 5c fe ff
	ff		 cmp	 DWORD PTR _slen$[ebp], eax
  00134	0f 8e 10 01 00
	00		 jle	 $LN63@PChatProc

; 1730 : 			{
; 1731 : 				if (CheckAuthority(34,lpObj) == 1) {

  0013a	8b bd 68 fe ff
	ff		 mov	 edi, DWORD PTR tv610[ebp]
  00140	57		 push	 edi
  00141	6a 22		 push	 34			; 00000022H
  00143	e8 00 00 00 00	 call	 ?CheckAuthority@@YAEHPAUOBJECTSTRUCT@@@Z ; CheckAuthority
  00148	83 c4 08	 add	 esp, 8
  0014b	3c 01		 cmp	 al, 1
  0014d	0f 85 97 00 00
	00		 jne	 $LN64@PChatProc

; 1732 : 					/*MSG_SYS_BROADCAST	res = { 0 };
; 1733 : 					res.h.set((LPBYTE)&res, 0xCD, sizeof(res));
; 1734 : 					res.btSize = lpChat->h.size;
; 1735 : 					CopyMemory(res.szMessage, lpChat->chatmsg, lpChat->h.size);
; 1736 : 					cDBSMng.Send((char*)&res, sizeof(MSG_SYS_BROADCAST));
; 1737 : 					AllSendServerMsg(&lpChat->chatmsg[1]);*/
; 1738 : 					
; 1739 : 					BroadCastMessageInfo lpRequest = { 0 };

  00153	6a 69		 push	 105			; 00000069H
  00155	33 db		 xor	 ebx, ebx
  00157	8d 4d 91	 lea	 ecx, DWORD PTR _lpRequest$217504[ebp+1]
  0015a	53		 push	 ebx
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memset

; 1740 : 					lpRequest.h.set((LPBYTE)&lpRequest, 0xCD, sizeof(lpRequest));
; 1741 : 					lpRequest.Type = 0;
; 1742 : 					CopyMemory(lpRequest.Text, lpChat->chatmsg, lpChat->h.size);

  00161	8b 95 64 fe ff
	ff		 mov	 edx, DWORD PTR _lpChat$GSCopy$[ebp]
  00167	0f b6 7a 01	 movzx	 edi, BYTE PTR [edx+1]
  0016b	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv611[ebp]
  00171	57		 push	 edi
  00172	50		 push	 eax
  00173	8d 4d a0	 lea	 ecx, DWORD PTR _lpRequest$217504[ebp+16]
  00176	51		 push	 ecx
  00177	c7 45 90 c2 00
	6a cd		 mov	 DWORD PTR _lpRequest$217504[ebp], -848691006 ; cd6a00c2H
  0017e	88 5d 94	 mov	 BYTE PTR _lpRequest$217504[ebp+4], bl
  00181	e8 00 00 00 00	 call	 _memcpy

; 1743 : 					DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);

  00186	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR tv608[ebp]
  0018c	57		 push	 edi
  0018d	8b bd 64 fe ff
	ff		 mov	 edi, DWORD PTR _lpChat$GSCopy$[ebp]
  00193	57		 push	 edi
  00194	52		 push	 edx
  00195	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0019a	83 c4 24	 add	 esp, 36			; 00000024H

; 1744 : 					wsJServerCli.DataSend((PCHAR)&lpRequest, sizeof(BroadCastMessageInfo));

  0019d	6a 6a		 push	 106			; 0000006aH
  0019f	8d 45 90	 lea	 eax, DWORD PTR _lpRequest$217504[ebp]
  001a2	50		 push	 eax
  001a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  001a8	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 1745 : 					LogAddTD(lMsg.Get(MSGGET(1, 215)), gObj[aIndex].AccountID, gObj[aIndex].Name, &lpChat->chatmsg[1]);

  001ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b2	83 c7 0e	 add	 edi, 14			; 0000000eH
  001b5	57		 push	 edi
  001b6	8d 4c 06 5d	 lea	 ecx, DWORD PTR [esi+eax+93]
  001ba	51		 push	 ecx
  001bb	8d 54 06 52	 lea	 edx, DWORD PTR [esi+eax+82]
  001bf	52		 push	 edx
  001c0	68 d7 01 00 00	 push	 471			; 000001d7H
  001c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001ca	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001cf	50		 push	 eax
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001d6	83 c4 10	 add	 esp, 16			; 00000010H
  001d9	5b		 pop	 ebx
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  001dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001df	33 cd		 xor	 ecx, ebp
  001e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c3		 ret	 0
$LN64@PChatProc:

; 1746 : 					return;
; 1747 : 				} else { // post
; 1748 : 					char tmpCommandText[200] = { 0 };

  001ea	68 c7 00 00 00	 push	 199			; 000000c7H
  001ef	8d 85 35 ff ff
	ff		 lea	 eax, DWORD PTR _tmpCommandText$217510[ebp+1]
  001f5	6a 00		 push	 0
  001f7	50		 push	 eax
  001f8	c6 85 34 ff ff
	ff 00		 mov	 BYTE PTR _tmpCommandText$217510[ebp], 0
  001ff	e8 00 00 00 00	 call	 _memset

; 1749 : 					sprintf_s(tmpCommandText, sizeof(tmpCommandText), "/post %s", &lpChat->chatmsg[1]);

  00204	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _lpChat$GSCopy$[ebp]
  0020a	83 c1 0e	 add	 ecx, 14			; 0000000eH
  0020d	51		 push	 ecx
  0020e	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFCDDNP@?1post?5?$CFs?$AA@
  00213	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR _tmpCommandText$217510[ebp]
  00219	68 c8 00 00 00	 push	 200			; 000000c8H
  0021e	52		 push	 edx
  0021f	e8 00 00 00 00	 call	 _sprintf_s
  00224	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1750 : 					g_CommandManager.Run(lpObj, tmpCommandText);

  00227	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _tmpCommandText$217510[ebp]
  0022d	50		 push	 eax
  0022e	57		 push	 edi
  0022f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CommandManager@@3VCommandManager@@A ; g_CommandManager
  00234	e8 00 00 00 00	 call	 ?Run@CommandManager@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CommandManager::Run
  00239	5b		 pop	 ebx
  0023a	5f		 pop	 edi
  0023b	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  0023c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023f	33 cd		 xor	 ecx, ebp
  00241	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c3		 ret	 0
$LN63@PChatProc:

; 1759 : 				return;
; 1760 : 			}
; 1761 : 			break;
; 1762 : 	}
; 1763 : 
; 1764 : 	// Other Commands
; 1765 : 	if ( lpObj->ChatLimitTime > 0 )

  0024a	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR tv610[ebp]
  00250	0f b7 82 f8 00
	00 00		 movzx	 eax, WORD PTR [edx+248]
  00257	66 85 c0	 test	 ax, ax
  0025a	74 33		 je	 SHORT $LN60@PChatProc

; 1766 : 	{
; 1767 : 		MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(4, 223)), lpObj->ChatLimitTime);

  0025c	50		 push	 eax
  0025d	68 df 04 00 00	 push	 1247			; 000004dfH
  00262	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00267	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0026c	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR tv610[ebp]
  00272	50		 push	 eax
  00273	8b 02		 mov	 eax, DWORD PTR [edx]
  00275	50		 push	 eax
  00276	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0027b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027e	5b		 pop	 ebx
  0027f	5f		 pop	 edi
  00280	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  00281	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00284	33 cd		 xor	 ecx, ebp
  00286	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028b	8b e5		 mov	 esp, ebp
  0028d	5d		 pop	 ebp
  0028e	c3		 ret	 0
$LN60@PChatProc:

; 1768 : 		return;
; 1769 : 	}
; 1770 : 
; 1771 : 	if ( (lpObj->Penalty&2)==2)

  0028f	f6 82 c0 01 00
	00 02		 test	 BYTE PTR [edx+448], 2
  00296	0f 85 43 05 00
	00		 jne	 $LN111@PChatProc

; 1772 : 		return;
; 1773 : 
; 1774 : 	// Party Message
; 1775 : 	if ( lpChat->chatmsg[0] == '~' || lpChat->chatmsg[0] == ']' )

  0029c	80 f9 7e	 cmp	 cl, 126			; 0000007eH
  0029f	0f 84 e0 04 00
	00		 je	 $LN57@PChatProc
  002a5	80 f9 5d	 cmp	 cl, 93			; 0000005dH
  002a8	0f 84 d7 04 00
	00		 je	 $LN57@PChatProc

; 1790 : 					}
; 1791 : 				}
; 1792 : 			}
; 1793 : 		}
; 1794 : 	}
; 1795 : 	// Guild
; 1796 : 	else if ( lpChat->chatmsg[0] == '@' )

  002ae	80 f9 40	 cmp	 cl, 64			; 00000040H
  002b1	0f 85 45 03 00
	00		 jne	 $LN49@PChatProc

; 1797 : 	{
; 1798 : 		if ( lpObj->GuildNumber > 0 )

  002b7	83 ba 14 06 00
	00 00		 cmp	 DWORD PTR [edx+1556], 0
  002be	0f 8e 1b 05 00
	00		 jle	 $LN111@PChatProc

; 1799 : 		{
; 1800 : 			// Notice
; 1801 : 			if ( lpChat->chatmsg[1] == '>' )

  002c4	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _lpChat$GSCopy$[ebp]
  002ca	8a 41 0e	 mov	 al, BYTE PTR [ecx+14]
  002cd	3c 3e		 cmp	 al, 62			; 0000003eH
  002cf	0f 85 99 00 00
	00		 jne	 $LN47@PChatProc

; 1802 : 			{
; 1803 : 				if ( lpObj->Name[0] == lpObj->lpGuild->Names[0][0] )

  002d5	8b 92 18 06 00
	00		 mov	 edx, DWORD PTR [edx+1560]
  002db	8a 0f		 mov	 cl, BYTE PTR [edi]
  002dd	3a 4a 2f	 cmp	 cl, BYTE PTR [edx+47]
  002e0	8d 42 2f	 lea	 eax, DWORD PTR [edx+47]
  002e3	0f 85 f6 04 00
	00		 jne	 $LN111@PChatProc
  002e9	8d a4 24 00 00
	00 00		 npad	 7
$LL95@PChatProc:

; 1804 : 				{
; 1805 : 					if ( !strcmp(lpObj->Name, lpObj->lpGuild->Names[0] ) )

  002f0	8a 0f		 mov	 cl, BYTE PTR [edi]
  002f2	3a 08		 cmp	 cl, BYTE PTR [eax]
  002f4	75 1a		 jne	 SHORT $LN96@PChatProc
  002f6	84 c9		 test	 cl, cl
  002f8	74 12		 je	 SHORT $LN97@PChatProc
  002fa	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  002fd	3a 48 01	 cmp	 cl, BYTE PTR [eax+1]
  00300	75 0e		 jne	 SHORT $LN96@PChatProc
  00302	83 c7 02	 add	 edi, 2
  00305	83 c0 02	 add	 eax, 2
  00308	84 c9		 test	 cl, cl
  0030a	75 e4		 jne	 SHORT $LL95@PChatProc
$LN97@PChatProc:
  0030c	33 c0		 xor	 eax, eax
  0030e	eb 05		 jmp	 SHORT $LN98@PChatProc
$LN96@PChatProc:
  00310	1b c0		 sbb	 eax, eax
  00312	83 d8 ff	 sbb	 eax, -1
$LN98@PChatProc:
  00315	85 c0		 test	 eax, eax
  00317	0f 85 c2 04 00
	00		 jne	 $LN111@PChatProc

; 1806 : 					{
; 1807 : 						GDGuildNoticeSave(lpObj->lpGuild->Name, &lpChat->chatmsg[2]);

  0031d	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _lpChat$GSCopy$[ebp]
  00323	83 c0 0f	 add	 eax, 15			; 0000000fH
  00326	50		 push	 eax
  00327	83 c2 04	 add	 edx, 4
  0032a	52		 push	 edx
  0032b	e8 00 00 00 00	 call	 ?GDGuildNoticeSave@@YAXPAD0@Z ; GDGuildNoticeSave

; 1808 : 						LogAdd(lMsg.Get(MSGGET(1, 216)), lpObj->lpGuild->Name, lpChat->chatmsg);

  00330	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR tv610[ebp]
  00336	8b 91 18 06 00
	00		 mov	 edx, DWORD PTR [ecx+1560]
  0033c	83 c4 08	 add	 esp, 8
  0033f	53		 push	 ebx
  00340	83 c2 04	 add	 edx, 4
  00343	52		 push	 edx
  00344	68 d8 01 00 00	 push	 472			; 000001d8H
  00349	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0034e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00353	50		 push	 eax
  00354	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0035a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0035d	5b		 pop	 ebx
  0035e	5f		 pop	 edi
  0035f	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  00360	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00363	33 cd		 xor	 ecx, ebp
  00365	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0036a	8b e5		 mov	 esp, ebp
  0036c	5d		 pop	 ebp
  0036d	c3		 ret	 0
$LN47@PChatProc:

; 1809 : 					}
; 1810 : 				}
; 1811 : 			}
; 1812 : 			// Aliances
; 1813 : 			else if ( lpChat->chatmsg[1] == '@' && lpObj->lpGuild->iGuildUnion )

  0036e	3c 40		 cmp	 al, 64			; 00000040H
  00370	0f 85 9b 01 00
	00		 jne	 $LN109@PChatProc
  00376	8b b2 18 06 00
	00		 mov	 esi, DWORD PTR [edx+1560]
  0037c	83 be 44 07 00
	00 00		 cmp	 DWORD PTR [esi+1860], 0
  00383	0f 84 88 01 00
	00		 je	 $LN109@PChatProc

; 1814 : 			{
; 1815 : 				int iGuildCount = 0;

  00389	33 ff		 xor	 edi, edi

; 1816 : 				int iGuildList[MAX_UNION_GUILD] ={0};

  0038b	68 8c 01 00 00	 push	 396			; 0000018cH
  00390	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _iGuildList$217540[ebp+4]
  00396	57		 push	 edi
  00397	50		 push	 eax
  00398	89 bd 60 fe ff
	ff		 mov	 DWORD PTR _iGuildCount$217539[ebp], edi
  0039e	89 bd 6c fe ff
	ff		 mov	 DWORD PTR _iGuildList$217540[ebp], edi
  003a4	e8 00 00 00 00	 call	 _memset

; 1817 : 
; 1818 : 				if ( UnionManager.GetGuildUnionMemberList(lpObj->lpGuild->iGuildUnion, iGuildCount, iGuildList) == TRUE )

  003a9	8b 86 44 07 00
	00		 mov	 eax, DWORD PTR [esi+1860]
  003af	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b2	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR _iGuildList$217540[ebp]
  003b8	51		 push	 ecx
  003b9	8d 95 60 fe ff
	ff		 lea	 edx, DWORD PTR _iGuildCount$217539[ebp]
  003bf	52		 push	 edx
  003c0	50		 push	 eax
  003c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  003c6	e8 00 00 00 00	 call	 ?GetGuildUnionMemberList@TUnion@@QAEHHAAHPAH@Z ; TUnion::GetGuildUnionMemberList
  003cb	83 f8 01	 cmp	 eax, 1
  003ce	0f 85 fd 00 00
	00		 jne	 $LN108@PChatProc

; 1819 : 				{
; 1820 : 					for ( int i=0;i<iGuildCount;i++)

  003d4	89 bd 5c fe ff
	ff		 mov	 DWORD PTR _i$217542[ebp], edi
  003da	39 bd 60 fe ff
	ff		 cmp	 DWORD PTR _iGuildCount$217539[ebp], edi
  003e0	0f 8e eb 00 00
	00		 jle	 $LN108@PChatProc
  003e6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL41@PChatProc:

; 1821 : 					{
; 1822 : 						_GUILD_INFO_STRUCT *lpGuildInfo = Guild.SearchGuild_Number(iGuildList[i]);

  003f0	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR _i$217542[ebp]
  003f6	8b 94 8d 6c fe
	ff ff		 mov	 edx, DWORD PTR _iGuildList$217540[ebp+ecx*4]
  003fd	52		 push	 edx
  003fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00403	e8 00 00 00 00	 call	 ?SearchGuild_Number@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@H@Z ; CGuildClass::SearchGuild_Number
  00408	89 85 54 fe ff
	ff		 mov	 DWORD PTR _lpGuildInfo$217546[ebp], eax

; 1823 : 
; 1824 : 						if ( !lpGuildInfo )

  0040e	85 c0		 test	 eax, eax
  00410	0f 84 a2 00 00
	00		 je	 $LN40@PChatProc

; 1825 : 							continue;
; 1826 : 
; 1827 : 						for (n=0;n<MAX_USER_GUILD;n++)

  00416	33 ff		 xor	 edi, edi
  00418	8d 70 2f	 lea	 esi, DWORD PTR [eax+47]
  0041b	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  00420	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv952[ebp], eax
  00426	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL37@PChatProc:

; 1828 : 						{
; 1829 : 							if ( lpGuildInfo->Use[n] )

  00430	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _lpGuildInfo$217546[ebp]
  00436	80 bc 38 40 04
	00 00 00	 cmp	 BYTE PTR [eax+edi+1088], 0
  0043e	74 64		 je	 SHORT $LN36@PChatProc

; 1830 : 							{
; 1831 : 								number = lpGuildInfo->Index[n];

  00440	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv952[ebp]
  00446	0f bf 19	 movsx	 ebx, WORD PTR [ecx]

; 1832 : 
; 1833 : 								if ( number >= 0 )

  00449	85 db		 test	 ebx, ebx
  0044b	78 57		 js	 SHORT $LN36@PChatProc

; 1834 : 								{
; 1835 : 									if ( lpGuildInfo->Names[n][0] == gObj[number].Name[0] )

  0044d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00452	8b d3		 mov	 edx, ebx
  00454	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  0045a	8d 4c 02 5d	 lea	 ecx, DWORD PTR [edx+eax+93]
  0045e	8a 16		 mov	 dl, BYTE PTR [esi]
  00460	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00462	75 40		 jne	 SHORT $LN36@PChatProc

; 1836 : 									{
; 1837 : 										if ( !strcmp(lpGuildInfo->Names[n], gObj[number].Name ))

  00464	8b c6		 mov	 eax, esi
$LL99@PChatProc:
  00466	8a 10		 mov	 dl, BYTE PTR [eax]
  00468	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0046a	75 1a		 jne	 SHORT $LN100@PChatProc
  0046c	84 d2		 test	 dl, dl
  0046e	74 12		 je	 SHORT $LN101@PChatProc
  00470	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00473	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00476	75 0e		 jne	 SHORT $LN100@PChatProc
  00478	83 c0 02	 add	 eax, 2
  0047b	83 c1 02	 add	 ecx, 2
  0047e	84 d2		 test	 dl, dl
  00480	75 e4		 jne	 SHORT $LL99@PChatProc
$LN101@PChatProc:
  00482	33 c0		 xor	 eax, eax
  00484	eb 05		 jmp	 SHORT $LN102@PChatProc
$LN100@PChatProc:
  00486	1b c0		 sbb	 eax, eax
  00488	83 d8 ff	 sbb	 eax, -1
$LN102@PChatProc:
  0048b	85 c0		 test	 eax, eax
  0048d	75 15		 jne	 SHORT $LN36@PChatProc

; 1838 : 										{
; 1839 : 											DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  0048f	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _lpChat$GSCopy$[ebp]
  00495	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00499	51		 push	 ecx
  0049a	50		 push	 eax
  0049b	53		 push	 ebx
  0049c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@PChatProc:

; 1825 : 							continue;
; 1826 : 
; 1827 : 						for (n=0;n<MAX_USER_GUILD;n++)

  004a4	83 85 58 fe ff
	ff 02		 add	 DWORD PTR tv952[ebp], 2
  004ab	47		 inc	 edi
  004ac	83 c6 0b	 add	 esi, 11			; 0000000bH
  004af	83 ff 50	 cmp	 edi, 80			; 00000050H
  004b2	0f 8c 78 ff ff
	ff		 jl	 $LL37@PChatProc
$LN40@PChatProc:

; 1819 : 				{
; 1820 : 					for ( int i=0;i<iGuildCount;i++)

  004b8	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR _i$217542[ebp]
  004be	40		 inc	 eax
  004bf	89 85 5c fe ff
	ff		 mov	 DWORD PTR _i$217542[ebp], eax
  004c5	3b 85 60 fe ff
	ff		 cmp	 eax, DWORD PTR _iGuildCount$217539[ebp]
  004cb	0f 8c 1f ff ff
	ff		 jl	 $LL41@PChatProc
$LN108@PChatProc:

; 1840 : 										}
; 1841 : 									}
; 1842 : 								}
; 1843 : 							}
; 1844 : 						}
; 1845 : 					}
; 1846 : 				}
; 1847 : 
; 1848 : 				if ( g_iServerGroupUnionChatting == TRUE )

  004d1	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_iServerGroupUnionChatting@@3HA, 1 ; g_iServerGroupUnionChatting
  004d8	0f 85 01 03 00
	00		 jne	 $LN111@PChatProc

; 1849 : 					GDUnionServerGroupChattingSend(lpObj->lpGuild->iGuildUnion, lpChat);

  004de	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR tv610[ebp]
  004e4	8b 95 64 fe ff
	ff		 mov	 edx, DWORD PTR _lpChat$GSCopy$[ebp]
  004ea	8b 88 18 06 00
	00		 mov	 ecx, DWORD PTR [eax+1560]
  004f0	52		 push	 edx
  004f1	8b 91 44 07 00
	00		 mov	 edx, DWORD PTR [ecx+1860]
  004f7	52		 push	 edx
  004f8	e8 00 00 00 00	 call	 ?GDUnionServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z ; GDUnionServerGroupChattingSend
  004fd	83 c4 08	 add	 esp, 8
  00500	5b		 pop	 ebx
  00501	5f		 pop	 edi
  00502	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  00503	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00506	33 cd		 xor	 ecx, ebp
  00508	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0050d	8b e5		 mov	 esp, ebp
  0050f	5d		 pop	 ebp
  00510	c3		 ret	 0
$LN109@PChatProc:

; 1850 : 			}
; 1851 : 			// Just Guild
; 1852 : 			else
; 1853 : 			{
; 1854 : 				int count = lpObj->lpGuild->Count;
; 1855 : 
; 1856 : 				if ( count >= 0 )
; 1857 : 				{
; 1858 : 					for ( n=0;n<MAX_USER_GUILD;n++)

  00511	33 db		 xor	 ebx, ebx
  00513	89 9d 60 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], ebx
  00519	bf a0 03 00 00	 mov	 edi, 928		; 000003a0H
  0051e	8b ff		 npad	 2
$LL27@PChatProc:

; 1859 : 					{
; 1860 : 						if ( lpObj->lpGuild->Use[n] )

  00520	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR tv610[ebp]
  00526	8b 80 18 06 00
	00		 mov	 eax, DWORD PTR [eax+1560]
  0052c	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  00532	80 bc 08 40 04
	00 00 00	 cmp	 BYTE PTR [eax+ecx+1088], 0
  0053a	74 62		 je	 SHORT $LN26@PChatProc

; 1861 : 							{
; 1862 : 								number = lpObj->lpGuild->Index[n];

  0053c	0f bf 34 07	 movsx	 esi, WORD PTR [edi+eax]

; 1863 : 
; 1864 : 								if ( number >= 0 )

  00540	85 f6		 test	 esi, esi
  00542	78 5a		 js	 SHORT $LN26@PChatProc

; 1865 : 								{
; 1866 : 									if ( lpObj->lpGuild->Names[n][0] == gObj[number].Name[0] )

  00544	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0054a	8b d6		 mov	 edx, esi
  0054c	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  00552	8d 44 03 2f	 lea	 eax, DWORD PTR [ebx+eax+47]
  00556	8d 4c 0a 5d	 lea	 ecx, DWORD PTR [edx+ecx+93]
  0055a	8a 10		 mov	 dl, BYTE PTR [eax]
  0055c	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0055e	75 3e		 jne	 SHORT $LN26@PChatProc
$LL103@PChatProc:

; 1867 : 									{
; 1868 : 										if ( !strcmp(lpObj->lpGuild->Names[n], gObj[number].Name ) )

  00560	8a 10		 mov	 dl, BYTE PTR [eax]
  00562	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00564	75 1a		 jne	 SHORT $LN104@PChatProc
  00566	84 d2		 test	 dl, dl
  00568	74 12		 je	 SHORT $LN105@PChatProc
  0056a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0056d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00570	75 0e		 jne	 SHORT $LN104@PChatProc
  00572	83 c0 02	 add	 eax, 2
  00575	83 c1 02	 add	 ecx, 2
  00578	84 d2		 test	 dl, dl
  0057a	75 e4		 jne	 SHORT $LL103@PChatProc
$LN105@PChatProc:
  0057c	33 c0		 xor	 eax, eax
  0057e	eb 05		 jmp	 SHORT $LN106@PChatProc
$LN104@PChatProc:
  00580	1b c0		 sbb	 eax, eax
  00582	83 d8 ff	 sbb	 eax, -1
$LN106@PChatProc:
  00585	85 c0		 test	 eax, eax
  00587	75 15		 jne	 SHORT $LN26@PChatProc

; 1869 : 										{
; 1870 : 											DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  00589	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _lpChat$GSCopy$[ebp]
  0058f	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00593	51		 push	 ecx
  00594	50		 push	 eax
  00595	56		 push	 esi
  00596	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0059b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@PChatProc:

; 1850 : 			}
; 1851 : 			// Just Guild
; 1852 : 			else
; 1853 : 			{
; 1854 : 				int count = lpObj->lpGuild->Count;
; 1855 : 
; 1856 : 				if ( count >= 0 )
; 1857 : 				{
; 1858 : 					for ( n=0;n<MAX_USER_GUILD;n++)

  0059e	ff 85 60 fe ff
	ff		 inc	 DWORD PTR _n$[ebp]
  005a4	83 c7 02	 add	 edi, 2
  005a7	83 c3 0b	 add	 ebx, 11			; 0000000bH
  005aa	81 ff 40 04 00
	00		 cmp	 edi, 1088		; 00000440H
  005b0	0f 8c 6a ff ff
	ff		 jl	 $LL27@PChatProc

; 1871 : 										}
; 1872 : 									}
; 1873 : 								}
; 1874 : 							}
; 1875 : 						}
; 1876 : 				}
; 1877 : 
; 1878 : 				if ( g_iServerGroupGuildChatting == TRUE )

  005b6	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_iServerGroupGuildChatting@@3HA, 1 ; g_iServerGroupGuildChatting
  005bd	0f 85 1c 02 00
	00		 jne	 $LN111@PChatProc

; 1879 : 				{
; 1880 : 					if ( lpObj->lpGuild->Count > 1 )

  005c3	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR tv610[ebp]
  005c9	8b 82 18 06 00
	00		 mov	 eax, DWORD PTR [edx+1560]
  005cf	80 78 2d 01	 cmp	 BYTE PTR [eax+45], 1
  005d3	0f 86 06 02 00
	00		 jbe	 $LN111@PChatProc

; 1881 : 					{
; 1882 : 						GDGuildServerGroupChattingSend(lpObj->lpGuild->Number, lpChat);

  005d9	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _lpChat$GSCopy$[ebp]
  005df	8b 10		 mov	 edx, DWORD PTR [eax]
  005e1	51		 push	 ecx
  005e2	52		 push	 edx
  005e3	e8 00 00 00 00	 call	 ?GDGuildServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z ; GDGuildServerGroupChattingSend
  005e8	83 c4 08	 add	 esp, 8
  005eb	5b		 pop	 ebx
  005ec	5f		 pop	 edi
  005ed	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  005ee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f1	33 cd		 xor	 ecx, ebp
  005f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f8	8b e5		 mov	 esp, ebp
  005fa	5d		 pop	 ebp
  005fb	c3		 ret	 0
$LN49@PChatProc:

; 1883 : 					}
; 1884 : 				}
; 1885 : 			}
; 1886 : 		}
; 1887 : 	}
; 1888 : #if (CUSTOM_OLYMP==1)
; 1889 : 	else if( lpChat->chatmsg[0] == '$' )
; 1890 : 	{
; 1891 : 		if( gObjCheckUsedBuffEffect(lpObj,BUFF_GLADIATOR_HONOR) )
; 1892 : 		{
; 1893 : 			for(int  n = OBJ_STARTUSERINDEX; n < OBJMAX; n++)
; 1894 : 			{
; 1895 : 				if( gObj[n].Connected < 3 )
; 1896 : 					continue;
; 1897 : 
; 1898 : 				DataSend(n, (LPBYTE)lpChat, lpChat->h.size);
; 1899 : 			}
; 1900 : 
; 1901 : 			if ( gWriteChatLog )
; 1902 : 			{
; 1903 : 				memcpy(pChatMsg.szChatMsg, &lpChat->chatmsg[1], MAX_CHAT_LEN-1);
; 1904 : 				pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 1905 : 				pChatMsg.btType = 0x06;
; 1906 : 			}
; 1907 : 		}
; 1908 : 		else
; 1909 : 		{
; 1910 : 			MsgOutput(lpObj->m_Index,"Only heroes can use this !");
; 1911 : 		}
; 1912 : 	}
; 1913 : #endif
; 1914 : #if(__GENS_SYSTEM__ == 1)
; 1915 : 	else if( lpChat->chatmsg[0] == '$' )

  005fc	80 f9 24	 cmp	 cl, 36			; 00000024H
  005ff	0f 85 b2 00 00
	00		 jne	 $LN17@PChatProc

; 1916 : 	{
; 1917 : 		if( lpObj->Money < gGensSystem.GetChatPrice() )

  00605	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  0060b	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR ?gGensSystem@@3VCGensSystem@@A+56
  00611	3b c1		 cmp	 eax, ecx
  00613	7d 23		 jge	 SHORT $LN16@PChatProc

; 1918 : 		{
; 1919 : 			MsgOutput(lpObj->m_Index, "Need more zen for gens chat");

  00615	8b c2		 mov	 eax, edx
  00617	8b 08		 mov	 ecx, DWORD PTR [eax]
  00619	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KJGOCGNH@Need?5more?5zen?5for?5gens?5chat?$AA@
  0061e	51		 push	 ecx
  0061f	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00624	83 c4 08	 add	 esp, 8
  00627	5b		 pop	 ebx
  00628	5f		 pop	 edi
  00629	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  0062a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0062d	33 cd		 xor	 ecx, ebp
  0062f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00634	8b e5		 mov	 esp, ebp
  00636	5d		 pop	 ebp
  00637	c3		 ret	 0
$LN16@PChatProc:

; 1920 : 			return;
; 1921 : 		}
; 1922 : 
; 1923 : 		lpObj->Money -= gGensSystem.GetChatPrice();

  00638	2b c1		 sub	 eax, ecx
  0063a	8b ca		 mov	 ecx, edx

; 1924 : 		GCMoneySend(lpObj->m_Index, lpObj->Money);

  0063c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0063e	50		 push	 eax
  0063f	52		 push	 edx
  00640	89 81 cc 00 00
	00		 mov	 DWORD PTR [ecx+204], eax
  00646	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0064b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00650	83 c4 08	 add	 esp, 8

; 1925 : 
; 1926 : 		for(int  n = OBJ_STARTUSERINDEX; n < OBJMAX; n++)

  00653	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  00658	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
  0065d	bb 03 00 00 00	 mov	 ebx, 3
$LL15@PChatProc:

; 1927 : 		{
; 1928 : 			if( gObj[n].Connected < 3 )

  00662	39 5c 30 04	 cmp	 DWORD PTR [eax+esi+4], ebx
  00666	7c 2f		 jl	 SHORT $LN14@PChatProc

; 1929 : 				continue;
; 1930 : 
; 1931 : 			if( gObj[n].m_GensInfo.btFamily == lpObj->m_GensInfo.btFamily )

  00668	8a 8c 30 ac 26
	00 00		 mov	 cl, BYTE PTR [eax+esi+9900]
  0066f	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR tv610[ebp]
  00675	3a 8a ac 26 00
	00		 cmp	 cl, BYTE PTR [edx+9900]
  0067b	75 1a		 jne	 SHORT $LN14@PChatProc

; 1932 : 			{
; 1933 : 				DataSend(n, (LPBYTE)lpChat, lpChat->h.size);

  0067d	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _lpChat$GSCopy$[ebp]
  00683	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00687	51		 push	 ecx
  00688	50		 push	 eax
  00689	57		 push	 edi
  0068a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0068f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00694	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@PChatProc:

; 1925 : 
; 1926 : 		for(int  n = OBJ_STARTUSERINDEX; n < OBJMAX; n++)

  00697	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  0069d	47		 inc	 edi
  0069e	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  006a4	7c bc		 jl	 SHORT $LL15@PChatProc
  006a6	5b		 pop	 ebx
  006a7	5f		 pop	 edi
  006a8	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  006a9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006ac	33 cd		 xor	 ecx, ebp
  006ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006b3	8b e5		 mov	 esp, ebp
  006b5	5d		 pop	 ebp
  006b6	c3		 ret	 0
$LN17@PChatProc:

; 1934 : 			}
; 1935 : 		}
; 1936 : 	}
; 1937 : #else
; 1938 : #if (CUSTOM_OLYMP==0)
; 1939 : 	else if( lpChat->chatmsg[0] == '$' )
; 1940 : 	{
; 1941 : 		MsgOutput(lpObj->m_Index,"Gens system is disabled!");
; 1942 : 	}
; 1943 : #endif
; 1944 : #endif
; 1945 : 	else
; 1946 : 	{
; 1947 : #if (__CUSTOM__ == 1)
; 1948 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);

  006b7	8b bd 64 fe ff
	ff		 mov	 edi, DWORD PTR _lpChat$GSCopy$[ebp]
  006bd	0f b6 57 01	 movzx	 edx, BYTE PTR [edi+1]
  006c1	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR tv608[ebp]
  006c7	52		 push	 edx
  006c8	57		 push	 edi
  006c9	50		 push	 eax
  006ca	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1949 : 
; 1950 : 		if( lpObj->MapNumber == MAP_INDEX_PKFIELD && lpObj->m_iDuelUser == -1 )

  006cf	8b b5 68 fe ff
	ff		 mov	 esi, DWORD PTR tv610[ebp]
  006d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  006d8	80 be 23 01 00
	00 40		 cmp	 BYTE PTR [esi+291], 64	; 00000040H
  006df	0f 85 80 00 00
	00		 jne	 $LN9@PChatProc
  006e5	83 be 50 12 00
	00 ff		 cmp	 DWORD PTR [esi+4688], -1
  006ec	75 77		 jne	 SHORT $LN9@PChatProc

; 1951 : 		{
; 1952 : 			for ( int n=0;n<MAX_VIEWPORT;n++)

  006ee	81 c6 48 0c 00
	00		 add	 esi, 3144		; 00000c48H
  006f4	bf 4b 00 00 00	 mov	 edi, 75			; 0000004bH
  006f9	bb 01 00 00 00	 mov	 ebx, 1
  006fe	8b ff		 npad	 2
$LL8@PChatProc:

; 1953 : 			{
; 1954 : 				if ( lpObj->VpPlayer2[n].type == OBJ_USER )

  00700	38 5e 04	 cmp	 BYTE PTR [esi+4], bl
  00703	75 48		 jne	 SHORT $LN7@PChatProc

; 1955 : 				{
; 1956 : 					if ( lpObj->VpPlayer2[n].state != 0 )

  00705	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00708	74 43		 je	 SHORT $LN7@PChatProc

; 1957 : 					{
; 1958 : 						int number = lpObj->VpPlayer2[n].number;

  0070a	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]

; 1959 : 	
; 1960 : 						if( OBJMAX_RANGE(number) )

  0070e	85 c0		 test	 eax, eax
  00710	78 3b		 js	 SHORT $LN7@PChatProc
  00712	33 c9		 xor	 ecx, ecx
  00714	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00719	0f 9e c1	 setle	 cl
  0071c	85 c9		 test	 ecx, ecx
  0071e	74 2d		 je	 SHORT $LN7@PChatProc

; 1961 : 						{
; 1962 : 							if( gObj[number].m_iDuelUser != -1 )

  00720	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00726	8b c8		 mov	 ecx, eax
  00728	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  0072e	83 bc 11 50 12
	00 00 ff	 cmp	 DWORD PTR [ecx+edx+4688], -1
  00736	75 15		 jne	 SHORT $LN7@PChatProc

; 1963 : 							{
; 1964 : 								continue;
; 1965 : 							}
; 1966 : 	
; 1967 : 							DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  00738	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _lpChat$GSCopy$[ebp]
  0073e	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00742	52		 push	 edx
  00743	51		 push	 ecx
  00744	50		 push	 eax
  00745	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0074a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@PChatProc:

; 1951 : 		{
; 1952 : 			for ( int n=0;n<MAX_VIEWPORT;n++)

  0074d	83 c6 0c	 add	 esi, 12			; 0000000cH
  00750	2b fb		 sub	 edi, ebx
  00752	75 ac		 jne	 SHORT $LL8@PChatProc
  00754	5b		 pop	 ebx
  00755	5f		 pop	 edi
  00756	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  00757	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0075a	33 cd		 xor	 ecx, ebp
  0075c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00761	8b e5		 mov	 esp, ebp
  00763	5d		 pop	 ebp
  00764	c3		 ret	 0
$LN9@PChatProc:

; 1968 : 						}
; 1969 : 					}
; 1970 : 				}
; 1971 : 			}
; 1972 : 		}
; 1973 : 		else
; 1974 : 		{
; 1975 : 			MsgSendV2(lpObj,(LPBYTE)lpChat,lpChat->h.size);

  00765	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  00769	50		 push	 eax
  0076a	57		 push	 edi
  0076b	56		 push	 esi
  0076c	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00771	83 c4 0c	 add	 esp, 12			; 0000000cH
  00774	5b		 pop	 ebx
  00775	5f		 pop	 edi
  00776	5e		 pop	 esi

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  00777	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0077a	33 cd		 xor	 ecx, ebp
  0077c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00781	8b e5		 mov	 esp, ebp
  00783	5d		 pop	 ebp
  00784	c3		 ret	 0
$LN57@PChatProc:

; 1776 : 	{
; 1777 : 		if ( lpObj->PartyNumber >= 0 )

  00785	8b 82 0c 06 00
	00		 mov	 eax, DWORD PTR [edx+1548]
  0078b	85 c0		 test	 eax, eax
  0078d	78 50		 js	 SHORT $LN111@PChatProc

; 1778 : 		{
; 1779 : 			int partycount = gParty.GetPartyCount(lpObj->PartyNumber);

  0078f	50		 push	 eax
  00790	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00795	e8 00 00 00 00	 call	 ?GetPartyCount@PartyClass@@QAEHH@Z ; PartyClass::GetPartyCount

; 1780 : 
; 1781 : 			if ( partycount >= 0 )

  0079a	85 c0		 test	 eax, eax
  0079c	78 41		 js	 SHORT $LN111@PChatProc

; 1782 : 			{
; 1783 : 				for (n=0;n<MAX_USER_IN_PARTY;n++ )

  0079e	8b 9d 64 fe ff
	ff		 mov	 ebx, DWORD PTR _lpChat$GSCopy$[ebp]
  007a4	8b bd 68 fe ff
	ff		 mov	 edi, DWORD PTR tv610[ebp]
  007aa	33 f6		 xor	 esi, esi
  007ac	8d 64 24 00	 npad	 4
$LL110@PChatProc:

; 1784 : 				{
; 1785 : 					number = gParty.m_PartyS[lpObj->PartyNumber].Number[n];

  007b0	8b 87 0c 06 00
	00		 mov	 eax, DWORD PTR [edi+1548]
  007b6	8b c8		 mov	 ecx, eax
  007b8	c1 e1 04	 shl	 ecx, 4
  007bb	2b c8		 sub	 ecx, eax
  007bd	03 ce		 add	 ecx, esi
  007bf	8b 04 8d 0c 00
	00 00		 mov	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[ecx*4+12]

; 1786 : 
; 1787 : 					if ( number >= 0 )

  007c6	85 c0		 test	 eax, eax
  007c8	78 0f		 js	 SHORT $LN53@PChatProc

; 1788 : 					{
; 1789 : 						DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  007ca	0f b6 53 01	 movzx	 edx, BYTE PTR [ebx+1]
  007ce	52		 push	 edx
  007cf	53		 push	 ebx
  007d0	50		 push	 eax
  007d1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  007d6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN53@PChatProc:

; 1782 : 			{
; 1783 : 				for (n=0;n<MAX_USER_IN_PARTY;n++ )

  007d9	46		 inc	 esi
  007da	83 fe 05	 cmp	 esi, 5
  007dd	7c d1		 jl	 SHORT $LL110@PChatProc
$LN111@PChatProc:
  007df	5b		 pop	 ebx
$LN52@PChatProc:

; 1976 : 		}
; 1977 : #else
; 1978 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1980 : #endif
; 1981 : 	}
; 1982 : }							

  007e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007e3	5f		 pop	 edi
  007e4	33 cd		 xor	 ecx, ebp
  007e6	5e		 pop	 esi
  007e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007ec	8b e5		 mov	 esp, ebp
  007ee	5d		 pop	 ebp
  007ef	c3		 ret	 0
?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z ENDP		; PChatProc
_TEXT	ENDS
PUBLIC	??_C@_0L@HMJAEILC@1111111111?$AA@		; `string'
PUBLIC	??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@ ; `string'
PUBLIC	??_C@_0BM@BJHJAKKO@?$FL0xBF?$FN?5Unknown?5packet?5BF?3?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ProtocolCore@@YAXEPAEHHHH@Z			; ProtocolCore
EXTRN	?CGReqGetMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEXPAUPMSG_REQ_MASTERLEVEL_SKILL@@H@Z:PROC ; CMasterLevelSkillTreeSystem::CGReqGetMasterLevelSkill
EXTRN	?gObjMoveDataLoadingOK@@YAXH@Z:PROC		; gObjMoveDataLoadingOK
EXTRN	?DataServerGetCharListRequest@@YAXF@Z:PROC	; DataServerGetCharListRequest
EXTRN	?SendGensInfo@CGensSystem@@QAEXH@Z:PROC		; CGensSystem::SendGensInfo
EXTRN	?CGRequestPrize@CGensSystem@@QAEXPAEH@Z:PROC	; CGensSystem::CGRequestPrize
EXTRN	?CGLeaveRequest@CGensSystem@@QAEXH@Z:PROC	; CGensSystem::CGLeaveRequest
EXTRN	?CGJoinRequest@CGensSystem@@QAEXPAEH@Z:PROC	; CGensSystem::CGJoinRequest
EXTRN	?GCSendBuff@CQuestInfoEx@@QAEXH@Z:PROC		; CQuestInfoEx::GCSendBuff
EXTRN	?GCSendAvaibleQuest@CQuestInfoEx@@QAEXH@Z:PROC	; CQuestInfoEx::GCSendAvaibleQuest
EXTRN	?CGReqQuestInfo@CQuestInfoEx@@QAEXPAEH@Z:PROC	; CQuestInfoEx::CGReqQuestInfo
EXTRN	?CGRequestQuestState@CQuestInfoEx@@QAEXH@Z:PROC	; CQuestInfoEx::CGRequestQuestState
EXTRN	?CGClientAction@CQuestInfoEx@@QAEXPAEH@Z:PROC	; CQuestInfoEx::CGClientAction
EXTRN	?CGQuitQuest@CQuestInfoEx@@QAEXPAEH@Z:PROC	; CQuestInfoEx::CGQuitQuest
EXTRN	?CGQuestComplete@CQuestInfoEx@@QAEXPAEH@Z:PROC	; CQuestInfoEx::CGQuestComplete
EXTRN	?CGRequestQuestStep@CQuestInfoEx@@QAEXPAEH@Z:PROC ; CQuestInfoEx::CGRequestQuestStep
EXTRN	?CGRequestInitQuest@CQuestInfoEx@@QAEXPAEH@Z:PROC ; CQuestInfoEx::CGRequestInitQuest
EXTRN	?gQuestInfoEx@@3VCQuestInfoEx@@A:BYTE		; gQuestInfoEx
EXTRN	?CGReqUseItem@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPSMG_REQ_CASHITEM_USE@@@Z:PROC ; CCashShop::CGReqUseItem
EXTRN	?CGReqInfo@CCashShop@@QAEHPAEH@Z:PROC		; CCashShop::CGReqInfo
EXTRN	?CGCashGiftSend@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z:PROC ; CCashShop::CGCashGiftSend
EXTRN	?CGCashItemBuy@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z:PROC ; CCashShop::CGCashItemBuy
EXTRN	?CGCashShopOpen@CCashShop@@QAEHPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHSHOPOPEN@@@Z:PROC ; CCashShop::CGCashShopOpen
EXTRN	?CGCashPoint@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CCashShop::CGCashPoint
EXTRN	?FriendRoomInvitationReq@@YAXPAUPMSG_ROOM_INVITATION@@H@Z:PROC ; FriendRoomInvitationReq
EXTRN	?FriendChatRoomCreateReq@@YAXPAUPMSG_FRIEND_ROOMCREATE_REQ@@H@Z:PROC ; FriendChatRoomCreateReq
EXTRN	?FriendMemoListReq@@YAXH@Z:PROC			; FriendMemoListReq
EXTRN	?FriendMemoDelReq@@YAXPAUPMSG_FRIEND_MEMO_DEL_REQ@@H@Z:PROC ; FriendMemoDelReq
EXTRN	?FriendMemoReadReq@@YAXPAUPMSG_FRIEND_READ_MEMO_REQ@@H@Z:PROC ; FriendMemoReadReq
EXTRN	?FriendMemoSend@@YAXPAUPMSG_FRIEND_MEMO@@H@Z:PROC ; FriendMemoSend
EXTRN	?FriendStateClientRecv@@YAXPAUPMSG_FRIEND_STATE_C@@H@Z:PROC ; FriendStateClientRecv
EXTRN	?FriendDelRequest@@YAXPAUPMSG_FRIEND_DEL_REQ@@H@Z:PROC ; FriendDelRequest
EXTRN	?WaitFriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_SIN_RESULT@@H@Z:PROC ; WaitFriendAddRequest
EXTRN	?FriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_REQ@@H@Z:PROC ; FriendAddRequest
EXTRN	?FriendListRequest@@YAXH@Z:PROC			; FriendListRequest
EXTRN	?OnDuelChannelLeave@@YAHPAU_tagPMSG_REQ_DUEL_LEAVECNANNEL@@H@Z:PROC ; OnDuelChannelLeave
EXTRN	?OnDuelChannelJoin@@YAHPAU_tagPMSG_REQ_DUEL_JOINCNANNEL@@H@Z:PROC ; OnDuelChannelJoin
EXTRN	?OnCGLeaveDuel@@YAHPAU_tagPMSG_REQ_DUEL_EXIT@@H@Z:PROC ; OnCGLeaveDuel
EXTRN	?OnCGAnswerDuel@@YAHPAU_tagPMSG_ANS_DUEL_ANSWER@@H@Z:PROC ; OnCGAnswerDuel
EXTRN	?OnCGInviteDuel@@YAHPAU_tagPMSG_REQ_DUEL_INVITE@@H@Z:PROC ; OnCGInviteDuel
EXTRN	?CGReqPartyMatchCancel@@YAXPAUPMSG_PARTYMATCH_CANCEL_REQ@@H@Z:PROC ; CGReqPartyMatchCancel
EXTRN	?CGReqPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_CGREQ_REQUESTANSWER@@H@Z:PROC ; CGReqPartyMatchRequestAnswer
EXTRN	?CGReqPartyMatchAcceptList@@YAXH@Z:PROC		; CGReqPartyMatchAcceptList
EXTRN	?CGReqPartyMatchWaitingList@@YAXH@Z:PROC	; CGReqPartyMatchWaitingList
EXTRN	?CGReqPartyMatchJoin@@YAXPAUPMSG_PARTYMATCH_JOIN_REQ@@H@Z:PROC ; CGReqPartyMatchJoin
EXTRN	?CGReqPartyMatchWindow@@YAXPAUPMSG_PARTYMATCH_INFO_REQ@@H@Z:PROC ; CGReqPartyMatchWindow
EXTRN	?CGReqPartyMatchReg@@YAXPAUPMSG_PARTYMATCH_REG_REQ@@H@Z:PROC ; CGReqPartyMatchReg
EXTRN	?CG_RequestStart@ResetSystem@@QAEXHPAUPacketResetStart@@@Z:PROC ; ResetSystem::CG_RequestStart
EXTRN	?g_ResetSystem@@3VResetSystem@@A:BYTE		; g_ResetSystem
EXTRN	?CGReqJoinReqStatus@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQSTATUS@@@Z:PROC ; GuildMatch::CGReqJoinReqStatus
EXTRN	?CGReqJoinReqList@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_REQUESTLIST@@@Z:PROC ; GuildMatch::CGReqJoinReqList
EXTRN	?CGReqJoinReqAnswer@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_REQUESTANSWER@@@Z:PROC ; GuildMatch::CGReqJoinReqAnswer
EXTRN	?CGReqJoinReqDelete@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQDELETE@@@Z:PROC ; GuildMatch::CGReqJoinReqDelete
EXTRN	?CGReqJoinReq@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQ@@@Z:PROC ; GuildMatch::CGReqJoinReq
EXTRN	?CGReqOfferDelete@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERDELETE@@@Z:PROC ; GuildMatch::CGReqOfferDelete
EXTRN	?CGReqOfferCreate@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERCREATE@@@Z:PROC ; GuildMatch::CGReqOfferCreate
EXTRN	?CGReqOfferListByFilter@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERLISTFILTER@@@Z:PROC ; GuildMatch::CGReqOfferListByFilter
EXTRN	?CGReqOfferList@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERLIST@@@Z:PROC ; GuildMatch::CGReqOfferList
EXTRN	?g_GuildMatch@@3VGuildMatch@@A:BYTE		; g_GuildMatch
EXTRN	?CGReqItemSearch@ShopBoard@@QAEXHPAUSHOPBOARD_CGREQ_ITEM@@@Z:PROC ; ShopBoard::CGReqItemSearch
EXTRN	?g_ShopBoard@@3VShopBoard@@A:DWORD		; g_ShopBoard
EXTRN	?CGUpgradeButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_LEVELUP@@H@Z:PROC ; CElementalSystem::CGUpgradeButtonClick
EXTRN	?CGCombineButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_COMBINE@@H@Z:PROC ; CElementalSystem::CGCombineButtonClick
EXTRN	?CGRemoveErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_REMOVEERTEL@@@Z:PROC ; CElementalSystem::CGRemoveErtel
EXTRN	?CGInsertErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_INSERTERTEL@@@Z:PROC ; CElementalSystem::CGInsertErtel
EXTRN	?CGReqSendMemberPosInfoStart@Minimap@@QAEXH@Z:PROC ; Minimap::CGReqSendMemberPosInfoStart
EXTRN	?CGReqSendMemberPosInfoStop@Minimap@@QAEXH@Z:PROC ; Minimap::CGReqSendMemberPosInfoStop
EXTRN	?GCReqSendNpcPosInfo@Minimap@@QAEXPAU_PMSG_REQ_NPC_POSITION@@H@Z:PROC ; Minimap::GCReqSendNpcPosInfo
EXTRN	?g_Minimap@@3VMinimap@@A:BYTE			; g_Minimap
EXTRN	?CGMiningRequest@@YAXPAUPMSG_MINING_REQUEST@@H@Z:PROC ; CGMiningRequest
EXTRN	?CGRewardRequest@@YAXPAUPMSG_MINING_REWARD_REQUEST@@H@Z:PROC ; CGRewardRequest
EXTRN	?CGMiningEnd@@YAXPAUPMSG_MINING_END@@H@Z:PROC	; CGMiningEnd
EXTRN	?GetSerial@NSerialCheck@@QAEHXZ:PROC		; NSerialCheck::GetSerial
EXTRN	?InCheck@NSerialCheck@@QAEHE@Z:PROC		; NSerialCheck::InCheck
EXTRN	?gNSerialCheck@@3PAVNSerialCheck@@A:BYTE	; gNSerialCheck
EXTRN	?LogAddHeadHex@@3P6AXPAD0H@ZA:DWORD		; LogAddHeadHex
EXTRN	?gStalkProtocolId@@3PADA:BYTE			; gStalkProtocolId
EXTRN	?gStalkProtocol@@3HA:DWORD			; gStalkProtocol
;	COMDAT ??_C@_0L@HMJAEILC@1111111111?$AA@
CONST	SEGMENT
??_C@_0L@HMJAEILC@1111111111?$AA@ DB '1111111111', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@
CONST	SEGMENT
??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@ DB 'er'
	DB	'ror-L2 : account:%s name:%s HEAD:%x (%s,%d) State:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BJHJAKKO@?$FL0xBF?$FN?5Unknown?5packet?5BF?3?$CFd?$AA@
CONST	SEGMENT
??_C@_0BM@BJHJAKKO@?$FL0xBF?$FN?5Unknown?5packet?5BF?3?$CFd?$AA@ DB '[0xB'
	DB	'F] Unknown packet BF:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@
CONST	SEGMENT
??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@ DB 'Er'
	DB	'ror-L1 : Socket Serial %s %d o_serial:%d serial:%d ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ProtocolCore@@YAXEPAEHHHH@Z
_TEXT	SEGMENT
tv1089 = -48						; size = 4
tv1108 = -44						; size = 4
_res$216758 = -44					; size = 5
_res$216750 = -36					; size = 30
_pMsg$216306 = -32					; size = 25
_res$216743 = -24					; size = 17
_res$216731 = -24					; size = 17
__$ArrayPad$ = -4					; size = 4
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
_aIndex$ = 20						; size = 4
_Encrypt$ = 24						; size = 4
_serial$ = 28						; size = 4
?ProtocolCore@@YAXEPAEHHHH@Z PROC			; ProtocolCore, COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 146  : 	// Check if we wanna log the packets
; 147  : 	if ( gStalkProtocol )

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gStalkProtocol@@3HA, 0 ; gStalkProtocol
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	8b 75 14	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001c	57		 push	 edi
  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _aRecv$[ebp]
  00020	74 66		 je	 SHORT $LN348@ProtocolCo

; 148  : 	{
; 149  : 		if ( gStalkProtocolId[0] == gObj[aIndex].AccountID[0] )

  00022	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ?gStalkProtocolId@@3PADA
  00028	8b c6		 mov	 eax, esi
  0002a	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00030	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	3a 50 52	 cmp	 dl, BYTE PTR [eax+82]
  00039	8d 58 52	 lea	 ebx, DWORD PTR [eax+82]
  0003c	75 4a		 jne	 SHORT $LN348@ProtocolCo

; 150  : 		{
; 151  : 			if ( gStalkProtocolId[1] == gObj[aIndex].AccountID[1] )

  0003e	8a 0d 01 00 00
	00		 mov	 cl, BYTE PTR ?gStalkProtocolId@@3PADA+1
  00044	3a 48 53	 cmp	 cl, BYTE PTR [eax+83]
  00047	75 3f		 jne	 SHORT $LN348@ProtocolCo

; 152  : 			{
; 153  : 				if ( !strcmp(gStalkProtocolId, gObj[aIndex].AccountID ) )

  00049	8b cb		 mov	 ecx, ebx
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET ?gStalkProtocolId@@3PADA ; gStalkProtocolId
$LL352@ProtocolCo:
  00050	8a 10		 mov	 dl, BYTE PTR [eax]
  00052	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00054	75 1a		 jne	 SHORT $LN353@ProtocolCo
  00056	84 d2		 test	 dl, dl
  00058	74 12		 je	 SHORT $LN339@ProtocolCo
  0005a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0005d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00060	75 0e		 jne	 SHORT $LN353@ProtocolCo
  00062	83 c0 02	 add	 eax, 2
  00065	83 c1 02	 add	 ecx, 2
  00068	84 d2		 test	 dl, dl
  0006a	75 e4		 jne	 SHORT $LL352@ProtocolCo
$LN339@ProtocolCo:
  0006c	33 c0		 xor	 eax, eax
  0006e	eb 05		 jmp	 SHORT $LN340@ProtocolCo
$LN353@ProtocolCo:
  00070	1b c0		 sbb	 eax, eax
  00072	83 d8 ff	 sbb	 eax, -1
$LN340@ProtocolCo:
  00075	85 c0		 test	 eax, eax
  00077	75 0f		 jne	 SHORT $LN348@ProtocolCo

; 154  : 				{
; 155  : 					LogAddHeadHex(gObj[aIndex].AccountID, (char*)aRecv, aLen);

  00079	8b 55 10	 mov	 edx, DWORD PTR _aLen$[ebp]
  0007c	52		 push	 edx
  0007d	57		 push	 edi
  0007e	53		 push	 ebx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddHeadHex@@3P6AXPAD0H@ZA ; LogAddHeadHex
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN348@ProtocolCo:

; 156  : 				}
; 157  : 			}
; 158  : 		}
; 159  : 	}	// ig gStalkProtocol
; 160  : 
; 161  : 	// Serial Checking
; 162  : 	if ( serial >= 0 )

  00088	83 7d 1c 00	 cmp	 DWORD PTR _serial$[ebp], 0
  0008c	8b 5d 08	 mov	 ebx, DWORD PTR _protoNum$[ebp]
  0008f	7c 63		 jl	 SHORT $LN349@ProtocolCo

; 163  : 	{
; 164  : 		if ( gObj[aIndex].Type == OBJ_USER )

  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00097	8b c6		 mov	 eax, esi
  00099	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0009f	80 7c 08 50 01	 cmp	 BYTE PTR [eax+ecx+80], 1
  000a4	89 45 d0	 mov	 DWORD PTR tv1089[ebp], eax
  000a7	75 4b		 jne	 SHORT $LN349@ProtocolCo

; 165  : 		{
; 166  : 			if ( gNSerialCheck[aIndex].InCheck(serial) == FALSE )

  000a9	8b 55 1c	 mov	 edx, DWORD PTR _serial$[ebp]
  000ac	8d 0c f5 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[esi*8]
  000b3	52		 push	 edx
  000b4	e8 00 00 00 00	 call	 ?InCheck@NSerialCheck@@QAEHE@Z ; NSerialCheck::InCheck
  000b9	85 c0		 test	 eax, eax
  000bb	75 37		 jne	 SHORT $LN349@ProtocolCo

; 167  : 			{
; 168  : 				LogAdd("Error-L1 : Socket Serial %s %d o_serial:%d serial:%d ",
; 169  : 					gObj[aIndex].AccountID, protoNum, gNSerialCheck[aIndex].GetSerial(), serial);

  000bd	8b 45 1c	 mov	 eax, DWORD PTR _serial$[ebp]
  000c0	50		 push	 eax
  000c1	8d 0c f5 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[esi*8]
  000c8	e8 00 00 00 00	 call	 ?GetSerial@NSerialCheck@@QAEHXZ ; NSerialCheck::GetSerial
  000cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d3	50		 push	 eax
  000d4	8b 45 d0	 mov	 eax, DWORD PTR tv1089[ebp]
  000d7	0f b6 cb	 movzx	 ecx, bl
  000da	51		 push	 ecx
  000db	8d 4c 10 52	 lea	 ecx, DWORD PTR [eax+edx+82]
  000df	51		 push	 ecx
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 170  : 
; 171  : 				CloseClient(aIndex);

  000eb	56		 push	 esi
  000ec	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000f1	83 c4 18	 add	 esp, 24			; 00000018H
$LN349@ProtocolCo:

; 172  : 			}
; 173  : 		}
; 174  : 	}	// if Serial Checking
; 175  : 
; 176  : 	if ( protoNum == 0xF1 || protoNum == 0xF3 )

  000f4	80 fb f1	 cmp	 bl, 241			; 000000f1H
  000f7	0f 84 cf 18 00
	00		 je	 $LN317@ProtocolCo
  000fd	80 fb f3	 cmp	 bl, 243			; 000000f3H
  00100	0f 84 c6 18 00
	00		 je	 $LN317@ProtocolCo

; 272  : 							break;
; 273  : 					}
; 274  : 				}
; 275  : 				break;
; 276  : 		}
; 277  : 	}
; 278  : 	else
; 279  : 	{
; 280  : 		LPOBJ lpObj = &gObj[aIndex];

  00106	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010c	8b c6		 mov	 eax, esi
  0010e	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00114	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 281  : 
; 282  : #if( DEBUG_PROTOCOL == 1 )
; 283  : 		LogAddHeadHexFunc(1, (LPSTR)aRecv, aLen);
; 284  : #endif
; 285  : 
; 286  : 		switch ( protoNum )

  00117	0f b6 d3	 movzx	 edx, bl
  0011a	89 45 d0	 mov	 DWORD PTR tv1089[ebp], eax
  0011d	89 55 d4	 mov	 DWORD PTR tv1108[ebp], edx
  00120	81 fa fe 00 00
	00		 cmp	 edx, 254		; 000000feH
  00126	0f 87 62 18 00
	00		 ja	 $LN1@ProtocolCo
  0012c	0f b6 92 00 00
	00 00		 movzx	 edx, BYTE PTR $LN341@ProtocolCo[edx]
  00133	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN357@ProtocolCo[edx*4]
$LN286@ProtocolCo:

; 287  : 		{
; 288  : 			case 0x00:
; 289  : 				tempindex = aIndex;
; 290  : 				PChatProc((PMSG_CHATDATA *)aRecv, aIndex);

  0013a	56		 push	 esi
  0013b	57		 push	 edi
  0013c	89 35 00 00 00
	00		 mov	 DWORD PTR ?tempindex@@3HA, esi ; tempindex
  00142	e8 00 00 00 00	 call	 ?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z ; PChatProc
  00147	83 c4 08	 add	 esp, 8
  0014a	5f		 pop	 edi
  0014b	5e		 pop	 esi
  0014c	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0014d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00150	33 cd		 xor	 ecx, ebp
  00152	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c3		 ret	 0
$LN285@ProtocolCo:

; 291  : 				break;
; 292  : 			case 0x01:
; 293  : 				CGChatRecv((PMSG_CHATDATA_NUMBER *)aRecv, aIndex);

  0015b	56		 push	 esi
  0015c	57		 push	 edi
  0015d	e8 00 00 00 00	 call	 ?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z ; CGChatRecv
  00162	83 c4 08	 add	 esp, 8
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00168	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016b	33 cd		 xor	 ecx, ebp
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
$LN284@ProtocolCo:

; 294  : 				break;
; 295  : 			case 0x02:
; 296  : 				CGChatWhisperRecv((PMSG_CHATDATA_WHISPER *)aRecv, aIndex);

  00176	56		 push	 esi
  00177	57		 push	 edi
  00178	e8 00 00 00 00	 call	 ?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ; CGChatWhisperRecv
  0017d	83 c4 08	 add	 esp, 8
  00180	5f		 pop	 edi
  00181	5e		 pop	 esi
  00182	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00183	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00186	33 cd		 xor	 ecx, ebp
  00188	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
$LN283@ProtocolCo:

; 297  : 				break;
; 298  : 			case 0x03:
; 299  : 				CGCheckMainRecv((PMSG_CHECK_MAINEXE_RESULT *)aRecv, aIndex);

  00191	56		 push	 esi
  00192	57		 push	 edi
  00193	e8 00 00 00 00	 call	 ?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ; CGCheckMainRecv
  00198	83 c4 08	 add	 esp, 8
  0019b	5f		 pop	 edi
  0019c	5e		 pop	 esi
  0019d	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0019e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a1	33 cd		 xor	 ecx, ebp
  001a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
$LN281@ProtocolCo:

; 300  : 				break;
; 301  : 			case 0x04:
; 302  : 				break;
; 303  : 			case 0x0E:
; 304  : 				CGLiveClient((PMSG_CLIENTTIME *)aRecv, aIndex);

  001ac	56		 push	 esi
  001ad	57		 push	 edi
  001ae	e8 00 00 00 00	 call	 ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ; CGLiveClient
  001b3	83 c4 08	 add	 esp, 8
  001b6	5f		 pop	 edi
  001b7	5e		 pop	 esi
  001b8	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  001b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bc	33 cd		 xor	 ecx, ebp
  001be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c3	8b e5		 mov	 esp, ebp
  001c5	5d		 pop	 ebp
  001c6	c3		 ret	 0
$LN280@ProtocolCo:

; 305  : 				break;
; 306  : 				
; 307  : #if (__ENG__ == 1)
; 308  : 			case 0xD4:
; 309  : #else
; 310  : 			// KOR PROTOCOL !!!
; 311  : 			case 0xD7:
; 312  : #endif
; 313  : 				PMoveProc((PMSG_MOVE *)aRecv, aIndex);

  001c7	56		 push	 esi
  001c8	57		 push	 edi
  001c9	e8 00 00 00 00	 call	 ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ; PMoveProc
  001ce	83 c4 08	 add	 esp, 8
  001d1	5f		 pop	 edi
  001d2	5e		 pop	 esi
  001d3	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  001d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d7	33 cd		 xor	 ecx, ebp
  001d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001de	8b e5		 mov	 esp, ebp
  001e0	5d		 pop	 ebp
  001e1	c3		 ret	 0
$LN279@ProtocolCo:

; 314  : 				break;	
; 315  : #if (__ENG__ == 1)
; 316  : 			case 0x15:// ENG PROTOCOL !!!
; 317  : #else
; 318  : 			case 0x10:// KOR PROTOCOL !!!
; 319  : #endif
; 320  : 				RecvPositionSetProc((PMSG_POSISTION_SET *)aRecv, aIndex);

  001e2	56		 push	 esi
  001e3	57		 push	 edi
  001e4	e8 00 00 00 00	 call	 ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
  001e9	83 c4 08	 add	 esp, 8
  001ec	5f		 pop	 edi
  001ed	5e		 pop	 esi
  001ee	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  001ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f2	33 cd		 xor	 ecx, ebp
  001f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c3		 ret	 0
$LN278@ProtocolCo:

; 321  : 				break;
; 322  : #if (__ENG__ == 1)
; 323  : 			case 0x11:	// ENG PROTOCOL !!!
; 324  : #else
; 325  : 			case 0xDF:	// KOR PROTOCOL !!!
; 326  : #endif
; 327  : 				CGAttack((PMSG_ATTACK *)aRecv, aIndex);

  001fd	56		 push	 esi
  001fe	57		 push	 edi
  001ff	e8 00 00 00 00	 call	 ?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z ; CGAttack
  00204	83 c4 08	 add	 esp, 8
  00207	5f		 pop	 edi
  00208	5e		 pop	 esi
  00209	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0020a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020d	33 cd		 xor	 ecx, ebp
  0020f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	c3		 ret	 0
$LN277@ProtocolCo:

; 328  : 				break;
; 329  : 			case 0x18:
; 330  : 				CGActionRecv((PMSG_ACTION *)aRecv, aIndex);

  00218	56		 push	 esi
  00219	57		 push	 edi
  0021a	e8 00 00 00 00	 call	 ?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z ; CGActionRecv
  0021f	83 c4 08	 add	 esp, 8
  00222	5f		 pop	 edi
  00223	5e		 pop	 esi
  00224	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00225	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00228	33 cd		 xor	 ecx, ebp
  0022a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c3		 ret	 0
$LN276@ProtocolCo:

; 331  : 				break;
; 332  : 			case 0x19:
; 333  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00233	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  00236	50		 push	 eax
  00237	53		 push	 ebx
  00238	56		 push	 esi
  00239	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0023e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00241	85 c0		 test	 eax, eax
  00243	0f 84 d8 19 00
	00		 je	 $LN313@ProtocolCo

; 334  : 				{
; 335  : 					CGMagicAttack((PMSG_MAGICATTACK *)aRecv, aIndex);

  00249	56		 push	 esi
  0024a	57		 push	 edi
  0024b	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  00250	83 c4 08	 add	 esp, 8
  00253	5f		 pop	 edi
  00254	5e		 pop	 esi
  00255	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00256	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00259	33 cd		 xor	 ecx, ebp
  0025b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c3		 ret	 0
$LN274@ProtocolCo:

; 336  : 				}
; 337  : 				break;
; 338  : 			case 0x1B:
; 339  : 				CGMagicCancel((PMSG_MAGICCANCEL *)aRecv, aIndex);

  00264	56		 push	 esi
  00265	57		 push	 edi
  00266	e8 00 00 00 00	 call	 ?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z ; CGMagicCancel
  0026b	83 c4 08	 add	 esp, 8
  0026e	5f		 pop	 edi
  0026f	5e		 pop	 esi
  00270	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00271	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00274	33 cd		 xor	 ecx, ebp
  00276	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027b	8b e5		 mov	 esp, ebp
  0027d	5d		 pop	 ebp
  0027e	c3		 ret	 0
$LN273@ProtocolCo:

; 340  : 				break;
; 341  : 			case 0x1C:
; 342  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0027f	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  00282	51		 push	 ecx
  00283	53		 push	 ebx
  00284	56		 push	 esi
  00285	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0028a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028d	85 c0		 test	 eax, eax
  0028f	0f 84 8c 19 00
	00		 je	 $LN313@ProtocolCo

; 343  : 				{
; 344  : 					CGTeleportRecv((PMSG_TELEPORT *)aRecv, aIndex);

  00295	56		 push	 esi
  00296	57		 push	 edi
  00297	e8 00 00 00 00	 call	 ?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z ; CGTeleportRecv
  0029c	83 c4 08	 add	 esp, 8
  0029f	5f		 pop	 edi
  002a0	5e		 pop	 esi
  002a1	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  002a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a5	33 cd		 xor	 ecx, ebp
  002a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ac	8b e5		 mov	 esp, ebp
  002ae	5d		 pop	 ebp
  002af	c3		 ret	 0
$LN271@ProtocolCo:

; 345  : 				}
; 346  : 				break;
; 347  : 			case 0xB0:
; 348  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  002b0	8b 55 18	 mov	 edx, DWORD PTR _Encrypt$[ebp]
  002b3	52		 push	 edx
  002b4	53		 push	 ebx
  002b5	56		 push	 esi
  002b6	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  002bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  002be	85 c0		 test	 eax, eax
  002c0	0f 84 5b 19 00
	00		 je	 $LN313@ProtocolCo

; 349  : 				{
; 350  : 					CGTargetTeleportRecv((PMSG_TARGET_TELEPORT *)aRecv, aIndex);

  002c6	56		 push	 esi
  002c7	57		 push	 edi
  002c8	e8 00 00 00 00	 call	 ?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ; CGTargetTeleportRecv
  002cd	83 c4 08	 add	 esp, 8
  002d0	5f		 pop	 edi
  002d1	5e		 pop	 esi
  002d2	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  002d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d6	33 cd		 xor	 ecx, ebp
  002d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002dd	8b e5		 mov	 esp, ebp
  002df	5d		 pop	 ebp
  002e0	c3		 ret	 0
$LN269@ProtocolCo:

; 351  : 				}
; 352  : 				break;
; 353  : 				
; 354  : #if (__ENG__ == 1)
; 355  : 			case 0xDB:// ENG PROTOCOL
; 356  : #else
; 357  : 			case 0xD3: // KOR PROTOCOL
; 358  : #endif
; 359  : 				CGBeattackRecv(aRecv, aIndex, FALSE);

  002e1	6a 00		 push	 0
  002e3	56		 push	 esi
  002e4	57		 push	 edi
  002e5	e8 00 00 00 00	 call	 ?CGBeattackRecv@@YAXPAEHH@Z ; CGBeattackRecv
  002ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ed	5f		 pop	 edi
  002ee	5e		 pop	 esi
  002ef	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  002f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f3	33 cd		 xor	 ecx, ebp
  002f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002fa	8b e5		 mov	 esp, ebp
  002fc	5d		 pop	 ebp
  002fd	c3		 ret	 0
$LN268@ProtocolCo:

; 360  : 				break;
; 361  : 			case 0x1E:
; 362  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  002fe	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  00301	50		 push	 eax
  00302	53		 push	 ebx
  00303	56		 push	 esi
  00304	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00309	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030c	85 c0		 test	 eax, eax
  0030e	0f 84 0d 19 00
	00		 je	 $LN313@ProtocolCo

; 363  : 				{
; 364  : 					CGDurationMagicRecv((PMSG_DURATION_MAGIC_RECV *)aRecv, aIndex);

  00314	56		 push	 esi
  00315	57		 push	 edi
  00316	e8 00 00 00 00	 call	 ?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ; CGDurationMagicRecv
  0031b	83 c4 08	 add	 esp, 8
  0031e	5f		 pop	 edi
  0031f	5e		 pop	 esi
  00320	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00321	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00324	33 cd		 xor	 ecx, ebp
  00326	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032b	8b e5		 mov	 esp, ebp
  0032d	5d		 pop	 ebp
  0032e	c3		 ret	 0
$LN266@ProtocolCo:

; 365  : 				}
; 366  : 				break;
; 367  : 			case 0x22:
; 368  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0032f	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  00332	51		 push	 ecx
  00333	53		 push	 ebx
  00334	56		 push	 esi
  00335	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0033a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0033d	85 c0		 test	 eax, eax
  0033f	0f 84 dc 18 00
	00		 je	 $LN313@ProtocolCo

; 369  : 				{
; 370  : 					CGItemGetRequest((PMSG_ITEMGETREQUEST *)aRecv, aIndex);

  00345	56		 push	 esi
  00346	57		 push	 edi
  00347	e8 00 00 00 00	 call	 ?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ; CGItemGetRequest
  0034c	83 c4 08	 add	 esp, 8
  0034f	5f		 pop	 edi
  00350	5e		 pop	 esi
  00351	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00352	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00355	33 cd		 xor	 ecx, ebp
  00357	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035c	8b e5		 mov	 esp, ebp
  0035e	5d		 pop	 ebp
  0035f	c3		 ret	 0
$LN264@ProtocolCo:

; 371  : 				}
; 372  : 				break;
; 373  : 			case 0x23:
; 374  : 				CGItemDropRequest((PMSG_ITEMTHROW *)aRecv, aIndex, 0);

  00360	6a 00		 push	 0
  00362	56		 push	 esi
  00363	57		 push	 edi
  00364	e8 00 00 00 00	 call	 ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ; CGItemDropRequest
  00369	83 c4 0c	 add	 esp, 12			; 0000000cH
  0036c	5f		 pop	 edi
  0036d	5e		 pop	 esi
  0036e	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0036f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00372	33 cd		 xor	 ecx, ebp
  00374	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00379	8b e5		 mov	 esp, ebp
  0037b	5d		 pop	 ebp
  0037c	c3		 ret	 0
$LN263@ProtocolCo:

; 375  : 				break;
; 376  : 			case 0x24:
; 377  : 				CGInventoryItemMove((PMSG_INVENTORYITEMMOVE *)aRecv, aIndex);

  0037d	56		 push	 esi
  0037e	57		 push	 edi
  0037f	e8 00 00 00 00	 call	 ?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ; CGInventoryItemMove
  00384	83 c4 08	 add	 esp, 8
  00387	5f		 pop	 edi
  00388	5e		 pop	 esi
  00389	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0038a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0038d	33 cd		 xor	 ecx, ebp
  0038f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00394	8b e5		 mov	 esp, ebp
  00396	5d		 pop	 ebp
  00397	c3		 ret	 0
$LN262@ProtocolCo:

; 378  : 				break;
; 379  : 			case 0x26:
; 380  : 				CGUseItemRecv((PMSG_USEITEM *)aRecv, aIndex);

  00398	56		 push	 esi
  00399	57		 push	 edi
  0039a	e8 00 00 00 00	 call	 ?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z ; CGUseItemRecv
  0039f	83 c4 08	 add	 esp, 8
  003a2	5f		 pop	 edi
  003a3	5e		 pop	 esi
  003a4	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  003a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a8	33 cd		 xor	 ecx, ebp
  003aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003af	8b e5		 mov	 esp, ebp
  003b1	5d		 pop	 ebp
  003b2	c3		 ret	 0
$LN261@ProtocolCo:

; 381  : 				break;
; 382  : 			case 0x30:
; 383  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  003b3	8b 55 18	 mov	 edx, DWORD PTR _Encrypt$[ebp]
  003b6	52		 push	 edx
  003b7	53		 push	 ebx
  003b8	56		 push	 esi
  003b9	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  003be	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c1	85 c0		 test	 eax, eax
  003c3	0f 84 58 18 00
	00		 je	 $LN313@ProtocolCo

; 384  : 				{
; 385  : 					CGTalkRequestRecv((PMSG_TALKREQUEST *)aRecv, aIndex);

  003c9	56		 push	 esi
  003ca	57		 push	 edi
  003cb	e8 00 00 00 00	 call	 ?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z ; CGTalkRequestRecv
  003d0	83 c4 08	 add	 esp, 8
  003d3	5f		 pop	 edi
  003d4	5e		 pop	 esi
  003d5	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  003d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d9	33 cd		 xor	 ecx, ebp
  003db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003e0	8b e5		 mov	 esp, ebp
  003e2	5d		 pop	 ebp
  003e3	c3		 ret	 0
$LN259@ProtocolCo:

; 386  : 				}
; 387  : 				break;
; 388  : 			case 0x31:
; 389  : 				CGCloseWindow(aIndex);

  003e4	56		 push	 esi
  003e5	e8 00 00 00 00	 call	 ?CGCloseWindow@@YAXH@Z	; CGCloseWindow
  003ea	83 c4 04	 add	 esp, 4
  003ed	5f		 pop	 edi
  003ee	5e		 pop	 esi
  003ef	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  003f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f3	33 cd		 xor	 ecx, ebp
  003f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003fa	8b e5		 mov	 esp, ebp
  003fc	5d		 pop	 ebp
  003fd	c3		 ret	 0
$LN258@ProtocolCo:

; 390  : 				break;
; 391  : 			case 0x32:
; 392  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  003fe	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  00401	50		 push	 eax
  00402	53		 push	 ebx
  00403	56		 push	 esi
  00404	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00409	83 c4 0c	 add	 esp, 12			; 0000000cH
  0040c	85 c0		 test	 eax, eax
  0040e	0f 84 0d 18 00
	00		 je	 $LN313@ProtocolCo

; 393  : 				{
; 394  : 					CGBuyRequestRecv((PMSG_BUYREQUEST *)aRecv, aIndex);

  00414	56		 push	 esi
  00415	57		 push	 edi
  00416	e8 00 00 00 00	 call	 ?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z ; CGBuyRequestRecv
  0041b	83 c4 08	 add	 esp, 8
  0041e	5f		 pop	 edi
  0041f	5e		 pop	 esi
  00420	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00421	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00424	33 cd		 xor	 ecx, ebp
  00426	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0042b	8b e5		 mov	 esp, ebp
  0042d	5d		 pop	 ebp
  0042e	c3		 ret	 0
$LN256@ProtocolCo:

; 395  : 				}
; 396  : 				break;
; 397  : 			case 0x33:
; 398  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0042f	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  00432	51		 push	 ecx
  00433	53		 push	 ebx
  00434	56		 push	 esi
  00435	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0043a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0043d	85 c0		 test	 eax, eax
  0043f	0f 84 dc 17 00
	00		 je	 $LN313@ProtocolCo

; 399  : 				{
; 400  : 					CGSellRequestRecv((PMSG_SELLREQUEST *)aRecv, aIndex);

  00445	56		 push	 esi
  00446	57		 push	 edi
  00447	e8 00 00 00 00	 call	 ?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z ; CGSellRequestRecv
  0044c	83 c4 08	 add	 esp, 8
  0044f	5f		 pop	 edi
  00450	5e		 pop	 esi
  00451	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00452	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00455	33 cd		 xor	 ecx, ebp
  00457	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045c	8b e5		 mov	 esp, ebp
  0045e	5d		 pop	 ebp
  0045f	c3		 ret	 0
$LN254@ProtocolCo:

; 401  : 				}
; 402  : 				break;
; 403  : 			case 0x34:
; 404  : 				CGModifyRequestItem((PMSG_ITEMDURREPAIR *)aRecv, aIndex);

  00460	56		 push	 esi
  00461	57		 push	 edi
  00462	e8 00 00 00 00	 call	 ?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ; CGModifyRequestItem
  00467	83 c4 08	 add	 esp, 8
  0046a	5f		 pop	 edi
  0046b	5e		 pop	 esi
  0046c	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0046d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00470	33 cd		 xor	 ecx, ebp
  00472	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00477	8b e5		 mov	 esp, ebp
  00479	5d		 pop	 ebp
  0047a	c3		 ret	 0
$LN253@ProtocolCo:

; 405  : 				break;
; 406  : 			case 0x36:
; 407  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0047b	8b 55 18	 mov	 edx, DWORD PTR _Encrypt$[ebp]
  0047e	52		 push	 edx
  0047f	53		 push	 ebx
  00480	56		 push	 esi
  00481	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00486	83 c4 0c	 add	 esp, 12			; 0000000cH
  00489	85 c0		 test	 eax, eax
  0048b	0f 84 90 17 00
	00		 je	 $LN313@ProtocolCo

; 408  : 				{
; 409  : 					CGTradeRequestSend((PMSG_TRADE_REQUEST *)aRecv, aIndex);

  00491	56		 push	 esi
  00492	57		 push	 edi
  00493	e8 00 00 00 00	 call	 ?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ; CGTradeRequestSend
  00498	83 c4 08	 add	 esp, 8
  0049b	5f		 pop	 edi
  0049c	5e		 pop	 esi
  0049d	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0049e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a1	33 cd		 xor	 ecx, ebp
  004a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a8	8b e5		 mov	 esp, ebp
  004aa	5d		 pop	 ebp
  004ab	c3		 ret	 0
$LN251@ProtocolCo:

; 410  : 				}
; 411  : 				break;
; 412  : 			case 0x37:
; 413  : 				CGTradeResponseRecv((PMSG_TRADE_RESPONSE *)aRecv, aIndex);

  004ac	56		 push	 esi
  004ad	57		 push	 edi
  004ae	e8 00 00 00 00	 call	 ?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ; CGTradeResponseRecv
  004b3	83 c4 08	 add	 esp, 8
  004b6	5f		 pop	 edi
  004b7	5e		 pop	 esi
  004b8	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  004b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004bc	33 cd		 xor	 ecx, ebp
  004be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c3	8b e5		 mov	 esp, ebp
  004c5	5d		 pop	 ebp
  004c6	c3		 ret	 0
$LN250@ProtocolCo:

; 414  : 				break;
; 415  : 			case 0x3A:
; 416  : 				CGTradeMoneyRecv((PMSG_TRADE_GOLD *)aRecv, aIndex);

  004c7	56		 push	 esi
  004c8	57		 push	 edi
  004c9	e8 00 00 00 00	 call	 ?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z ; CGTradeMoneyRecv
  004ce	83 c4 08	 add	 esp, 8
  004d1	5f		 pop	 edi
  004d2	5e		 pop	 esi
  004d3	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  004d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d7	33 cd		 xor	 ecx, ebp
  004d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004de	8b e5		 mov	 esp, ebp
  004e0	5d		 pop	 ebp
  004e1	c3		 ret	 0
$LN249@ProtocolCo:

; 417  : 				break;
; 418  : 			case 0x3C:
; 419  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  004e2	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  004e5	50		 push	 eax
  004e6	53		 push	 ebx
  004e7	56		 push	 esi
  004e8	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  004ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  004f0	85 c0		 test	 eax, eax
  004f2	0f 84 29 17 00
	00		 je	 $LN313@ProtocolCo

; 420  : 				{
; 421  : 					CGTradeOkButtonRecv((PMSG_TRADE_OKBUTTON *)aRecv, aIndex);

  004f8	56		 push	 esi
  004f9	57		 push	 edi
  004fa	e8 00 00 00 00	 call	 ?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ; CGTradeOkButtonRecv
  004ff	83 c4 08	 add	 esp, 8
  00502	5f		 pop	 edi
  00503	5e		 pop	 esi
  00504	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00505	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00508	33 cd		 xor	 ecx, ebp
  0050a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0050f	8b e5		 mov	 esp, ebp
  00511	5d		 pop	 ebp
  00512	c3		 ret	 0
$LN247@ProtocolCo:

; 422  : 				}
; 423  : 				break;
; 424  : 			case 0x3D:
; 425  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00513	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  00516	51		 push	 ecx
  00517	53		 push	 ebx
  00518	56		 push	 esi
  00519	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0051e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00521	85 c0		 test	 eax, eax
  00523	0f 84 f8 16 00
	00		 je	 $LN313@ProtocolCo

; 426  : 				{
; 427  : 					CGTradeCancelButtonRecv(aIndex);

  00529	56		 push	 esi
  0052a	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv
  0052f	83 c4 04	 add	 esp, 4
  00532	5f		 pop	 edi
  00533	5e		 pop	 esi
  00534	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00535	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00538	33 cd		 xor	 ecx, ebp
  0053a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0053f	8b e5		 mov	 esp, ebp
  00541	5d		 pop	 ebp
  00542	c3		 ret	 0
$LN245@ProtocolCo:

; 428  : 				}
; 429  : 				break;
; 430  : 			case 0x3F:
; 431  : 				{
; 432  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 433  : 
; 434  : 					switch ( lpDef->subcode )

  00543	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00547	48		 dec	 eax
  00548	83 f8 05	 cmp	 eax, 5
  0054b	0f 87 d0 16 00
	00		 ja	 $LN313@ProtocolCo
  00551	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN358@ProtocolCo[eax*4]
$LN242@ProtocolCo:

; 435  : 					{
; 436  : 						case 0x01:
; 437  : 							CGPShopReqSetItemPrice((PMSG_REQ_PSHOP_SETITEMPRICE *)aRecv, aIndex);

  00558	56		 push	 esi
  00559	57		 push	 edi
  0055a	e8 00 00 00 00	 call	 ?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ; CGPShopReqSetItemPrice
  0055f	83 c4 08	 add	 esp, 8
  00562	5f		 pop	 edi
  00563	5e		 pop	 esi
  00564	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00565	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00568	33 cd		 xor	 ecx, ebp
  0056a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0056f	8b e5		 mov	 esp, ebp
  00571	5d		 pop	 ebp
  00572	c3		 ret	 0
$LN241@ProtocolCo:

; 438  : 							break;
; 439  : 						case 0x02:
; 440  : 							CGPShopReqOpen((PMSG_REQ_PSHOP_OPEN *)aRecv, aIndex);

  00573	56		 push	 esi
  00574	57		 push	 edi
  00575	e8 00 00 00 00	 call	 ?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z ; CGPShopReqOpen
  0057a	83 c4 08	 add	 esp, 8
  0057d	5f		 pop	 edi
  0057e	5e		 pop	 esi
  0057f	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00580	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00583	33 cd		 xor	 ecx, ebp
  00585	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0058a	8b e5		 mov	 esp, ebp
  0058c	5d		 pop	 ebp
  0058d	c3		 ret	 0
$LN240@ProtocolCo:

; 441  : 							break;
; 442  : 						case 0x03:
; 443  : 							CGPShopReqClose(aIndex);

  0058e	56		 push	 esi
  0058f	e8 00 00 00 00	 call	 ?CGPShopReqClose@@YAXH@Z ; CGPShopReqClose
  00594	83 c4 04	 add	 esp, 4
  00597	5f		 pop	 edi
  00598	5e		 pop	 esi
  00599	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0059a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0059d	33 cd		 xor	 ecx, ebp
  0059f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005a4	8b e5		 mov	 esp, ebp
  005a6	5d		 pop	 ebp
  005a7	c3		 ret	 0
$LN239@ProtocolCo:

; 444  : 							break;
; 445  : 						case 0x05:
; 446  : 							CGPShopReqBuyList((PMSG_REQ_BUYLIST_FROM_PSHOP *)aRecv, aIndex);

  005a8	56		 push	 esi
  005a9	57		 push	 edi
  005aa	e8 00 00 00 00	 call	 ?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ; CGPShopReqBuyList
  005af	83 c4 08	 add	 esp, 8
  005b2	5f		 pop	 edi
  005b3	5e		 pop	 esi
  005b4	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  005b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005b8	33 cd		 xor	 ecx, ebp
  005ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005bf	8b e5		 mov	 esp, ebp
  005c1	5d		 pop	 ebp
  005c2	c3		 ret	 0
$LN238@ProtocolCo:

; 447  : 							break;
; 448  : 						case 0x06:
; 449  : 							CGPShopReqBuyItem((PMSG_REQ_BUYITEM_FROM_PSHOP *)aRecv, aIndex);

  005c3	56		 push	 esi
  005c4	57		 push	 edi
  005c5	e8 00 00 00 00	 call	 ?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ; CGPShopReqBuyItem
  005ca	83 c4 08	 add	 esp, 8
  005cd	5f		 pop	 edi
  005ce	5e		 pop	 esi
  005cf	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  005d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005d3	33 cd		 xor	 ecx, ebp
  005d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005da	8b e5		 mov	 esp, ebp
  005dc	5d		 pop	 ebp
  005dd	c3		 ret	 0
$LN237@ProtocolCo:

; 450  : 							break;
; 451  : 					}
; 452  : 				}
; 453  : 				break;
; 454  : 			case 0x40:
; 455  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  005de	8b 55 18	 mov	 edx, DWORD PTR _Encrypt$[ebp]
  005e1	52		 push	 edx
  005e2	53		 push	 ebx
  005e3	56		 push	 esi
  005e4	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  005e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  005ec	85 c0		 test	 eax, eax
  005ee	0f 84 2d 16 00
	00		 je	 $LN313@ProtocolCo

; 456  : 				{
; 457  : 					CGPartyRequestRecv((PMSG_PARTYREQUEST *)aRecv, aIndex);

  005f4	56		 push	 esi
  005f5	57		 push	 edi
  005f6	e8 00 00 00 00	 call	 ?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ; CGPartyRequestRecv
  005fb	83 c4 08	 add	 esp, 8
  005fe	5f		 pop	 edi
  005ff	5e		 pop	 esi
  00600	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00601	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00604	33 cd		 xor	 ecx, ebp
  00606	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0060b	8b e5		 mov	 esp, ebp
  0060d	5d		 pop	 ebp
  0060e	c3		 ret	 0
$LN235@ProtocolCo:

; 458  : 				}
; 459  : 				break;
; 460  : 			case 0x41:
; 461  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0060f	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  00612	50		 push	 eax
  00613	53		 push	 ebx
  00614	56		 push	 esi
  00615	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0061a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0061d	85 c0		 test	 eax, eax
  0061f	0f 84 fc 15 00
	00		 je	 $LN313@ProtocolCo

; 462  : 				{
; 463  : 					CGPartyRequestResultRecv((PMSG_PARTYREQUESTRESULT *)aRecv, aIndex);

  00625	56		 push	 esi
  00626	57		 push	 edi
  00627	e8 00 00 00 00	 call	 ?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ; CGPartyRequestResultRecv
  0062c	83 c4 08	 add	 esp, 8
  0062f	5f		 pop	 edi
  00630	5e		 pop	 esi
  00631	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00632	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00635	33 cd		 xor	 ecx, ebp
  00637	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0063c	8b e5		 mov	 esp, ebp
  0063e	5d		 pop	 ebp
  0063f	c3		 ret	 0
$LN233@ProtocolCo:

; 464  : 				}
; 465  : 				break;
; 466  : 			case 0x42:
; 467  : 				CGPartyList(aIndex);

  00640	56		 push	 esi
  00641	e8 00 00 00 00	 call	 ?CGPartyList@@YAXH@Z	; CGPartyList
  00646	83 c4 04	 add	 esp, 4
  00649	5f		 pop	 edi
  0064a	5e		 pop	 esi
  0064b	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0064c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0064f	33 cd		 xor	 ecx, ebp
  00651	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00656	8b e5		 mov	 esp, ebp
  00658	5d		 pop	 ebp
  00659	c3		 ret	 0
$LN232@ProtocolCo:

; 468  : 				break;
; 469  : 			case 0x43:
; 470  : 				if ( PacketCheckTime(&gObj[aIndex]) == TRUE )

  0065a	51		 push	 ecx
  0065b	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00660	83 c4 04	 add	 esp, 4
  00663	83 f8 01	 cmp	 eax, 1
  00666	0f 85 b5 15 00
	00		 jne	 $LN313@ProtocolCo

; 471  : 				{
; 472  : 					if(!IT_MAP_RANGE(gObj[aIndex].MapNumber)
; 473  : 						&& !DG_MAP_RANGE(gObj[aIndex].MapNumber)
; 474  : 						&& !IF_MAP_RANGE(gObj[aIndex].MapNumber)
; 475  : 						)

  0066c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00672	8b 55 d0	 mov	 edx, DWORD PTR tv1089[ebp]
  00675	8a 84 0a 23 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+291]
  0067c	3c 2d		 cmp	 al, 45			; 0000002dH
  0067e	72 10		 jb	 SHORT $LN350@ProtocolCo
  00680	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00685	3a c8		 cmp	 cl, al
  00687	1b c9		 sbb	 ecx, ecx
  00689	41		 inc	 ecx
  0068a	0f 85 91 15 00
	00		 jne	 $LN313@ProtocolCo
$LN350@ProtocolCo:
  00690	3c 41		 cmp	 al, 65			; 00000041H
  00692	72 0d		 jb	 SHORT $LN355@ProtocolCo
  00694	b2 44		 mov	 dl, 68			; 00000044H
  00696	3a d0		 cmp	 dl, al
  00698	1b c9		 sbb	 ecx, ecx
  0069a	41		 inc	 ecx
  0069b	0f 85 80 15 00
	00		 jne	 $LN313@ProtocolCo
$LN355@ProtocolCo:
  006a1	3c 45		 cmp	 al, 69			; 00000045H
  006a3	72 0d		 jb	 SHORT $LN336@ProtocolCo
  006a5	b1 48		 mov	 cl, 72			; 00000048H
  006a7	3a c8		 cmp	 cl, al
  006a9	1b c0		 sbb	 eax, eax
  006ab	40		 inc	 eax
  006ac	0f 85 6f 15 00
	00		 jne	 $LN313@ProtocolCo
$LN336@ProtocolCo:

; 476  : 					{
; 477  : 						CGPartyDelUser((PMSG_PARTYDELUSER *)aRecv, aIndex);

  006b2	56		 push	 esi
  006b3	57		 push	 edi
  006b4	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  006b9	83 c4 08	 add	 esp, 8
  006bc	5f		 pop	 edi
  006bd	5e		 pop	 esi
  006be	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  006bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006c2	33 cd		 xor	 ecx, ebp
  006c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006c9	8b e5		 mov	 esp, ebp
  006cb	5d		 pop	 ebp
  006cc	c3		 ret	 0
$LN229@ProtocolCo:

; 478  : 					}
; 479  : 				}
; 480  : 				break;
; 481  : 			case 0x4A:
; 482  : 				GCMonkMagicAttack((PMSG_MAGICATTACK*)aRecv,aIndex);

  006cd	56		 push	 esi
  006ce	57		 push	 edi
  006cf	e8 00 00 00 00	 call	 ?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; GCMonkMagicAttack
  006d4	83 c4 08	 add	 esp, 8
  006d7	5f		 pop	 edi
  006d8	5e		 pop	 esi
  006d9	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  006da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006dd	33 cd		 xor	 ecx, ebp
  006df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006e4	8b e5		 mov	 esp, ebp
  006e6	5d		 pop	 ebp
  006e7	c3		 ret	 0
$LN228@ProtocolCo:

; 483  : 				break;
; 484  : 			case 0x4B:
; 485  : 				GCMonkDarkSideTargetSelect((PMSG_MONK_DARKSIDE_RECV*)aRecv,aIndex);

  006e8	56		 push	 esi
  006e9	57		 push	 edi
  006ea	e8 00 00 00 00	 call	 ?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z ; GCMonkDarkSideTargetSelect
  006ef	83 c4 08	 add	 esp, 8
  006f2	5f		 pop	 edi
  006f3	5e		 pop	 esi
  006f4	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  006f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006f8	33 cd		 xor	 ecx, ebp
  006fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006ff	8b e5		 mov	 esp, ebp
  00701	5d		 pop	 ebp
  00702	c3		 ret	 0
$LN227@ProtocolCo:

; 486  : 				break;
; 487  : 			case 0x4C:
; 488  : 				{
; 489  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 490  : 
; 491  : 					switch (lpDef->subcode)

  00703	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00707	83 e8 00	 sub	 eax, 0
  0070a	74 42		 je	 SHORT $LN224@ProtocolCo
  0070c	48		 dec	 eax
  0070d	74 24		 je	 SHORT $LN223@ProtocolCo
  0070f	83 e8 02	 sub	 eax, 2
  00712	0f 85 09 15 00
	00		 jne	 $LN313@ProtocolCo

; 498  : 						break;
; 499  : 					case 3:
; 500  : 						CGMiningEnd((PMSG_MINING_END*)aRecv,aIndex);

  00718	56		 push	 esi
  00719	57		 push	 edi
  0071a	e8 00 00 00 00	 call	 ?CGMiningEnd@@YAXPAUPMSG_MINING_END@@H@Z ; CGMiningEnd
  0071f	83 c4 08	 add	 esp, 8
  00722	5f		 pop	 edi
  00723	5e		 pop	 esi
  00724	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00725	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00728	33 cd		 xor	 ecx, ebp
  0072a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0072f	8b e5		 mov	 esp, ebp
  00731	5d		 pop	 ebp
  00732	c3		 ret	 0
$LN223@ProtocolCo:

; 495  : 						break;
; 496  : 					case 1:
; 497  : 						CGRewardRequest((PMSG_MINING_REWARD_REQUEST*)aRecv,aIndex);

  00733	56		 push	 esi
  00734	57		 push	 edi
  00735	e8 00 00 00 00	 call	 ?CGRewardRequest@@YAXPAUPMSG_MINING_REWARD_REQUEST@@H@Z ; CGRewardRequest
  0073a	83 c4 08	 add	 esp, 8
  0073d	5f		 pop	 edi
  0073e	5e		 pop	 esi
  0073f	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00740	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00743	33 cd		 xor	 ecx, ebp
  00745	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0074a	8b e5		 mov	 esp, ebp
  0074c	5d		 pop	 ebp
  0074d	c3		 ret	 0
$LN224@ProtocolCo:

; 492  : 					{
; 493  : 					case 0:
; 494  : 						CGMiningRequest((PMSG_MINING_REQUEST*)aRecv,aIndex);

  0074e	56		 push	 esi
  0074f	57		 push	 edi
  00750	e8 00 00 00 00	 call	 ?CGMiningRequest@@YAXPAUPMSG_MINING_REQUEST@@H@Z ; CGMiningRequest
  00755	83 c4 08	 add	 esp, 8
  00758	5f		 pop	 edi
  00759	5e		 pop	 esi
  0075a	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0075b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0075e	33 cd		 xor	 ecx, ebp
  00760	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00765	8b e5		 mov	 esp, ebp
  00767	5d		 pop	 ebp
  00768	c3		 ret	 0
$LN221@ProtocolCo:

; 501  : 						break;
; 502  : 					}
; 503  : 				}
; 504  : 				break;
; 505  : #if (ENABLETEST_RUMMY == 1)
; 506  : 			case 0x4D:
; 507  : 				{
; 508  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 509  : 
; 510  : 					switch (lpDef->subcode)
; 511  : 					{
; 512  : 					case 0:
; 513  : 					  //if ( DataEncryptCheck(aIndex, protoNum, Encrypt) )
; 514  : 						//CGEventItemGetRequest((PMSG_EVENTITEM_GETREQUEST *)aRecv, aIndex);
; 515  : 					  break;
; 516  : 					case 1:
; 517  : 					  //CGEventItemDropRequest((PMSG_EVENTITEM_THROW*)aRecv, aIndex);
; 518  : 					  break;
; 519  : 					case 0xF:
; 520  : 					  g_CMuRummyMng.CGReqMuRummyEventOpen((_tagPMSG_REQ_MURUMMY_EVENT_OPEN*)aRecv, aIndex);
; 521  : 					  break;
; 522  : 					case 0x10:
; 523  : 					  g_CMuRummyMng.CGReqMuRummyStart((_tagPMSG_REQ_MURUMMY_INFO*)aRecv, aIndex);
; 524  : 					  break;
; 525  : 					case 0x11:
; 526  : 					  g_CMuRummyMng.CGReqCardReveal((_tagPMSG_REQ_REVEAL_CARD*)aRecv, aIndex);
; 527  : 					  break;
; 528  : 					case 0x12:
; 529  : 					  g_CMuRummyMng.CGReqCardMove((_tagPMSG_REQ_CARD_MOVE*)aRecv, aIndex);
; 530  : 					  break;
; 531  : 					case 0x13:
; 532  : 					  g_CMuRummyMng.CGReqCardReMove((_tagPMSG_REQ_CARD_REMOVE*)aRecv, aIndex);
; 533  : 					  break;
; 534  : 					case 0x14:
; 535  : 					  g_CMuRummyMng.CGReqCardMatch((_tagPMSG_REQ_CARD_MATCH*)aRecv, aIndex);
; 536  : 					  break;
; 537  : 					case 0x15:
; 538  : 					  g_CMuRummyMng.CGReqMuRummyEnd((_tagPMSG_REQ_MURUMMY_END*)aRecv, aIndex);
; 539  : 					  break;
; 540  : 					}
; 541  : 				}
; 542  : 				break;
; 543  : #endif
; 544  : #if (ENABLETEST_MUUN == 1)
; 545  : 			case 0x4E:
; 546  : 				{
; 547  : 					PMSG_DEFAULT2* lpDef = (PMSG_DEFAULT2*)aRecv;
; 548  : 					switch (lpDef->subcode) 
; 549  : 					{
; 550  : 					case 0:
; 551  : 						if (DataEncryptCheck(aIndex, protoNum, Encrypt)) {
; 552  : 							CGMuunItemGetRequest((PMSG_MUUNITEM_GETREQUEST*)aRecv, aIndex);
; 553  : 						}
; 554  : 						break;
; 555  : 					case 8:
; 556  : 						g_CMuunSystem.CGMuunInventoryUseItemRecv((PMSG_USEITEM_MUUN_INVEN*)aRecv, aIndex);
; 557  : 						break;
; 558  : 					case 9:
; 559  : 						if (DataEncryptCheck(aIndex, protoNum, Encrypt)) {
; 560  : 							CGMuunItemSellRequestRecv((PMSG_MUUN_ITEM_SELLREQUEST*)aRecv, aIndex);
; 561  : 						}
; 562  : 						break;
; 563  : 					}
; 564  : 					break;
; 565  : 				}
; 566  : 				break;
; 567  : #endif
; 568  : 			case 0x50:
; 569  : 				CGGuildRequestRecv((PMSG_GUILDJOINQ *)aRecv, aIndex);

  00769	56		 push	 esi
  0076a	57		 push	 edi
  0076b	e8 00 00 00 00	 call	 ?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z ; CGGuildRequestRecv
  00770	83 c4 08	 add	 esp, 8
  00773	5f		 pop	 edi
  00774	5e		 pop	 esi
  00775	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00776	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00779	33 cd		 xor	 ecx, ebp
  0077b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00780	8b e5		 mov	 esp, ebp
  00782	5d		 pop	 ebp
  00783	c3		 ret	 0
$LN220@ProtocolCo:

; 570  : 				break;
; 571  : 			case 0x51:
; 572  : 				CGGuildRequestResultRecv((PMSG_GUILDQRESULT *)aRecv, aIndex);

  00784	56		 push	 esi
  00785	57		 push	 edi
  00786	e8 00 00 00 00	 call	 ?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ; CGGuildRequestResultRecv
  0078b	83 c4 08	 add	 esp, 8
  0078e	5f		 pop	 edi
  0078f	5e		 pop	 esi
  00790	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00791	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00794	33 cd		 xor	 ecx, ebp
  00796	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0079b	8b e5		 mov	 esp, ebp
  0079d	5d		 pop	 ebp
  0079e	c3		 ret	 0
$LN219@ProtocolCo:

; 573  : 				break;
; 574  : 			case 0x52:
; 575  : 				CGGuildListAll(aIndex);

  0079f	56		 push	 esi
  007a0	e8 00 00 00 00	 call	 ?CGGuildListAll@@YAXH@Z	; CGGuildListAll
  007a5	83 c4 04	 add	 esp, 4
  007a8	5f		 pop	 edi
  007a9	5e		 pop	 esi
  007aa	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  007ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ae	33 cd		 xor	 ecx, ebp
  007b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007b5	8b e5		 mov	 esp, ebp
  007b7	5d		 pop	 ebp
  007b8	c3		 ret	 0
$LN218@ProtocolCo:

; 576  : 				break;
; 577  : 			case 0x53:
; 578  : 				CGGuildDelUser((PMSG_GUILDDELUSER *)aRecv, aIndex);

  007b9	56		 push	 esi
  007ba	57		 push	 edi
  007bb	e8 00 00 00 00	 call	 ?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z ; CGGuildDelUser
  007c0	83 c4 08	 add	 esp, 8
  007c3	5f		 pop	 edi
  007c4	5e		 pop	 esi
  007c5	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  007c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007c9	33 cd		 xor	 ecx, ebp
  007cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007d0	8b e5		 mov	 esp, ebp
  007d2	5d		 pop	 ebp
  007d3	c3		 ret	 0
$LN217@ProtocolCo:

; 579  : 				break;
; 580  : 			case 0x54:
; 581  : 				CGGuildMasterAnswerRecv((PMSG_GUILDMASTERANSWER *)aRecv, aIndex);

  007d4	56		 push	 esi
  007d5	57		 push	 edi
  007d6	e8 00 00 00 00	 call	 ?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ; CGGuildMasterAnswerRecv
  007db	83 c4 08	 add	 esp, 8
  007de	5f		 pop	 edi
  007df	5e		 pop	 esi
  007e0	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  007e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007e4	33 cd		 xor	 ecx, ebp
  007e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007eb	8b e5		 mov	 esp, ebp
  007ed	5d		 pop	 ebp
  007ee	c3		 ret	 0
$LN216@ProtocolCo:

; 582  : 				break;
; 583  : 			case 0x55:
; 584  : 				CGGuildMasterInfoSave(aIndex, (PMSG_GUILDINFOSAVE *)aRecv);

  007ef	57		 push	 edi
  007f0	56		 push	 esi
  007f1	e8 00 00 00 00	 call	 ?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ; CGGuildMasterInfoSave
  007f6	83 c4 08	 add	 esp, 8
  007f9	5f		 pop	 edi
  007fa	5e		 pop	 esi
  007fb	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  007fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ff	33 cd		 xor	 ecx, ebp
  00801	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00806	8b e5		 mov	 esp, ebp
  00808	5d		 pop	 ebp
  00809	c3		 ret	 0
$LN215@ProtocolCo:

; 585  : 				break;
; 586  : 			case 0x57:
; 587  : 				CGGuildMasterCreateCancel(aIndex);

  0080a	56		 push	 esi
  0080b	e8 00 00 00 00	 call	 ?CGGuildMasterCreateCancel@@YAXH@Z ; CGGuildMasterCreateCancel
  00810	83 c4 04	 add	 esp, 4
  00813	5f		 pop	 edi
  00814	5e		 pop	 esi
  00815	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00816	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00819	33 cd		 xor	 ecx, ebp
  0081b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00820	8b e5		 mov	 esp, ebp
  00822	5d		 pop	 ebp
  00823	c3		 ret	 0
$LN214@ProtocolCo:

; 588  : 				break;
; 589  : 			case 0x61:
; 590  : 				GCGuildWarRequestSendRecv((PMSG_GUILDWARSEND_RESULT *)aRecv, aIndex);

  00824	56		 push	 esi
  00825	57		 push	 edi
  00826	e8 00 00 00 00	 call	 ?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ; GCGuildWarRequestSendRecv
  0082b	83 c4 08	 add	 esp, 8
  0082e	5f		 pop	 edi
  0082f	5e		 pop	 esi
  00830	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00831	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00834	33 cd		 xor	 ecx, ebp
  00836	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0083b	8b e5		 mov	 esp, ebp
  0083d	5d		 pop	 ebp
  0083e	c3		 ret	 0
$LN213@ProtocolCo:

; 591  : 				break;
; 592  : 			case 0x66:
; 593  : 				GCGuildViewportInfo((PMSG_REQ_GUILDVIEWPORT *)aRecv, aIndex);

  0083f	56		 push	 esi
  00840	57		 push	 edi
  00841	e8 00 00 00 00	 call	 ?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z ; GCGuildViewportInfo
  00846	83 c4 08	 add	 esp, 8
  00849	5f		 pop	 edi
  0084a	5e		 pop	 esi
  0084b	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0084c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0084f	33 cd		 xor	 ecx, ebp
  00851	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00856	8b e5		 mov	 esp, ebp
  00858	5d		 pop	 ebp
  00859	c3		 ret	 0
$LN212@ProtocolCo:

; 594  : 				break;
; 595  : 			case 0xB1:
; 596  : 				{
; 597  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 598  : 					
; 599  : 					switch ( lpDef->subcode )

  0085a	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0085e	48		 dec	 eax
  0085f	0f 85 bc 13 00
	00		 jne	 $LN313@ProtocolCo

; 600  : 					{
; 601  : 						case 0x01:
; 602  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00865	8b 55 18	 mov	 edx, DWORD PTR _Encrypt$[ebp]
  00868	52		 push	 edx
  00869	53		 push	 ebx
  0086a	56		 push	 esi
  0086b	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00870	83 c4 0c	 add	 esp, 12			; 0000000cH
  00873	85 c0		 test	 eax, eax
  00875	0f 84 a6 13 00
	00		 je	 $LN313@ProtocolCo

; 603  : 							{
; 604  : 								CGReqMapSvrAuth((PMSG_REQ_MAPSERVERAUTH *)aRecv, aIndex);

  0087b	56		 push	 esi
  0087c	57		 push	 edi
  0087d	e8 00 00 00 00	 call	 ?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z ; CGReqMapSvrAuth
  00882	83 c4 08	 add	 esp, 8
  00885	5f		 pop	 edi
  00886	5e		 pop	 esi
  00887	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00888	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0088b	33 cd		 xor	 ecx, ebp
  0088d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00892	8b e5		 mov	 esp, ebp
  00894	5d		 pop	 ebp
  00895	c3		 ret	 0
$LN207@ProtocolCo:

; 605  : 							}
; 606  : 							break;
; 607  : 					}
; 608  : 				}
; 609  : 				break;
; 610  : 			case 0xB2:
; 611  : 				{
; 612  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 613  : 
; 614  : 					switch ( lpDef->subcode )

  00896	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0089a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0089d	0f 87 7e 13 00
	00		 ja	 $LN313@ProtocolCo
  008a3	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN342@ProtocolCo[eax]
  008aa	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN359@ProtocolCo[eax*4]
$LN204@ProtocolCo:

; 615  : 					{
; 616  : 						case 0x00:
; 617  : 							CGReqCastleSiegeState((PMSG_REQ_CASTLESIEGESTATE *)aRecv, aIndex);

  008b1	56		 push	 esi
  008b2	57		 push	 edi
  008b3	e8 00 00 00 00	 call	 ?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z ; CGReqCastleSiegeState
  008b8	83 c4 08	 add	 esp, 8
  008bb	5f		 pop	 edi
  008bc	5e		 pop	 esi
  008bd	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  008be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008c1	33 cd		 xor	 ecx, ebp
  008c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008c8	8b e5		 mov	 esp, ebp
  008ca	5d		 pop	 ebp
  008cb	c3		 ret	 0
$LN203@ProtocolCo:

; 618  : 							break;
; 619  : 						case 0x01:
; 620  : 							CGReqRegCastleSiege((PMSG_REQ_REGCASTLESIEGE *)aRecv, aIndex);

  008cc	56		 push	 esi
  008cd	57		 push	 edi
  008ce	e8 00 00 00 00	 call	 ?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z ; CGReqRegCastleSiege
  008d3	83 c4 08	 add	 esp, 8
  008d6	5f		 pop	 edi
  008d7	5e		 pop	 esi
  008d8	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  008d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008dc	33 cd		 xor	 ecx, ebp
  008de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008e3	8b e5		 mov	 esp, ebp
  008e5	5d		 pop	 ebp
  008e6	c3		 ret	 0
$LN202@ProtocolCo:

; 621  : 							break;
; 622  : 						case 0x02:
; 623  : 							CGReqGiveUpCastleSiege((PMSG_REQ_GIVEUPCASTLESIEGE *)aRecv, aIndex);

  008e7	56		 push	 esi
  008e8	57		 push	 edi
  008e9	e8 00 00 00 00	 call	 ?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z ; CGReqGiveUpCastleSiege
  008ee	83 c4 08	 add	 esp, 8
  008f1	5f		 pop	 edi
  008f2	5e		 pop	 esi
  008f3	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  008f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008f7	33 cd		 xor	 ecx, ebp
  008f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008fe	8b e5		 mov	 esp, ebp
  00900	5d		 pop	 ebp
  00901	c3		 ret	 0
$LN201@ProtocolCo:

; 624  : 							break;
; 625  : 						case 0x03:
; 626  : 							CGReqGuildRegInfo((PMSG_REQ_GUILDREGINFO *)aRecv, aIndex);

  00902	56		 push	 esi
  00903	57		 push	 edi
  00904	e8 00 00 00 00	 call	 ?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z ; CGReqGuildRegInfo
  00909	83 c4 08	 add	 esp, 8
  0090c	5f		 pop	 edi
  0090d	5e		 pop	 esi
  0090e	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0090f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00912	33 cd		 xor	 ecx, ebp
  00914	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00919	8b e5		 mov	 esp, ebp
  0091b	5d		 pop	 ebp
  0091c	c3		 ret	 0
$LN200@ProtocolCo:

; 627  : 							break;
; 628  : 						case 0x04:
; 629  : 							CGReqRegGuildMark((PMSG_REQ_REGGUILDMARK *)aRecv, aIndex);

  0091d	56		 push	 esi
  0091e	57		 push	 edi
  0091f	e8 00 00 00 00	 call	 ?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z ; CGReqRegGuildMark
  00924	83 c4 08	 add	 esp, 8
  00927	5f		 pop	 edi
  00928	5e		 pop	 esi
  00929	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0092a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0092d	33 cd		 xor	 ecx, ebp
  0092f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00934	8b e5		 mov	 esp, ebp
  00936	5d		 pop	 ebp
  00937	c3		 ret	 0
$LN199@ProtocolCo:

; 630  : 							break;
; 631  : 						case 0x05:
; 632  : 							CGReqNpcBuy((PMSG_REQ_NPCBUY *)aRecv, aIndex);

  00938	56		 push	 esi
  00939	57		 push	 edi
  0093a	e8 00 00 00 00	 call	 ?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z ; CGReqNpcBuy
  0093f	83 c4 08	 add	 esp, 8
  00942	5f		 pop	 edi
  00943	5e		 pop	 esi
  00944	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00945	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00948	33 cd		 xor	 ecx, ebp
  0094a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0094f	8b e5		 mov	 esp, ebp
  00951	5d		 pop	 ebp
  00952	c3		 ret	 0
$LN198@ProtocolCo:

; 633  : 							break;
; 634  : 						case 0x06:
; 635  : 							CGReqNpcRepair((PMSG_REQ_NPCREPAIR *)aRecv, aIndex);

  00953	56		 push	 esi
  00954	57		 push	 edi
  00955	e8 00 00 00 00	 call	 ?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z ; CGReqNpcRepair
  0095a	83 c4 08	 add	 esp, 8
  0095d	5f		 pop	 edi
  0095e	5e		 pop	 esi
  0095f	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00960	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00963	33 cd		 xor	 ecx, ebp
  00965	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0096a	8b e5		 mov	 esp, ebp
  0096c	5d		 pop	 ebp
  0096d	c3		 ret	 0
$LN197@ProtocolCo:

; 636  : 							break;
; 637  : 						case 0x07:
; 638  : 							CGReqNpcUpgrade((PMSG_REQ_NPCUPGRADE *)aRecv, aIndex);

  0096e	56		 push	 esi
  0096f	57		 push	 edi
  00970	e8 00 00 00 00	 call	 ?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z ; CGReqNpcUpgrade
  00975	83 c4 08	 add	 esp, 8
  00978	5f		 pop	 edi
  00979	5e		 pop	 esi
  0097a	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0097b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0097e	33 cd		 xor	 ecx, ebp
  00980	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00985	8b e5		 mov	 esp, ebp
  00987	5d		 pop	 ebp
  00988	c3		 ret	 0
$LN196@ProtocolCo:

; 639  : 							break;
; 640  : 						case 0x08:
; 641  : 							CGReqTaxMoneyInfo((PMSG_REQ_TAXMONEYINFO *)aRecv, aIndex);

  00989	56		 push	 esi
  0098a	57		 push	 edi
  0098b	e8 00 00 00 00	 call	 ?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z ; CGReqTaxMoneyInfo
  00990	83 c4 08	 add	 esp, 8
  00993	5f		 pop	 edi
  00994	5e		 pop	 esi
  00995	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00996	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00999	33 cd		 xor	 ecx, ebp
  0099b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009a0	8b e5		 mov	 esp, ebp
  009a2	5d		 pop	 ebp
  009a3	c3		 ret	 0
$LN195@ProtocolCo:

; 642  : 							break;
; 643  : 						case 0x09:
; 644  : 							CGReqTaxRateChange((PMSG_REQ_TAXRATECHANGE *)aRecv, aIndex);

  009a4	56		 push	 esi
  009a5	57		 push	 edi
  009a6	e8 00 00 00 00	 call	 ?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z ; CGReqTaxRateChange
  009ab	83 c4 08	 add	 esp, 8
  009ae	5f		 pop	 edi
  009af	5e		 pop	 esi
  009b0	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  009b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009b4	33 cd		 xor	 ecx, ebp
  009b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009bb	8b e5		 mov	 esp, ebp
  009bd	5d		 pop	 ebp
  009be	c3		 ret	 0
$LN194@ProtocolCo:

; 645  : 							break;
; 646  : 						case 0x10:
; 647  : 							CGReqMoneyDrawOut((PMSG_REQ_MONEYDRAWOUT *)aRecv, aIndex);

  009bf	56		 push	 esi
  009c0	57		 push	 edi
  009c1	e8 00 00 00 00	 call	 ?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z ; CGReqMoneyDrawOut
  009c6	83 c4 08	 add	 esp, 8
  009c9	5f		 pop	 edi
  009ca	5e		 pop	 esi
  009cb	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  009cc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009cf	33 cd		 xor	 ecx, ebp
  009d1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009d6	8b e5		 mov	 esp, ebp
  009d8	5d		 pop	 ebp
  009d9	c3		 ret	 0
$LN193@ProtocolCo:

; 648  : 							break;
; 649  : 						case 0x12:
; 650  : 							CGReqCsGateOperate((PMSG_REQ_CSGATEOPERATE *)aRecv, aIndex);

  009da	56		 push	 esi
  009db	57		 push	 edi
  009dc	e8 00 00 00 00	 call	 ?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z ; CGReqCsGateOperate
  009e1	83 c4 08	 add	 esp, 8
  009e4	5f		 pop	 edi
  009e5	5e		 pop	 esi
  009e6	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  009e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009ea	33 cd		 xor	 ecx, ebp
  009ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009f1	8b e5		 mov	 esp, ebp
  009f3	5d		 pop	 ebp
  009f4	c3		 ret	 0
$LN192@ProtocolCo:

; 651  : 							break;
; 652  : 						case 0x1B:
; 653  : 							CGReqCsMiniMapData((PMSG_REQ_MINIMAPDATA *)aRecv, aIndex);

  009f5	56		 push	 esi
  009f6	57		 push	 edi
  009f7	e8 00 00 00 00	 call	 ?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z ; CGReqCsMiniMapData
  009fc	83 c4 08	 add	 esp, 8
  009ff	5f		 pop	 edi
  00a00	5e		 pop	 esi
  00a01	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00a02	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a05	33 cd		 xor	 ecx, ebp
  00a07	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a0c	8b e5		 mov	 esp, ebp
  00a0e	5d		 pop	 ebp
  00a0f	c3		 ret	 0
$LN191@ProtocolCo:

; 654  : 							break;
; 655  : 						case 0x1C:
; 656  : 							CGReqStopCsMiniMapData((PMSG_REQ_STOPMINIMAPDATA *)aRecv, aIndex);

  00a10	56		 push	 esi
  00a11	57		 push	 edi
  00a12	e8 00 00 00 00	 call	 ?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z ; CGReqStopCsMiniMapData
  00a17	83 c4 08	 add	 esp, 8
  00a1a	5f		 pop	 edi
  00a1b	5e		 pop	 esi
  00a1c	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00a1d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a20	33 cd		 xor	 ecx, ebp
  00a22	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a27	8b e5		 mov	 esp, ebp
  00a29	5d		 pop	 ebp
  00a2a	c3		 ret	 0
$LN190@ProtocolCo:

; 657  : 							break;
; 658  : 						case 0x1D:
; 659  : 							CGReqCsSendCommand((PMSG_REQ_CSCOMMAND *)aRecv, aIndex);

  00a2b	56		 push	 esi
  00a2c	57		 push	 edi
  00a2d	e8 00 00 00 00	 call	 ?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z ; CGReqCsSendCommand
  00a32	83 c4 08	 add	 esp, 8
  00a35	5f		 pop	 edi
  00a36	5e		 pop	 esi
  00a37	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00a38	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a3b	33 cd		 xor	 ecx, ebp
  00a3d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a42	8b e5		 mov	 esp, ebp
  00a44	5d		 pop	 ebp
  00a45	c3		 ret	 0
$LN189@ProtocolCo:

; 660  : 							break;
; 661  : 						case 0x1F:
; 662  : 							CGReqCsSetEnterHuntZone((PMSG_REQ_CSHUNTZONEENTER *)aRecv, aIndex);

  00a46	56		 push	 esi
  00a47	57		 push	 edi
  00a48	e8 00 00 00 00	 call	 ?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z ; CGReqCsSetEnterHuntZone
  00a4d	83 c4 08	 add	 esp, 8
  00a50	5f		 pop	 edi
  00a51	5e		 pop	 esi
  00a52	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00a53	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a56	33 cd		 xor	 ecx, ebp
  00a58	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a5d	8b e5		 mov	 esp, ebp
  00a5f	5d		 pop	 ebp
  00a60	c3		 ret	 0
$LN188@ProtocolCo:

; 663  : 							break;
; 664  : 					}
; 665  : 				}
; 666  : 				break;
; 667  : 			case 0xB3:
; 668  : 				CGReqNpcDbList((PMSG_REQ_NPCDBLIST *)aRecv, aIndex);

  00a61	56		 push	 esi
  00a62	57		 push	 edi
  00a63	e8 00 00 00 00	 call	 ?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z ; CGReqNpcDbList
  00a68	83 c4 08	 add	 esp, 8
  00a6b	5f		 pop	 edi
  00a6c	5e		 pop	 esi
  00a6d	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00a6e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a71	33 cd		 xor	 ecx, ebp
  00a73	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a78	8b e5		 mov	 esp, ebp
  00a7a	5d		 pop	 ebp
  00a7b	c3		 ret	 0
$LN187@ProtocolCo:

; 669  : 				break;
; 670  : 			case 0xB4:
; 671  : 				CGReqCsRegGuildList((PMSG_REQ_CSREGGUILDLIST *)aRecv, aIndex);

  00a7c	56		 push	 esi
  00a7d	57		 push	 edi
  00a7e	e8 00 00 00 00	 call	 ?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z ; CGReqCsRegGuildList
  00a83	83 c4 08	 add	 esp, 8
  00a86	5f		 pop	 edi
  00a87	5e		 pop	 esi
  00a88	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00a89	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a8c	33 cd		 xor	 ecx, ebp
  00a8e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a93	8b e5		 mov	 esp, ebp
  00a95	5d		 pop	 ebp
  00a96	c3		 ret	 0
$LN186@ProtocolCo:

; 672  : 				break;
; 673  : 			case 0xB5:
; 674  : 				CGReqCsAttkGuildList((PMSG_REQ_CSATTKGUILDLIST *)aRecv, aIndex);

  00a97	56		 push	 esi
  00a98	57		 push	 edi
  00a99	e8 00 00 00 00	 call	 ?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z ; CGReqCsAttkGuildList
  00a9e	83 c4 08	 add	 esp, 8
  00aa1	5f		 pop	 edi
  00aa2	5e		 pop	 esi
  00aa3	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00aa4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00aa7	33 cd		 xor	 ecx, ebp
  00aa9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00aae	8b e5		 mov	 esp, ebp
  00ab0	5d		 pop	 ebp
  00ab1	c3		 ret	 0
$LN185@ProtocolCo:

; 675  : 				break;
; 676  : 			case 0xB7:
; 677  : 				{
; 678  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 679  : 
; 680  : 					switch ( lpDef->subcode )

  00ab2	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00ab6	48		 dec	 eax
  00ab7	74 24		 je	 SHORT $LN182@ProtocolCo
  00ab9	83 e8 03	 sub	 eax, 3
  00abc	0f 85 5f 11 00
	00		 jne	 $LN313@ProtocolCo

; 684  : 							break;
; 685  : 						case 0x04:
; 686  : 							CGReqWeaponDamageValue((PMSG_REQ_WEAPON_DAMAGE_VALUE *)aRecv, aIndex);

  00ac2	56		 push	 esi
  00ac3	57		 push	 edi
  00ac4	e8 00 00 00 00	 call	 ?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z ; CGReqWeaponDamageValue
  00ac9	83 c4 08	 add	 esp, 8
  00acc	5f		 pop	 edi
  00acd	5e		 pop	 esi
  00ace	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00acf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ad2	33 cd		 xor	 ecx, ebp
  00ad4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ad9	8b e5		 mov	 esp, ebp
  00adb	5d		 pop	 ebp
  00adc	c3		 ret	 0
$LN182@ProtocolCo:

; 681  : 					{
; 682  : 						case 0x01:
; 683  : 							CGReqWeaponUse((PMSG_REQ_USEWEAPON *)aRecv, aIndex);

  00add	56		 push	 esi
  00ade	57		 push	 edi
  00adf	e8 00 00 00 00	 call	 ?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z ; CGReqWeaponUse
  00ae4	83 c4 08	 add	 esp, 8
  00ae7	5f		 pop	 edi
  00ae8	5e		 pop	 esi
  00ae9	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00aea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00aed	33 cd		 xor	 ecx, ebp
  00aef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00af4	8b e5		 mov	 esp, ebp
  00af6	5d		 pop	 ebp
  00af7	c3		 ret	 0
$LN180@ProtocolCo:

; 687  : 							break;
; 688  : 					}
; 689  : 				}
; 690  : 				break;
; 691  : 			case 0xB9:
; 692  : 				{
; 693  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 694  : 
; 695  : 					switch ( lpDef->subcode )

  00af8	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00afc	83 e8 02	 sub	 eax, 2
  00aff	74 24		 je	 SHORT $LN177@ProtocolCo
  00b01	83 e8 03	 sub	 eax, 3
  00b04	0f 85 17 11 00
	00		 jne	 $LN313@ProtocolCo

; 699  : 							break;
; 700  : 						case 0x05:
; 701  : 							CGReqCastleHuntZoneEntrance((PMSG_REQ_MOVE_TO_CASTLE_HUNTZONE *)aRecv,aIndex);

  00b0a	56		 push	 esi
  00b0b	57		 push	 edi
  00b0c	e8 00 00 00 00	 call	 ?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z ; CGReqCastleHuntZoneEntrance
  00b11	83 c4 08	 add	 esp, 8
  00b14	5f		 pop	 edi
  00b15	5e		 pop	 esi
  00b16	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00b17	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b1a	33 cd		 xor	 ecx, ebp
  00b1c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b21	8b e5		 mov	 esp, ebp
  00b23	5d		 pop	 ebp
  00b24	c3		 ret	 0
$LN177@ProtocolCo:

; 696  : 					{
; 697  : 						case 0x02:
; 698  : 							CGReqGuildMarkOfCastleOwner((PMSG_REQ_GUILDMARK_OF_CASTLEOWNER *)aRecv, aIndex);

  00b25	56		 push	 esi
  00b26	57		 push	 edi
  00b27	e8 00 00 00 00	 call	 ?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z ; CGReqGuildMarkOfCastleOwner
  00b2c	83 c4 08	 add	 esp, 8
  00b2f	5f		 pop	 edi
  00b30	5e		 pop	 esi
  00b31	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00b32	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b35	33 cd		 xor	 ecx, ebp
  00b37	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b3c	8b e5		 mov	 esp, ebp
  00b3e	5d		 pop	 ebp
  00b3f	c3		 ret	 0
$LN175@ProtocolCo:

; 702  : 							break;
; 703  : 					}
; 704  : 				}
; 705  : 				break;
; 706  : 			case 0xBC:
; 707  : 				{
; 708  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 709  : 
; 710  : 					switch ( lpDef->subcode )

  00b40	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00b44	83 e8 00	 sub	 eax, 0
  00b47	74 22		 je	 SHORT $LN172@ProtocolCo
  00b49	48		 dec	 eax
  00b4a	0f 85 d1 10 00
	00		 jne	 $LN313@ProtocolCo

; 714  : 							break;
; 715  : 						case 0x01:
; 716  : 							CGReqJewelUnMix((PMSG_REQ_JEWEL_UNMIX *)aRecv, aIndex);

  00b50	56		 push	 esi
  00b51	57		 push	 edi
  00b52	e8 00 00 00 00	 call	 ?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z ; CGReqJewelUnMix
  00b57	83 c4 08	 add	 esp, 8
  00b5a	5f		 pop	 edi
  00b5b	5e		 pop	 esi
  00b5c	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00b5d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b60	33 cd		 xor	 ecx, ebp
  00b62	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b67	8b e5		 mov	 esp, ebp
  00b69	5d		 pop	 ebp
  00b6a	c3		 ret	 0
$LN172@ProtocolCo:

; 711  : 					{
; 712  : 						case 0x00:
; 713  : 							CGReqJewelMix((PMSG_REQ_JEWEL_MIX *)aRecv, aIndex);

  00b6b	56		 push	 esi
  00b6c	57		 push	 edi
  00b6d	e8 00 00 00 00	 call	 ?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z ; CGReqJewelMix
  00b72	83 c4 08	 add	 esp, 8
  00b75	5f		 pop	 edi
  00b76	5e		 pop	 esi
  00b77	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00b78	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b7b	33 cd		 xor	 ecx, ebp
  00b7d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b82	8b e5		 mov	 esp, ebp
  00b84	5d		 pop	 ebp
  00b85	c3		 ret	 0
$LN170@ProtocolCo:

; 717  : 							break;
; 718  : 					}
; 719  : 				}
; 720  : 				break;
; 721  : 			case 0xBD:
; 722  : 				{
; 723  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 724  : 
; 725  : 					switch ( lpDef->subcode )

  00b86	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00b89	84 c0		 test	 al, al
  00b8b	74 42		 je	 SHORT $LN167@ProtocolCo
  00b8d	3c 03		 cmp	 al, 3
  00b8f	74 23		 je	 SHORT $LN166@ProtocolCo
  00b91	3c 09		 cmp	 al, 9
  00b93	0f 85 88 10 00
	00		 jne	 $LN313@ProtocolCo

; 732  : 							break;
; 733  : 						case 0x09:
; 734  : 							CGReqPlusChaosRate((PMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE *)aRecv, aIndex);

  00b99	56		 push	 esi
  00b9a	57		 push	 edi
  00b9b	e8 00 00 00 00	 call	 ?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z ; CGReqPlusChaosRate
  00ba0	83 c4 08	 add	 esp, 8
  00ba3	5f		 pop	 edi
  00ba4	5e		 pop	 esi
  00ba5	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00ba6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ba9	33 cd		 xor	 ecx, ebp
  00bab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bb0	8b e5		 mov	 esp, ebp
  00bb2	5d		 pop	 ebp
  00bb3	c3		 ret	 0
$LN166@ProtocolCo:

; 729  : 							break;
; 730  : 						case 0x03:
; 731  : 							CGReqAlatrContract((PMSG_REQ_CRYWOLF_ALTAR_CONTRACT *)aRecv, aIndex);

  00bb4	56		 push	 esi
  00bb5	57		 push	 edi
  00bb6	e8 00 00 00 00	 call	 ?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z ; CGReqAlatrContract
  00bbb	83 c4 08	 add	 esp, 8
  00bbe	5f		 pop	 edi
  00bbf	5e		 pop	 esi
  00bc0	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00bc1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bc4	33 cd		 xor	 ecx, ebp
  00bc6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bcb	8b e5		 mov	 esp, ebp
  00bcd	5d		 pop	 ebp
  00bce	c3		 ret	 0
$LN167@ProtocolCo:

; 726  : 					{
; 727  : 						case 0x00:
; 728  : 							CGReqCrywolfInfo((PMSG_REQ_CRYWOLF_INFO *)aRecv, aIndex);

  00bcf	56		 push	 esi
  00bd0	57		 push	 edi
  00bd1	e8 00 00 00 00	 call	 ?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z ; CGReqCrywolfInfo
  00bd6	83 c4 08	 add	 esp, 8
  00bd9	5f		 pop	 edi
  00bda	5e		 pop	 esi
  00bdb	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00bdc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bdf	33 cd		 xor	 ecx, ebp
  00be1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00be6	8b e5		 mov	 esp, ebp
  00be8	5d		 pop	 ebp
  00be9	c3		 ret	 0
$LN164@ProtocolCo:

; 735  : 							break;
; 736  : 					}
; 737  : 				}
; 738  : 				break;
; 739  : 			case 0xBF:
; 740  : 				{
; 741  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 742  : 
; 743  : 					switch ( lpDef->subcode )

  00bea	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00bee	83 f8 51	 cmp	 eax, 81			; 00000051H
  00bf1	0f 87 b8 00 00
	00		 ja	 $LN154@ProtocolCo
  00bf7	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN343@ProtocolCo[eax]
  00bfe	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN360@ProtocolCo[ecx*4]
$LN161@ProtocolCo:

; 744  : 					{
; 745  : 						case 0x00:
; 746  : 							GCReqmoveIllusionTemple((PMSG_REQ_MOVEILLUSIONTEMPLE*)aRecv, aIndex);

  00c05	56		 push	 esi
  00c06	57		 push	 edi
  00c07	e8 00 00 00 00	 call	 ?GCReqmoveIllusionTemple@@YAXPAUPMSG_REQ_MOVEILLUSIONTEMPLE@@H@Z ; GCReqmoveIllusionTemple
  00c0c	83 c4 08	 add	 esp, 8
  00c0f	5f		 pop	 edi
  00c10	5e		 pop	 esi
  00c11	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00c12	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c15	33 cd		 xor	 ecx, ebp
  00c17	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c1c	8b e5		 mov	 esp, ebp
  00c1e	5d		 pop	 ebp
  00c1f	c3		 ret	 0
$LN160@ProtocolCo:

; 747  : 							break;
; 748  : 						case 0x02:
; 749  : 							GCIllusionSkillUseSend((PMSG_ILLUSION_REQ_SKILLUSE*)aRecv,aIndex);

  00c20	56		 push	 esi
  00c21	57		 push	 edi
  00c22	e8 00 00 00 00	 call	 ?GCIllusionSkillUseSend@@YAXPAUPMSG_ILLUSION_REQ_SKILLUSE@@H@Z ; GCIllusionSkillUseSend
  00c27	83 c4 08	 add	 esp, 8
  00c2a	5f		 pop	 edi
  00c2b	5e		 pop	 esi
  00c2c	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00c2d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c30	33 cd		 xor	 ecx, ebp
  00c32	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c37	8b e5		 mov	 esp, ebp
  00c39	5d		 pop	 ebp
  00c3a	c3		 ret	 0
$LN159@ProtocolCo:

; 750  : 							break;
; 751  : 						case 0x05:
; 752  : 							CGIllusionTempleReward(aIndex);

  00c3b	56		 push	 esi
  00c3c	e8 00 00 00 00	 call	 ?CGIllusionTempleReward@@YAXH@Z ; CGIllusionTempleReward
  00c41	83 c4 04	 add	 esp, 4
  00c44	5f		 pop	 edi
  00c45	5e		 pop	 esi
  00c46	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00c47	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c4a	33 cd		 xor	 ecx, ebp
  00c4c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c51	8b e5		 mov	 esp, ebp
  00c53	5d		 pop	 ebp
  00c54	c3		 ret	 0
$LN158@ProtocolCo:

; 753  : 							break;
; 754  : 						case 0x0E:
; 755  : 							CGReqmoveDoubleGoer(aRecv,aIndex);

  00c55	56		 push	 esi
  00c56	57		 push	 edi
  00c57	e8 00 00 00 00	 call	 ?CGReqmoveDoubleGoer@@YAXPAEH@Z ; CGReqmoveDoubleGoer
  00c5c	83 c4 08	 add	 esp, 8
  00c5f	5f		 pop	 edi
  00c60	5e		 pop	 esi
  00c61	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00c62	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c65	33 cd		 xor	 ecx, ebp
  00c67	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c6c	8b e5		 mov	 esp, ebp
  00c6e	5d		 pop	 ebp
  00c6f	c3		 ret	 0
$LN157@ProtocolCo:

; 756  : 							break;
; 757  : 						case 0x17:
; 758  : 							CGReqmoveLorenMarket(aIndex);

  00c70	56		 push	 esi
  00c71	e8 00 00 00 00	 call	 ?CGReqmoveLorenMarket@@YAXH@Z ; CGReqmoveLorenMarket
  00c76	83 c4 04	 add	 esp, 4
  00c79	5f		 pop	 edi
  00c7a	5e		 pop	 esi
  00c7b	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00c7c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c7f	33 cd		 xor	 ecx, ebp
  00c81	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c86	8b e5		 mov	 esp, ebp
  00c88	5d		 pop	 ebp
  00c89	c3		 ret	 0
$LN156@ProtocolCo:

; 759  : 							break;
; 760  : 						case 0x20:	//OK
; 761  : 							CGInventoryEquipment((_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM *)aRecv, aIndex);

  00c8a	56		 push	 esi
  00c8b	57		 push	 edi
  00c8c	e8 00 00 00 00	 call	 ?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z ; CGInventoryEquipment
  00c91	83 c4 08	 add	 esp, 8
$LN155@ProtocolCo:

; 762  : 						case 0x51:
; 763  : 							CGRequestStartMuBot((PMSG_MUBOT_REQ_START*)aRecv,aIndex);

  00c94	56		 push	 esi
  00c95	57		 push	 edi
  00c96	e8 00 00 00 00	 call	 ?CGRequestStartMuBot@@YAXPAUPMSG_MUBOT_REQ_START@@H@Z ; CGRequestStartMuBot
  00c9b	83 c4 08	 add	 esp, 8
  00c9e	5f		 pop	 edi
  00c9f	5e		 pop	 esi
  00ca0	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00ca1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ca4	33 cd		 xor	 ecx, ebp
  00ca6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cab	8b e5		 mov	 esp, ebp
  00cad	5d		 pop	 ebp
  00cae	c3		 ret	 0
$LN154@ProtocolCo:

; 764  : 							break;
; 765  : 						default:
; 766  : 							LogAddTD("[0xBF] Unknown packet BF:%d",lpDef->subcode);

  00caf	50		 push	 eax
  00cb0	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BJHJAKKO@?$FL0xBF?$FN?5Unknown?5packet?5BF?3?$CFd?$AA@
  00cb5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00cbb	83 c4 08	 add	 esp, 8
  00cbe	5f		 pop	 edi
  00cbf	5e		 pop	 esi
  00cc0	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00cc1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cc4	33 cd		 xor	 ecx, ebp
  00cc6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ccb	8b e5		 mov	 esp, ebp
  00ccd	5d		 pop	 ebp
  00cce	c3		 ret	 0
$LN153@ProtocolCo:

; 767  : 							break;
; 768  : 					}
; 769  : 				}
; 770  : 				break;
; 771  : 			//case 0xBE:
; 772  : 			case 0xE1:
; 773  : 				CGGuildAssignStatus((PMSG_GUILD_ASSIGN_STATUS_REQ *)aRecv, aIndex);

  00ccf	56		 push	 esi
  00cd0	57		 push	 edi
  00cd1	e8 00 00 00 00	 call	 ?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z ; CGGuildAssignStatus
  00cd6	83 c4 08	 add	 esp, 8
  00cd9	5f		 pop	 edi
  00cda	5e		 pop	 esi
  00cdb	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00cdc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cdf	33 cd		 xor	 ecx, ebp
  00ce1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ce6	8b e5		 mov	 esp, ebp
  00ce8	5d		 pop	 ebp
  00ce9	c3		 ret	 0
$LN152@ProtocolCo:

; 774  : 				break;
; 775  : 			case 0xE2:
; 776  : 				CGGuildAssignType((PMSG_GUILD_ASSIGN_TYPE_REQ *)aRecv, aIndex);

  00cea	56		 push	 esi
  00ceb	57		 push	 edi
  00cec	e8 00 00 00 00	 call	 ?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z ; CGGuildAssignType
  00cf1	83 c4 08	 add	 esp, 8
  00cf4	5f		 pop	 edi
  00cf5	5e		 pop	 esi
  00cf6	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00cf7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cfa	33 cd		 xor	 ecx, ebp
  00cfc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d01	8b e5		 mov	 esp, ebp
  00d03	5d		 pop	 ebp
  00d04	c3		 ret	 0
$LN151@ProtocolCo:

; 777  : 				break;
; 778  : 			case 0xE5:
; 779  : 				CGRelationShipReqJoinBreakOff((PMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ *)aRecv, aIndex);

  00d05	56		 push	 esi
  00d06	57		 push	 edi
  00d07	e8 00 00 00 00	 call	 ?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z ; CGRelationShipReqJoinBreakOff
  00d0c	83 c4 08	 add	 esp, 8
  00d0f	5f		 pop	 edi
  00d10	5e		 pop	 esi
  00d11	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00d12	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d15	33 cd		 xor	 ecx, ebp
  00d17	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d1c	8b e5		 mov	 esp, ebp
  00d1e	5d		 pop	 ebp
  00d1f	c3		 ret	 0
$LN150@ProtocolCo:

; 780  : 				break;
; 781  : 			case 0xE6:
; 782  : 				CGRelationShipAnsJoinBreakOff((PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS *)aRecv, aIndex);

  00d20	56		 push	 esi
  00d21	57		 push	 edi
  00d22	e8 00 00 00 00	 call	 ?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z ; CGRelationShipAnsJoinBreakOff
  00d27	83 c4 08	 add	 esp, 8
  00d2a	5f		 pop	 edi
  00d2b	5e		 pop	 esi
  00d2c	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00d2d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d30	33 cd		 xor	 ecx, ebp
  00d32	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d37	8b e5		 mov	 esp, ebp
  00d39	5d		 pop	 ebp
  00d3a	c3		 ret	 0
$LN149@ProtocolCo:

; 783  : 				break;
; 784  : 			case 0xE7:
; 785  : 				{
; 786  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 787  : 
; 788  : 					switch ( lpDef->subcode )

  00d3b	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00d3f	48		 dec	 eax

; 797  : 						break;
; 798  : 					default:
; 799  : //						LogAddTD("[0xE7] Unknown packet BF:%d",lpDef->subcode);
; 800  : 						g_Minimap.GCReqSendNpcPosInfo((_PMSG_REQ_NPC_POSITION*)aRecv, aIndex);

  00d40	56		 push	 esi
  00d41	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Minimap@@3VMinimap@@A ; g_Minimap
  00d46	74 30		 je	 SHORT $LN146@ProtocolCo

; 783  : 				break;
; 784  : 			case 0xE7:
; 785  : 				{
; 786  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 787  : 
; 788  : 					switch ( lpDef->subcode )

  00d48	48		 dec	 eax
  00d49	74 17		 je	 SHORT $LN145@ProtocolCo

; 797  : 						break;
; 798  : 					default:
; 799  : //						LogAddTD("[0xE7] Unknown packet BF:%d",lpDef->subcode);
; 800  : 						g_Minimap.GCReqSendNpcPosInfo((_PMSG_REQ_NPC_POSITION*)aRecv, aIndex);

  00d4b	57		 push	 edi
  00d4c	e8 00 00 00 00	 call	 ?GCReqSendNpcPosInfo@Minimap@@QAEXPAU_PMSG_REQ_NPC_POSITION@@H@Z ; Minimap::GCReqSendNpcPosInfo
  00d51	5f		 pop	 edi
  00d52	5e		 pop	 esi
  00d53	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00d54	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d57	33 cd		 xor	 ecx, ebp
  00d59	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d5e	8b e5		 mov	 esp, ebp
  00d60	5d		 pop	 ebp
  00d61	c3		 ret	 0
$LN145@ProtocolCo:

; 793  : 						break;
; 794  : 					case 2:
; 795  : //						g_MiniMap.SetCloseMinimap(aIndex);
; 796  : 						g_Minimap.CGReqSendMemberPosInfoStop(aIndex);

  00d62	e8 00 00 00 00	 call	 ?CGReqSendMemberPosInfoStop@Minimap@@QAEXH@Z ; Minimap::CGReqSendMemberPosInfoStop
  00d67	5f		 pop	 edi
  00d68	5e		 pop	 esi
  00d69	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00d6a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d6d	33 cd		 xor	 ecx, ebp
  00d6f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d74	8b e5		 mov	 esp, ebp
  00d76	5d		 pop	 ebp
  00d77	c3		 ret	 0
$LN146@ProtocolCo:

; 789  : 					{
; 790  : 					case 1:
; 791  : //						g_MiniMap.SetOpenMinimap(aIndex);
; 792  : 						g_Minimap.CGReqSendMemberPosInfoStart(aIndex);

  00d78	e8 00 00 00 00	 call	 ?CGReqSendMemberPosInfoStart@Minimap@@QAEXH@Z ; Minimap::CGReqSendMemberPosInfoStart
  00d7d	5f		 pop	 edi
  00d7e	5e		 pop	 esi
  00d7f	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00d80	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d83	33 cd		 xor	 ecx, ebp
  00d85	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d8a	8b e5		 mov	 esp, ebp
  00d8c	5d		 pop	 ebp
  00d8d	c3		 ret	 0
$LN143@ProtocolCo:

; 801  : 						break;
; 802  : 					}
; 803  : 				}
; 804  : 				break;
; 805  : 			case 0xE9:
; 806  : 				CGUnionList((PMSG_UNIONLIST_REQ *)aRecv, aIndex);

  00d8e	56		 push	 esi
  00d8f	57		 push	 edi
  00d90	e8 00 00 00 00	 call	 ?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z ; CGUnionList
  00d95	83 c4 08	 add	 esp, 8
  00d98	5f		 pop	 edi
  00d99	5e		 pop	 esi
  00d9a	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00d9b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d9e	33 cd		 xor	 ecx, ebp
  00da0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00da5	8b e5		 mov	 esp, ebp
  00da7	5d		 pop	 ebp
  00da8	c3		 ret	 0
$LN142@ProtocolCo:

; 807  : 				break;
; 808  : 			case 0xEC:
; 809  : 				{
; 810  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 811  : 
; 812  : 					switch( lpDef->subcode )

  00da9	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00dad	83 f8 31	 cmp	 eax, 49			; 00000031H
  00db0	0f 87 6b 0e 00
	00		 ja	 $LN313@ProtocolCo
  00db6	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN344@ProtocolCo[eax]
  00dbd	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN361@ProtocolCo[edx*4]
$LN139@ProtocolCo:

; 813  : 					{
; 814  : 					case 0x00:
; 815  : 						g_ElementalSystem.CGInsertErtel(aIndex,(PMSG_REQ_INSERTERTEL*)aRecv);

  00dc4	57		 push	 edi
  00dc5	56		 push	 esi
  00dc6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00dcb	e8 00 00 00 00	 call	 ?CGInsertErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_INSERTERTEL@@@Z ; CElementalSystem::CGInsertErtel
  00dd0	5f		 pop	 edi
  00dd1	5e		 pop	 esi
  00dd2	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00dd3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00dd6	33 cd		 xor	 ecx, ebp
  00dd8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ddd	8b e5		 mov	 esp, ebp
  00ddf	5d		 pop	 ebp
  00de0	c3		 ret	 0
$LN138@ProtocolCo:

; 816  : 						break;
; 817  : 					case 0x01:
; 818  : 						g_ElementalSystem.CGRemoveErtel(aIndex,(PMSG_REQ_REMOVEERTEL*)aRecv);

  00de1	57		 push	 edi
  00de2	56		 push	 esi
  00de3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00de8	e8 00 00 00 00	 call	 ?CGRemoveErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_REMOVEERTEL@@@Z ; CElementalSystem::CGRemoveErtel
  00ded	5f		 pop	 edi
  00dee	5e		 pop	 esi
  00def	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00df0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00df3	33 cd		 xor	 ecx, ebp
  00df5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00dfa	8b e5		 mov	 esp, ebp
  00dfc	5d		 pop	 ebp
  00dfd	c3		 ret	 0
$LN137@ProtocolCo:

; 819  : 						break;
; 820  : 					case 0x02:
; 821  : 						g_ElementalSystem.CGCombineButtonClick((PMSG_ERTEL_COMBINE*)aRecv,aIndex);

  00dfe	56		 push	 esi
  00dff	57		 push	 edi
  00e00	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00e05	e8 00 00 00 00	 call	 ?CGCombineButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_COMBINE@@H@Z ; CElementalSystem::CGCombineButtonClick
  00e0a	5f		 pop	 edi
  00e0b	5e		 pop	 esi
  00e0c	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00e0d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e10	33 cd		 xor	 ecx, ebp
  00e12	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e17	8b e5		 mov	 esp, ebp
  00e19	5d		 pop	 ebp
  00e1a	c3		 ret	 0
$LN136@ProtocolCo:

; 822  : 						break;
; 823  : 					case 0x03:
; 824  : 						g_ElementalSystem.CGUpgradeButtonClick((PMSG_ERTEL_LEVELUP*)aRecv,aIndex);

  00e1b	56		 push	 esi
  00e1c	57		 push	 edi
  00e1d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00e22	e8 00 00 00 00	 call	 ?CGUpgradeButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_LEVELUP@@H@Z ; CElementalSystem::CGUpgradeButtonClick
  00e27	5f		 pop	 edi
  00e28	5e		 pop	 esi
  00e29	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00e2a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e2d	33 cd		 xor	 ecx, ebp
  00e2f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e34	8b e5		 mov	 esp, ebp
  00e36	5d		 pop	 ebp
  00e37	c3		 ret	 0
$LN135@ProtocolCo:

; 825  : 						break;
; 826  : 					case 0x31:
; 827  : 						g_ShopBoard.CGReqItemSearch(aIndex, (SHOPBOARD_CGREQ_ITEM*)aRecv);

  00e38	57		 push	 edi
  00e39	56		 push	 esi
  00e3a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopBoard@@3VShopBoard@@A ; g_ShopBoard
  00e3f	e8 00 00 00 00	 call	 ?CGReqItemSearch@ShopBoard@@QAEXHPAUSHOPBOARD_CGREQ_ITEM@@@Z ; ShopBoard::CGReqItemSearch
  00e44	5f		 pop	 edi
  00e45	5e		 pop	 esi
  00e46	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00e47	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e4a	33 cd		 xor	 ecx, ebp
  00e4c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e51	8b e5		 mov	 esp, ebp
  00e53	5d		 pop	 ebp
  00e54	c3		 ret	 0
$LN134@ProtocolCo:

; 828  : 						break;
; 829  : 					}
; 830  : 				}
; 831  : 				break;
; 832  : 			case 0xED:
; 833  : 				{
; 834  : 					PMSG_DEFAULT2* lpDef = (PMSG_DEFAULT2*)aRecv;
; 835  : 					// ----
; 836  : 					switch(lpDef->subcode)

  00e55	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00e59	83 f8 08	 cmp	 eax, 8
  00e5c	0f 87 bf 0d 00
	00		 ja	 $LN313@ProtocolCo
  00e62	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN362@ProtocolCo[eax*4]
$LN131@ProtocolCo:

; 837  : 					{
; 838  : 					case 0x00:
; 839  : 						g_GuildMatch.CGReqOfferList(aIndex, (GUILDMATCH_CGREQ_OFFERLIST*)aRecv);

  00e69	57		 push	 edi
  00e6a	56		 push	 esi
  00e6b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00e70	e8 00 00 00 00	 call	 ?CGReqOfferList@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERLIST@@@Z ; GuildMatch::CGReqOfferList
  00e75	5f		 pop	 edi
  00e76	5e		 pop	 esi
  00e77	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00e78	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e7b	33 cd		 xor	 ecx, ebp
  00e7d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e82	8b e5		 mov	 esp, ebp
  00e84	5d		 pop	 ebp
  00e85	c3		 ret	 0
$LN130@ProtocolCo:

; 840  : 						break;
; 841  : 					case 0x01:
; 842  : 						g_GuildMatch.CGReqOfferListByFilter(aIndex, (GUILDMATCH_CGREQ_OFFERLISTFILTER*)aRecv);

  00e86	57		 push	 edi
  00e87	56		 push	 esi
  00e88	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00e8d	e8 00 00 00 00	 call	 ?CGReqOfferListByFilter@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERLISTFILTER@@@Z ; GuildMatch::CGReqOfferListByFilter
  00e92	5f		 pop	 edi
  00e93	5e		 pop	 esi
  00e94	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00e95	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e98	33 cd		 xor	 ecx, ebp
  00e9a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e9f	8b e5		 mov	 esp, ebp
  00ea1	5d		 pop	 ebp
  00ea2	c3		 ret	 0
$LN129@ProtocolCo:

; 843  : 						break;
; 844  : 					case 0x02:
; 845  : 						g_GuildMatch.CGReqOfferCreate(aIndex, (GUILDMATCH_CGREQ_OFFERCREATE*)aRecv);

  00ea3	57		 push	 edi
  00ea4	56		 push	 esi
  00ea5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00eaa	e8 00 00 00 00	 call	 ?CGReqOfferCreate@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERCREATE@@@Z ; GuildMatch::CGReqOfferCreate
  00eaf	5f		 pop	 edi
  00eb0	5e		 pop	 esi
  00eb1	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00eb2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00eb5	33 cd		 xor	 ecx, ebp
  00eb7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ebc	8b e5		 mov	 esp, ebp
  00ebe	5d		 pop	 ebp
  00ebf	c3		 ret	 0
$LN128@ProtocolCo:

; 846  : 						break;
; 847  : 					case 0x03:
; 848  : 						g_GuildMatch.CGReqOfferDelete(aIndex, (GUILDMATCH_CGREQ_OFFERDELETE*)aRecv);

  00ec0	57		 push	 edi
  00ec1	56		 push	 esi
  00ec2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00ec7	e8 00 00 00 00	 call	 ?CGReqOfferDelete@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERDELETE@@@Z ; GuildMatch::CGReqOfferDelete
  00ecc	5f		 pop	 edi
  00ecd	5e		 pop	 esi
  00ece	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00ecf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ed2	33 cd		 xor	 ecx, ebp
  00ed4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ed9	8b e5		 mov	 esp, ebp
  00edb	5d		 pop	 ebp
  00edc	c3		 ret	 0
$LN127@ProtocolCo:

; 849  : 						break;
; 850  : 					case 0x04:
; 851  : 						g_GuildMatch.CGReqJoinReq(aIndex, (GUILDMATCH_CGREQ_JOINREQ*)aRecv);

  00edd	57		 push	 edi
  00ede	56		 push	 esi
  00edf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00ee4	e8 00 00 00 00	 call	 ?CGReqJoinReq@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQ@@@Z ; GuildMatch::CGReqJoinReq
  00ee9	5f		 pop	 edi
  00eea	5e		 pop	 esi
  00eeb	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00eec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00eef	33 cd		 xor	 ecx, ebp
  00ef1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ef6	8b e5		 mov	 esp, ebp
  00ef8	5d		 pop	 ebp
  00ef9	c3		 ret	 0
$LN126@ProtocolCo:

; 852  : 						break;
; 853  : 					case 0x05:
; 854  : 						g_GuildMatch.CGReqJoinReqDelete(aIndex, (GUILDMATCH_CGREQ_JOINREQDELETE*)aRecv);

  00efa	57		 push	 edi
  00efb	56		 push	 esi
  00efc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00f01	e8 00 00 00 00	 call	 ?CGReqJoinReqDelete@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQDELETE@@@Z ; GuildMatch::CGReqJoinReqDelete
  00f06	5f		 pop	 edi
  00f07	5e		 pop	 esi
  00f08	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00f09	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f0c	33 cd		 xor	 ecx, ebp
  00f0e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f13	8b e5		 mov	 esp, ebp
  00f15	5d		 pop	 ebp
  00f16	c3		 ret	 0
$LN125@ProtocolCo:

; 855  : 						break;
; 856  : 					case 0x06:
; 857  : 						g_GuildMatch.CGReqJoinReqAnswer(aIndex, (GUILDMATCH_CGREQ_REQUESTANSWER*)aRecv);

  00f17	57		 push	 edi
  00f18	56		 push	 esi
  00f19	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00f1e	e8 00 00 00 00	 call	 ?CGReqJoinReqAnswer@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_REQUESTANSWER@@@Z ; GuildMatch::CGReqJoinReqAnswer
  00f23	5f		 pop	 edi
  00f24	5e		 pop	 esi
  00f25	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00f26	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f29	33 cd		 xor	 ecx, ebp
  00f2b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f30	8b e5		 mov	 esp, ebp
  00f32	5d		 pop	 ebp
  00f33	c3		 ret	 0
$LN124@ProtocolCo:

; 858  : 						break;
; 859  : 					case 0x07:
; 860  : 						g_GuildMatch.CGReqJoinReqList(aIndex, (GUILDMATCH_CGREQ_REQUESTLIST*)aRecv);

  00f34	57		 push	 edi
  00f35	56		 push	 esi
  00f36	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00f3b	e8 00 00 00 00	 call	 ?CGReqJoinReqList@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_REQUESTLIST@@@Z ; GuildMatch::CGReqJoinReqList
  00f40	5f		 pop	 edi
  00f41	5e		 pop	 esi
  00f42	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00f43	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f46	33 cd		 xor	 ecx, ebp
  00f48	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f4d	8b e5		 mov	 esp, ebp
  00f4f	5d		 pop	 ebp
  00f50	c3		 ret	 0
$LN123@ProtocolCo:

; 861  : 						break;
; 862  : 					case 0x08:
; 863  : 						g_GuildMatch.CGReqJoinReqStatus(aIndex, (GUILDMATCH_CGREQ_JOINREQSTATUS*)aRecv);

  00f51	57		 push	 edi
  00f52	56		 push	 esi
  00f53	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00f58	e8 00 00 00 00	 call	 ?CGReqJoinReqStatus@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQSTATUS@@@Z ; GuildMatch::CGReqJoinReqStatus
  00f5d	5f		 pop	 edi
  00f5e	5e		 pop	 esi
  00f5f	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00f60	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f63	33 cd		 xor	 ecx, ebp
  00f65	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f6a	8b e5		 mov	 esp, ebp
  00f6c	5d		 pop	 ebp
  00f6d	c3		 ret	 0
$LN122@ProtocolCo:

; 864  : 						break;
; 865  : 
; 866  : 					}
; 867  : 				}
; 868  : 				break;
; 869  : 
; 870  : 			case 0xFE:
; 871  : 				{
; 872  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 873  : 
; 874  : 					switch( lpDef->subcode )

  00f6e	8a 57 03	 mov	 dl, BYTE PTR [edi+3]
  00f71	80 fa 05	 cmp	 dl, 5
  00f74	74 58		 je	 SHORT $LN119@ProtocolCo
  00f76	80 fa fe	 cmp	 dl, 254			; 000000feH
  00f79	0f 85 a2 0c 00
	00		 jne	 $LN313@ProtocolCo

; 892  : 						break;
; 893  : 
; 894  : 					case 0xFE:
; 895  : 						{
; 896  : 							if( gObj[aIndex].m_IfState.type == 21 )

  00f7f	8b 91 b8 11 00
	00		 mov	 edx, DWORD PTR [ecx+4536]
  00f85	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00f8b	81 fa 40 05 00
	00		 cmp	 edx, 1344		; 00000540H
  00f91	0f 85 8a 0c 00
	00		 jne	 $LN313@ProtocolCo

; 897  : 							{
; 898  : 								gObj[aIndex].m_IfState.use = 0;

  00f97	83 a1 b8 11 00
	00 fc		 and	 DWORD PTR [ecx+4536], -4 ; fffffffcH

; 899  : 								gObj[aIndex].m_IfState.type = 0;

  00f9e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fa4	81 a4 08 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [eax+ecx+4536], -65473 ; ffff003fH

; 900  : 								gObj[aIndex].m_IfState.state = 0;

  00faf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fb5	83 a4 08 b8 11
	00 00 c3	 and	 DWORD PTR [eax+ecx+4536], -61 ; ffffffc3H
  00fbd	5f		 pop	 edi
  00fbe	5e		 pop	 esi
  00fbf	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00fc0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00fc3	33 cd		 xor	 ecx, ebp
  00fc5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fca	8b e5		 mov	 esp, ebp
  00fcc	5d		 pop	 ebp
  00fcd	c3		 ret	 0
$LN119@ProtocolCo:

; 875  : 					{
; 876  : #if (CUSTOM_OLYMP==1)
; 877  : 					case 0x01:
; 878  : 						g_CustomOlymp.CGRequestReg(aIndex);
; 879  : 						break;
; 880  : 					case 0x02:
; 881  : 						g_CustomOlymp.CGRequestReward(aIndex);
; 882  : 						break;
; 883  : #endif
; 884  : 
; 885  : #if(__NOVUS == 1)
; 886  : 					case 0x03:
; 887  : 						g_ExPoint.Update(aIndex);
; 888  : 						break;
; 889  : #endif
; 890  : 					case 0x05:
; 891  : 						g_ResetSystem.CG_RequestStart(aIndex, (PacketResetStart*)aRecv);

  00fce	57		 push	 edi
  00fcf	56		 push	 esi
  00fd0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ResetSystem@@3VResetSystem@@A ; g_ResetSystem
  00fd5	e8 00 00 00 00	 call	 ?CG_RequestStart@ResetSystem@@QAEXHPAUPacketResetStart@@@Z ; ResetSystem::CG_RequestStart
  00fda	5f		 pop	 edi
  00fdb	5e		 pop	 esi
  00fdc	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  00fdd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00fe0	33 cd		 xor	 ecx, ebp
  00fe2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fe7	8b e5		 mov	 esp, ebp
  00fe9	5d		 pop	 ebp
  00fea	c3		 ret	 0
$LN116@ProtocolCo:

; 901  : 							}
; 902  : 						}
; 903  : 						break;
; 904  : 					}
; 905  : 
; 906  : 				}
; 907  : 				break;
; 908  : 			case 0xEF:
; 909  : 				{
; 910  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 911  : 					
; 912  : 					switch( lpDef->subcode )

  00feb	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00fef	83 f8 07	 cmp	 eax, 7
  00ff2	0f 87 29 0c 00
	00		 ja	 $LN313@ProtocolCo
  00ff8	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN363@ProtocolCo[eax*4]
$LN113@ProtocolCo:

; 913  : 					{
; 914  : 					case 0x00:
; 915  : 						CGReqPartyMatchReg((PMSG_PARTYMATCH_REG_REQ*)aRecv,aIndex);

  00fff	56		 push	 esi
  01000	57		 push	 edi
  01001	e8 00 00 00 00	 call	 ?CGReqPartyMatchReg@@YAXPAUPMSG_PARTYMATCH_REG_REQ@@H@Z ; CGReqPartyMatchReg
  01006	83 c4 08	 add	 esp, 8
  01009	5f		 pop	 edi
  0100a	5e		 pop	 esi
  0100b	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0100c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0100f	33 cd		 xor	 ecx, ebp
  01011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01016	8b e5		 mov	 esp, ebp
  01018	5d		 pop	 ebp
  01019	c3		 ret	 0
$LN112@ProtocolCo:

; 916  : 						break;
; 917  : 					case 0x01:
; 918  : 						CGReqPartyMatchWindow((PMSG_PARTYMATCH_INFO_REQ*)aRecv,aIndex);

  0101a	56		 push	 esi
  0101b	57		 push	 edi
  0101c	e8 00 00 00 00	 call	 ?CGReqPartyMatchWindow@@YAXPAUPMSG_PARTYMATCH_INFO_REQ@@H@Z ; CGReqPartyMatchWindow
  01021	83 c4 08	 add	 esp, 8
  01024	5f		 pop	 edi
  01025	5e		 pop	 esi
  01026	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01027	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0102a	33 cd		 xor	 ecx, ebp
  0102c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01031	8b e5		 mov	 esp, ebp
  01033	5d		 pop	 ebp
  01034	c3		 ret	 0
$LN111@ProtocolCo:

; 919  : 						break;
; 920  : 					case 0x02:
; 921  : 						CGReqPartyMatchJoin((PMSG_PARTYMATCH_JOIN_REQ*)aRecv,aIndex);

  01035	56		 push	 esi
  01036	57		 push	 edi
  01037	e8 00 00 00 00	 call	 ?CGReqPartyMatchJoin@@YAXPAUPMSG_PARTYMATCH_JOIN_REQ@@H@Z ; CGReqPartyMatchJoin
  0103c	83 c4 08	 add	 esp, 8
  0103f	5f		 pop	 edi
  01040	5e		 pop	 esi
  01041	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01042	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01045	33 cd		 xor	 ecx, ebp
  01047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0104c	8b e5		 mov	 esp, ebp
  0104e	5d		 pop	 ebp
  0104f	c3		 ret	 0
$LN110@ProtocolCo:

; 922  : 						break;
; 923  : 					case 0x03:
; 924  : 						CGReqPartyMatchWaitingList(aIndex);

  01050	56		 push	 esi
  01051	e8 00 00 00 00	 call	 ?CGReqPartyMatchWaitingList@@YAXH@Z ; CGReqPartyMatchWaitingList
  01056	83 c4 04	 add	 esp, 4
  01059	5f		 pop	 edi
  0105a	5e		 pop	 esi
  0105b	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0105c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0105f	33 cd		 xor	 ecx, ebp
  01061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01066	8b e5		 mov	 esp, ebp
  01068	5d		 pop	 ebp
  01069	c3		 ret	 0
$LN109@ProtocolCo:

; 925  : 						break;
; 926  : 					case 0x04:
; 927  : 						CGReqPartyMatchAcceptList(aIndex);

  0106a	56		 push	 esi
  0106b	e8 00 00 00 00	 call	 ?CGReqPartyMatchAcceptList@@YAXH@Z ; CGReqPartyMatchAcceptList
  01070	83 c4 04	 add	 esp, 4
  01073	5f		 pop	 edi
  01074	5e		 pop	 esi
  01075	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01076	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01079	33 cd		 xor	 ecx, ebp
  0107b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01080	8b e5		 mov	 esp, ebp
  01082	5d		 pop	 ebp
  01083	c3		 ret	 0
$LN108@ProtocolCo:

; 928  : 						break;
; 929  : 					case 0x05:
; 930  : 						CGReqPartyMatchRequestAnswer((PARTYMATCH_CGREQ_REQUESTANSWER*)aRecv, aIndex);

  01084	56		 push	 esi
  01085	57		 push	 edi
  01086	e8 00 00 00 00	 call	 ?CGReqPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_CGREQ_REQUESTANSWER@@H@Z ; CGReqPartyMatchRequestAnswer
  0108b	83 c4 08	 add	 esp, 8
  0108e	5f		 pop	 edi
  0108f	5e		 pop	 esi
  01090	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01094	33 cd		 xor	 ecx, ebp
  01096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0109b	8b e5		 mov	 esp, ebp
  0109d	5d		 pop	 ebp
  0109e	c3		 ret	 0
$LN107@ProtocolCo:

; 931  : 						break;
; 932  : 					case 0x06:
; 933  : 						CGReqPartyMatchCancel((PMSG_PARTYMATCH_CANCEL_REQ*)aRecv,aIndex);

  0109f	56		 push	 esi
  010a0	57		 push	 edi
  010a1	e8 00 00 00 00	 call	 ?CGReqPartyMatchCancel@@YAXPAUPMSG_PARTYMATCH_CANCEL_REQ@@H@Z ; CGReqPartyMatchCancel
  010a6	83 c4 08	 add	 esp, 8
  010a9	5f		 pop	 edi
  010aa	5e		 pop	 esi
  010ab	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  010ac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010af	33 cd		 xor	 ecx, ebp
  010b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010b6	8b e5		 mov	 esp, ebp
  010b8	5d		 pop	 ebp
  010b9	c3		 ret	 0
$LN106@ProtocolCo:

; 934  : 						break;
; 935  : 					case 0x07:
; 936  : 						ClientTestSend(aIndex, (ClientTest*)aRecv);

  010ba	57		 push	 edi
  010bb	56		 push	 esi
  010bc	e8 00 00 00 00	 call	 ?ClientTestSend@@YAXHPAUClientTest@@@Z ; ClientTestSend
  010c1	83 c4 08	 add	 esp, 8
  010c4	5f		 pop	 edi
  010c5	5e		 pop	 esi
  010c6	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  010c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010ca	33 cd		 xor	 ecx, ebp
  010cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010d1	8b e5		 mov	 esp, ebp
  010d3	5d		 pop	 ebp
  010d4	c3		 ret	 0
$LN105@ProtocolCo:

; 937  : 						break;
; 938  : 					}
; 939  : 				}
; 940  : 				//LogAddHeadHexFunc(1,(PCHAR)aRecv,aLen);
; 941  : 				break;
; 942  : 			case 0xEB:
; 943  : 				{
; 944  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 945  : 
; 946  : 					switch ( lpDef->subcode )

  010d5	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  010d9	48		 dec	 eax
  010da	0f 85 41 0b 00
	00		 jne	 $LN313@ProtocolCo

; 947  : 					{
; 948  : 						case 0x01:
; 949  : 							CGRelationShipReqKickOutUnionMember((PMSG_KICKOUT_UNIONMEMBER_REQ *)aRecv, aIndex);

  010e0	56		 push	 esi
  010e1	57		 push	 edi
  010e2	e8 00 00 00 00	 call	 ?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z ; CGRelationShipReqKickOutUnionMember
  010e7	83 c4 08	 add	 esp, 8
  010ea	5f		 pop	 edi
  010eb	5e		 pop	 esi
  010ec	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  010ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010f0	33 cd		 xor	 ecx, ebp
  010f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010f7	8b e5		 mov	 esp, ebp
  010f9	5d		 pop	 ebp
  010fa	c3		 ret	 0
$LN100@ProtocolCo:

; 950  : 							break;
; 951  : 					}
; 952  : 				}
; 953  : 				break;
; 954  : 			case 0x71:
; 955  : 				//GCPingSendRecv((PMSG_PING_RESULT *)aRecv, aIndex);
; 956  : 				break;
; 957  : 			case 0x72:
; 958  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  010fb	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  010fe	50		 push	 eax
  010ff	53		 push	 ebx
  01100	56		 push	 esi
  01101	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  01106	83 c4 0c	 add	 esp, 12			; 0000000cH
  01109	85 c0		 test	 eax, eax
  0110b	0f 84 10 0b 00
	00		 je	 $LN313@ProtocolCo

; 959  : 				{
; 960  : 					GCPacketCheckSumRecv((PMSG_PACKETCHECKSUM *)aRecv, aIndex);

  01111	56		 push	 esi
  01112	57		 push	 edi
  01113	e8 00 00 00 00	 call	 ?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z ; GCPacketCheckSumRecv
  01118	83 c4 08	 add	 esp, 8
  0111b	5f		 pop	 edi
  0111c	5e		 pop	 esi
  0111d	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0111e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01121	33 cd		 xor	 ecx, ebp
  01123	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01128	8b e5		 mov	 esp, ebp
  0112a	5d		 pop	 ebp
  0112b	c3		 ret	 0
$LN98@ProtocolCo:

; 961  : 				}
; 962  : 				break;
; 963  : 			case 0x73:
; 964  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0112c	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  0112f	51		 push	 ecx
  01130	53		 push	 ebx
  01131	56		 push	 esi
  01132	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  01137	83 c4 0c	 add	 esp, 12			; 0000000cH
  0113a	5f		 pop	 edi
  0113b	5e		 pop	 esi
  0113c	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0113d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01140	33 cd		 xor	 ecx, ebp
  01142	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01147	8b e5		 mov	 esp, ebp
  01149	5d		 pop	 ebp
  0114a	c3		 ret	 0
$LN96@ProtocolCo:

; 965  : 				{
; 966  : 					GCNPggCheckSumRecv((PMSG_NPROTECTGGCHECKSUM *)aRecv, aIndex);
; 967  : 				}
; 968  : 				break;
; 969  : 			case 0x81:
; 970  : 				CGWarehouseMoneyInOut(aIndex, (PMSG_WAREHOUSEMONEYINOUT *)aRecv);

  0114b	57		 push	 edi
  0114c	56		 push	 esi
  0114d	e8 00 00 00 00	 call	 ?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ; CGWarehouseMoneyInOut
  01152	83 c4 08	 add	 esp, 8
  01155	5f		 pop	 edi
  01156	5e		 pop	 esi
  01157	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01158	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0115b	33 cd		 xor	 ecx, ebp
  0115d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01162	8b e5		 mov	 esp, ebp
  01164	5d		 pop	 ebp
  01165	c3		 ret	 0
$LN95@ProtocolCo:

; 971  : 				break;
; 972  : 			case 0x82:
; 973  : 				CGWarehouseUseEnd(aIndex);

  01166	56		 push	 esi
  01167	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd
  0116c	83 c4 04	 add	 esp, 4
  0116f	5f		 pop	 edi
  01170	5e		 pop	 esi
  01171	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01172	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01175	33 cd		 xor	 ecx, ebp
  01177	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0117c	8b e5		 mov	 esp, ebp
  0117e	5d		 pop	 ebp
  0117f	c3		 ret	 0
$LN94@ProtocolCo:

; 974  : 				break;
; 975  : 			case 0x83:
; 976  : 				GCWarehouseRecivePassword(aIndex, (PMSG_WAREHOUSEPASSSEND *)aRecv);

  01180	57		 push	 edi
  01181	56		 push	 esi
  01182	e8 00 00 00 00	 call	 ?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ; GCWarehouseRecivePassword
  01187	83 c4 08	 add	 esp, 8
  0118a	5f		 pop	 edi
  0118b	5e		 pop	 esi
  0118c	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0118d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01190	33 cd		 xor	 ecx, ebp
  01192	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01197	8b e5		 mov	 esp, ebp
  01199	5d		 pop	 ebp
  0119a	c3		 ret	 0
$LN93@ProtocolCo:

; 977  : 				break;
; 978  : 			case 0x86:
; 979  : 				CGChaosBoxItemMixButtonClick((PMSG_CHAOSMIX *)aRecv, aIndex);

  0119b	56		 push	 esi
  0119c	57		 push	 edi
  0119d	e8 00 00 00 00	 call	 ?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ; CGChaosBoxItemMixButtonClick
  011a2	83 c4 08	 add	 esp, 8
  011a5	5f		 pop	 edi
  011a6	5e		 pop	 esi
  011a7	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  011a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011ab	33 cd		 xor	 ecx, ebp
  011ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011b2	8b e5		 mov	 esp, ebp
  011b4	5d		 pop	 ebp
  011b5	c3		 ret	 0
$LN92@ProtocolCo:

; 980  : 				break;
; 981  : 			case 0x87:
; 982  : 				CGChaosBoxUseEnd(aIndex);

  011b6	56		 push	 esi
  011b7	e8 00 00 00 00	 call	 ?CGChaosBoxUseEnd@@YAXH@Z ; CGChaosBoxUseEnd
  011bc	83 c4 04	 add	 esp, 4
  011bf	5f		 pop	 edi
  011c0	5e		 pop	 esi
  011c1	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  011c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011c5	33 cd		 xor	 ecx, ebp
  011c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011cc	8b e5		 mov	 esp, ebp
  011ce	5d		 pop	 ebp
  011cf	c3		 ret	 0
$LN91@ProtocolCo:

; 983  : 				break;
; 984  : 			case 0x8E:
; 985  : 				CGWindowReqMove((PMSG_MOVE_REQUEST*)aRecv,aIndex);

  011d0	56		 push	 esi
  011d1	57		 push	 edi
  011d2	e8 00 00 00 00	 call	 ?CGWindowReqMove@@YAXPAUPMSG_MOVE_REQUEST@@H@Z ; CGWindowReqMove
  011d7	83 c4 08	 add	 esp, 8
  011da	5f		 pop	 edi
  011db	5e		 pop	 esi
  011dc	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  011dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011e0	33 cd		 xor	 ecx, ebp
  011e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011e7	8b e5		 mov	 esp, ebp
  011e9	5d		 pop	 ebp
  011ea	c3		 ret	 0
$LN90@ProtocolCo:

; 986  : 				break;
; 987  : 			case 0x90:
; 988  : 				GCReqmoveDevilSquare((PMSG_REQ_MOVEDEVILSQUARE *)aRecv, aIndex);

  011eb	56		 push	 esi
  011ec	57		 push	 edi
  011ed	e8 00 00 00 00	 call	 ?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ; GCReqmoveDevilSquare
  011f2	83 c4 08	 add	 esp, 8
  011f5	5f		 pop	 edi
  011f6	5e		 pop	 esi
  011f7	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  011f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011fb	33 cd		 xor	 ecx, ebp
  011fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01202	8b e5		 mov	 esp, ebp
  01204	5d		 pop	 ebp
  01205	c3		 ret	 0
$LN89@ProtocolCo:

; 989  : 				break;
; 990  : 			case 0x91:
; 991  : 				GCReqDevilSquareRemainTime((PMSG_REQ_DEVILSQUARE_REMAINTIME *)aRecv, aIndex);

  01206	56		 push	 esi
  01207	57		 push	 edi
  01208	e8 00 00 00 00	 call	 ?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ; GCReqDevilSquareRemainTime
  0120d	83 c4 08	 add	 esp, 8
  01210	5f		 pop	 edi
  01211	5e		 pop	 esi
  01212	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01213	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01216	33 cd		 xor	 ecx, ebp
  01218	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0121d	8b e5		 mov	 esp, ebp
  0121f	5d		 pop	 ebp
  01220	c3		 ret	 0
$LN88@ProtocolCo:

; 992  : 				break;
; 993  : 			case 0x95:
; 994  : 				GCRegEventChipRecv((PMSG_REGEVENTCHIP *)aRecv, aIndex);

  01221	56		 push	 esi
  01222	57		 push	 edi
  01223	e8 00 00 00 00	 call	 ?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ; GCRegEventChipRecv
  01228	83 c4 08	 add	 esp, 8
  0122b	5f		 pop	 edi
  0122c	5e		 pop	 esi
  0122d	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0122e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01231	33 cd		 xor	 ecx, ebp
  01233	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01238	8b e5		 mov	 esp, ebp
  0123a	5d		 pop	 ebp
  0123b	c3		 ret	 0
$LN87@ProtocolCo:

; 995  : 				break;
; 996  : 			case 0x96:
; 997  : 				GCGetMutoNumRecv((PMSG_GETMUTONUMBER *)aRecv, aIndex);

  0123c	56		 push	 esi
  0123d	57		 push	 edi
  0123e	e8 00 00 00 00	 call	 ?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ; GCGetMutoNumRecv
  01243	83 c4 08	 add	 esp, 8
  01246	5f		 pop	 edi
  01247	5e		 pop	 esi
  01248	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01249	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0124c	33 cd		 xor	 ecx, ebp
  0124e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01253	8b e5		 mov	 esp, ebp
  01255	5d		 pop	 ebp
  01256	c3		 ret	 0
$LN86@ProtocolCo:

; 998  : 				break;
; 999  : 			case 0x97:
; 1000 : 				GCUseEndEventChipRescv(aIndex);

  01257	56		 push	 esi
  01258	e8 00 00 00 00	 call	 ?GCUseEndEventChipRescv@@YAXH@Z ; GCUseEndEventChipRescv
  0125d	83 c4 04	 add	 esp, 4
  01260	5f		 pop	 edi
  01261	5e		 pop	 esi
  01262	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01263	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01266	33 cd		 xor	 ecx, ebp
  01268	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0126d	8b e5		 mov	 esp, ebp
  0126f	5d		 pop	 ebp
  01270	c3		 ret	 0
$LN85@ProtocolCo:

; 1001 : 				break;
; 1002 : 			case 0x98:
; 1003 : 				GCUseRenaChangeZenRecv((PMSG_EXCHANGE_EVENTCHIP *)aRecv, aIndex);

  01271	56		 push	 esi
  01272	57		 push	 edi
  01273	e8 00 00 00 00	 call	 ?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ; GCUseRenaChangeZenRecv
  01278	83 c4 08	 add	 esp, 8
  0127b	5f		 pop	 edi
  0127c	5e		 pop	 esi
  0127d	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0127e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01281	33 cd		 xor	 ecx, ebp
  01283	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01288	8b e5		 mov	 esp, ebp
  0128a	5d		 pop	 ebp
  0128b	c3		 ret	 0
$LN84@ProtocolCo:

; 1004 : 				break;
; 1005 : 			case 0x99:
; 1006 : 				CGReqMoveOtherServer((PMSG_REQ_MOVE_OTHERSERVER *)aRecv, aIndex);

  0128c	56		 push	 esi
  0128d	57		 push	 edi
  0128e	e8 00 00 00 00	 call	 ?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z ; CGReqMoveOtherServer
  01293	83 c4 08	 add	 esp, 8
  01296	5f		 pop	 edi
  01297	5e		 pop	 esi
  01298	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01299	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0129c	33 cd		 xor	 ecx, ebp
  0129e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012a3	8b e5		 mov	 esp, ebp
  012a5	5d		 pop	 ebp
  012a6	c3		 ret	 0
$LN83@ProtocolCo:

; 1007 : 				break;
; 1008 : 			case 0xA0:
; 1009 : 				CGRequestQuestInfo(aIndex);

  012a7	56		 push	 esi
  012a8	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo
  012ad	83 c4 04	 add	 esp, 4
  012b0	5f		 pop	 edi
  012b1	5e		 pop	 esi
  012b2	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  012b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012b6	33 cd		 xor	 ecx, ebp
  012b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012bd	8b e5		 mov	 esp, ebp
  012bf	5d		 pop	 ebp
  012c0	c3		 ret	 0
$LN82@ProtocolCo:

; 1010 : 				break;
; 1011 : 			case 0xA2:
; 1012 : 				CGSetQuestState((PMSG_SETQUEST *)aRecv, aIndex);

  012c1	56		 push	 esi
  012c2	57		 push	 edi
  012c3	e8 00 00 00 00	 call	 ?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z ; CGSetQuestState
  012c8	83 c4 08	 add	 esp, 8
  012cb	5f		 pop	 edi
  012cc	5e		 pop	 esi
  012cd	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  012ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012d1	33 cd		 xor	 ecx, ebp
  012d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012d8	8b e5		 mov	 esp, ebp
  012da	5d		 pop	 ebp
  012db	c3		 ret	 0
$LN81@ProtocolCo:

; 1013 : 				break;
; 1014 : 			case 0xA7:
; 1015 : 				CGRequestPetItemCommand((PMSG_REQUEST_PET_ITEM_COMMAND *)aRecv, aIndex);

  012dc	56		 push	 esi
  012dd	57		 push	 edi
  012de	e8 00 00 00 00	 call	 ?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ; CGRequestPetItemCommand
  012e3	83 c4 08	 add	 esp, 8
  012e6	5f		 pop	 edi
  012e7	5e		 pop	 esi
  012e8	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  012e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012ec	33 cd		 xor	 ecx, ebp
  012ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012f3	8b e5		 mov	 esp, ebp
  012f5	5d		 pop	 ebp
  012f6	c3		 ret	 0
$LN80@ProtocolCo:

; 1016 : 				break;
; 1017 : 			case 0xA9:
; 1018 : 				CGRequestPetItemInfo((PMSG_REQUEST_PET_ITEMINFO *)aRecv, aIndex);

  012f7	56		 push	 esi
  012f8	57		 push	 edi
  012f9	e8 00 00 00 00	 call	 ?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ; CGRequestPetItemInfo
  012fe	83 c4 08	 add	 esp, 8
  01301	5f		 pop	 edi
  01302	5e		 pop	 esi
  01303	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01304	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01307	33 cd		 xor	 ecx, ebp
  01309	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0130e	8b e5		 mov	 esp, ebp
  01310	5d		 pop	 ebp
  01311	c3		 ret	 0
$LN79@ProtocolCo:

; 1019 : 				break;
; 1020 : #if (ENABLETEST_NEWPVP == 1)
; 1021 : 			case 0xAA://1.00.93
; 1022 : 				{
; 1023 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1024 : 					WORD wPacketType = MAKEWORD(lpDef->subcode,0xAA);
; 1025 : 					// ----
; 1026 : 					switch(wPacketType)

  01312	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  01316	0d 00 aa 00 00	 or	 eax, 43520		; 0000aa00H
  0131b	05 ff 55 ff ff	 add	 eax, -43521		; ffff55ffH
  01320	83 f8 08	 cmp	 eax, 8
  01323	0f 87 f8 08 00
	00		 ja	 $LN313@ProtocolCo
  01329	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN364@ProtocolCo[eax*4]
$LN76@ProtocolCo:

; 1027 : 					{
; 1028 : 					case MSG_DUEL_INVITE :
; 1029 : 						{
; 1030 : 							LPPMSG_REQ_DUEL_INVITE lpReq = (LPPMSG_REQ_DUEL_INVITE)aRecv;
; 1031 : 							int nRet = OnCGInviteDuel(lpReq, aIndex);

  01330	56		 push	 esi
  01331	57		 push	 edi
  01332	e8 00 00 00 00	 call	 ?OnCGInviteDuel@@YAHPAU_tagPMSG_REQ_DUEL_INVITE@@H@Z ; OnCGInviteDuel
  01337	83 c4 08	 add	 esp, 8

; 1032 : 							if( nRet != ENEWPVP::E_NO_ERROR )

  0133a	85 c0		 test	 eax, eax
  0133c	0f 84 df 08 00
	00		 je	 $LN313@ProtocolCo

; 1033 : 							{
; 1034 : 								PMSG_ANS_DUEL_INVITE res = {0};

  01342	33 c9		 xor	 ecx, ecx

; 1035 : 								res.h.c = PMHC_BYTE;
; 1036 : 								res.h.size = sizeof(PMSG_ANS_DUEL_INVITE);
; 1037 : 								res.h.headcode = 0xAA;
; 1038 : 								res.h.subcode = 0x01;
; 1039 : 								res.nResult = nRet;
; 1040 : 								DataSend(aIndex, (LPBYTE)&res, res.h.size);

  01344	6a 11		 push	 17			; 00000011H
  01346	8d 55 e8	 lea	 edx, DWORD PTR _res$216731[ebp]
  01349	52		 push	 edx
  0134a	89 4d e9	 mov	 DWORD PTR _res$216731[ebp+1], ecx
  0134d	56		 push	 esi
  0134e	89 4d ed	 mov	 DWORD PTR _res$216731[ebp+5], ecx
  01351	89 4d f1	 mov	 DWORD PTR _res$216731[ebp+9], ecx
  01354	89 4d f5	 mov	 DWORD PTR _res$216731[ebp+13], ecx
  01357	c7 45 e8 c1 11
	aa 01		 mov	 DWORD PTR _res$216731[ebp], 27922881 ; 01aa11c1H
  0135e	88 45 ec	 mov	 BYTE PTR _res$216731[ebp+4], al
  01361	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01366	83 c4 0c	 add	 esp, 12			; 0000000cH
  01369	5f		 pop	 edi
  0136a	5e		 pop	 esi
  0136b	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0136c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0136f	33 cd		 xor	 ecx, ebp
  01371	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01376	8b e5		 mov	 esp, ebp
  01378	5d		 pop	 ebp
  01379	c3		 ret	 0
$LN74@ProtocolCo:

; 1041 : 							}
; 1042 : 						}
; 1043 : 						break;
; 1044 : 					case MSG_DUEL_ANSWER :
; 1045 : 						{
; 1046 : 							LPPMSG_ANS_DUEL_ANSWER lpReq = (LPPMSG_ANS_DUEL_ANSWER)aRecv;
; 1047 : 							int nRet = OnCGAnswerDuel(lpReq, aIndex);

  0137a	56		 push	 esi
  0137b	57		 push	 edi
  0137c	e8 00 00 00 00	 call	 ?OnCGAnswerDuel@@YAHPAU_tagPMSG_ANS_DUEL_ANSWER@@H@Z ; OnCGAnswerDuel
  01381	83 c4 08	 add	 esp, 8
  01384	5f		 pop	 edi
  01385	5e		 pop	 esi
  01386	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01387	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0138a	33 cd		 xor	 ecx, ebp
  0138c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01391	8b e5		 mov	 esp, ebp
  01393	5d		 pop	 ebp
  01394	c3		 ret	 0
$LN73@ProtocolCo:

; 1048 : 							/*if( nRet != ENEWPVP::E_NO_ERROR )
; 1049 : 							{
; 1050 : 							}*/
; 1051 : 						}
; 1052 : 						break;
; 1053 : 					case MSG_DUEL_LEAVE :
; 1054 : 						{
; 1055 : 							LPPMSG_REQ_DUEL_EXIT lpReq = (LPPMSG_REQ_DUEL_EXIT)aRecv;
; 1056 : 							int nRet = OnCGLeaveDuel(lpReq, aIndex);

  01395	56		 push	 esi
  01396	57		 push	 edi
  01397	e8 00 00 00 00	 call	 ?OnCGLeaveDuel@@YAHPAU_tagPMSG_REQ_DUEL_EXIT@@H@Z ; OnCGLeaveDuel
  0139c	83 c4 08	 add	 esp, 8

; 1057 : 							if( nRet != ENEWPVP::E_NO_ERROR )

  0139f	85 c0		 test	 eax, eax
  013a1	0f 84 7a 08 00
	00		 je	 $LN313@ProtocolCo

; 1058 : 							{
; 1059 : 								PMSG_ANS_DUEL_EXIT res = {0};

  013a7	33 c9		 xor	 ecx, ecx
  013a9	89 4d e9	 mov	 DWORD PTR _res$216743[ebp+1], ecx

; 1060 : 								res.h.c = PMHC_BYTE;
; 1061 : 								res.h.size = sizeof(PMSG_ANS_DUEL_EXIT);
; 1062 : 								res.h.headcode = 0xAA;
; 1063 : 								res.h.subcode = 0x03;
; 1064 : 								res.nResult = nRet;

  013ac	88 45 ec	 mov	 BYTE PTR _res$216743[ebp+4], al

; 1065 : 								DataSend(aIndex, (LPBYTE)&res, res.h.size);

  013af	6a 11		 push	 17			; 00000011H
  013b1	8d 45 e8	 lea	 eax, DWORD PTR _res$216743[ebp]
  013b4	50		 push	 eax
  013b5	56		 push	 esi
  013b6	89 4d ed	 mov	 DWORD PTR _res$216743[ebp+5], ecx
  013b9	89 4d f1	 mov	 DWORD PTR _res$216743[ebp+9], ecx
  013bc	89 4d f5	 mov	 DWORD PTR _res$216743[ebp+13], ecx
  013bf	c7 45 e8 c1 11
	aa 03		 mov	 DWORD PTR _res$216743[ebp], 61477313 ; 03aa11c1H
  013c6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  013cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  013ce	5f		 pop	 edi
  013cf	5e		 pop	 esi
  013d0	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  013d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  013d4	33 cd		 xor	 ecx, ebp
  013d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  013db	8b e5		 mov	 esp, ebp
  013dd	5d		 pop	 ebp
  013de	c3		 ret	 0
$LN71@ProtocolCo:

; 1066 : 							}
; 1067 : 						}
; 1068 : 						break;
; 1069 : 					case MSG_DUEL_JOINCNANNEL :
; 1070 : 						{
; 1071 : 							int nRet = OnDuelChannelJoin((LPPMSG_REQ_DUEL_JOINCNANNEL)aRecv, aIndex);

  013df	56		 push	 esi
  013e0	57		 push	 edi
  013e1	e8 00 00 00 00	 call	 ?OnDuelChannelJoin@@YAHPAU_tagPMSG_REQ_DUEL_JOINCNANNEL@@H@Z ; OnDuelChannelJoin
  013e6	83 c4 08	 add	 esp, 8

; 1072 : 							if( nRet != ENEWPVP::E_NO_ERROR )

  013e9	85 c0		 test	 eax, eax
  013eb	0f 84 30 08 00
	00		 je	 $LN313@ProtocolCo

; 1073 : 							{
; 1074 : 								PMSG_ANS_DUEL_JOINCNANNEL res = {0};

  013f1	33 c9		 xor	 ecx, ecx
  013f3	89 4d dd	 mov	 DWORD PTR _res$216750[ebp+1], ecx
  013f6	89 4d e1	 mov	 DWORD PTR _res$216750[ebp+5], ecx
  013f9	89 4d e5	 mov	 DWORD PTR _res$216750[ebp+9], ecx
  013fc	89 4d e9	 mov	 DWORD PTR _res$216750[ebp+13], ecx
  013ff	89 4d ed	 mov	 DWORD PTR _res$216750[ebp+17], ecx
  01402	89 4d f1	 mov	 DWORD PTR _res$216750[ebp+21], ecx
  01405	89 4d f5	 mov	 DWORD PTR _res$216750[ebp+25], ecx
  01408	88 4d f9	 mov	 BYTE PTR _res$216750[ebp+29], cl

; 1075 : 								res.h.c = PMHC_BYTE;
; 1076 : 								res.h.size = sizeof(PMSG_ANS_DUEL_JOINCNANNEL);
; 1077 : 								res.h.headcode = 0xAA;
; 1078 : 								res.h.subcode = 0x07;
; 1079 : 								res.nResult = nRet;
; 1080 : 								DataSend(aIndex, (LPBYTE)&res, res.h.size);

  0140b	6a 1e		 push	 30			; 0000001eH
  0140d	8d 4d dc	 lea	 ecx, DWORD PTR _res$216750[ebp]
  01410	51		 push	 ecx
  01411	56		 push	 esi
  01412	c7 45 dc c1 1e
	aa 07		 mov	 DWORD PTR _res$216750[ebp], 128589505 ; 07aa1ec1H
  01419	88 45 e0	 mov	 BYTE PTR _res$216750[ebp+4], al
  0141c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01421	83 c4 0c	 add	 esp, 12			; 0000000cH
  01424	5f		 pop	 edi
  01425	5e		 pop	 esi
  01426	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01427	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0142a	33 cd		 xor	 ecx, ebp
  0142c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01431	8b e5		 mov	 esp, ebp
  01433	5d		 pop	 ebp
  01434	c3		 ret	 0
$LN69@ProtocolCo:

; 1081 : 							}
; 1082 : 						}
; 1083 : 						break;
; 1084 : 					case MSG_DUEL_LEAVECNANNEL :
; 1085 : 						{
; 1086 : 							LPPMSG_REQ_DUEL_LEAVECNANNEL lpReq = (LPPMSG_REQ_DUEL_LEAVECNANNEL)aRecv;
; 1087 : 							int nRet = OnDuelChannelLeave(lpReq, aIndex);

  01435	56		 push	 esi
  01436	57		 push	 edi
  01437	e8 00 00 00 00	 call	 ?OnDuelChannelLeave@@YAHPAU_tagPMSG_REQ_DUEL_LEAVECNANNEL@@H@Z ; OnDuelChannelLeave
  0143c	83 c4 08	 add	 esp, 8

; 1088 : 							if( nRet != ENEWPVP::E_NO_ERROR )

  0143f	85 c0		 test	 eax, eax
  01441	0f 84 da 07 00
	00		 je	 $LN313@ProtocolCo

; 1089 : 							{
; 1090 : 								PMSG_ANS_DUEL_LEAVECNANNEL res = {0};
; 1091 : 								res.h.c = PMHC_BYTE;
; 1092 : 								res.h.size = sizeof(PMSG_ANS_DUEL_LEAVECNANNEL);
; 1093 : 								res.h.headcode = 0xAA;
; 1094 : 								res.h.subcode = 0x09;
; 1095 : 								res.nResult = nRet;
; 1096 : 								DataSend(aIndex, (LPBYTE)&res, res.h.size);

  01447	6a 05		 push	 5
  01449	8d 55 d4	 lea	 edx, DWORD PTR _res$216758[ebp]
  0144c	52		 push	 edx
  0144d	c7 45 d5 00 00
	00 00		 mov	 DWORD PTR _res$216758[ebp+1], 0
  01454	56		 push	 esi
  01455	c7 45 d4 c1 05
	aa 09		 mov	 DWORD PTR _res$216758[ebp], 162137537 ; 09aa05c1H
  0145c	88 45 d8	 mov	 BYTE PTR _res$216758[ebp+4], al
  0145f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01464	83 c4 0c	 add	 esp, 12			; 0000000cH
  01467	5f		 pop	 edi
  01468	5e		 pop	 esi
  01469	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0146a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0146d	33 cd		 xor	 ecx, ebp
  0146f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01474	8b e5		 mov	 esp, ebp
  01476	5d		 pop	 ebp
  01477	c3		 ret	 0
$LN67@ProtocolCo:

; 1097 : 							}
; 1098 : 						}
; 1099 : 						break;
; 1100 : 					}
; 1101 : 				}
; 1102 : 				break;
; 1103 : #else
; 1104 : 			case 0xAA:
; 1105 : 				{
; 1106 : 					//g_DuelManager.ProtocolCore(lpObj, aRecv);
; 1107 : 				}
; 1108 : 				break;
; 1109 : #endif
; 1110 : 			/*case 0xAA:
; 1111 : 				CGDuelStartRequestRecv((PMSG_REQ_START_DUEL *)aRecv, aIndex);
; 1112 : 				break;
; 1113 : 			case 0xAB:
; 1114 : 				CGDuelEndRequestRecv((PMSG_REQ_END_DUEL *)aRecv, aIndex);
; 1115 : 				break;
; 1116 : 			case 0xAC:
; 1117 : 				CGDuelOkRequestRecv((PMSG_ANS_DUEL_OK *)aRecv, aIndex);
; 1118 : 				break;*/
; 1119 : 			case 0xAE:
; 1120 : 				CGSaveMuBotSettings((PMSG_MUBOT_SETTINGS_RECV*)aRecv,aIndex);

  01478	56		 push	 esi
  01479	57		 push	 edi
  0147a	e8 00 00 00 00	 call	 ?CGSaveMuBotSettings@@YAXPAUPMSG_MUBOT_SETTINGS_RECV@@H@Z ; CGSaveMuBotSettings
  0147f	83 c4 08	 add	 esp, 8
  01482	5f		 pop	 edi
  01483	5e		 pop	 esi
  01484	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01485	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01488	33 cd		 xor	 ecx, ebp
  0148a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0148f	8b e5		 mov	 esp, ebp
  01491	5d		 pop	 ebp
  01492	c3		 ret	 0
$LN66@ProtocolCo:

; 1121 : 				break;
; 1122 : 			case 0x9A:
; 1123 : 				CGRequestEnterBloodCastle((PMSG_REQ_MOVEBLOODCASTLE*)aRecv, aIndex);

  01493	56		 push	 esi
  01494	57		 push	 edi
  01495	e8 00 00 00 00	 call	 ?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ; CGRequestEnterBloodCastle
  0149a	83 c4 08	 add	 esp, 8
  0149d	5f		 pop	 edi
  0149e	5e		 pop	 esi
  0149f	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  014a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  014a3	33 cd		 xor	 ecx, ebp
  014a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  014aa	8b e5		 mov	 esp, ebp
  014ac	5d		 pop	 ebp
  014ad	c3		 ret	 0
$LN64@ProtocolCo:

; 1124 : 				break;
; 1125 : 			case 0x9B:
; 1126 : 				//
; 1127 : 				break;
; 1128 : 			case 0x9F:
; 1129 : 				CGRequestEventEnterCount((PMSG_REQ_CL_ENTERCOUNT *)aRecv, aIndex);

  014ae	56		 push	 esi
  014af	57		 push	 edi
  014b0	e8 00 00 00 00	 call	 ?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ; CGRequestEventEnterCount
  014b5	83 c4 08	 add	 esp, 8
  014b8	5f		 pop	 edi
  014b9	5e		 pop	 esi
  014ba	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  014bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  014be	33 cd		 xor	 ecx, ebp
  014c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  014c5	8b e5		 mov	 esp, ebp
  014c7	5d		 pop	 ebp
  014c8	c3		 ret	 0
$LN63@ProtocolCo:

; 1130 : 				break;
; 1131 : 			case 0x9D:
; 1132 : 				CGRequestLottoRegister((PMSG_REQ_2ANV_LOTTO_EVENT *)aRecv, aIndex);

  014c9	56		 push	 esi
  014ca	57		 push	 edi
  014cb	e8 00 00 00 00	 call	 ?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ; CGRequestLottoRegister
  014d0	83 c4 08	 add	 esp, 8
  014d3	5f		 pop	 edi
  014d4	5e		 pop	 esi
  014d5	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  014d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  014d9	33 cd		 xor	 ecx, ebp
  014db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  014e0	8b e5		 mov	 esp, ebp
  014e2	5d		 pop	 ebp
  014e3	c3		 ret	 0
$LN62@ProtocolCo:

; 1133 : 				break;
; 1134 : 			case 0xAF:
; 1135 : 				{
; 1136 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1137 : 
; 1138 : 					switch ( lpDef->subcode )

  014e4	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  014e8	48		 dec	 eax
  014e9	74 22		 je	 SHORT $LN59@ProtocolCo
  014eb	48		 dec	 eax
  014ec	0f 85 2f 07 00
	00		 jne	 $LN313@ProtocolCo

; 1142 : 							break;
; 1143 : 						case 0x02:
; 1144 : 							CGRequestRepositionUserInChaosCastle((PMSG_REQ_REPOSUSER_IN_CC *)aRecv, aIndex);

  014f2	56		 push	 esi
  014f3	57		 push	 edi
  014f4	e8 00 00 00 00	 call	 ?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ; CGRequestRepositionUserInChaosCastle
  014f9	83 c4 08	 add	 esp, 8
  014fc	5f		 pop	 edi
  014fd	5e		 pop	 esi
  014fe	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  014ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01502	33 cd		 xor	 ecx, ebp
  01504	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01509	8b e5		 mov	 esp, ebp
  0150b	5d		 pop	 ebp
  0150c	c3		 ret	 0
$LN59@ProtocolCo:

; 1139 : 					{
; 1140 : 						case 0x01:
; 1141 : 							CGRequestEnterChaosCastle((PMSG_REQ_MOVECHAOSCASTLE *)aRecv, aIndex);

  0150d	56		 push	 esi
  0150e	57		 push	 edi
  0150f	e8 00 00 00 00	 call	 ?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ; CGRequestEnterChaosCastle
  01514	83 c4 08	 add	 esp, 8
  01517	5f		 pop	 edi
  01518	5e		 pop	 esi
  01519	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0151a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0151d	33 cd		 xor	 ecx, ebp
  0151f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01524	8b e5		 mov	 esp, ebp
  01526	5d		 pop	 ebp
  01527	c3		 ret	 0
$LN57@ProtocolCo:

; 1145 : 							break;
; 1146 : 					}
; 1147 : 				}
; 1148 : 				break;
; 1149 : 			case 0xC0:
; 1150 : 				FriendListRequest(aIndex);

  01528	56		 push	 esi
  01529	e8 00 00 00 00	 call	 ?FriendListRequest@@YAXH@Z ; FriendListRequest
  0152e	83 c4 04	 add	 esp, 4
  01531	5f		 pop	 edi
  01532	5e		 pop	 esi
  01533	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01534	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01537	33 cd		 xor	 ecx, ebp
  01539	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0153e	8b e5		 mov	 esp, ebp
  01540	5d		 pop	 ebp
  01541	c3		 ret	 0
$LN56@ProtocolCo:

; 1151 : 				break;
; 1152 : 			case 0xC1:
; 1153 : 				FriendAddRequest((PMSG_FRIEND_ADD_REQ *)aRecv, aIndex);

  01542	56		 push	 esi
  01543	57		 push	 edi
  01544	e8 00 00 00 00	 call	 ?FriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_REQ@@H@Z ; FriendAddRequest
  01549	83 c4 08	 add	 esp, 8
  0154c	5f		 pop	 edi
  0154d	5e		 pop	 esi
  0154e	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0154f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01552	33 cd		 xor	 ecx, ebp
  01554	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01559	8b e5		 mov	 esp, ebp
  0155b	5d		 pop	 ebp
  0155c	c3		 ret	 0
$LN55@ProtocolCo:

; 1154 : 				break;
; 1155 : 			case 0xC2:
; 1156 : 				WaitFriendAddRequest((PMSG_FRIEND_ADD_SIN_RESULT *)aRecv, aIndex);

  0155d	56		 push	 esi
  0155e	57		 push	 edi
  0155f	e8 00 00 00 00	 call	 ?WaitFriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_SIN_RESULT@@H@Z ; WaitFriendAddRequest
  01564	83 c4 08	 add	 esp, 8
  01567	5f		 pop	 edi
  01568	5e		 pop	 esi
  01569	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0156a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0156d	33 cd		 xor	 ecx, ebp
  0156f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01574	8b e5		 mov	 esp, ebp
  01576	5d		 pop	 ebp
  01577	c3		 ret	 0
$LN54@ProtocolCo:

; 1157 : 				break;
; 1158 : 			case 0xC3:
; 1159 : 				FriendDelRequest((PMSG_FRIEND_DEL_REQ *)aRecv, aIndex);

  01578	56		 push	 esi
  01579	57		 push	 edi
  0157a	e8 00 00 00 00	 call	 ?FriendDelRequest@@YAXPAUPMSG_FRIEND_DEL_REQ@@H@Z ; FriendDelRequest
  0157f	83 c4 08	 add	 esp, 8
  01582	5f		 pop	 edi
  01583	5e		 pop	 esi
  01584	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01585	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01588	33 cd		 xor	 ecx, ebp
  0158a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0158f	8b e5		 mov	 esp, ebp
  01591	5d		 pop	 ebp
  01592	c3		 ret	 0
$LN53@ProtocolCo:

; 1160 : 				break;
; 1161 : 			case 0xC4:
; 1162 : 				FriendStateClientRecv((PMSG_FRIEND_STATE_C *)aRecv, aIndex);

  01593	56		 push	 esi
  01594	57		 push	 edi
  01595	e8 00 00 00 00	 call	 ?FriendStateClientRecv@@YAXPAUPMSG_FRIEND_STATE_C@@H@Z ; FriendStateClientRecv
  0159a	83 c4 08	 add	 esp, 8
  0159d	5f		 pop	 edi
  0159e	5e		 pop	 esi
  0159f	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  015a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015a3	33 cd		 xor	 ecx, ebp
  015a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015aa	8b e5		 mov	 esp, ebp
  015ac	5d		 pop	 ebp
  015ad	c3		 ret	 0
$LN52@ProtocolCo:

; 1163 : 				break;
; 1164 : 			case 0xC5:
; 1165 : 				FriendMemoSend((PMSG_FRIEND_MEMO *)aRecv, aIndex);

  015ae	56		 push	 esi
  015af	57		 push	 edi
  015b0	e8 00 00 00 00	 call	 ?FriendMemoSend@@YAXPAUPMSG_FRIEND_MEMO@@H@Z ; FriendMemoSend
  015b5	83 c4 08	 add	 esp, 8
  015b8	5f		 pop	 edi
  015b9	5e		 pop	 esi
  015ba	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  015bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015be	33 cd		 xor	 ecx, ebp
  015c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015c5	8b e5		 mov	 esp, ebp
  015c7	5d		 pop	 ebp
  015c8	c3		 ret	 0
$LN51@ProtocolCo:

; 1166 : 				break;
; 1167 : 			case 0xC7:
; 1168 : 				FriendMemoReadReq((PMSG_FRIEND_READ_MEMO_REQ *)aRecv, aIndex);

  015c9	56		 push	 esi
  015ca	57		 push	 edi
  015cb	e8 00 00 00 00	 call	 ?FriendMemoReadReq@@YAXPAUPMSG_FRIEND_READ_MEMO_REQ@@H@Z ; FriendMemoReadReq
  015d0	83 c4 08	 add	 esp, 8
  015d3	5f		 pop	 edi
  015d4	5e		 pop	 esi
  015d5	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  015d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015d9	33 cd		 xor	 ecx, ebp
  015db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015e0	8b e5		 mov	 esp, ebp
  015e2	5d		 pop	 ebp
  015e3	c3		 ret	 0
$LN50@ProtocolCo:

; 1169 : 				break;
; 1170 : 			case 0xC8:
; 1171 : 				FriendMemoDelReq((PMSG_FRIEND_MEMO_DEL_REQ *)aRecv, aIndex);

  015e4	56		 push	 esi
  015e5	57		 push	 edi
  015e6	e8 00 00 00 00	 call	 ?FriendMemoDelReq@@YAXPAUPMSG_FRIEND_MEMO_DEL_REQ@@H@Z ; FriendMemoDelReq
  015eb	83 c4 08	 add	 esp, 8
  015ee	5f		 pop	 edi
  015ef	5e		 pop	 esi
  015f0	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  015f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015f4	33 cd		 xor	 ecx, ebp
  015f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015fb	8b e5		 mov	 esp, ebp
  015fd	5d		 pop	 ebp
  015fe	c3		 ret	 0
$LN49@ProtocolCo:

; 1172 : 				break;
; 1173 : 			case 0xC9:
; 1174 : 				FriendMemoListReq(aIndex);

  015ff	56		 push	 esi
  01600	e8 00 00 00 00	 call	 ?FriendMemoListReq@@YAXH@Z ; FriendMemoListReq
  01605	83 c4 04	 add	 esp, 4
  01608	5f		 pop	 edi
  01609	5e		 pop	 esi
  0160a	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0160b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0160e	33 cd		 xor	 ecx, ebp
  01610	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01615	8b e5		 mov	 esp, ebp
  01617	5d		 pop	 ebp
  01618	c3		 ret	 0
$LN48@ProtocolCo:

; 1175 : 				break;
; 1176 : 			case 0xCA:
; 1177 : 				FriendChatRoomCreateReq((PMSG_FRIEND_ROOMCREATE_REQ *)aRecv, aIndex);

  01619	56		 push	 esi
  0161a	57		 push	 edi
  0161b	e8 00 00 00 00	 call	 ?FriendChatRoomCreateReq@@YAXPAUPMSG_FRIEND_ROOMCREATE_REQ@@H@Z ; FriendChatRoomCreateReq
  01620	83 c4 08	 add	 esp, 8
  01623	5f		 pop	 edi
  01624	5e		 pop	 esi
  01625	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01626	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01629	33 cd		 xor	 ecx, ebp
  0162b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01630	8b e5		 mov	 esp, ebp
  01632	5d		 pop	 ebp
  01633	c3		 ret	 0
$LN47@ProtocolCo:

; 1178 : 				break;
; 1179 : 			case 0xCB:
; 1180 : 				FriendRoomInvitationReq((PMSG_ROOM_INVITATION *)aRecv, aIndex);

  01634	56		 push	 esi
  01635	57		 push	 edi
  01636	e8 00 00 00 00	 call	 ?FriendRoomInvitationReq@@YAXPAUPMSG_ROOM_INVITATION@@H@Z ; FriendRoomInvitationReq
  0163b	83 c4 08	 add	 esp, 8
  0163e	5f		 pop	 edi
  0163f	5e		 pop	 esi
  01640	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01641	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01644	33 cd		 xor	 ecx, ebp
  01646	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0164b	8b e5		 mov	 esp, ebp
  0164d	5d		 pop	 ebp
  0164e	c3		 ret	 0
$LN46@ProtocolCo:

; 1181 : 				break;
; 1182 : 			case 0xD0:
; 1183 : 				{
; 1184 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1185 : 
; 1186 : 					switch ( lpDef->subcode )

  0164f	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  01653	83 e8 07	 sub	 eax, 7
  01656	74 21		 je	 SHORT $LN43@ProtocolCo
  01658	48		 dec	 eax
  01659	0f 85 c2 05 00
	00		 jne	 $LN313@ProtocolCo

; 1190 : 							break;
; 1191 : 						case 0x08:
; 1192 : 							GCReqEnterBalgassLair(aIndex);

  0165f	56		 push	 esi
  01660	e8 00 00 00 00	 call	 ?GCReqEnterBalgassLair@@YAXH@Z ; GCReqEnterBalgassLair
  01665	83 c4 04	 add	 esp, 4
  01668	5f		 pop	 edi
  01669	5e		 pop	 esi
  0166a	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0166b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0166e	33 cd		 xor	 ecx, ebp
  01670	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01675	8b e5		 mov	 esp, ebp
  01677	5d		 pop	 ebp
  01678	c3		 ret	 0
$LN43@ProtocolCo:

; 1187 : 					{
; 1188 : 						case 0x07:
; 1189 : 							GCReqEnterBarracks(aIndex);

  01679	56		 push	 esi
  0167a	e8 00 00 00 00	 call	 ?GCReqEnterBarracks@@YAXH@Z ; GCReqEnterBarracks
  0167f	83 c4 04	 add	 esp, 4
  01682	5f		 pop	 edi
  01683	5e		 pop	 esi
  01684	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01685	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01688	33 cd		 xor	 ecx, ebp
  0168a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0168f	8b e5		 mov	 esp, ebp
  01691	5d		 pop	 ebp
  01692	c3		 ret	 0
$LN41@ProtocolCo:

; 1193 : 							break;
; 1194 : 					}
; 1195 : 				}
; 1196 : 				break;
; 1197 : 			case 0xD1:
; 1198 : 				{
; 1199 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1200 : 
; 1201 : 					switch ( lpDef->subcode )

  01693	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  01697	83 e8 00	 sub	 eax, 0
  0169a	74 22		 je	 SHORT $LN38@ProtocolCo
  0169c	48		 dec	 eax
  0169d	0f 85 7e 05 00
	00		 jne	 $LN313@ProtocolCo

; 1205 : 							break;
; 1206 : 						case 0x01:
; 1207 : 							GCReqEnterKanturuBossMap((PMSG_REQ_ENTER_KANTURU_BOSS_MAP *)aRecv, aIndex);

  016a3	56		 push	 esi
  016a4	57		 push	 edi
  016a5	e8 00 00 00 00	 call	 ?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z ; GCReqEnterKanturuBossMap
  016aa	83 c4 08	 add	 esp, 8
  016ad	5f		 pop	 edi
  016ae	5e		 pop	 esi
  016af	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  016b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016b3	33 cd		 xor	 ecx, ebp
  016b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  016ba	8b e5		 mov	 esp, ebp
  016bc	5d		 pop	 ebp
  016bd	c3		 ret	 0
$LN38@ProtocolCo:

; 1202 : 					{
; 1203 : 						case 0x00:
; 1204 : 							CGReqKanturuStateInfo((PMSG_REQ_KANTURU_STATE_INFO *)aRecv, aIndex);

  016be	56		 push	 esi
  016bf	57		 push	 edi
  016c0	e8 00 00 00 00	 call	 ?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z ; CGReqKanturuStateInfo
  016c5	83 c4 08	 add	 esp, 8
  016c8	5f		 pop	 edi
  016c9	5e		 pop	 esi
  016ca	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  016cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016ce	33 cd		 xor	 ecx, ebp
  016d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  016d5	8b e5		 mov	 esp, ebp
  016d7	5d		 pop	 ebp
  016d8	c3		 ret	 0
$LN36@ProtocolCo:

; 1208 : 							break;
; 1209 : 					}
; 1210 : 				}
; 1211 : 				break;
; 1212 : 			case 0xD2:
; 1213 : 				{
; 1214 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1215 : 
; 1216 : 					switch(lpDef->subcode)

  016d9	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  016dd	48		 dec	 eax
  016de	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  016e1	0f 87 3a 05 00
	00		 ja	 $LN313@ProtocolCo
  016e7	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN365@ProtocolCo[eax*4]
$LN33@ProtocolCo:

; 1217 : 					{
; 1218 : 					case 0x01:
; 1219 : 						g_CashShop.CGCashPoint(lpObj);

  016ee	51		 push	 ecx
  016ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  016f4	e8 00 00 00 00	 call	 ?CGCashPoint@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z ; CCashShop::CGCashPoint
  016f9	5f		 pop	 edi
  016fa	5e		 pop	 esi
  016fb	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  016fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016ff	33 cd		 xor	 ecx, ebp
  01701	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01706	8b e5		 mov	 esp, ebp
  01708	5d		 pop	 ebp
  01709	c3		 ret	 0
$LN32@ProtocolCo:

; 1220 : 						break;
; 1221 : 					case 0x02:
; 1222 : 						g_CashShop.CGCashShopOpen(lpObj,(PMSG_REQ_CASHSHOPOPEN*)aRecv);

  0170a	57		 push	 edi
  0170b	51		 push	 ecx
  0170c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  01711	e8 00 00 00 00	 call	 ?CGCashShopOpen@CCashShop@@QAEHPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHSHOPOPEN@@@Z ; CCashShop::CGCashShopOpen
  01716	5f		 pop	 edi
  01717	5e		 pop	 esi
  01718	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01719	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0171c	33 cd		 xor	 ecx, ebp
  0171e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01723	8b e5		 mov	 esp, ebp
  01725	5d		 pop	 ebp
  01726	c3		 ret	 0
$LN31@ProtocolCo:

; 1223 : 						break;
; 1224 : 					case 0x03:
; 1225 : 						g_CashShop.CGCashItemBuy(lpObj,(PMSG_REQ_CASHITEM_BUY*)aRecv);

  01727	57		 push	 edi
  01728	51		 push	 ecx
  01729	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  0172e	e8 00 00 00 00	 call	 ?CGCashItemBuy@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z ; CCashShop::CGCashItemBuy
  01733	5f		 pop	 edi
  01734	5e		 pop	 esi
  01735	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01736	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01739	33 cd		 xor	 ecx, ebp
  0173b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01740	8b e5		 mov	 esp, ebp
  01742	5d		 pop	 ebp
  01743	c3		 ret	 0
$LN30@ProtocolCo:

; 1226 : 						break;
; 1227 : 					case 0x04:
; 1228 : 						g_CashShop.CGCashGiftSend(lpObj,(PMSG_REQ_CASHITEM_GIFT*)aRecv);

  01744	57		 push	 edi
  01745	51		 push	 ecx
  01746	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  0174b	e8 00 00 00 00	 call	 ?CGCashGiftSend@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z ; CCashShop::CGCashGiftSend
  01750	5f		 pop	 edi
  01751	5e		 pop	 esi
  01752	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01753	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01756	33 cd		 xor	 ecx, ebp
  01758	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0175d	8b e5		 mov	 esp, ebp
  0175f	5d		 pop	 ebp
  01760	c3		 ret	 0
$LN29@ProtocolCo:

; 1229 : 						break;
; 1230 : 					case 0x05:
; 1231 : 						g_CashShop.CGReqInfo(aRecv,lpObj->m_Index);

  01761	8b 01		 mov	 eax, DWORD PTR [ecx]
  01763	50		 push	 eax
  01764	57		 push	 edi
  01765	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  0176a	e8 00 00 00 00	 call	 ?CGReqInfo@CCashShop@@QAEHPAEH@Z ; CCashShop::CGReqInfo
  0176f	5f		 pop	 edi
  01770	5e		 pop	 esi
  01771	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01772	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01775	33 cd		 xor	 ecx, ebp
  01777	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0177c	8b e5		 mov	 esp, ebp
  0177e	5d		 pop	 ebp
  0177f	c3		 ret	 0
$LN28@ProtocolCo:

; 1232 : 						break;
; 1233 : 					case 0x0B:
; 1234 : 						g_CashShop.CGReqUseItem(lpObj,(PSMG_REQ_CASHITEM_USE*)aRecv);

  01780	57		 push	 edi
  01781	51		 push	 ecx
  01782	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  01787	e8 00 00 00 00	 call	 ?CGReqUseItem@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPSMG_REQ_CASHITEM_USE@@@Z ; CCashShop::CGReqUseItem
  0178c	5f		 pop	 edi
  0178d	5e		 pop	 esi
  0178e	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0178f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01792	33 cd		 xor	 ecx, ebp
  01794	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01799	8b e5		 mov	 esp, ebp
  0179b	5d		 pop	 ebp
  0179c	c3		 ret	 0
$LN27@ProtocolCo:

; 1235 : 						break;
; 1236 : 					}
; 1237 : 				}
; 1238 : 				break;
; 1239 : #if (__QUEST_SYSTEM__== 1)
; 1240 : 
; 1241 : 			case 0xF6:
; 1242 : 				{
; 1243 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1244 : 
; 1245 : 					switch ( lpDef->subcode )

  0179d	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  017a1	83 c0 f6	 add	 eax, -10		; fffffff6H
  017a4	83 f8 27	 cmp	 eax, 39			; 00000027H
  017a7	0f 87 74 04 00
	00		 ja	 $LN313@ProtocolCo
  017ad	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN345@ProtocolCo[eax]
  017b4	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN366@ProtocolCo[ecx*4]
$LN24@ProtocolCo:

; 1246 : 					{
; 1247 : 					case 0x0A:
; 1248 : 						gQuestInfoEx.CGRequestInitQuest(aRecv,aIndex);

  017bb	56		 push	 esi
  017bc	57		 push	 edi
  017bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  017c2	e8 00 00 00 00	 call	 ?CGRequestInitQuest@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGRequestInitQuest
  017c7	5f		 pop	 edi
  017c8	5e		 pop	 esi
  017c9	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  017ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017cd	33 cd		 xor	 ecx, ebp
  017cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017d4	8b e5		 mov	 esp, ebp
  017d6	5d		 pop	 ebp
  017d7	c3		 ret	 0
$LN23@ProtocolCo:

; 1249 : 						break;
; 1250 : 					case 0x0B:
; 1251 : 						gQuestInfoEx.CGRequestQuestStep(aRecv,aIndex);

  017d8	56		 push	 esi
  017d9	57		 push	 edi
  017da	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  017df	e8 00 00 00 00	 call	 ?CGRequestQuestStep@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGRequestQuestStep
  017e4	5f		 pop	 edi
  017e5	5e		 pop	 esi
  017e6	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  017e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017ea	33 cd		 xor	 ecx, ebp
  017ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017f1	8b e5		 mov	 esp, ebp
  017f3	5d		 pop	 ebp
  017f4	c3		 ret	 0
$LN22@ProtocolCo:

; 1252 : 						break;
; 1253 : 					case 0x0D:
; 1254 : 						gQuestInfoEx.CGQuestComplete(aRecv,aIndex);

  017f5	56		 push	 esi
  017f6	57		 push	 edi
  017f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  017fc	e8 00 00 00 00	 call	 ?CGQuestComplete@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGQuestComplete
  01801	5f		 pop	 edi
  01802	5e		 pop	 esi
  01803	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01804	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01807	33 cd		 xor	 ecx, ebp
  01809	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0180e	8b e5		 mov	 esp, ebp
  01810	5d		 pop	 ebp
  01811	c3		 ret	 0
$LN21@ProtocolCo:

; 1255 : 						break;
; 1256 : 					case 0x0F:
; 1257 : 						gQuestInfoEx.CGQuitQuest(aRecv,aIndex);

  01812	56		 push	 esi
  01813	57		 push	 edi
  01814	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  01819	e8 00 00 00 00	 call	 ?CGQuitQuest@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGQuitQuest
  0181e	5f		 pop	 edi
  0181f	5e		 pop	 esi
  01820	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01821	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01824	33 cd		 xor	 ecx, ebp
  01826	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0182b	8b e5		 mov	 esp, ebp
  0182d	5d		 pop	 ebp
  0182e	c3		 ret	 0
$LN20@ProtocolCo:

; 1258 : 						break;
; 1259 : 					case 0x10:
; 1260 : 						gQuestInfoEx.CGClientAction(aRecv,aIndex);

  0182f	56		 push	 esi
  01830	57		 push	 edi
  01831	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  01836	e8 00 00 00 00	 call	 ?CGClientAction@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGClientAction
  0183b	5f		 pop	 edi
  0183c	5e		 pop	 esi
  0183d	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0183e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01841	33 cd		 xor	 ecx, ebp
  01843	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01848	8b e5		 mov	 esp, ebp
  0184a	5d		 pop	 ebp
  0184b	c3		 ret	 0
$LN19@ProtocolCo:

; 1261 : 						break;
; 1262 : 					case 0x1A:
; 1263 : 						gQuestInfoEx.CGRequestQuestState(aIndex);

  0184c	56		 push	 esi
  0184d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  01852	e8 00 00 00 00	 call	 ?CGRequestQuestState@CQuestInfoEx@@QAEXH@Z ; CQuestInfoEx::CGRequestQuestState
  01857	5f		 pop	 edi
  01858	5e		 pop	 esi
  01859	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0185a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0185d	33 cd		 xor	 ecx, ebp
  0185f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01864	8b e5		 mov	 esp, ebp
  01866	5d		 pop	 ebp
  01867	c3		 ret	 0
$LN18@ProtocolCo:

; 1264 : 						break;
; 1265 : 					case 0x1B:
; 1266 : 						gQuestInfoEx.CGReqQuestInfo(aRecv,aIndex);

  01868	56		 push	 esi
  01869	57		 push	 edi
  0186a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  0186f	e8 00 00 00 00	 call	 ?CGReqQuestInfo@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGReqQuestInfo
  01874	5f		 pop	 edi
  01875	5e		 pop	 esi
  01876	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01877	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0187a	33 cd		 xor	 ecx, ebp
  0187c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01881	8b e5		 mov	 esp, ebp
  01883	5d		 pop	 ebp
  01884	c3		 ret	 0
$LN16@ProtocolCo:

; 1267 : 						break;
; 1268 : 					case 0x21:
; 1269 : 						break;
; 1270 : 					case 0x30:
; 1271 : 						gQuestInfoEx.GCSendAvaibleQuest(aIndex);

  01885	56		 push	 esi
  01886	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  0188b	e8 00 00 00 00	 call	 ?GCSendAvaibleQuest@CQuestInfoEx@@QAEXH@Z ; CQuestInfoEx::GCSendAvaibleQuest
  01890	5f		 pop	 edi
  01891	5e		 pop	 esi
  01892	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01893	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01896	33 cd		 xor	 ecx, ebp
  01898	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0189d	8b e5		 mov	 esp, ebp
  0189f	5d		 pop	 ebp
  018a0	c3		 ret	 0
$LN15@ProtocolCo:

; 1272 : 						break;
; 1273 : 					case 0x31:
; 1274 : 						gQuestInfoEx.GCSendBuff(aIndex);

  018a1	56		 push	 esi
  018a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  018a7	e8 00 00 00 00	 call	 ?GCSendBuff@CQuestInfoEx@@QAEXH@Z ; CQuestInfoEx::GCSendBuff
  018ac	5f		 pop	 edi
  018ad	5e		 pop	 esi
  018ae	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  018af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  018b2	33 cd		 xor	 ecx, ebp
  018b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  018b9	8b e5		 mov	 esp, ebp
  018bb	5d		 pop	 ebp
  018bc	c3		 ret	 0
$LN14@ProtocolCo:

; 1275 : 						break;
; 1276 : 					}
; 1277 : 				}
; 1278 : 				break;
; 1279 : #endif
; 1280 : 			case 0xF7:
; 1281 : 				{
; 1282 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1283 : 
; 1284 : 					switch( lpDef->subcode )

  018bd	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  018c1	48		 dec	 eax
  018c2	0f 85 59 03 00
	00		 jne	 $LN313@ProtocolCo

; 1285 : 					{
; 1286 : 					case 0x01:
; 1287 : 						CGReqEnterZone((PMSG_REQ_ENTERZONE*)aRecv,aIndex);

  018c8	56		 push	 esi
  018c9	57		 push	 edi
  018ca	e8 00 00 00 00	 call	 ?CGReqEnterZone@@YAXPAUPMSG_REQ_ENTERZONE@@H@Z ; CGReqEnterZone
  018cf	83 c4 08	 add	 esp, 8
  018d2	5f		 pop	 edi
  018d3	5e		 pop	 esi
  018d4	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  018d5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  018d8	33 cd		 xor	 ecx, ebp
  018da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  018df	8b e5		 mov	 esp, ebp
  018e1	5d		 pop	 ebp
  018e2	c3		 ret	 0
$LN10@ProtocolCo:

; 1288 : 						break;
; 1289 : 					}
; 1290 : 				}
; 1291 : 				break;
; 1292 : 			case 0xF8:
; 1293 : 				{
; 1294 : 
; 1295 : 					//LogAddHeadHexFunc(1,(char*)aRecv,aLen);
; 1296 : 
; 1297 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1298 : 
; 1299 : 					switch(lpDef->subcode)

  018e3	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  018e7	48		 dec	 eax
  018e8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  018eb	0f 87 30 03 00
	00		 ja	 $LN313@ProtocolCo
  018f1	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN346@ProtocolCo[eax]
  018f8	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN367@ProtocolCo[edx*4]
$LN7@ProtocolCo:

; 1300 : 					{
; 1301 : #if (__GENS_SYSTEM__ == 1)
; 1302 : 					case 0x01:
; 1303 : 						gGensSystem.CGJoinRequest(aRecv,aIndex);

  018ff	56		 push	 esi
  01900	57		 push	 edi
  01901	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  01906	e8 00 00 00 00	 call	 ?CGJoinRequest@CGensSystem@@QAEXPAEH@Z ; CGensSystem::CGJoinRequest
  0190b	5f		 pop	 edi
  0190c	5e		 pop	 esi
  0190d	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0190e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01911	33 cd		 xor	 ecx, ebp
  01913	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01918	8b e5		 mov	 esp, ebp
  0191a	5d		 pop	 ebp
  0191b	c3		 ret	 0
$LN6@ProtocolCo:

; 1304 : 						break;
; 1305 : 					case 0x03:
; 1306 : 						gGensSystem.CGLeaveRequest(aIndex);

  0191c	56		 push	 esi
  0191d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  01922	e8 00 00 00 00	 call	 ?CGLeaveRequest@CGensSystem@@QAEXH@Z ; CGensSystem::CGLeaveRequest
  01927	5f		 pop	 edi
  01928	5e		 pop	 esi
  01929	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0192a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0192d	33 cd		 xor	 ecx, ebp
  0192f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01934	8b e5		 mov	 esp, ebp
  01936	5d		 pop	 ebp
  01937	c3		 ret	 0
$LN5@ProtocolCo:

; 1307 : 						break;
; 1308 : 					case 0x09:
; 1309 : 						gGensSystem.CGRequestPrize(aRecv,aIndex);

  01938	56		 push	 esi
  01939	57		 push	 edi
  0193a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  0193f	e8 00 00 00 00	 call	 ?CGRequestPrize@CGensSystem@@QAEXPAEH@Z ; CGensSystem::CGRequestPrize
  01944	5f		 pop	 edi
  01945	5e		 pop	 esi
  01946	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01947	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0194a	33 cd		 xor	 ecx, ebp
  0194c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01951	8b e5		 mov	 esp, ebp
  01953	5d		 pop	 ebp
  01954	c3		 ret	 0
$LN4@ProtocolCo:

; 1310 : 						break;
; 1311 : 					case 0x0B:
; 1312 : 						gGensSystem.SendGensInfo(aIndex);

  01955	56		 push	 esi
  01956	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  0195b	e8 00 00 00 00	 call	 ?SendGensInfo@CGensSystem@@QAEXH@Z ; CGensSystem::SendGensInfo
  01960	5f		 pop	 edi
  01961	5e		 pop	 esi
  01962	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01963	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01966	33 cd		 xor	 ecx, ebp
  01968	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0196d	8b e5		 mov	 esp, ebp
  0196f	5d		 pop	 ebp
  01970	c3		 ret	 0
$LN3@ProtocolCo:

; 1313 : 						break;
; 1314 : #endif
; 1315 : 					case 0x20:
; 1316 : 						CGReqMoveAcheron(aIndex);

  01971	56		 push	 esi
  01972	e8 00 00 00 00	 call	 ?CGReqMoveAcheron@@YAXH@Z ; CGReqMoveAcheron
  01977	83 c4 04	 add	 esp, 4
  0197a	5f		 pop	 edi
  0197b	5e		 pop	 esi
  0197c	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  0197d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01980	33 cd		 xor	 ecx, ebp
  01982	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01987	8b e5		 mov	 esp, ebp
  01989	5d		 pop	 ebp
  0198a	c3		 ret	 0
$LN351@ProtocolCo:

; 864  : 						break;
; 865  : 
; 866  : 					}
; 867  : 				}
; 868  : 				break;
; 869  : 
; 870  : 			case 0xFE:
; 871  : 				{
; 872  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 873  : 
; 874  : 					switch( lpDef->subcode )

  0198b	8b 55 d4	 mov	 edx, DWORD PTR tv1108[ebp]
$LN1@ProtocolCo:

; 1317 : 						//CGReqAcheronEnter((_tagPMSG_REQ_ACHERON_ENTER *)aRecv, aIndex);
; 1318 : 						break;
; 1319 : #if (ENABLETEST_ARCA == 1)
; 1320 : 					case 0x30:
; 1321 : 						//CGReqArcaBattleGuildMasterJoin((_tagPMSG_REQ_ARCA_BATTLE_JOIN *)aRecv, aIndex);
; 1322 : 						break;
; 1323 : 					case 0x32:
; 1324 : 						//CGReqArcaBattleGuildMemberJoin((_tagPMSG_REQ_ARCA_BATTLE_JOIN *)aRecv, aIndex);
; 1325 : 						break;
; 1326 : 					case 0x34:
; 1327 : 						//CGReqArcaBattleEnter((_tagPMSG_REQ_ARCA_BATTLE_ENTER *)aRecv, aIndex);
; 1328 : 						break;
; 1329 : 					case 0x36:
; 1330 : 						//CGReqArcaBattleBootyExchange(aIndex);
; 1331 : 						break;
; 1332 : 					case 0x3C:
; 1333 : 						//CGReqSpritemapExchange(aIndex);
; 1334 : 						break;
; 1335 : 					case 0x41:
; 1336 : 						//CGReqRegisteredMemberCnt(aIndex);
; 1337 : 						break;
; 1338 : 					case 0x43:
; 1339 : 						//g_ArcaBattle.CGReqMarkReg(aIndex);
; 1340 : 						break;
; 1341 : 					case 0x45:
; 1342 : 						//g_ArcaBattle.CGReqMarkRank(aIndex);
; 1343 : 						break;
; 1344 : #endif
; 1345 : #if (ENABLETEST_ACHERON == 1)
; 1346 : 					case 0x4B:
; 1347 : 						g_AcheronGuardianEvent.CGReqAcheronEventEnter((_tagPMSG_REQ_ACHERON_EVENT_ENTER*)aRecv, aIndex);
; 1348 : 						break;
; 1349 : #endif
; 1350 : 					}
; 1351 : 				}
; 1352 : 				break;
; 1353 : #if (ENABLETEST_MUUN == 1)
; 1354 : 			case 0xF1:
; 1355 : 				g_CMuunSystem.DGLoadMuunInvenItem((_tagSDHP_ANS_DBMUUN_INVEN_LOAD *)aRecv);
; 1356 : 				break;
; 1357 : #endif
; 1358 : 			case 0xFC:
; 1359 : 				{
; 1360 : 					
; 1361 : 				}
; 1362 : 				break;
; 1363 : 
; 1364 : 
; 1365 : 			default:
; 1366 : 				LogAddC(2, "error-L2 : account:%s name:%s HEAD:%x (%s,%d) State:%d",
; 1367 : 					gObj[aIndex].AccountID, gObj[aIndex].Name, protoNum, __FILE__, __LINE__, gObj[aIndex].Connected);

  0198e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01991	50		 push	 eax
  01992	68 57 05 00 00	 push	 1367			; 00000557H
  01997	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0199c	52		 push	 edx
  0199d	8d 51 5d	 lea	 edx, DWORD PTR [ecx+93]
  019a0	52		 push	 edx
  019a1	83 c1 52	 add	 ecx, 82			; 00000052H
  019a4	51		 push	 ecx
  019a5	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@
  019aa	6a 02		 push	 2
  019ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1368 : 				CloseClient(aIndex);

  019b2	56		 push	 esi
  019b3	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  019b8	83 c4 24	 add	 esp, 36			; 00000024H
  019bb	5f		 pop	 edi
  019bc	5e		 pop	 esi
  019bd	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  019be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  019c1	33 cd		 xor	 ecx, ebp
  019c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  019c8	8b e5		 mov	 esp, ebp
  019ca	5d		 pop	 ebp
  019cb	c3		 ret	 0
$LN317@ProtocolCo:

; 177  : 	{
; 178  : #if( DEBUG_PROTOCOL == 1 )
; 179  : 		LogAddHeadHexFunc(1, (LPSTR)aRecv, aLen);
; 180  : #endif
; 181  : 		switch ( protoNum )

  019cc	0f b6 c3	 movzx	 eax, bl
  019cf	83 e8 0e	 sub	 eax, 14			; 0000000eH
  019d2	0f 84 27 02 00
	00		 je	 $LN314@ProtocolCo
  019d8	2d e3 00 00 00	 sub	 eax, 227		; 000000e3H
  019dd	0f 84 80 01 00
	00		 je	 $LN312@ProtocolCo
  019e3	83 e8 02	 sub	 eax, 2
  019e6	0f 85 35 02 00
	00		 jne	 $LN313@ProtocolCo

; 212  : 							}
; 213  : 							break;
; 214  : 					}
; 215  : 				}
; 216  : 				break;
; 217  : 			case 0xF3:
; 218  : 				{
; 219  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 220  : 
; 221  : 					switch ( lpDef->subcode )

  019ec	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  019f0	83 f8 52	 cmp	 eax, 82			; 00000052H
  019f3	0f 87 28 02 00
	00		 ja	 $LN313@ProtocolCo
  019f9	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN347@ProtocolCo[eax]
  01a00	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN368@ProtocolCo[eax*4]
$LN300@ProtocolCo:

; 222  : 					{
; 223  : 						case 0x00:
; 224  : 							DataServerGetCharListRequest(aIndex);

  01a07	56		 push	 esi
  01a08	e8 00 00 00 00	 call	 ?DataServerGetCharListRequest@@YAXF@Z ; DataServerGetCharListRequest
  01a0d	83 c4 04	 add	 esp, 4
  01a10	5f		 pop	 edi
  01a11	5e		 pop	 esi
  01a12	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01a13	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a16	33 cd		 xor	 ecx, ebp
  01a18	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a1d	8b e5		 mov	 esp, ebp
  01a1f	5d		 pop	 ebp
  01a20	c3		 ret	 0
$LN299@ProtocolCo:

; 225  : 							break;
; 226  : 						case 0x01:
; 227  : 							CGPCharacterCreate((PMSG_CHARCREATE *)aRecv, aIndex);

  01a21	56		 push	 esi
  01a22	57		 push	 edi
  01a23	e8 00 00 00 00	 call	 ?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z ; CGPCharacterCreate
  01a28	83 c4 08	 add	 esp, 8
  01a2b	5f		 pop	 edi
  01a2c	5e		 pop	 esi
  01a2d	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01a2e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a31	33 cd		 xor	 ecx, ebp
  01a33	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a38	8b e5		 mov	 esp, ebp
  01a3a	5d		 pop	 ebp
  01a3b	c3		 ret	 0
$LN298@ProtocolCo:

; 228  : 							break;
; 229  : 						case 0x02:
; 230  : 							CGPCharDel((PMSG_CHARDELETE *)aRecv, aIndex);

  01a3c	56		 push	 esi
  01a3d	57		 push	 edi
  01a3e	e8 00 00 00 00	 call	 ?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z ; CGPCharDel
  01a43	83 c4 08	 add	 esp, 8
  01a46	5f		 pop	 edi
  01a47	5e		 pop	 esi
  01a48	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01a49	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a4c	33 cd		 xor	 ecx, ebp
  01a4e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a53	8b e5		 mov	 esp, ebp
  01a55	5d		 pop	 ebp
  01a56	c3		 ret	 0
$LN297@ProtocolCo:

; 231  : 							break;
; 232  : 						case 0x03:
; 233  : 							CGPCharacterMapJoinRequest((PMSG_CHARMAPJOIN *)aRecv, aIndex);

  01a57	56		 push	 esi
  01a58	57		 push	 edi
  01a59	e8 00 00 00 00	 call	 ?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ; CGPCharacterMapJoinRequest
  01a5e	83 c4 08	 add	 esp, 8
  01a61	5f		 pop	 edi
  01a62	5e		 pop	 esi
  01a63	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01a64	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a67	33 cd		 xor	 ecx, ebp
  01a69	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a6e	8b e5		 mov	 esp, ebp
  01a70	5d		 pop	 ebp
  01a71	c3		 ret	 0
$LN296@ProtocolCo:

; 234  : 							break;
; 235  : 						case 0x06:
; 236  : 							CGLevelUpPointAdd((PMSG_LVPOINTADD *)aRecv, aIndex);

  01a72	56		 push	 esi
  01a73	57		 push	 edi
  01a74	e8 00 00 00 00	 call	 ?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z ; CGLevelUpPointAdd
  01a79	83 c4 08	 add	 esp, 8
  01a7c	5f		 pop	 edi
  01a7d	5e		 pop	 esi
  01a7e	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01a7f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a82	33 cd		 xor	 ecx, ebp
  01a84	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a89	8b e5		 mov	 esp, ebp
  01a8b	5d		 pop	 ebp
  01a8c	c3		 ret	 0
$LN295@ProtocolCo:

; 237  : 							break;
; 238  : 						case 0x12:
; 239  : 							gObjMoveDataLoadingOK(aIndex);

  01a8d	56		 push	 esi
  01a8e	e8 00 00 00 00	 call	 ?gObjMoveDataLoadingOK@@YAXH@Z ; gObjMoveDataLoadingOK
  01a93	83 c4 04	 add	 esp, 4
  01a96	5f		 pop	 edi
  01a97	5e		 pop	 esi
  01a98	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01a99	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a9c	33 cd		 xor	 ecx, ebp
  01a9e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01aa3	8b e5		 mov	 esp, ebp
  01aa5	5d		 pop	 ebp
  01aa6	c3		 ret	 0
$LN294@ProtocolCo:

; 240  : 							break;
; 241  : 						case 0x15:
; 242  : 							{
; 243  : 								PMSG_REQ_CHAR_PASSWORD* lpMsg = (PMSG_REQ_CHAR_PASSWORD*)aRecv;
; 244  : 								PMSG_ANS_CHECK_PASSWORD pMsg;
; 245  : 
; 246  : 								PHeadSubSetB((LPBYTE)&pMsg,0xF3,0x16,sizeof(pMsg));

  01aa7	6a 19		 push	 25			; 00000019H
  01aa9	6a 16		 push	 22			; 00000016H
  01aab	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$216306[ebp]
  01aae	68 f3 00 00 00	 push	 243			; 000000f3H
  01ab3	51		 push	 ecx
  01ab4	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 247  : 								memcpy(pMsg.Password,"1111111111",10);

  01ab9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0L@HMJAEILC@1111111111?$AA@
  01abf	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@HMJAEILC@1111111111?$AA@+4
  01ac4	0f b7 0d 08 00
	00 00		 movzx	 ecx, WORD PTR ??_C@_0L@HMJAEILC@1111111111?$AA@+8
  01acb	89 55 e4	 mov	 DWORD PTR _pMsg$216306[ebp+4], edx

; 248  : 								memcpy(pMsg.Name,lpMsg->Name,10);

  01ace	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  01ad1	89 45 e8	 mov	 DWORD PTR _pMsg$216306[ebp+8], eax
  01ad4	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  01ad7	89 55 ee	 mov	 DWORD PTR _pMsg$216306[ebp+14], edx

; 249  : 
; 250  : 								pMsg.btResult = 0;
; 251  : 
; 252  : 								DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  01ada	0f b6 55 e1	 movzx	 edx, BYTE PTR _pMsg$216306[ebp+1]
  01ade	89 45 f2	 mov	 DWORD PTR _pMsg$216306[ebp+18], eax
  01ae1	52		 push	 edx
  01ae2	66 89 4d ec	 mov	 WORD PTR _pMsg$216306[ebp+12], cx
  01ae6	0f b7 4f 0c	 movzx	 ecx, WORD PTR [edi+12]
  01aea	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$216306[ebp]
  01aed	50		 push	 eax
  01aee	56		 push	 esi
  01aef	66 89 4d f6	 mov	 WORD PTR _pMsg$216306[ebp+22], cx
  01af3	c6 45 f8 00	 mov	 BYTE PTR _pMsg$216306[ebp+24], 0
  01af7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01afc	83 c4 1c	 add	 esp, 28			; 0000001cH
  01aff	5f		 pop	 edi
  01b00	5e		 pop	 esi
  01b01	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01b02	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b05	33 cd		 xor	 ecx, ebp
  01b07	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01b0c	8b e5		 mov	 esp, ebp
  01b0e	5d		 pop	 ebp
  01b0f	c3		 ret	 0
$LN293@ProtocolCo:

; 253  : 							}
; 254  : 							break;
; 255  : 						/*case 0x15:
; 256  : 						  CGReqCheckChangeName
; 257  : 						  break;
; 258  : 						case 0x16:
; 259  : 						  CGChangeName
; 260  : 						  break;*/
; 261  : 						case 0x21:
; 262  : 							CGEnableUsePolymorphSkinrRecv((PMSG_REQ_USE_POLYMORPH_SKIN*)aRecv, aIndex);

  01b10	56		 push	 esi
  01b11	57		 push	 edi
  01b12	e8 00 00 00 00	 call	 ?CGEnableUsePolymorphSkinrRecv@@YAXPAUPMSG_REQ_USE_POLYMORPH_SKIN@@H@Z ; CGEnableUsePolymorphSkinrRecv
  01b17	83 c4 08	 add	 esp, 8
  01b1a	5f		 pop	 edi
  01b1b	5e		 pop	 esi
  01b1c	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01b1d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b20	33 cd		 xor	 ecx, ebp
  01b22	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01b27	8b e5		 mov	 esp, ebp
  01b29	5d		 pop	 ebp
  01b2a	c3		 ret	 0
$LN292@ProtocolCo:

; 263  : 						  break;
; 264  : 						case 0x30:
; 265  : 							GCSkillKeyRecv((PMSG_SKILLKEY *)aRecv, aIndex);

  01b2b	56		 push	 esi
  01b2c	57		 push	 edi
  01b2d	e8 00 00 00 00	 call	 ?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z ; GCSkillKeyRecv
  01b32	83 c4 08	 add	 esp, 8
  01b35	5f		 pop	 edi
  01b36	5e		 pop	 esi
  01b37	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01b38	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b3b	33 cd		 xor	 ecx, ebp
  01b3d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01b42	8b e5		 mov	 esp, ebp
  01b44	5d		 pop	 ebp
  01b45	c3		 ret	 0
$LN290@ProtocolCo:

; 266  : 							break;
; 267  : 						case 0x31:
; 268  : 							//CGNotifyGuarditBreach
; 269  : 							break;
; 270  : 						case 0x52:
; 271  : 							g_MasterSkillSystem.CGReqGetMasterLevelSkill((PMSG_REQ_MASTERLEVEL_SKILL*)aRecv,aIndex);

  01b46	56		 push	 esi
  01b47	57		 push	 edi
  01b48	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  01b4d	e8 00 00 00 00	 call	 ?CGReqGetMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEXPAUPMSG_REQ_MASTERLEVEL_SKILL@@H@Z ; CMasterLevelSkillTreeSystem::CGReqGetMasterLevelSkill
  01b52	5f		 pop	 edi
  01b53	5e		 pop	 esi
  01b54	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01b55	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b58	33 cd		 xor	 ecx, ebp
  01b5a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01b5f	8b e5		 mov	 esp, ebp
  01b61	5d		 pop	 ebp
  01b62	c3		 ret	 0
$LN312@ProtocolCo:

; 188  : 				}
; 189  : 				break;
; 190  : 			case 0xF1:
; 191  : 				{
; 192  : 					PMSG_DEFAULT2 * lpMsg2 = (PMSG_DEFAULT2 *)aRecv;
; 193  : 					
; 194  : 					switch ( lpMsg2->subcode )

  01b63	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  01b67	48		 dec	 eax
  01b68	74 68		 je	 SHORT $LN309@ProtocolCo
  01b6a	48		 dec	 eax
  01b6b	74 38		 je	 SHORT $LN307@ProtocolCo
  01b6d	48		 dec	 eax
  01b6e	0f 85 ad 00 00
	00		 jne	 $LN313@ProtocolCo

; 206  : 							}
; 207  : 							break;
; 208  : 						case 0x03:
; 209  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  01b74	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  01b77	51		 push	 ecx
  01b78	53		 push	 ebx
  01b79	56		 push	 esi
  01b7a	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  01b7f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b82	85 c0		 test	 eax, eax
  01b84	0f 84 97 00 00
	00		 je	 $LN313@ProtocolCo

; 210  : 							{
; 211  : 								CGClientMsg((PMSG_CLIENTMSG *)aRecv, aIndex);

  01b8a	56		 push	 esi
  01b8b	57		 push	 edi
  01b8c	e8 00 00 00 00	 call	 ?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z ; CGClientMsg
  01b91	83 c4 08	 add	 esp, 8
  01b94	5f		 pop	 edi
  01b95	5e		 pop	 esi
  01b96	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01b97	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b9a	33 cd		 xor	 ecx, ebp
  01b9c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01ba1	8b e5		 mov	 esp, ebp
  01ba3	5d		 pop	 ebp
  01ba4	c3		 ret	 0
$LN307@ProtocolCo:

; 200  : 							}
; 201  : 							break;
; 202  : 						case 0x02:
; 203  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  01ba5	8b 55 18	 mov	 edx, DWORD PTR _Encrypt$[ebp]
  01ba8	52		 push	 edx
  01ba9	53		 push	 ebx
  01baa	56		 push	 esi
  01bab	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  01bb0	83 c4 0c	 add	 esp, 12			; 0000000cH
  01bb3	85 c0		 test	 eax, eax
  01bb5	74 6a		 je	 SHORT $LN313@ProtocolCo

; 204  : 							{
; 205  : 								CGClientCloseMsg((PMSG_CLIENTCLOSE *)aRecv, aIndex);

  01bb7	56		 push	 esi
  01bb8	57		 push	 edi
  01bb9	e8 00 00 00 00	 call	 ?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z ; CGClientCloseMsg
  01bbe	83 c4 08	 add	 esp, 8
  01bc1	5f		 pop	 edi
  01bc2	5e		 pop	 esi
  01bc3	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01bc4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01bc7	33 cd		 xor	 ecx, ebp
  01bc9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01bce	8b e5		 mov	 esp, ebp
  01bd0	5d		 pop	 ebp
  01bd1	c3		 ret	 0
$LN309@ProtocolCo:

; 195  : 					{
; 196  : 						case 0x01:
; 197  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  01bd2	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  01bd5	50		 push	 eax
  01bd6	53		 push	 ebx
  01bd7	56		 push	 esi
  01bd8	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  01bdd	83 c4 0c	 add	 esp, 12			; 0000000cH
  01be0	85 c0		 test	 eax, eax
  01be2	74 3d		 je	 SHORT $LN313@ProtocolCo

; 198  : 							{
; 199  : 								CSPJoinIdPassRequest((PMSG_IDPASS *)aRecv, aIndex);

  01be4	56		 push	 esi
  01be5	57		 push	 edi
  01be6	e8 00 00 00 00	 call	 ?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z ; CSPJoinIdPassRequest
  01beb	83 c4 08	 add	 esp, 8
  01bee	5f		 pop	 edi
  01bef	5e		 pop	 esi
  01bf0	5b		 pop	 ebx

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01bf1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01bf4	33 cd		 xor	 ecx, ebp
  01bf6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01bfb	8b e5		 mov	 esp, ebp
  01bfd	5d		 pop	 ebp
  01bfe	c3		 ret	 0
$LN314@ProtocolCo:

; 182  : 		{
; 183  : 			case 0x0E:
; 184  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  01bff	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  01c02	51		 push	 ecx
  01c03	53		 push	 ebx
  01c04	56		 push	 esi
  01c05	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  01c0a	83 c4 0c	 add	 esp, 12			; 0000000cH
  01c0d	85 c0		 test	 eax, eax
  01c0f	74 10		 je	 SHORT $LN313@ProtocolCo

; 185  : 				{
; 186  : 					CGLiveClient((PMSG_CLIENTTIME *)aRecv, aIndex);

  01c11	56		 push	 esi
  01c12	57		 push	 edi
  01c13	e8 00 00 00 00	 call	 ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ; CGLiveClient

; 187  : 					tempindex = aIndex;

  01c18	89 35 00 00 00
	00		 mov	 DWORD PTR ?tempindex@@3HA, esi ; tempindex
  01c1e	83 c4 08	 add	 esp, 8
$LN313@ProtocolCo:

; 1369 : 
; 1370 : 
; 1371 : 		}	
; 1372 : 	}
; 1373 : }

  01c21	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c24	5f		 pop	 edi
  01c25	5e		 pop	 esi
  01c26	33 cd		 xor	 ecx, ebp
  01c28	5b		 pop	 ebx
  01c29	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c2e	8b e5		 mov	 esp, ebp
  01c30	5d		 pop	 ebp
  01c31	c3		 ret	 0
  01c32	8b ff		 npad	 2
$LN357@ProtocolCo:
  01c34	00 00 00 00	 DD	 $LN286@ProtocolCo
  01c38	00 00 00 00	 DD	 $LN285@ProtocolCo
  01c3c	00 00 00 00	 DD	 $LN284@ProtocolCo
  01c40	00 00 00 00	 DD	 $LN283@ProtocolCo
  01c44	00 00 00 00	 DD	 $LN313@ProtocolCo
  01c48	00 00 00 00	 DD	 $LN281@ProtocolCo
  01c4c	00 00 00 00	 DD	 $LN278@ProtocolCo
  01c50	00 00 00 00	 DD	 $LN279@ProtocolCo
  01c54	00 00 00 00	 DD	 $LN277@ProtocolCo
  01c58	00 00 00 00	 DD	 $LN276@ProtocolCo
  01c5c	00 00 00 00	 DD	 $LN274@ProtocolCo
  01c60	00 00 00 00	 DD	 $LN273@ProtocolCo
  01c64	00 00 00 00	 DD	 $LN268@ProtocolCo
  01c68	00 00 00 00	 DD	 $LN266@ProtocolCo
  01c6c	00 00 00 00	 DD	 $LN264@ProtocolCo
  01c70	00 00 00 00	 DD	 $LN263@ProtocolCo
  01c74	00 00 00 00	 DD	 $LN262@ProtocolCo
  01c78	00 00 00 00	 DD	 $LN261@ProtocolCo
  01c7c	00 00 00 00	 DD	 $LN259@ProtocolCo
  01c80	00 00 00 00	 DD	 $LN258@ProtocolCo
  01c84	00 00 00 00	 DD	 $LN256@ProtocolCo
  01c88	00 00 00 00	 DD	 $LN254@ProtocolCo
  01c8c	00 00 00 00	 DD	 $LN253@ProtocolCo
  01c90	00 00 00 00	 DD	 $LN251@ProtocolCo
  01c94	00 00 00 00	 DD	 $LN250@ProtocolCo
  01c98	00 00 00 00	 DD	 $LN249@ProtocolCo
  01c9c	00 00 00 00	 DD	 $LN247@ProtocolCo
  01ca0	00 00 00 00	 DD	 $LN245@ProtocolCo
  01ca4	00 00 00 00	 DD	 $LN237@ProtocolCo
  01ca8	00 00 00 00	 DD	 $LN235@ProtocolCo
  01cac	00 00 00 00	 DD	 $LN233@ProtocolCo
  01cb0	00 00 00 00	 DD	 $LN232@ProtocolCo
  01cb4	00 00 00 00	 DD	 $LN229@ProtocolCo
  01cb8	00 00 00 00	 DD	 $LN228@ProtocolCo
  01cbc	00 00 00 00	 DD	 $LN227@ProtocolCo
  01cc0	00 00 00 00	 DD	 $LN221@ProtocolCo
  01cc4	00 00 00 00	 DD	 $LN220@ProtocolCo
  01cc8	00 00 00 00	 DD	 $LN219@ProtocolCo
  01ccc	00 00 00 00	 DD	 $LN218@ProtocolCo
  01cd0	00 00 00 00	 DD	 $LN217@ProtocolCo
  01cd4	00 00 00 00	 DD	 $LN216@ProtocolCo
  01cd8	00 00 00 00	 DD	 $LN215@ProtocolCo
  01cdc	00 00 00 00	 DD	 $LN214@ProtocolCo
  01ce0	00 00 00 00	 DD	 $LN213@ProtocolCo
  01ce4	00 00 00 00	 DD	 $LN100@ProtocolCo
  01ce8	00 00 00 00	 DD	 $LN98@ProtocolCo
  01cec	00 00 00 00	 DD	 $LN96@ProtocolCo
  01cf0	00 00 00 00	 DD	 $LN95@ProtocolCo
  01cf4	00 00 00 00	 DD	 $LN94@ProtocolCo
  01cf8	00 00 00 00	 DD	 $LN93@ProtocolCo
  01cfc	00 00 00 00	 DD	 $LN92@ProtocolCo
  01d00	00 00 00 00	 DD	 $LN91@ProtocolCo
  01d04	00 00 00 00	 DD	 $LN90@ProtocolCo
  01d08	00 00 00 00	 DD	 $LN89@ProtocolCo
  01d0c	00 00 00 00	 DD	 $LN88@ProtocolCo
  01d10	00 00 00 00	 DD	 $LN87@ProtocolCo
  01d14	00 00 00 00	 DD	 $LN86@ProtocolCo
  01d18	00 00 00 00	 DD	 $LN85@ProtocolCo
  01d1c	00 00 00 00	 DD	 $LN84@ProtocolCo
  01d20	00 00 00 00	 DD	 $LN66@ProtocolCo
  01d24	00 00 00 00	 DD	 $LN63@ProtocolCo
  01d28	00 00 00 00	 DD	 $LN64@ProtocolCo
  01d2c	00 00 00 00	 DD	 $LN83@ProtocolCo
  01d30	00 00 00 00	 DD	 $LN82@ProtocolCo
  01d34	00 00 00 00	 DD	 $LN81@ProtocolCo
  01d38	00 00 00 00	 DD	 $LN80@ProtocolCo
  01d3c	00 00 00 00	 DD	 $LN79@ProtocolCo
  01d40	00 00 00 00	 DD	 $LN67@ProtocolCo
  01d44	00 00 00 00	 DD	 $LN62@ProtocolCo
  01d48	00 00 00 00	 DD	 $LN271@ProtocolCo
  01d4c	00 00 00 00	 DD	 $LN212@ProtocolCo
  01d50	00 00 00 00	 DD	 $LN207@ProtocolCo
  01d54	00 00 00 00	 DD	 $LN188@ProtocolCo
  01d58	00 00 00 00	 DD	 $LN187@ProtocolCo
  01d5c	00 00 00 00	 DD	 $LN186@ProtocolCo
  01d60	00 00 00 00	 DD	 $LN185@ProtocolCo
  01d64	00 00 00 00	 DD	 $LN180@ProtocolCo
  01d68	00 00 00 00	 DD	 $LN175@ProtocolCo
  01d6c	00 00 00 00	 DD	 $LN170@ProtocolCo
  01d70	00 00 00 00	 DD	 $LN164@ProtocolCo
  01d74	00 00 00 00	 DD	 $LN57@ProtocolCo
  01d78	00 00 00 00	 DD	 $LN56@ProtocolCo
  01d7c	00 00 00 00	 DD	 $LN55@ProtocolCo
  01d80	00 00 00 00	 DD	 $LN54@ProtocolCo
  01d84	00 00 00 00	 DD	 $LN53@ProtocolCo
  01d88	00 00 00 00	 DD	 $LN52@ProtocolCo
  01d8c	00 00 00 00	 DD	 $LN51@ProtocolCo
  01d90	00 00 00 00	 DD	 $LN50@ProtocolCo
  01d94	00 00 00 00	 DD	 $LN49@ProtocolCo
  01d98	00 00 00 00	 DD	 $LN48@ProtocolCo
  01d9c	00 00 00 00	 DD	 $LN47@ProtocolCo
  01da0	00 00 00 00	 DD	 $LN46@ProtocolCo
  01da4	00 00 00 00	 DD	 $LN41@ProtocolCo
  01da8	00 00 00 00	 DD	 $LN36@ProtocolCo
  01dac	00 00 00 00	 DD	 $LN280@ProtocolCo
  01db0	00 00 00 00	 DD	 $LN269@ProtocolCo
  01db4	00 00 00 00	 DD	 $LN153@ProtocolCo
  01db8	00 00 00 00	 DD	 $LN152@ProtocolCo
  01dbc	00 00 00 00	 DD	 $LN151@ProtocolCo
  01dc0	00 00 00 00	 DD	 $LN150@ProtocolCo
  01dc4	00 00 00 00	 DD	 $LN149@ProtocolCo
  01dc8	00 00 00 00	 DD	 $LN143@ProtocolCo
  01dcc	00 00 00 00	 DD	 $LN105@ProtocolCo
  01dd0	00 00 00 00	 DD	 $LN142@ProtocolCo
  01dd4	00 00 00 00	 DD	 $LN134@ProtocolCo
  01dd8	00 00 00 00	 DD	 $LN116@ProtocolCo
  01ddc	00 00 00 00	 DD	 $LN27@ProtocolCo
  01de0	00 00 00 00	 DD	 $LN14@ProtocolCo
  01de4	00 00 00 00	 DD	 $LN10@ProtocolCo
  01de8	00 00 00 00	 DD	 $LN122@ProtocolCo
  01dec	00 00 00 00	 DD	 $LN351@ProtocolCo
$LN341@ProtocolCo:
  01df0	00		 DB	 0
  01df1	01		 DB	 1
  01df2	02		 DB	 2
  01df3	03		 DB	 3
  01df4	04		 DB	 4
  01df5	6e		 DB	 110			; 0000006eH
  01df6	6e		 DB	 110			; 0000006eH
  01df7	6e		 DB	 110			; 0000006eH
  01df8	6e		 DB	 110			; 0000006eH
  01df9	6e		 DB	 110			; 0000006eH
  01dfa	6e		 DB	 110			; 0000006eH
  01dfb	6e		 DB	 110			; 0000006eH
  01dfc	6e		 DB	 110			; 0000006eH
  01dfd	6e		 DB	 110			; 0000006eH
  01dfe	05		 DB	 5
  01dff	6e		 DB	 110			; 0000006eH
  01e00	6e		 DB	 110			; 0000006eH
  01e01	06		 DB	 6
  01e02	6e		 DB	 110			; 0000006eH
  01e03	6e		 DB	 110			; 0000006eH
  01e04	6e		 DB	 110			; 0000006eH
  01e05	07		 DB	 7
  01e06	6e		 DB	 110			; 0000006eH
  01e07	6e		 DB	 110			; 0000006eH
  01e08	08		 DB	 8
  01e09	09		 DB	 9
  01e0a	6e		 DB	 110			; 0000006eH
  01e0b	0a		 DB	 10			; 0000000aH
  01e0c	0b		 DB	 11			; 0000000bH
  01e0d	6e		 DB	 110			; 0000006eH
  01e0e	0c		 DB	 12			; 0000000cH
  01e0f	6e		 DB	 110			; 0000006eH
  01e10	6e		 DB	 110			; 0000006eH
  01e11	6e		 DB	 110			; 0000006eH
  01e12	0d		 DB	 13			; 0000000dH
  01e13	0e		 DB	 14			; 0000000eH
  01e14	0f		 DB	 15			; 0000000fH
  01e15	6e		 DB	 110			; 0000006eH
  01e16	10		 DB	 16			; 00000010H
  01e17	6e		 DB	 110			; 0000006eH
  01e18	6e		 DB	 110			; 0000006eH
  01e19	6e		 DB	 110			; 0000006eH
  01e1a	6e		 DB	 110			; 0000006eH
  01e1b	6e		 DB	 110			; 0000006eH
  01e1c	6e		 DB	 110			; 0000006eH
  01e1d	6e		 DB	 110			; 0000006eH
  01e1e	6e		 DB	 110			; 0000006eH
  01e1f	6e		 DB	 110			; 0000006eH
  01e20	11		 DB	 17			; 00000011H
  01e21	12		 DB	 18			; 00000012H
  01e22	13		 DB	 19			; 00000013H
  01e23	14		 DB	 20			; 00000014H
  01e24	15		 DB	 21			; 00000015H
  01e25	6e		 DB	 110			; 0000006eH
  01e26	16		 DB	 22			; 00000016H
  01e27	17		 DB	 23			; 00000017H
  01e28	6e		 DB	 110			; 0000006eH
  01e29	6e		 DB	 110			; 0000006eH
  01e2a	18		 DB	 24			; 00000018H
  01e2b	6e		 DB	 110			; 0000006eH
  01e2c	19		 DB	 25			; 00000019H
  01e2d	1a		 DB	 26			; 0000001aH
  01e2e	6e		 DB	 110			; 0000006eH
  01e2f	1b		 DB	 27			; 0000001bH
  01e30	1c		 DB	 28			; 0000001cH
  01e31	1d		 DB	 29			; 0000001dH
  01e32	1e		 DB	 30			; 0000001eH
  01e33	1f		 DB	 31			; 0000001fH
  01e34	6e		 DB	 110			; 0000006eH
  01e35	6e		 DB	 110			; 0000006eH
  01e36	6e		 DB	 110			; 0000006eH
  01e37	6e		 DB	 110			; 0000006eH
  01e38	6e		 DB	 110			; 0000006eH
  01e39	6e		 DB	 110			; 0000006eH
  01e3a	20		 DB	 32			; 00000020H
  01e3b	21		 DB	 33			; 00000021H
  01e3c	22		 DB	 34			; 00000022H
  01e3d	6e		 DB	 110			; 0000006eH
  01e3e	6e		 DB	 110			; 0000006eH
  01e3f	6e		 DB	 110			; 0000006eH
  01e40	23		 DB	 35			; 00000023H
  01e41	24		 DB	 36			; 00000024H
  01e42	25		 DB	 37			; 00000025H
  01e43	26		 DB	 38			; 00000026H
  01e44	27		 DB	 39			; 00000027H
  01e45	28		 DB	 40			; 00000028H
  01e46	6e		 DB	 110			; 0000006eH
  01e47	29		 DB	 41			; 00000029H
  01e48	6e		 DB	 110			; 0000006eH
  01e49	6e		 DB	 110			; 0000006eH
  01e4a	6e		 DB	 110			; 0000006eH
  01e4b	6e		 DB	 110			; 0000006eH
  01e4c	6e		 DB	 110			; 0000006eH
  01e4d	6e		 DB	 110			; 0000006eH
  01e4e	6e		 DB	 110			; 0000006eH
  01e4f	6e		 DB	 110			; 0000006eH
  01e50	6e		 DB	 110			; 0000006eH
  01e51	2a		 DB	 42			; 0000002aH
  01e52	6e		 DB	 110			; 0000006eH
  01e53	6e		 DB	 110			; 0000006eH
  01e54	6e		 DB	 110			; 0000006eH
  01e55	6e		 DB	 110			; 0000006eH
  01e56	2b		 DB	 43			; 0000002bH
  01e57	6e		 DB	 110			; 0000006eH
  01e58	6e		 DB	 110			; 0000006eH
  01e59	6e		 DB	 110			; 0000006eH
  01e5a	6e		 DB	 110			; 0000006eH
  01e5b	6e		 DB	 110			; 0000006eH
  01e5c	6e		 DB	 110			; 0000006eH
  01e5d	6e		 DB	 110			; 0000006eH
  01e5e	6e		 DB	 110			; 0000006eH
  01e5f	6e		 DB	 110			; 0000006eH
  01e60	6e		 DB	 110			; 0000006eH
  01e61	04		 DB	 4
  01e62	2c		 DB	 44			; 0000002cH
  01e63	2d		 DB	 45			; 0000002dH
  01e64	6e		 DB	 110			; 0000006eH
  01e65	6e		 DB	 110			; 0000006eH
  01e66	6e		 DB	 110			; 0000006eH
  01e67	6e		 DB	 110			; 0000006eH
  01e68	6e		 DB	 110			; 0000006eH
  01e69	6e		 DB	 110			; 0000006eH
  01e6a	6e		 DB	 110			; 0000006eH
  01e6b	6e		 DB	 110			; 0000006eH
  01e6c	6e		 DB	 110			; 0000006eH
  01e6d	6e		 DB	 110			; 0000006eH
  01e6e	6e		 DB	 110			; 0000006eH
  01e6f	6e		 DB	 110			; 0000006eH
  01e70	6e		 DB	 110			; 0000006eH
  01e71	2e		 DB	 46			; 0000002eH
  01e72	2f		 DB	 47			; 0000002fH
  01e73	30		 DB	 48			; 00000030H
  01e74	6e		 DB	 110			; 0000006eH
  01e75	6e		 DB	 110			; 0000006eH
  01e76	31		 DB	 49			; 00000031H
  01e77	32		 DB	 50			; 00000032H
  01e78	6e		 DB	 110			; 0000006eH
  01e79	6e		 DB	 110			; 0000006eH
  01e7a	6e		 DB	 110			; 0000006eH
  01e7b	6e		 DB	 110			; 0000006eH
  01e7c	6e		 DB	 110			; 0000006eH
  01e7d	6e		 DB	 110			; 0000006eH
  01e7e	33		 DB	 51			; 00000033H
  01e7f	6e		 DB	 110			; 0000006eH
  01e80	34		 DB	 52			; 00000034H
  01e81	35		 DB	 53			; 00000035H
  01e82	6e		 DB	 110			; 0000006eH
  01e83	6e		 DB	 110			; 0000006eH
  01e84	6e		 DB	 110			; 0000006eH
  01e85	36		 DB	 54			; 00000036H
  01e86	37		 DB	 55			; 00000037H
  01e87	38		 DB	 56			; 00000038H
  01e88	39		 DB	 57			; 00000039H
  01e89	3a		 DB	 58			; 0000003aH
  01e8a	3b		 DB	 59			; 0000003bH
  01e8b	04		 DB	 4
  01e8c	6e		 DB	 110			; 0000006eH
  01e8d	3c		 DB	 60			; 0000003cH
  01e8e	6e		 DB	 110			; 0000006eH
  01e8f	3d		 DB	 61			; 0000003dH
  01e90	3e		 DB	 62			; 0000003eH
  01e91	6e		 DB	 110			; 0000006eH
  01e92	3f		 DB	 63			; 0000003fH
  01e93	6e		 DB	 110			; 0000006eH
  01e94	6e		 DB	 110			; 0000006eH
  01e95	6e		 DB	 110			; 0000006eH
  01e96	6e		 DB	 110			; 0000006eH
  01e97	40		 DB	 64			; 00000040H
  01e98	6e		 DB	 110			; 0000006eH
  01e99	41		 DB	 65			; 00000041H
  01e9a	42		 DB	 66			; 00000042H
  01e9b	6e		 DB	 110			; 0000006eH
  01e9c	6e		 DB	 110			; 0000006eH
  01e9d	6e		 DB	 110			; 0000006eH
  01e9e	43		 DB	 67			; 00000043H
  01e9f	44		 DB	 68			; 00000044H
  01ea0	45		 DB	 69			; 00000045H
  01ea1	46		 DB	 70			; 00000046H
  01ea2	47		 DB	 71			; 00000047H
  01ea3	48		 DB	 72			; 00000048H
  01ea4	49		 DB	 73			; 00000049H
  01ea5	4a		 DB	 74			; 0000004aH
  01ea6	6e		 DB	 110			; 0000006eH
  01ea7	4b		 DB	 75			; 0000004bH
  01ea8	6e		 DB	 110			; 0000006eH
  01ea9	4c		 DB	 76			; 0000004cH
  01eaa	6e		 DB	 110			; 0000006eH
  01eab	6e		 DB	 110			; 0000006eH
  01eac	4d		 DB	 77			; 0000004dH
  01ead	4e		 DB	 78			; 0000004eH
  01eae	6e		 DB	 110			; 0000006eH
  01eaf	4f		 DB	 79			; 0000004fH
  01eb0	50		 DB	 80			; 00000050H
  01eb1	51		 DB	 81			; 00000051H
  01eb2	52		 DB	 82			; 00000052H
  01eb3	53		 DB	 83			; 00000053H
  01eb4	54		 DB	 84			; 00000054H
  01eb5	55		 DB	 85			; 00000055H
  01eb6	6e		 DB	 110			; 0000006eH
  01eb7	56		 DB	 86			; 00000056H
  01eb8	57		 DB	 87			; 00000057H
  01eb9	58		 DB	 88			; 00000058H
  01eba	59		 DB	 89			; 00000059H
  01ebb	5a		 DB	 90			; 0000005aH
  01ebc	6e		 DB	 110			; 0000006eH
  01ebd	6e		 DB	 110			; 0000006eH
  01ebe	6e		 DB	 110			; 0000006eH
  01ebf	6e		 DB	 110			; 0000006eH
  01ec0	5b		 DB	 91			; 0000005bH
  01ec1	5c		 DB	 92			; 0000005cH
  01ec2	5d		 DB	 93			; 0000005dH
  01ec3	6e		 DB	 110			; 0000006eH
  01ec4	5e		 DB	 94			; 0000005eH
  01ec5	6e		 DB	 110			; 0000006eH
  01ec6	6e		 DB	 110			; 0000006eH
  01ec7	6e		 DB	 110			; 0000006eH
  01ec8	6e		 DB	 110			; 0000006eH
  01ec9	6e		 DB	 110			; 0000006eH
  01eca	6e		 DB	 110			; 0000006eH
  01ecb	5f		 DB	 95			; 0000005fH
  01ecc	6e		 DB	 110			; 0000006eH
  01ecd	6e		 DB	 110			; 0000006eH
  01ece	6e		 DB	 110			; 0000006eH
  01ecf	6e		 DB	 110			; 0000006eH
  01ed0	6e		 DB	 110			; 0000006eH
  01ed1	60		 DB	 96			; 00000060H
  01ed2	61		 DB	 97			; 00000061H
  01ed3	6e		 DB	 110			; 0000006eH
  01ed4	6e		 DB	 110			; 0000006eH
  01ed5	62		 DB	 98			; 00000062H
  01ed6	63		 DB	 99			; 00000063H
  01ed7	64		 DB	 100			; 00000064H
  01ed8	6e		 DB	 110			; 0000006eH
  01ed9	65		 DB	 101			; 00000065H
  01eda	6e		 DB	 110			; 0000006eH
  01edb	66		 DB	 102			; 00000066H
  01edc	67		 DB	 103			; 00000067H
  01edd	68		 DB	 104			; 00000068H
  01ede	6e		 DB	 110			; 0000006eH
  01edf	69		 DB	 105			; 00000069H
  01ee0	6e		 DB	 110			; 0000006eH
  01ee1	6e		 DB	 110			; 0000006eH
  01ee2	6e		 DB	 110			; 0000006eH
  01ee3	6e		 DB	 110			; 0000006eH
  01ee4	6e		 DB	 110			; 0000006eH
  01ee5	6e		 DB	 110			; 0000006eH
  01ee6	6a		 DB	 106			; 0000006aH
  01ee7	6b		 DB	 107			; 0000006bH
  01ee8	6c		 DB	 108			; 0000006cH
  01ee9	6e		 DB	 110			; 0000006eH
  01eea	6e		 DB	 110			; 0000006eH
  01eeb	6e		 DB	 110			; 0000006eH
  01eec	04		 DB	 4
  01eed	6e		 DB	 110			; 0000006eH
  01eee	6d		 DB	 109			; 0000006dH
  01eef	90		 npad	 1
$LN358@ProtocolCo:
  01ef0	00 00 00 00	 DD	 $LN242@ProtocolCo
  01ef4	00 00 00 00	 DD	 $LN241@ProtocolCo
  01ef8	00 00 00 00	 DD	 $LN240@ProtocolCo
  01efc	00 00 00 00	 DD	 $LN313@ProtocolCo
  01f00	00 00 00 00	 DD	 $LN239@ProtocolCo
  01f04	00 00 00 00	 DD	 $LN238@ProtocolCo
$LN359@ProtocolCo:
  01f08	00 00 00 00	 DD	 $LN204@ProtocolCo
  01f0c	00 00 00 00	 DD	 $LN203@ProtocolCo
  01f10	00 00 00 00	 DD	 $LN202@ProtocolCo
  01f14	00 00 00 00	 DD	 $LN201@ProtocolCo
  01f18	00 00 00 00	 DD	 $LN200@ProtocolCo
  01f1c	00 00 00 00	 DD	 $LN199@ProtocolCo
  01f20	00 00 00 00	 DD	 $LN198@ProtocolCo
  01f24	00 00 00 00	 DD	 $LN197@ProtocolCo
  01f28	00 00 00 00	 DD	 $LN196@ProtocolCo
  01f2c	00 00 00 00	 DD	 $LN195@ProtocolCo
  01f30	00 00 00 00	 DD	 $LN194@ProtocolCo
  01f34	00 00 00 00	 DD	 $LN193@ProtocolCo
  01f38	00 00 00 00	 DD	 $LN192@ProtocolCo
  01f3c	00 00 00 00	 DD	 $LN191@ProtocolCo
  01f40	00 00 00 00	 DD	 $LN190@ProtocolCo
  01f44	00 00 00 00	 DD	 $LN189@ProtocolCo
  01f48	00 00 00 00	 DD	 $LN313@ProtocolCo
$LN342@ProtocolCo:
  01f4c	00		 DB	 0
  01f4d	01		 DB	 1
  01f4e	02		 DB	 2
  01f4f	03		 DB	 3
  01f50	04		 DB	 4
  01f51	05		 DB	 5
  01f52	06		 DB	 6
  01f53	07		 DB	 7
  01f54	08		 DB	 8
  01f55	09		 DB	 9
  01f56	10		 DB	 16			; 00000010H
  01f57	10		 DB	 16			; 00000010H
  01f58	10		 DB	 16			; 00000010H
  01f59	10		 DB	 16			; 00000010H
  01f5a	10		 DB	 16			; 00000010H
  01f5b	10		 DB	 16			; 00000010H
  01f5c	0a		 DB	 10			; 0000000aH
  01f5d	10		 DB	 16			; 00000010H
  01f5e	0b		 DB	 11			; 0000000bH
  01f5f	10		 DB	 16			; 00000010H
  01f60	10		 DB	 16			; 00000010H
  01f61	10		 DB	 16			; 00000010H
  01f62	10		 DB	 16			; 00000010H
  01f63	10		 DB	 16			; 00000010H
  01f64	10		 DB	 16			; 00000010H
  01f65	10		 DB	 16			; 00000010H
  01f66	10		 DB	 16			; 00000010H
  01f67	0c		 DB	 12			; 0000000cH
  01f68	0d		 DB	 13			; 0000000dH
  01f69	0e		 DB	 14			; 0000000eH
  01f6a	10		 DB	 16			; 00000010H
  01f6b	0f		 DB	 15			; 0000000fH
$LN360@ProtocolCo:
  01f6c	00 00 00 00	 DD	 $LN161@ProtocolCo
  01f70	00 00 00 00	 DD	 $LN160@ProtocolCo
  01f74	00 00 00 00	 DD	 $LN159@ProtocolCo
  01f78	00 00 00 00	 DD	 $LN158@ProtocolCo
  01f7c	00 00 00 00	 DD	 $LN157@ProtocolCo
  01f80	00 00 00 00	 DD	 $LN156@ProtocolCo
  01f84	00 00 00 00	 DD	 $LN155@ProtocolCo
  01f88	00 00 00 00	 DD	 $LN154@ProtocolCo
$LN343@ProtocolCo:
  01f8c	00		 DB	 0
  01f8d	07		 DB	 7
  01f8e	01		 DB	 1
  01f8f	07		 DB	 7
  01f90	07		 DB	 7
  01f91	02		 DB	 2
  01f92	07		 DB	 7
  01f93	07		 DB	 7
  01f94	07		 DB	 7
  01f95	07		 DB	 7
  01f96	07		 DB	 7
  01f97	07		 DB	 7
  01f98	07		 DB	 7
  01f99	07		 DB	 7
  01f9a	03		 DB	 3
  01f9b	07		 DB	 7
  01f9c	07		 DB	 7
  01f9d	07		 DB	 7
  01f9e	07		 DB	 7
  01f9f	07		 DB	 7
  01fa0	07		 DB	 7
  01fa1	07		 DB	 7
  01fa2	07		 DB	 7
  01fa3	04		 DB	 4
  01fa4	07		 DB	 7
  01fa5	07		 DB	 7
  01fa6	07		 DB	 7
  01fa7	07		 DB	 7
  01fa8	07		 DB	 7
  01fa9	07		 DB	 7
  01faa	07		 DB	 7
  01fab	07		 DB	 7
  01fac	05		 DB	 5
  01fad	07		 DB	 7
  01fae	07		 DB	 7
  01faf	07		 DB	 7
  01fb0	07		 DB	 7
  01fb1	07		 DB	 7
  01fb2	07		 DB	 7
  01fb3	07		 DB	 7
  01fb4	07		 DB	 7
  01fb5	07		 DB	 7
  01fb6	07		 DB	 7
  01fb7	07		 DB	 7
  01fb8	07		 DB	 7
  01fb9	07		 DB	 7
  01fba	07		 DB	 7
  01fbb	07		 DB	 7
  01fbc	07		 DB	 7
  01fbd	07		 DB	 7
  01fbe	07		 DB	 7
  01fbf	07		 DB	 7
  01fc0	07		 DB	 7
  01fc1	07		 DB	 7
  01fc2	07		 DB	 7
  01fc3	07		 DB	 7
  01fc4	07		 DB	 7
  01fc5	07		 DB	 7
  01fc6	07		 DB	 7
  01fc7	07		 DB	 7
  01fc8	07		 DB	 7
  01fc9	07		 DB	 7
  01fca	07		 DB	 7
  01fcb	07		 DB	 7
  01fcc	07		 DB	 7
  01fcd	07		 DB	 7
  01fce	07		 DB	 7
  01fcf	07		 DB	 7
  01fd0	07		 DB	 7
  01fd1	07		 DB	 7
  01fd2	07		 DB	 7
  01fd3	07		 DB	 7
  01fd4	07		 DB	 7
  01fd5	07		 DB	 7
  01fd6	07		 DB	 7
  01fd7	07		 DB	 7
  01fd8	07		 DB	 7
  01fd9	07		 DB	 7
  01fda	07		 DB	 7
  01fdb	07		 DB	 7
  01fdc	07		 DB	 7
  01fdd	06		 DB	 6
  01fde	8b ff		 npad	 2
$LN361@ProtocolCo:
  01fe0	00 00 00 00	 DD	 $LN139@ProtocolCo
  01fe4	00 00 00 00	 DD	 $LN138@ProtocolCo
  01fe8	00 00 00 00	 DD	 $LN137@ProtocolCo
  01fec	00 00 00 00	 DD	 $LN136@ProtocolCo
  01ff0	00 00 00 00	 DD	 $LN135@ProtocolCo
  01ff4	00 00 00 00	 DD	 $LN313@ProtocolCo
$LN344@ProtocolCo:
  01ff8	00		 DB	 0
  01ff9	01		 DB	 1
  01ffa	02		 DB	 2
  01ffb	03		 DB	 3
  01ffc	05		 DB	 5
  01ffd	05		 DB	 5
  01ffe	05		 DB	 5
  01fff	05		 DB	 5
  02000	05		 DB	 5
  02001	05		 DB	 5
  02002	05		 DB	 5
  02003	05		 DB	 5
  02004	05		 DB	 5
  02005	05		 DB	 5
  02006	05		 DB	 5
  02007	05		 DB	 5
  02008	05		 DB	 5
  02009	05		 DB	 5
  0200a	05		 DB	 5
  0200b	05		 DB	 5
  0200c	05		 DB	 5
  0200d	05		 DB	 5
  0200e	05		 DB	 5
  0200f	05		 DB	 5
  02010	05		 DB	 5
  02011	05		 DB	 5
  02012	05		 DB	 5
  02013	05		 DB	 5
  02014	05		 DB	 5
  02015	05		 DB	 5
  02016	05		 DB	 5
  02017	05		 DB	 5
  02018	05		 DB	 5
  02019	05		 DB	 5
  0201a	05		 DB	 5
  0201b	05		 DB	 5
  0201c	05		 DB	 5
  0201d	05		 DB	 5
  0201e	05		 DB	 5
  0201f	05		 DB	 5
  02020	05		 DB	 5
  02021	05		 DB	 5
  02022	05		 DB	 5
  02023	05		 DB	 5
  02024	05		 DB	 5
  02025	05		 DB	 5
  02026	05		 DB	 5
  02027	05		 DB	 5
  02028	05		 DB	 5
  02029	04		 DB	 4
  0202a	8b ff		 npad	 2
$LN362@ProtocolCo:
  0202c	00 00 00 00	 DD	 $LN131@ProtocolCo
  02030	00 00 00 00	 DD	 $LN130@ProtocolCo
  02034	00 00 00 00	 DD	 $LN129@ProtocolCo
  02038	00 00 00 00	 DD	 $LN128@ProtocolCo
  0203c	00 00 00 00	 DD	 $LN127@ProtocolCo
  02040	00 00 00 00	 DD	 $LN126@ProtocolCo
  02044	00 00 00 00	 DD	 $LN125@ProtocolCo
  02048	00 00 00 00	 DD	 $LN124@ProtocolCo
  0204c	00 00 00 00	 DD	 $LN123@ProtocolCo
$LN363@ProtocolCo:
  02050	00 00 00 00	 DD	 $LN113@ProtocolCo
  02054	00 00 00 00	 DD	 $LN112@ProtocolCo
  02058	00 00 00 00	 DD	 $LN111@ProtocolCo
  0205c	00 00 00 00	 DD	 $LN110@ProtocolCo
  02060	00 00 00 00	 DD	 $LN109@ProtocolCo
  02064	00 00 00 00	 DD	 $LN108@ProtocolCo
  02068	00 00 00 00	 DD	 $LN107@ProtocolCo
  0206c	00 00 00 00	 DD	 $LN106@ProtocolCo
$LN364@ProtocolCo:
  02070	00 00 00 00	 DD	 $LN76@ProtocolCo
  02074	00 00 00 00	 DD	 $LN74@ProtocolCo
  02078	00 00 00 00	 DD	 $LN73@ProtocolCo
  0207c	00 00 00 00	 DD	 $LN313@ProtocolCo
  02080	00 00 00 00	 DD	 $LN313@ProtocolCo
  02084	00 00 00 00	 DD	 $LN313@ProtocolCo
  02088	00 00 00 00	 DD	 $LN71@ProtocolCo
  0208c	00 00 00 00	 DD	 $LN313@ProtocolCo
  02090	00 00 00 00	 DD	 $LN69@ProtocolCo
$LN365@ProtocolCo:
  02094	00 00 00 00	 DD	 $LN33@ProtocolCo
  02098	00 00 00 00	 DD	 $LN32@ProtocolCo
  0209c	00 00 00 00	 DD	 $LN31@ProtocolCo
  020a0	00 00 00 00	 DD	 $LN30@ProtocolCo
  020a4	00 00 00 00	 DD	 $LN29@ProtocolCo
  020a8	00 00 00 00	 DD	 $LN313@ProtocolCo
  020ac	00 00 00 00	 DD	 $LN313@ProtocolCo
  020b0	00 00 00 00	 DD	 $LN313@ProtocolCo
  020b4	00 00 00 00	 DD	 $LN313@ProtocolCo
  020b8	00 00 00 00	 DD	 $LN313@ProtocolCo
  020bc	00 00 00 00	 DD	 $LN28@ProtocolCo
$LN366@ProtocolCo:
  020c0	00 00 00 00	 DD	 $LN24@ProtocolCo
  020c4	00 00 00 00	 DD	 $LN23@ProtocolCo
  020c8	00 00 00 00	 DD	 $LN22@ProtocolCo
  020cc	00 00 00 00	 DD	 $LN21@ProtocolCo
  020d0	00 00 00 00	 DD	 $LN20@ProtocolCo
  020d4	00 00 00 00	 DD	 $LN19@ProtocolCo
  020d8	00 00 00 00	 DD	 $LN18@ProtocolCo
  020dc	00 00 00 00	 DD	 $LN16@ProtocolCo
  020e0	00 00 00 00	 DD	 $LN15@ProtocolCo
  020e4	00 00 00 00	 DD	 $LN313@ProtocolCo
$LN345@ProtocolCo:
  020e8	00		 DB	 0
  020e9	01		 DB	 1
  020ea	09		 DB	 9
  020eb	02		 DB	 2
  020ec	09		 DB	 9
  020ed	03		 DB	 3
  020ee	04		 DB	 4
  020ef	09		 DB	 9
  020f0	09		 DB	 9
  020f1	09		 DB	 9
  020f2	09		 DB	 9
  020f3	09		 DB	 9
  020f4	09		 DB	 9
  020f5	09		 DB	 9
  020f6	09		 DB	 9
  020f7	09		 DB	 9
  020f8	05		 DB	 5
  020f9	06		 DB	 6
  020fa	09		 DB	 9
  020fb	09		 DB	 9
  020fc	09		 DB	 9
  020fd	09		 DB	 9
  020fe	09		 DB	 9
  020ff	09		 DB	 9
  02100	09		 DB	 9
  02101	09		 DB	 9
  02102	09		 DB	 9
  02103	09		 DB	 9
  02104	09		 DB	 9
  02105	09		 DB	 9
  02106	09		 DB	 9
  02107	09		 DB	 9
  02108	09		 DB	 9
  02109	09		 DB	 9
  0210a	09		 DB	 9
  0210b	09		 DB	 9
  0210c	09		 DB	 9
  0210d	09		 DB	 9
  0210e	07		 DB	 7
  0210f	08		 DB	 8
$LN367@ProtocolCo:
  02110	00 00 00 00	 DD	 $LN7@ProtocolCo
  02114	00 00 00 00	 DD	 $LN6@ProtocolCo
  02118	00 00 00 00	 DD	 $LN5@ProtocolCo
  0211c	00 00 00 00	 DD	 $LN4@ProtocolCo
  02120	00 00 00 00	 DD	 $LN3@ProtocolCo
  02124	00 00 00 00	 DD	 $LN313@ProtocolCo
$LN346@ProtocolCo:
  02128	00		 DB	 0
  02129	05		 DB	 5
  0212a	01		 DB	 1
  0212b	05		 DB	 5
  0212c	05		 DB	 5
  0212d	05		 DB	 5
  0212e	05		 DB	 5
  0212f	05		 DB	 5
  02130	02		 DB	 2
  02131	05		 DB	 5
  02132	03		 DB	 3
  02133	05		 DB	 5
  02134	05		 DB	 5
  02135	05		 DB	 5
  02136	05		 DB	 5
  02137	05		 DB	 5
  02138	05		 DB	 5
  02139	05		 DB	 5
  0213a	05		 DB	 5
  0213b	05		 DB	 5
  0213c	05		 DB	 5
  0213d	05		 DB	 5
  0213e	05		 DB	 5
  0213f	05		 DB	 5
  02140	05		 DB	 5
  02141	05		 DB	 5
  02142	05		 DB	 5
  02143	05		 DB	 5
  02144	05		 DB	 5
  02145	05		 DB	 5
  02146	05		 DB	 5
  02147	04		 DB	 4
$LN368@ProtocolCo:
  02148	00 00 00 00	 DD	 $LN300@ProtocolCo
  0214c	00 00 00 00	 DD	 $LN299@ProtocolCo
  02150	00 00 00 00	 DD	 $LN298@ProtocolCo
  02154	00 00 00 00	 DD	 $LN297@ProtocolCo
  02158	00 00 00 00	 DD	 $LN296@ProtocolCo
  0215c	00 00 00 00	 DD	 $LN295@ProtocolCo
  02160	00 00 00 00	 DD	 $LN294@ProtocolCo
  02164	00 00 00 00	 DD	 $LN293@ProtocolCo
  02168	00 00 00 00	 DD	 $LN292@ProtocolCo
  0216c	00 00 00 00	 DD	 $LN290@ProtocolCo
  02170	00 00 00 00	 DD	 $LN313@ProtocolCo
$LN347@ProtocolCo:
  02174	00		 DB	 0
  02175	01		 DB	 1
  02176	02		 DB	 2
  02177	03		 DB	 3
  02178	0a		 DB	 10			; 0000000aH
  02179	0a		 DB	 10			; 0000000aH
  0217a	04		 DB	 4
  0217b	0a		 DB	 10			; 0000000aH
  0217c	0a		 DB	 10			; 0000000aH
  0217d	0a		 DB	 10			; 0000000aH
  0217e	0a		 DB	 10			; 0000000aH
  0217f	0a		 DB	 10			; 0000000aH
  02180	0a		 DB	 10			; 0000000aH
  02181	0a		 DB	 10			; 0000000aH
  02182	0a		 DB	 10			; 0000000aH
  02183	0a		 DB	 10			; 0000000aH
  02184	0a		 DB	 10			; 0000000aH
  02185	0a		 DB	 10			; 0000000aH
  02186	05		 DB	 5
  02187	0a		 DB	 10			; 0000000aH
  02188	0a		 DB	 10			; 0000000aH
  02189	06		 DB	 6
  0218a	0a		 DB	 10			; 0000000aH
  0218b	0a		 DB	 10			; 0000000aH
  0218c	0a		 DB	 10			; 0000000aH
  0218d	0a		 DB	 10			; 0000000aH
  0218e	0a		 DB	 10			; 0000000aH
  0218f	0a		 DB	 10			; 0000000aH
  02190	0a		 DB	 10			; 0000000aH
  02191	0a		 DB	 10			; 0000000aH
  02192	0a		 DB	 10			; 0000000aH
  02193	0a		 DB	 10			; 0000000aH
  02194	0a		 DB	 10			; 0000000aH
  02195	07		 DB	 7
  02196	0a		 DB	 10			; 0000000aH
  02197	0a		 DB	 10			; 0000000aH
  02198	0a		 DB	 10			; 0000000aH
  02199	0a		 DB	 10			; 0000000aH
  0219a	0a		 DB	 10			; 0000000aH
  0219b	0a		 DB	 10			; 0000000aH
  0219c	0a		 DB	 10			; 0000000aH
  0219d	0a		 DB	 10			; 0000000aH
  0219e	0a		 DB	 10			; 0000000aH
  0219f	0a		 DB	 10			; 0000000aH
  021a0	0a		 DB	 10			; 0000000aH
  021a1	0a		 DB	 10			; 0000000aH
  021a2	0a		 DB	 10			; 0000000aH
  021a3	0a		 DB	 10			; 0000000aH
  021a4	08		 DB	 8
  021a5	0a		 DB	 10			; 0000000aH
  021a6	0a		 DB	 10			; 0000000aH
  021a7	0a		 DB	 10			; 0000000aH
  021a8	0a		 DB	 10			; 0000000aH
  021a9	0a		 DB	 10			; 0000000aH
  021aa	0a		 DB	 10			; 0000000aH
  021ab	0a		 DB	 10			; 0000000aH
  021ac	0a		 DB	 10			; 0000000aH
  021ad	0a		 DB	 10			; 0000000aH
  021ae	0a		 DB	 10			; 0000000aH
  021af	0a		 DB	 10			; 0000000aH
  021b0	0a		 DB	 10			; 0000000aH
  021b1	0a		 DB	 10			; 0000000aH
  021b2	0a		 DB	 10			; 0000000aH
  021b3	0a		 DB	 10			; 0000000aH
  021b4	0a		 DB	 10			; 0000000aH
  021b5	0a		 DB	 10			; 0000000aH
  021b6	0a		 DB	 10			; 0000000aH
  021b7	0a		 DB	 10			; 0000000aH
  021b8	0a		 DB	 10			; 0000000aH
  021b9	0a		 DB	 10			; 0000000aH
  021ba	0a		 DB	 10			; 0000000aH
  021bb	0a		 DB	 10			; 0000000aH
  021bc	0a		 DB	 10			; 0000000aH
  021bd	0a		 DB	 10			; 0000000aH
  021be	0a		 DB	 10			; 0000000aH
  021bf	0a		 DB	 10			; 0000000aH
  021c0	0a		 DB	 10			; 0000000aH
  021c1	0a		 DB	 10			; 0000000aH
  021c2	0a		 DB	 10			; 0000000aH
  021c3	0a		 DB	 10			; 0000000aH
  021c4	0a		 DB	 10			; 0000000aH
  021c5	0a		 DB	 10			; 0000000aH
  021c6	09		 DB	 9
?ProtocolCore@@YAXEPAEHHHH@Z ENDP			; ProtocolCore
_TEXT	ENDS
PUBLIC	??_C@_07GDHHDJMO@Credits?$AA@			; `string'
PUBLIC	??_C@_0O@BDDJAJFG@?4?2Log?2Credits?$AA@		; `string'
EXTRN	_atexit:PROC
EXTRN	??0CLogToFile@@QAE@QAD0H@Z:PROC			; CLogToFile::CLogToFile
;	COMDAT ??_C@_07GDHHDJMO@Credits?$AA@
CONST	SEGMENT
??_C@_07GDHHDJMO@Credits?$AA@ DB 'Credits', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BDDJAJFG@?4?2Log?2Credits?$AA@
CONST	SEGMENT
??_C@_0O@BDDJAJFG@?4?2Log?2Credits?$AA@ DB '.\Log\Credits', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??__Eg_CreditLog@@YAXXZ
text$yc	SEGMENT
??__Eg_CreditLog@@YAXXZ PROC				; `dynamic initializer for 'g_CreditLog'', COMDAT

; 109  : CLogToFile g_CreditLog(LOG_NAME_CREDITS, LOG_PATH_CREDITS, TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BDDJAJFG@?4?2Log?2Credits?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_07GDHHDJMO@Credits?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CreditLog@@3VCLogToFile@@A ; g_CreditLog
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__Fg_CreditLog@@YAXXZ ; `dynamic atexit destructor for 'g_CreditLog''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__Eg_CreditLog@@YAXXZ ENDP				; `dynamic initializer for 'g_CreditLog''
text$yc	ENDS
EXTRN	??1CLogToFile@@QAE@XZ:PROC			; CLogToFile::~CLogToFile
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_CreditLog@@YAXXZ
text$yd	SEGMENT
??__Fg_CreditLog@@YAXXZ PROC				; `dynamic atexit destructor for 'g_CreditLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CreditLog@@3VCLogToFile@@A ; g_CreditLog
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__Fg_CreditLog@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_CreditLog''
text$yd	ENDS
PUBLIC	?g_CreditLog@@3VCLogToFile@@A			; g_CreditLog
_BSS	SEGMENT
?g_CreditLog@@3VCLogToFile@@A DB 010228H DUP (?)	; g_CreditLog
_BSS	ENDS
CRT$XCU	SEGMENT
_g_CreditLog$initializer$ DD FLAT:??__Eg_CreditLog@@YAXXZ
CRT$XCU	ENDS
END
