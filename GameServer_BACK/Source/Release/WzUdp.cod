; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\muserver_dev\development\MU-S8EP2-Repack\GameServer\Source\WzUdp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__$ArrayPad$
PUBLIC	?Init@WzUdp@@QAEHXZ				; WzUdp::Init
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\wzudp.cpp
;	COMDAT ?Init@WzUdp@@QAEHXZ
_TEXT	SEGMENT
_wsd$ = -404						; size = 400
__$ArrayPad$ = -4					; size = 4
?Init@WzUdp@@QAEHXZ PROC				; WzUdp::Init, COMDAT
; _this$ = ecx

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 33   : 	WSADATA wsd;
; 34   : 
; 35   : 	if ( WSAStartup(WZ_UPD_WINSOCK_VERSION, &wsd) )

  00014	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _wsd$[ebp]
  0001a	50		 push	 eax
  0001b	68 02 02 00 00	 push	 514			; 00000202H
  00020	8b f1		 mov	 esi, ecx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAStartup@8
  00028	85 c0		 test	 eax, eax
  0002a	74 11		 je	 SHORT $LN1@Init

; 36   : 	{
; 37   : 		return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 38   : 	}
; 39   : 	this->m_Socket = INVALID_SOCKET;	// Set socket NULL
; 40   : 	this->m_dwLength = 4096;
; 41   : 	this->m_dwRecvOfs = 0;
; 42   : 	this->m_ThreadHandle = NULL;
; 43   : 	this->ProtocolCore=0;	// Protocol Core Null
; 44   : 	return 1;
; 45   : }

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00032	33 cd		 xor	 ecx, ebp
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN1@Init:
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 c0		 xor	 eax, eax
  00042	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00045	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00048	89 86 5c 08 00
	00		 mov	 DWORD PTR [esi+2140], eax
  0004e	c7 46 10 ff ff
	ff ff		 mov	 DWORD PTR [esi+16], -1
  00055	c7 46 1c 00 10
	00 00		 mov	 DWORD PTR [esi+28], 4096 ; 00001000H
  0005c	33 cd		 xor	 ecx, ebp
  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	5e		 pop	 esi
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?Init@WzUdp@@QAEHXZ ENDP				; WzUdp::Init
_TEXT	ENDS
PUBLIC	?Close@WzUdp@@QAEHXZ				; WzUdp::Close
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__TerminateThread@8:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Close@WzUdp@@QAEHXZ
_TEXT	SEGMENT
?Close@WzUdp@@QAEHXZ PROC				; WzUdp::Close, COMDAT
; _this$ = ecx

; 48   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 49   : 	::TerminateThread(this->m_ThreadHandle, 0);

  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00006	6a 00		 push	 0
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 50   : 
; 51   : 	if (this->m_ThreadHandle != 0)

  0000f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00012	85 c0		 test	 eax, eax
  00014	74 1a		 je	 SHORT $LN1@Close

; 52   : 	{
; 53   : 		WaitForSingleObject(this->m_ThreadHandle , INFINITE);	// Interesting, this could block GS

  00016	6a ff		 push	 -1
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 54   : 		CloseHandle(this->m_ThreadHandle );

  0001f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00022	51		 push	 ecx
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 55   : 		this->m_ThreadHandle =0;	// NULL handle

  00029	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Close:

; 56   : 	}
; 57   : 
; 58   : 	HeapFree(GetProcessHeap(), 0, this->m_Recvbuf);

  00030	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00033	52		 push	 edx
  00034	6a 00		 push	 0
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 59   : 	return 1;

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	5e		 pop	 esi

; 60   : }

  00049	c3		 ret	 0
?Close@WzUdp@@QAEHXZ ENDP				; WzUdp::Close
_TEXT	ENDS
PUBLIC	?CreateSocket@WzUdp@@QAEHXZ			; WzUdp::CreateSocket
EXTRN	__imp__WSASocketA@24:PROC
EXTRN	__imp__closesocket@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CreateSocket@WzUdp@@QAEHXZ
_TEXT	SEGMENT
?CreateSocket@WzUdp@@QAEHXZ PROC			; WzUdp::CreateSocket, COMDAT
; _this$ = ecx

; 64   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 65   : 	if ( this->m_Socket != INVALID_SOCKET )

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	74 0e		 je	 SHORT $LN2@CreateSock

; 66   : 	{
; 67   : 		closesocket(this->m_Socket );

  0000b	50		 push	 eax
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 68   : 		this->m_Socket=INVALID_SOCKET;

  00012	c7 46 10 ff ff
	ff ff		 mov	 DWORD PTR [esi+16], -1
$LN2@CreateSock:

; 69   : 	}
; 70   : 	this->m_Socket=WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_IP, NULL, 0,0);

  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	6a 00		 push	 0
  00021	6a 02		 push	 2
  00023	6a 02		 push	 2
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24

; 71   : 
; 72   : 	if ( this->m_Socket== INVALID_SOCKET)

  0002b	33 c9		 xor	 ecx, ecx
  0002d	83 f8 ff	 cmp	 eax, -1
  00030	0f 95 c1	 setne	 cl
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	5e		 pop	 esi
  00037	8b c1		 mov	 eax, ecx

; 73   : 	{
; 74   : 		return 0;
; 75   : 	}
; 76   : 	return 1;
; 77   : }

  00039	c3		 ret	 0
?CreateSocket@WzUdp@@QAEHXZ ENDP			; WzUdp::CreateSocket
_TEXT	ENDS
PUBLIC	?SendSet@WzUdp@@QAEHPADH@Z			; WzUdp::SendSet
EXTRN	__imp__gethostbyname@4:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?SendSet@WzUdp@@QAEHPADH@Z
_TEXT	SEGMENT
_ip$ = 8						; size = 4
_port$ = 12						; size = 4
?SendSet@WzUdp@@QAEHPADH@Z PROC				; WzUdp::SendSet, COMDAT
; _this$ = ecx

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   : 	this->m_Port = port;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _port$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi

; 82   : 	this->m_SockAddr.sin_family=AF_INET;

  0000a	b9 02 00 00 00	 mov	 ecx, 2

; 83   : 
; 84   : 	this->m_SockAddr.sin_port=htons(port);

  0000f	50		 push	 eax
  00010	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00013	66 89 8e 4c 08
	00 00		 mov	 WORD PTR [esi+2124], cx
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 85   : 	this->m_SockAddr.sin_addr.S_un.S_addr=inet_addr(ip);

  00020	8b 7d 08	 mov	 edi, DWORD PTR _ip$[ebp]
  00023	57		 push	 edi
  00024	66 89 86 4e 08
	00 00		 mov	 WORD PTR [esi+2126], ax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4
  00031	81 c6 50 08 00
	00		 add	 esi, 2128		; 00000850H
  00037	89 06		 mov	 DWORD PTR [esi], eax

; 86   : 
; 87   : 	if ( this->m_SockAddr.sin_addr.S_un.S_addr == -1)

  00039	83 f8 ff	 cmp	 eax, -1
  0003c	75 1f		 jne	 SHORT $LN1@SendSet

; 88   : 	{
; 89   : 		hostent* host=0;	// NULL pointer
; 90   : 		host=gethostbyname(ip);

  0003e	57		 push	 edi
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostbyname@4

; 91   : 
; 92   : 		if (host != 0)

  00045	85 c0		 test	 eax, eax
  00047	74 1f		 je	 SHORT $LN2@SendSet

; 93   : 		{
; 94   : 			memcpy(&this->m_SockAddr.sin_addr.S_un.S_addr,*host->h_addr_list ,host->h_length);	// Add Type Structure {$D }

  00049	0f bf 50 0a	 movsx	 edx, WORD PTR [eax+10]
  0004d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	52		 push	 edx
  00053	51		 push	 ecx
  00054	56		 push	 esi
  00055	e8 00 00 00 00	 call	 _memcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SendSet:

; 99   : 		}
; 100  : 	}
; 101  : 	return 1;

  0005d	5f		 pop	 edi
  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	5e		 pop	 esi

; 102  : }

  00064	5d		 pop	 ebp
  00065	c2 08 00	 ret	 8
$LN2@SendSet:
  00068	5f		 pop	 edi

; 95   : 		}
; 96   : 		else
; 97   : 		{
; 98   : 			return 0;

  00069	33 c0		 xor	 eax, eax
  0006b	5e		 pop	 esi

; 102  : }

  0006c	5d		 pop	 ebp
  0006d	c2 08 00	 ret	 8
?SendSet@WzUdp@@QAEHPADH@Z ENDP				; WzUdp::SendSet
_TEXT	ENDS
PUBLIC	?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z	; WzUdp::SetProtocolCore
; Function compile flags: /Ogtp
;	COMDAT ?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z
_TEXT	SEGMENT
_pc$ = 8						; size = 4
?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z PROC		; WzUdp::SetProtocolCore, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 106  : 	this->ProtocolCore=pc;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pc$[ebp]
  00006	89 81 5c 08 00
	00		 mov	 DWORD PTR [ecx+2140], eax

; 107  : 	return 1;

  0000c	b8 01 00 00 00	 mov	 eax, 1

; 108  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z ENDP		; WzUdp::SetProtocolCore
_TEXT	ENDS
PUBLIC	?RecvSet@WzUdp@@QAEHH@Z				; WzUdp::RecvSet
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__htonl@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?RecvSet@WzUdp@@QAEHH@Z
_TEXT	SEGMENT
_port$ = 8						; size = 4
?RecvSet@WzUdp@@QAEHH@Z PROC				; WzUdp::RecvSet, COMDAT
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 112  : 
; 113  : 	this->m_Port=port;

  00003	8b 45 08	 mov	 eax, DWORD PTR _port$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 114  : 
; 115  : 	this->m_SockAddr.sin_port=htons(port);

  0000a	50		 push	 eax
  0000b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  00014	66 89 86 4e 08
	00 00		 mov	 WORD PTR [esi+2126], ax

; 116  : 	this->m_SockAddr.sin_family=AF_INET;

  0001b	b8 02 00 00 00	 mov	 eax, 2
  00020	8d be 4c 08 00
	00		 lea	 edi, DWORD PTR [esi+2124]

; 117  : 
; 118  : 	this->m_SockAddr.sin_addr.S_un.S_addr=htonl(0);

  00026	6a 00		 push	 0
  00028	66 89 07	 mov	 WORD PTR [edi], ax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htonl@4

; 119  : 	
; 120  : 	if( bind(this->m_Socket, (sockaddr*)&this->m_SockAddr, 16) == -1 )

  00031	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00034	6a 10		 push	 16			; 00000010H
  00036	57		 push	 edi
  00037	51		 push	 ecx
  00038	89 86 50 08 00
	00		 mov	 DWORD PTR [esi+2128], eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12
  00044	83 f8 ff	 cmp	 eax, -1
  00047	75 08		 jne	 SHORT $LN2@RecvSet

; 121  : 	{
; 122  : 		return 0;

  00049	5f		 pop	 edi
  0004a	33 c0		 xor	 eax, eax
  0004c	5e		 pop	 esi

; 127  : 	{
; 128  : 		return 0;
; 129  : 	}
; 130  : 	return 1;
; 131  : }

  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN2@RecvSet:

; 123  : 	}
; 124  : 	this->m_Recvbuf=(unsigned char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, this->m_dwLength);

  00051	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00054	52		 push	 edx
  00055	6a 08		 push	 8
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0005d	50		 push	 eax
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12

; 125  : 
; 126  : 	if ( this->m_Recvbuf == 0)

  00064	33 c9		 xor	 ecx, ecx
  00066	85 c0		 test	 eax, eax
  00068	0f 95 c1	 setne	 cl
  0006b	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	8b c1		 mov	 eax, ecx

; 127  : 	{
; 128  : 		return 0;
; 129  : 	}
; 130  : 	return 1;
; 131  : }

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
?RecvSet@WzUdp@@QAEHH@Z ENDP				; WzUdp::RecvSet
_TEXT	ENDS
PUBLIC	?SendData@WzUdp@@QAEHPAEK@Z			; WzUdp::SendData
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSASendTo@36:PROC
; Function compile flags: /Ogtp
;	COMDAT ?SendData@WzUdp@@QAEHPAEK@Z
_TEXT	SEGMENT
_SendData$ = 8						; size = 4
_nSendDataLen$ = 12					; size = 4
?SendData@WzUdp@@QAEHPAEK@Z PROC			; WzUdp::SendData, COMDAT
; _this$ = ecx

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 135  : 	/*int Ret;
; 136  : 	memset(&this->m_PerIoSendData.Overlapped, 0, 20);	// Add Type Structure {$D}
; 137  : 	memcpy(this->m_PerIoSendData.Buffer , SendData, nSendDataLen);
; 138  : 	
; 139  : 	this->m_PerIoSendData.lOfs=nSendDataLen;
; 140  : 	this->m_PerIoSendData.DataBuf.buf =this->m_PerIoSendData.Buffer;	// 40 Pointer 44 ...
; 141  : 	this->m_PerIoSendData.DataBuf.len =this->m_PerIoSendData.lOfs;	// No complex
; 142  : 
; 143  : 	Ret=WSASendTo(this->m_Socket, &this->m_PerIoSendData.DataBuf, 1, (unsigned long*)&nSendDataLen, 0, (sockaddr*)&this->m_SockAddr, 16, &this->m_PerIoSendData.Overlapped, NULL); 		// 28 Add Type Structure {$D}
; 144  : 	if (Ret == -1 )
; 145  : 	{
; 146  : 		if (WSAGetLastError() != WSA_IO_PENDING ) //WSA_IO_PENDING
; 147  : 		{
; 148  : 			return -1;
; 149  : 		}
; 150  : 	}
; 151  : 	return 1;*/
; 152  : 	DWORD Ret;
; 153  : 
; 154  : 	ZeroMemory(&(m_PerIoSendData.Overlapped), sizeof(OVERLAPPED));

  00005	33 c0		 xor	 eax, eax
  00007	8b f1		 mov	 esi, ecx

; 155  : 	
; 156  : 	memcpy(m_PerIoSendData.Buffer, SendData, nSendDataLen);

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _SendData$[ebp]
  0000c	57		 push	 edi
  0000d	8d 7e 28	 lea	 edi, DWORD PTR [esi+40]
  00010	89 07		 mov	 DWORD PTR [edi], eax
  00012	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00015	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00018	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  0001b	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _nSendDataLen$[ebp]
  00021	50		 push	 eax
  00022	51		 push	 ecx
  00023	8d 5e 44	 lea	 ebx, DWORD PTR [esi+68]
  00026	53		 push	 ebx
  00027	e8 00 00 00 00	 call	 _memcpy

; 157  : 	
; 158  : 	m_PerIoSendData.lOfs		= nSendDataLen;

  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _nSendDataLen$[ebp]
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 159  : 	m_PerIoSendData.DataBuf.buf = m_PerIoSendData.Buffer;
; 160  : 	m_PerIoSendData.DataBuf.len = m_PerIoSendData.lOfs;
; 161  : 		
; 162  : 	Ret = WSASendTo(m_Socket, &(m_PerIoSendData.DataBuf), 1, &nSendDataLen, 0, (SOCKADDR*)&m_SockAddr, sizeof(m_SockAddr), &(m_PerIoSendData.Overlapped), NULL);

  00032	6a 00		 push	 0
  00034	57		 push	 edi
  00035	6a 10		 push	 16			; 00000010H
  00037	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  0003a	8d 96 4c 08 00
	00		 lea	 edx, DWORD PTR [esi+2124]
  00040	52		 push	 edx
  00041	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00044	6a 00		 push	 0
  00046	89 8e 48 08 00
	00		 mov	 DWORD PTR [esi+2120], ecx
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
  0004e	8d 4d 0c	 lea	 ecx, DWORD PTR _nSendDataLen$[ebp]
  00051	51		 push	 ecx
  00052	6a 01		 push	 1
  00054	50		 push	 eax
  00055	52		 push	 edx
  00056	89 5e 40	 mov	 DWORD PTR [esi+64], ebx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASendTo@36
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx

; 163  : 	if( Ret == SOCKET_ERROR )

  00062	83 f8 ff	 cmp	 eax, -1
  00065	75 14		 jne	 SHORT $LN1@SendData

; 164  : 	{
; 165  : 		if (WSAGetLastError() != ERROR_IO_PENDING)

  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0006d	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  00072	74 07		 je	 SHORT $LN1@SendData

; 166  : 		{
; 167  : 			//printf("WSASend() failed with error %d\n", WSAGetLastError());
; 168  : 			return -1;

  00074	83 c8 ff	 or	 eax, -1

; 172  : }

  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
$LN1@SendData:

; 169  : 		}
; 170  : 	}
; 171  : 	return TRUE;

  0007b	b8 01 00 00 00	 mov	 eax, 1

; 172  : }

  00080	5d		 pop	 ebp
  00081	c2 08 00	 ret	 8
?SendData@WzUdp@@QAEHPAEK@Z ENDP			; WzUdp::SendData
_TEXT	ENDS
PUBLIC	?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z		; WzUdp::MuProtocolParse
; Function compile flags: /Ogtp
;	COMDAT ?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z
_TEXT	SEGMENT
_headcode$ = -4						; size = 1
_RecvData$ = 8						; size = 4
_nRecvDataLen$ = 12					; size = 4
?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z PROC		; WzUdp::MuProtocolParse, COMDAT
; _this$ = ecx

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi
  00006	8b d9		 mov	 ebx, ecx

; 176  : 	int lOfs=0;

  00008	33 ff		 xor	 edi, edi

; 177  : 	int size=0;
; 178  : 	BYTE headcode;
; 179  : 
; 180  : 	if (this->ProtocolCore == 0)

  0000a	39 bb 5c 08 00
	00		 cmp	 DWORD PTR [ebx+2140], edi
  00010	75 0a		 jne	 SHORT $LN21@MuProtocol

; 181  : 	{
; 182  : 		return 0;

  00012	5f		 pop	 edi
  00013	33 c0		 xor	 eax, eax
  00015	5b		 pop	 ebx

; 230  : 		}
; 231  : 		else
; 232  : 		{
; 233  : 			break;
; 234  : 		}
; 235  : 	}
; 236  : 	return 1;
; 237  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN21@MuProtocol:
  0001c	56		 push	 esi
  0001d	8d 49 00	 npad	 3
$LL13@MuProtocol:

; 183  : 	}
; 184  : 
; 185  : 	while ( true )	
; 186  : 	{
; 187  : 		if ( RecvData[lOfs]==0xC1 ) // Packet Type Manager

  00020	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  00023	8a 0c 07	 mov	 cl, BYTE PTR [edi+eax]
  00026	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  00029	80 f9 c1	 cmp	 cl, 193			; 000000c1H
  0002c	75 0b		 jne	 SHORT $LN11@MuProtocol

; 188  : 		{
; 189  : 			size=RecvData[lOfs+1];	// Set Size

  0002e	0f b6 74 07 01	 movzx	 esi, BYTE PTR [edi+eax+1]

; 190  : 			headcode=RecvData[lOfs+2];

  00033	8a 4c 07 02	 mov	 cl, BYTE PTR [edi+eax+2]
  00037	eb 18		 jmp	 SHORT $LN23@MuProtocol
$LN11@MuProtocol:

; 191  : 		}
; 192  : 		else if ( RecvData[lOfs]== 0xC2 )

  00039	80 f9 c2	 cmp	 cl, 194			; 000000c2H
  0003c	75 72		 jne	 SHORT $LN9@MuProtocol

; 193  : 		{
; 194  : 			size=RecvData[lOfs+1];
; 195  : 			size =size<<8;
; 196  : 			size |= RecvData[lOfs+2];

  0003e	0f b6 74 07 01	 movzx	 esi, BYTE PTR [edi+eax+1]
  00043	0f b6 4c 07 02	 movzx	 ecx, BYTE PTR [edi+eax+2]
  00048	c1 e6 08	 shl	 esi, 8
  0004b	0b f1		 or	 esi, ecx

; 197  : 			headcode = RecvData[lOfs+3];

  0004d	8a 4c 07 03	 mov	 cl, BYTE PTR [edi+eax+3]
$LN23@MuProtocol:
  00051	88 4d fc	 mov	 BYTE PTR _headcode$[ebp], cl

; 203  : 		}
; 204  : 
; 205  : 		if ( size <= 0 )

  00054	85 f6		 test	 esi, esi
  00056	7e 5f		 jle	 SHORT $LN18@MuProtocol

; 206  : 		{
; 207  : 			return 0;
; 208  : 		}
; 209  : 
; 210  : 		if ( size <= nRecvDataLen )

  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _nRecvDataLen$[ebp]
  0005b	3b 31		 cmp	 esi, DWORD PTR [ecx]
  0005d	7f 2a		 jg	 SHORT $LN6@MuProtocol

; 211  : 		{
; 212  : 			this->ProtocolCore(headcode, &RecvData[lOfs], size );

  0005f	8b 83 5c 08 00
	00		 mov	 eax, DWORD PTR [ebx+2140]
  00065	56		 push	 esi
  00066	52		 push	 edx
  00067	8b 55 fc	 mov	 edx, DWORD PTR _headcode$[ebp]
  0006a	52		 push	 edx
  0006b	ff d0		 call	 eax

; 213  : 			lOfs += size;
; 214  : 			this->m_dwRecvOfs -= size;

  0006d	29 73 20	 sub	 DWORD PTR [ebx+32], esi
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	03 fe		 add	 edi, esi

; 215  : 
; 216  : 			if (this->m_dwRecvOfs <= 0 )

  00075	83 7b 20 00	 cmp	 DWORD PTR [ebx+32], 0
  00079	7f a5		 jg	 SHORT $LL13@MuProtocol

; 229  : 			return 1;

  0007b	5e		 pop	 esi
  0007c	5f		 pop	 edi
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	5b		 pop	 ebx

; 230  : 		}
; 231  : 		else
; 232  : 		{
; 233  : 			break;
; 234  : 		}
; 235  : 	}
; 236  : 	return 1;
; 237  : }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 08 00	 ret	 8
$LN6@MuProtocol:

; 217  : 			{
; 218  : 				break;
; 219  : 			}
; 220  : 		}
; 221  : 		else if ( lOfs > 0 )

  00089	85 ff		 test	 edi, edi
  0008b	7e 15		 jle	 SHORT $LN3@MuProtocol

; 222  : 		{
; 223  : 			if (this->m_dwRecvOfs < 1 )

  0008d	8b 5b 20	 mov	 ebx, DWORD PTR [ebx+32]
  00090	83 fb 01	 cmp	 ebx, 1

; 224  : 			{
; 225  : 				return 0;

  00093	7c 22		 jl	 SHORT $LN18@MuProtocol

; 226  : 			}
; 227  : 
; 228  : 			memcpy(RecvData, &RecvData[lOfs], this->m_dwRecvOfs);

  00095	53		 push	 ebx
  00096	03 f8		 add	 edi, eax
  00098	57		 push	 edi
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _memcpy
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@MuProtocol:

; 229  : 			return 1;

  000a2	5e		 pop	 esi
  000a3	5f		 pop	 edi
  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	5b		 pop	 ebx

; 230  : 		}
; 231  : 		else
; 232  : 		{
; 233  : 			break;
; 234  : 		}
; 235  : 	}
; 236  : 	return 1;
; 237  : }

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8
$LN9@MuProtocol:

; 198  : 		}
; 199  : 		else
; 200  : 		{
; 201  : 			this->m_dwRecvOfs = 0;

  000b0	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0
$LN18@MuProtocol:
  000b7	5e		 pop	 esi
  000b8	5f		 pop	 edi

; 202  : 			return 0;

  000b9	33 c0		 xor	 eax, eax
  000bb	5b		 pop	 ebx

; 230  : 		}
; 231  : 		else
; 232  : 		{
; 233  : 			break;
; 234  : 		}
; 235  : 	}
; 236  : 	return 1;
; 237  : }

  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 08 00	 ret	 8
?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z ENDP		; WzUdp::MuProtocolParse
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?RecvThread@WzUdp@@QAEHXZ			; WzUdp::RecvThread
EXTRN	__imp__recvfrom@24:PROC
; Function compile flags: /Ogtp
;	COMDAT ?RecvThread@WzUdp@@QAEHXZ
_TEXT	SEGMENT
_dwSenderSize$ = -24					; size = 4
_sender$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?RecvThread@WzUdp@@QAEHXZ PROC				; WzUdp::RecvThread, COMDAT
; _this$ = ecx

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 254  : 	int ret;
; 255  : 	DWORD dwSenderSize;
; 256  : 	sockaddr_in sender;
; 257  : 	dwSenderSize=16;

  00012	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__recvfrom@24
  00018	8b f1		 mov	 esi, ecx
  0001a	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR _dwSenderSize$[ebp], 16 ; 00000010H
$LL6@RecvThread:

; 258  : 	while ( true )
; 259  : 	{
; 260  : 		ret=recvfrom(this->m_Socket , (char*)&this->m_Recvbuf[this->m_dwRecvOfs], ( 4096 - this->m_dwRecvOfs ), 0, (sockaddr*)&sender, (int*)&dwSenderSize);

  00021	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00024	8d 4d e8	 lea	 ecx, DWORD PTR _dwSenderSize$[ebp]
  00027	51		 push	 ecx
  00028	8d 55 ec	 lea	 edx, DWORD PTR _sender$[ebp]
  0002b	52		 push	 edx
  0002c	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0002f	6a 00		 push	 0
  00031	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00036	2b c8		 sub	 ecx, eax
  00038	51		 push	 ecx
  00039	03 d0		 add	 edx, eax
  0003b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0003e	52		 push	 edx
  0003f	50		 push	 eax
  00040	ff d7		 call	 edi

; 261  : 
; 262  : 		if ( ret == -1 )

  00042	83 f8 ff	 cmp	 eax, -1
  00045	74 da		 je	 SHORT $LL6@RecvThread

; 263  : 		{
; 264  : 			//continue;
; 265  : 		}
; 266  : 		else if ( ret == 0 )

  00047	85 c0		 test	 eax, eax
  00049	74 d6		 je	 SHORT $LL6@RecvThread

; 267  : 		{
; 268  : 			//continue;
; 269  : 		}
; 270  : 		else
; 271  : 		{
; 272  : 			this->m_dwLength=ret;
; 273  : 			this->m_dwRecvOfs += ret;

  0004b	01 46 20	 add	 DWORD PTR [esi+32], eax
  0004e	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]

; 274  : 			this->MuProtocolParse(this->m_Recvbuf, this->m_dwLength);

  00051	51		 push	 ecx
  00052	89 01		 mov	 DWORD PTR [ecx], eax
  00054	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00057	51		 push	 ecx
  00058	8b ce		 mov	 ecx, esi
  0005a	e8 00 00 00 00	 call	 ?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z ; WzUdp::MuProtocolParse

; 275  : 		}
; 276  : 	}

  0005f	eb c0		 jmp	 SHORT $LL6@RecvThread
?RecvThread@WzUdp@@QAEHXZ ENDP				; WzUdp::RecvThread
_TEXT	ENDS
PUBLIC	?WzUdpRecvThread@@YGKPAVWzUdp@@@Z		; WzUdpRecvThread
; Function compile flags: /Ogtp
;	COMDAT ?WzUdpRecvThread@@YGKPAVWzUdp@@@Z
_TEXT	SEGMENT
_lpWzUdp$ = 8						; size = 4
?WzUdpRecvThread@@YGKPAVWzUdp@@@Z PROC			; WzUdpRecvThread, COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  : 	lpWzUdp->RecvThread();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpWzUdp$[ebp]
  00006	e8 00 00 00 00	 call	 ?RecvThread@WzUdp@@QAEHXZ ; WzUdp::RecvThread
$LN4@WzUdpRecvT:
$LN3@WzUdpRecvT:
  0000b	cc		 int	 3
?WzUdpRecvThread@@YGKPAVWzUdp@@@Z ENDP			; WzUdpRecvThread
_TEXT	ENDS
PUBLIC	??_7WzUdp@@6B@					; WzUdp::`vftable'
PUBLIC	??0WzUdp@@QAE@XZ				; WzUdp::WzUdp
PUBLIC	??_R4WzUdp@@6B@					; WzUdp::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVWzUdp@@@8				; WzUdp `RTTI Type Descriptor'
PUBLIC	??_R3WzUdp@@8					; WzUdp::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2WzUdp@@8					; WzUdp::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@WzUdp@@8				; WzUdp::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EWzUdp@@UAEPAXI@Z:PROC			; WzUdp::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@WzUdp@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@WzUdp@@8 DD FLAT:??_R0?AVWzUdp@@@8	; WzUdp::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_R2WzUdp@@8
rdata$r	SEGMENT
??_R2WzUdp@@8 DD FLAT:??_R1A@?0A@EA@WzUdp@@8		; WzUdp::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3WzUdp@@8
rdata$r	SEGMENT
??_R3WzUdp@@8 DD 00H					; WzUdp::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWzUdp@@@8
_DATA	SEGMENT
??_R0?AVWzUdp@@@8 DD FLAT:??_7type_info@@6B@		; WzUdp `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWzUdp@@', 00H
_DATA	ENDS
;	COMDAT ??_R4WzUdp@@6B@
rdata$r	SEGMENT
??_R4WzUdp@@6B@ DD 00H					; WzUdp::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVWzUdp@@@8
	DD	FLAT:??_R3WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_7WzUdp@@6B@
CONST	SEGMENT
??_7WzUdp@@6B@ DD FLAT:??_R4WzUdp@@6B@			; WzUdp::`vftable'
	DD	FLAT:??_EWzUdp@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0WzUdp@@QAE@XZ
_TEXT	SEGMENT
??0WzUdp@@QAE@XZ PROC					; WzUdp::WzUdp, COMDAT
; _this$ = ecx

; 21   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7WzUdp@@6B@

; 22   : 	this->Init();

  00009	e8 00 00 00 00	 call	 ?Init@WzUdp@@QAEHXZ	; WzUdp::Init

; 23   : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0WzUdp@@QAE@XZ ENDP					; WzUdp::WzUdp
_TEXT	ENDS
PUBLIC	??1WzUdp@@UAE@XZ				; WzUdp::~WzUdp
; Function compile flags: /Ogtp
;	COMDAT ??1WzUdp@@UAE@XZ
_TEXT	SEGMENT
??1WzUdp@@UAE@XZ PROC					; WzUdp::~WzUdp, COMDAT
; _this$ = ecx

; 27   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7WzUdp@@6B@

; 28   : 	this->Close();

  00006	e9 00 00 00 00	 jmp	 ?Close@WzUdp@@QAEHXZ	; WzUdp::Close
??1WzUdp@@UAE@XZ ENDP					; WzUdp::~WzUdp
_TEXT	ENDS
PUBLIC	?Run@WzUdp@@QAEHXZ				; WzUdp::Run
EXTRN	__imp__CreateThread@24:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Run@WzUdp@@QAEHXZ
_TEXT	SEGMENT
?Run@WzUdp@@QAEHXZ PROC					; WzUdp::Run, COMDAT
; _this$ = ecx

; 242  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 243  : 	this->m_ThreadHandle=CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WzUdpRecvThread, this, 0, &this->m_ThreadID);

  00003	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	56		 push	 esi
  0000a	68 00 00 00 00	 push	 OFFSET ?WzUdpRecvThread@@YGKPAVWzUdp@@@Z ; WzUdpRecvThread
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24

; 244  : 
; 245  : 	if (this->m_ThreadHandle == 0 )

  00019	33 c9		 xor	 ecx, ecx
  0001b	85 c0		 test	 eax, eax
  0001d	0f 95 c1	 setne	 cl
  00020	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00023	5e		 pop	 esi
  00024	8b c1		 mov	 eax, ecx

; 246  : 	{
; 247  : 		return 0;
; 248  : 	}
; 249  : 	 return 1;
; 250  : }

  00026	c3		 ret	 0
?Run@WzUdp@@QAEHXZ ENDP					; WzUdp::Run
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GWzUdp@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GWzUdp@@UAEPAXI@Z PROC				; WzUdp::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1WzUdp@@UAE@XZ	; WzUdp::~WzUdp
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GWzUdp@@UAEPAXI@Z ENDP				; WzUdp::`scalar deleting destructor'
_TEXT	ENDS
END
